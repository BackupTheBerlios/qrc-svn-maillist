From deckrider at sheep.berlios.de  Fri Jul  1 14:09:58 2005
From: deckrider at sheep.berlios.de (David Everly at BerliOS)
Date: Fri, 1 Jul 2005 14:09:58 +0200
Subject: [Qrc-svn] r133 - trunk/gaym/src
Message-ID: <200507011209.j61C9wAd021368@sheep.berlios.de>

Author: deckrider
Date: 2005-07-01 14:09:55 +0200 (Fri, 01 Jul 2005)
New Revision: 133

Modified:
   trunk/gaym/src/botfilter.c
Log:
Update comments that accidentally were cut and pasted.


Modified: trunk/gaym/src/botfilter.c
===================================================================
--- trunk/gaym/src/botfilter.c	2005-06-30 17:11:17 UTC (rev 132)
+++ trunk/gaym/src/botfilter.c	2005-07-01 12:09:55 UTC (rev 133)
@@ -91,13 +91,13 @@
         return permitted;
     }
 
-    /* don't make buddies use the challenge/response system */
+    /* don't ignore buddies */
     if (gaim_find_buddy(gc->account, nick)) {
         permitted = TRUE;
         return permitted;
     }
 
-    /* don't make permit list members use the challenge/response system */
+    /* don't ignore permit list members */
     GSList *slist = NULL;
     for (slist = gc->account->permit; slist != NULL; slist = slist->next) {
         if (!gaim_utf8_strcasecmp



From deckrider at sheep.berlios.de  Fri Jul  1 16:07:03 2005
From: deckrider at sheep.berlios.de (David Everly at BerliOS)
Date: Fri, 1 Jul 2005 16:07:03 +0200
Subject: [Qrc-svn] r134 - trunk/gaym/src
Message-ID: <200507011407.j61E73hw032701@sheep.berlios.de>

Author: deckrider
Date: 2005-07-01 16:07:02 +0200 (Fri, 01 Jul 2005)
New Revision: 134

Modified:
   trunk/gaym/src/gaym.c
   trunk/gaym/src/gaympriv.c
   trunk/gaym/src/gaympriv.h
   trunk/gaym/src/msgs.c
Log:
Removed the "Only buddies may open an IM session" feature, which no one
seems to use, and is somewhat reduntant anyway.


Modified: trunk/gaym/src/gaym.c
===================================================================
--- trunk/gaym/src/gaym.c	2005-07-01 12:09:55 UTC (rev 133)
+++ trunk/gaym/src/gaym.c	2005-07-01 14:07:02 UTC (rev 134)
@@ -1112,17 +1112,6 @@
           GAYBOI_SPAM_URL));
     gaim_plugin_pref_frame_add(frame, ppref);
 
-    ppref =
-        gaim_plugin_pref_new_with_label(_
-                                        ("Instant Messages (stricter privacy settings override these)"));
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_name_and_label
-        ("/plugins/prpl/gaym/only_buddies_can_im",
-         _("Only buddies may open an IM session to me"));
-    gaim_plugin_pref_frame_add(frame, ppref);
-
     return frame;
 }
 
@@ -1189,7 +1178,6 @@
     gaim_prefs_add_none("/plugins/prpl/gaym");
     gaim_prefs_add_int("/plugins/prpl/gaym/chat_room_instances", 4);
     gaim_prefs_add_bool("/plugins/prpl/gaym/show_bio_with_join", TRUE);
-    gaim_prefs_add_bool("/plugins/prpl/gaym/only_buddies_can_im", FALSE);
 
     gaim_prefs_add_bool("/plugins/prpl/gaym/botfilter_enable", FALSE);
     gaim_prefs_add_bool("/plugins/prpl/gaym/botfilter_ignore_null", FALSE);

Modified: trunk/gaym/src/gaympriv.c
===================================================================
--- trunk/gaym/src/gaympriv.c	2005-07-01 12:09:55 UTC (rev 133)
+++ trunk/gaym/src/gaympriv.c	2005-07-01 14:07:02 UTC (rev 134)
@@ -166,40 +166,6 @@
     }
 }
 
-gboolean gaym_im_check(GaimConnection * gc, const char *nick,
-                       const char *msg)
-{
-    gboolean retval = TRUE;
-
-    /* not good, but don't do anything */
-    if (!gc || !nick) {
-        return retval;
-    }
-
-    /* there is already an open conversation, so it must be allowed */
-    if (gaim_find_conversation_with_account(nick, gc->account)) {
-        return retval;
-    }
-
-    /* user wants to allow only Buddies to IM */
-    if (gaim_prefs_get_bool("/plugins/prpl/gaym/only_buddies_can_im")) {
-        /* nick is not on the account's buddy list */
-        if (!gaim_find_buddy(gc->account, nick)) {
-            retval = FALSE;
-            return retval;
-        } else {
-            return retval;
-        }
-    } else {
-        /* don't make buddies use the challenge/response system */
-        if (gaim_find_buddy(gc->account, nick)) {
-            return retval;
-        }
-    }
-
-    return retval;
-}
-
 void gaym_server_change_deny_status_cb(void *data, const char *result,
                                        size_t len)
 {

Modified: trunk/gaym/src/gaympriv.h
===================================================================
--- trunk/gaym/src/gaympriv.h	2005-07-01 12:09:55 UTC (rev 133)
+++ trunk/gaym/src/gaympriv.h	2005-07-01 14:07:02 UTC (rev 134)
@@ -52,17 +52,6 @@
 void gaym_privacy_change(GaimConnection * gc, const char *name);
 
 /**
- * Check if the plugin's settings allow or block an IM.
- *
- * @param gc   The connection.
- * @param nick The user sending the IM.
- *
- * @return TRUE if the user is allowed, or @c FALSE otherwise.
- */
-gboolean gaym_im_check(GaimConnection * gc, const char *nick,
-                       const char *msg);
-
-/**
  * Report the status of the http request to add a name to the deny
  * list or remove a name from the deny list.
  *

Modified: trunk/gaym/src/msgs.c
===================================================================
--- trunk/gaym/src/msgs.c	2005-07-01 12:09:55 UTC (rev 133)
+++ trunk/gaym/src/msgs.c	2005-07-01 14:07:02 UTC (rev 134)
@@ -1381,9 +1381,7 @@
 
     if (!gaim_utf8_strcasecmp
         (args[0], gaim_connection_get_display_name(gc))) {
-        if (gaym_im_check(gc, nick, msg)) {
-            serv_got_im(gc, nick, msg, 0, time(NULL));
-        }
+        serv_got_im(gc, nick, msg, 0, time(NULL));
     } else if (notice) {
         serv_got_im(gc, nick, msg, 0, time(NULL));
     } else if (convo) {



From deckrider at sheep.berlios.de  Fri Jul  1 17:46:31 2005
From: deckrider at sheep.berlios.de (David Everly at BerliOS)
Date: Fri, 1 Jul 2005 17:46:31 +0200
Subject: [Qrc-svn] r135 - trunk
Message-ID: <200507011546.j61FkVCN008428@sheep.berlios.de>

Author: deckrider
Date: 2005-07-01 17:46:30 +0200 (Fri, 01 Jul 2005)
New Revision: 135

Modified:
   trunk/ChangeLog
Log:
Added ChangeLog entries.


Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2005-07-01 14:07:02 UTC (rev 134)
+++ trunk/ChangeLog	2005-07-01 15:46:30 UTC (rev 135)
@@ -0,0 +1,49 @@
+0.34.0:
+	New Features:
+	- Full win32 support for autotools and packaging
+	- Enabled and implemented all Gaim privacy hooks, including
+	  synchronization of ignore list with gay.com's server
+	- New /trace command to opbain IP address of a user
+	- New protocol icon
+	- Enabled "Warn", mapping it to gay.com's "Report User" web
+	  form.
+	- New bot-challenger plugin to block unwanted IM pop-ups
+	- New roombrowse plugin (alpha).
+	- New chatsort plugin (alpha).
+	- Permit user to customize bot filtering strings (see preference
+	  changes below)
+
+	Bug Fixes:
+	- More cleanup/fix of autotools
+	- Code / documentation / repository cleanup / restructuring
+
+	Preference Changes:
+	- Number of chat room instances to display
+	- Enable/disable bot filtering in chat
+	- Modification of bot filtering strings
+	- Download and use GayBoy's spam list
+	- Removed entrance/exit notification option, since this is
+	  available in another plugin:  http://gaim-extprefs.sf.net/
+
+0.33.0:
+	New Features:
+	- Improved thumbnail grabs
+	- Green star in chat indicates photo
+	- Half green start in chat indicates adult photo
+	- Retrieve member created rooms
+	- Add protocol icon support
+
+	Bug Fixes:
+	- Fixed crash when user has no bio or profile
+	- Use copy for nick conversions
+	- Null/dangling pointer fixes
+	- Cleanup/fix of autotools
+	- Show special characters properly in roomlist
+	- Show error when non-member tries to create a new room
+
+	Preference Changes:
+	- Entrance/exit notification option
+	- Optional bio line in entrance notification
+
+0.21.0:
+	Initial Release.



From deckrider at sheep.berlios.de  Fri Jul  1 18:02:48 2005
From: deckrider at sheep.berlios.de (David Everly at BerliOS)
Date: Fri, 1 Jul 2005 18:02:48 +0200
Subject: [Qrc-svn] r136 - trunk
Message-ID: <200507011602.j61G2mmj009910@sheep.berlios.de>

Author: deckrider
Date: 2005-07-01 18:02:47 +0200 (Fri, 01 Jul 2005)
New Revision: 136

Modified:
   trunk/ChangeLog
Log:
Spelling correction.

Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2005-07-01 15:46:30 UTC (rev 135)
+++ trunk/ChangeLog	2005-07-01 16:02:47 UTC (rev 136)
@@ -29,7 +29,7 @@
 	New Features:
 	- Improved thumbnail grabs
 	- Green star in chat indicates photo
-	- Half green start in chat indicates adult photo
+	- Half green star in chat indicates adult photo
 	- Retrieve member created rooms
 	- Add protocol icon support
 



From deckrider at berlios.de  Sun Jul  3 16:07:07 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sun, 3 Jul 2005 16:07:07 +0200
Subject: [Qrc-svn] r137 - in trunk: . gaym/src
Message-ID: <200507031407.j63E77XI003603@sheep.berlios.de>

Author: deckrider
Date: 2005-07-03 16:07:06 +0200 (Sun, 03 Jul 2005)
New Revision: 137

Modified:
   trunk/ChangeLog
   trunk/gaym/src/gaym.c
Log:
Use g_hash_table_replace() instead of g_hash_table_insert() because of
problems caused by adding the same buddy twice to the buddy list.  These
are possibly memory issues--and some of these may yet exist since NULL
is still the third parameter of g_hash_table_new_full().  This happens
if the user wants the buddy to appear in multiple groups.


Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2005-07-01 16:02:47 UTC (rev 136)
+++ trunk/ChangeLog	2005-07-03 14:07:06 UTC (rev 137)
@@ -16,6 +16,9 @@
 	Bug Fixes:
 	- More cleanup/fix of autotools
 	- Code / documentation / repository cleanup / restructuring
+	- Fixed problems that caused invalid characters/commands to be
+	  sent to the server when checking to see if buddy list members
+	  were on line
 
 	Preference Changes:
 	- Number of chat room instances to display

Modified: trunk/gaym/src/gaym.c
===================================================================
--- trunk/gaym/src/gaym.c	2005-07-01 16:02:47 UTC (rev 136)
+++ trunk/gaym/src/gaym.c	2005-07-03 14:07:06 UTC (rev 137)
@@ -613,7 +613,7 @@
     struct gaym_conn *gaym = (struct gaym_conn *) gc->proto_data;
     struct gaym_buddy *ib = g_new0(struct gaym_buddy, 1);
     ib->name = g_strdup(buddy->name);
-    g_hash_table_insert(gaym->buddies, ib->name, ib);
+    g_hash_table_replace(gaym->buddies, ib->name, ib);
     gaim_debug_misc("gaym", "Add buddy: %s\n", buddy->name);
     /**
      * if the timer isn't set, this is during signon, so we don't want to



From deckrider at berlios.de  Mon Jul  4 04:54:11 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Mon, 4 Jul 2005 04:54:11 +0200
Subject: [Qrc-svn] r138 - trunk
Message-ID: <200507040254.j642sBwq032224@sheep.berlios.de>

Author: deckrider
Date: 2005-07-04 04:53:59 +0200 (Mon, 04 Jul 2005)
New Revision: 138

Modified:
   trunk/ChangeLog
Log:
Spelling correction

Modified: trunk/ChangeLog
===================================================================
--- trunk/ChangeLog	2005-07-03 14:07:06 UTC (rev 137)
+++ trunk/ChangeLog	2005-07-04 02:53:59 UTC (rev 138)
@@ -24,7 +24,7 @@
 	- Number of chat room instances to display
 	- Enable/disable bot filtering in chat
 	- Modification of bot filtering strings
-	- Download and use GayBoy's spam list
+	- Download and use GayBoi's spam list
 	- Removed entrance/exit notification option, since this is
 	  available in another plugin:  http://gaim-extprefs.sf.net/
 



From deckrider at berlios.de  Tue Jul  5 15:36:33 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 5 Jul 2005 15:36:33 +0200
Subject: [Qrc-svn] r139 - /
Message-ID: <200507051336.j65DaXq2025317@sheep.berlios.de>

Author: deckrider
Date: 2005-07-05 15:36:30 +0200 (Tue, 05 Jul 2005)
New Revision: 139

Added:
   qrc/
Log:
Allow other modules in our repository besides the qrc module.



From deckrider at berlios.de  Tue Jul  5 15:37:26 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 5 Jul 2005 15:37:26 +0200
Subject: [Qrc-svn] r140 - / qrc
Message-ID: <200507051337.j65DbQ1m025435@sheep.berlios.de>

Author: deckrider
Date: 2005-07-05 15:37:21 +0200 (Tue, 05 Jul 2005)
New Revision: 140

Added:
   qrc/trunk/
Removed:
   trunk/
Log:
This move is to allow other modules in our repository besides the qrc
module.

Copied: qrc/trunk (from rev 139, trunk)



From deckrider at berlios.de  Tue Jul  5 15:41:41 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 5 Jul 2005 15:41:41 +0200
Subject: [Qrc-svn] r141 - qrc
Message-ID: <200507051341.j65DffYF025724@sheep.berlios.de>

Author: deckrider
Date: 2005-07-05 15:41:39 +0200 (Tue, 05 Jul 2005)
New Revision: 141

Added:
   qrc/tags/
Log:
Allow for tagging of the qrc module.



From deckrider at berlios.de  Tue Jul  5 15:41:59 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 5 Jul 2005 15:41:59 +0200
Subject: [Qrc-svn] r142 - qrc
Message-ID: <200507051341.j65DfxEa025783@sheep.berlios.de>

Author: deckrider
Date: 2005-07-05 15:41:59 +0200 (Tue, 05 Jul 2005)
New Revision: 142

Added:
   qrc/branches/
Log:
Allow for branching of the qrc module.



From deckrider at berlios.de  Tue Jul  5 15:49:21 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 5 Jul 2005 15:49:21 +0200
Subject: [Qrc-svn] r143 - qrc/trunk
Message-ID: <200507051349.j65DnLWt026120@sheep.berlios.de>

Author: deckrider
Date: 2005-07-05 15:49:20 +0200 (Tue, 05 Jul 2005)
New Revision: 143

Removed:
   qrc/trunk/bioline.r18.patch
Log:
Removing this patch since it is not currently serving a purpose.  Of course, it can be retrieved from an earlier revision if someone decides it is useful.

Deleted: qrc/trunk/bioline.r18.patch
===================================================================
--- qrc/trunk/bioline.r18.patch	2005-07-05 13:41:59 UTC (rev 142)
+++ qrc/trunk/bioline.r18.patch	2005-07-05 13:49:20 UTC (rev 143)
@@ -1,189 +0,0 @@
-Common subdirectories: gaym-plugin-release-0.18/src/.deps and gaym-current/src/.deps
-diff -u gaym-plugin-release-0.18/src/gaym.c gaym-current/src/gaym.c
---- gaym-plugin-release-0.18/src/gaym.c	2004-12-02 22:29:08.927084544 -0600
-+++ gaym-current/src/gaym.c	2004-12-02 03:48:39.000000000 -0600
-@@ -40,7 +40,7 @@
- 
- #include "gaym.h"
- 
--
-+char *gaym_mask_bio(const char *biostring);
- static const char *gaym_blist_icon(GaimAccount *a, GaimBuddy *b);
- static void gaym_blist_emblems(GaimBuddy *b, char **se, char **sw, char **nw, char **ne);
- static GList *gaym_away_states(GaimConnection *gc);
-@@ -165,25 +165,44 @@
- 	struct gaym_conn *gaym=gc->proto_data;
- 	GaimAccount* account = gaim_connection_get_account(gc);
- 	char* hostname="none";
--	char* buf;
--	gaym->bio = g_strdup(info);
--	gaim_account_set_user_info(account, info);
--	gaim_account_set_string(account, "bioline",info);
--	buf = gaym_format(gaym, "vvvv:", "USER", gaim_account_get_username(account), hostname, gaym->server,
--			  gaym->bio);
-+	char* buf, *bioline;
-+
-+	if (gaym->bio)
-+		g_free (gaym->bio);
-+		
-+	if (info && strlen(info) > 2) {
-+		gaym->bio = g_strdup(info);
-+	} else if (gaym->server_bioline && strlen(gaym->server_bioline) > 2) {
-+		gaym->bio = g_strdup(gaym_mask_bio(gaym->server_bioline));
-+	} else {
-+		gaym->bio = g_strdup("Gaim User");
-+	}
-+	
-+	gaim_account_set_user_info(account, gaym->bio);
-+	gaim_account_set_string(account, "bioline",gaym->bio);
-+	gaim_debug_info ("gaym","INFO=%s BIO=%s\n",info,gaym->bio);
-+	gaim_debug_misc("gaym","In login_cb, gc->account=%x\n",gc->account);
-+	bioline=g_strdup_printf("%s#%s", gaym->thumbnail,gaym->bio); 
-+
-+	buf = gaym_format(gaym, "vvvv:", "USER", 
-+		gaim_account_get_username(account), 
-+		hostname, gaym->server, bioline);
-+	
-+	g_free (bioline);
- 	
- 	if (gaym_send(gaym, buf) < 0) {
- 		gaim_connection_error(gc, "Error registering with server");
- 		return;
- 	}
- }
-+
- static void gaym_show_set_info(GaimPluginAction *action)
- {
- 	GaimConnection *gc = (GaimConnection *) action->context;
--	gaim_debug_misc("gaym","in show-set_info, gc->account=%x\n",gc->account);
--	
-+	gaim_debug_misc("gaym","in show-set_info, gc->account=%x\n",gc->account);	
- 	gaim_account_request_change_user_info(gaim_connection_get_account(gc));
- }
-+
- static GList *gaym_actions(GaimPlugin *plugin, gpointer context)
- {
- 	GList *list = NULL;
-@@ -471,11 +490,6 @@
-     last_room=room;
-     }
-     
--   
--    
--    
--       
--        
- }
- 
- static void gaym_login_cb(gpointer data, gint source, GaimInputCondition cond)
-@@ -518,6 +532,7 @@
- 	hostname[sizeof(hostname) - 1] = '\0';
- 	username = gaim_account_get_string(gaym->account, "username", "");
- 	user_bioline = gaim_account_get_string(gaym->account, "bioline", ""); 
-+	gaim_debug_info ("gaym","USER BIOLINE=%s\n",user_bioline);
- 	gaim_account_set_user_info(gc->account, user_bioline);
- 	gaim_debug_misc("gaym","In login_cb, gc->account=%x\n",gc->account);
- 	bioline=g_strdup_printf("%s#%s", gaym->thumbnail,user_bioline); 
-@@ -592,8 +607,6 @@
- 	args[0] = who;
- 	gaym->info_window_needed=TRUE;
- 	gaym_cmd_whois(gaym, "whois", NULL, args);
--	
--	
- }
- 
- static void gaym_set_away(GaimConnection *gc, const char *state, const char *msg)
-diff -u gaym-plugin-release-0.18/src/msgs.c gaym-current/src/msgs.c
---- gaym-plugin-release-0.18/src/msgs.c	2004-12-02 22:29:08.921085480 -0600
-+++ gaym-current/src/msgs.c	2004-12-02 02:28:23.000000000 -0600
-@@ -39,7 +39,7 @@
- static void gaym_chat_remove_buddy(GaimConversation *convo, char *data[2]);
- static void gaym_buddy_status(char *name, struct gaym_buddy *ib, struct gaym_conn *gaym);
- 
--static char * gaym_mask_thumbnail(const char* biostring)
-+char * gaym_mask_thumbnail(const char* biostring)
- {    
-   char * start = strchr(biostring,':');
-   char * end=0;
-@@ -59,13 +59,14 @@
- }
- 
- 
--char* gaym_bot_detect(char * bio,GaimConversation *chat,const char *name)
-+char * gaym_bot_detect(char * bio,GaimConversation *chat,const char *name)
- {
- 	static char * appendStr = 
- 		"  <b><font size=2>** BOT ALERT **</font></b>";
- 	static char *badlines[] = {
-                 "geocities","tripod","angelcities",
- 		"icamsonline","ratefun","dudepages",
-+		"h0rnydolls","hornydolls",
-                 "gayonlinevideos","gaystreamingvideos",
-                 "gaypornfilms",
- 		NULL
-@@ -144,7 +145,7 @@
- 	return bio;
- }
- 
--static char* gaym_mask_bio(const char* biostring)
-+char* gaym_mask_bio(const char* biostring)
- {
-   char * start = strchr(biostring,'#');
-   char* end=0;
-diff -u gaym-plugin-release-0.18/src/weblogin.c gaym-current/src/weblogin.c
---- gaym-plugin-release-0.18/src/weblogin.c	2004-11-24 04:42:40.000000000 -0600
-+++ gaym-current/src/weblogin.c	2004-12-02 03:49:10.000000000 -0600
-@@ -63,6 +63,22 @@
-   GaimUrlSession* session;
- 
- } GaimFetchUrlData;
-+
-+/* gaim_url_decode doesn't change pluses to spaces - edit in place */
-+static const char * gaym_url_decode (const char *string)
-+{
-+	char * retval;
-+
-+	gaim_debug_info ("gaym","Changing %s with gaym_url_decode\n", string);
-+	retval = string = gaim_url_decode(string);
-+	while (*retval != NULL) {
-+		if (*retval == '+')
-+			*retval = ' ';
-+		retval++;
-+	}
-+	return string;
-+}
-+
- static void
-     destroy_fetch_url_data(GaimFetchUrlData *gfud)
- {
-@@ -496,7 +512,7 @@
- 	if(temp && temp2)
- 	{
- 		thumbnail=g_strndup(temp,(temp2-temp)*sizeof(char));
--		result=gaim_url_decode(thumbnail);
-+		result=gaym_url_decode(thumbnail);
- 		(gaym->thumbnail=g_strdup(result)) ||(gaym->thumbnail=g_strdup(" "));
- 		
- 		g_free(thumbnail);
-@@ -505,17 +521,16 @@
- 		if(temp) 
- 		{
- 			bio=g_strndup(temp2,(temp-temp2)*sizeof(char));
--			result=gaim_url_decode(bio);
-+			result=gaym_url_decode(bio);
-+			gaim_debug_info("gaym","Server BIO: %s Thumb: %s\n",
-+				result, gaym->thumbnail);
- 			(gaym->server_bioline=g_strdup(result))
--					||(gaym->server_bioline=g_strdup(" "));
-+					||(gaym->server_bioline=NULL);
- 			g_free(bio);
- 			
- 		}
- 		//We have established a session. Call session callback.
- 		
--		
--	
--		
- 	}
- 	else
- 	{



From deckrider at berlios.de  Tue Jul  5 15:55:23 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 5 Jul 2005 15:55:23 +0200
Subject: [Qrc-svn] r144 - qrc/trunk
Message-ID: <200507051355.j65DtNbn026474@sheep.berlios.de>

Author: deckrider
Date: 2005-07-05 15:55:22 +0200 (Tue, 05 Jul 2005)
New Revision: 144

Modified:
   qrc/trunk/configure.ac
Log:
Preparing for the 0.34.0 release

Modified: qrc/trunk/configure.ac
===================================================================
--- qrc/trunk/configure.ac	2005-07-05 13:49:20 UTC (rev 143)
+++ qrc/trunk/configure.ac	2005-07-05 13:55:22 UTC (rev 144)
@@ -2,7 +2,7 @@
 # Process this file with autoconf to produce a configure script.
 
 AC_PREREQ(2.59)
-AC_INIT([qrc],[0.33.0+svn],[gaymplugin at yahoogroups.com])
+AC_INIT([qrc],[0.34.0],[gaymplugin at yahoogroups.com])
 AC_CANONICAL_TARGET([])
 AM_INIT_AUTOMAKE([1.9.5 no-dist-gzip dist-bzip2])
 



From deckrider at berlios.de  Tue Jul  5 16:02:26 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 5 Jul 2005 16:02:26 +0200
Subject: [Qrc-svn] r145 - qrc/tags
Message-ID: <200507051402.j65E2Qmm026835@sheep.berlios.de>

Author: deckrider
Date: 2005-07-05 16:02:23 +0200 (Tue, 05 Jul 2005)
New Revision: 145

Added:
   qrc/tags/0.21.0/
Log:
Tagging release 0.21.0

Copied: qrc/tags/0.21.0 (from rev 21, gaym/trunk)



From deckrider at berlios.de  Tue Jul  5 16:03:13 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 5 Jul 2005 16:03:13 +0200
Subject: [Qrc-svn] r146 - qrc/tags
Message-ID: <200507051403.j65E3D0N026897@sheep.berlios.de>

Author: deckrider
Date: 2005-07-05 16:03:12 +0200 (Tue, 05 Jul 2005)
New Revision: 146

Added:
   qrc/tags/0.33.0/
Log:
Tagging release 0.33.0

Copied: qrc/tags/0.33.0 (from rev 33, gaym/trunk)



From deckrider at berlios.de  Tue Jul  5 16:10:32 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 5 Jul 2005 16:10:32 +0200
Subject: [Qrc-svn] r147 - qrc/tags
Message-ID: <200507051410.j65EAWrF027437@sheep.berlios.de>

Author: deckrider
Date: 2005-07-05 16:10:31 +0200 (Tue, 05 Jul 2005)
New Revision: 147

Added:
   qrc/tags/0.34.0/
Log:
Tagging release 0.34.0

Copied: qrc/tags/0.34.0 (from rev 146, qrc/trunk)



From deckrider at berlios.de  Tue Jul  5 19:03:43 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 5 Jul 2005 19:03:43 +0200
Subject: [Qrc-svn] r148 - /
Message-ID: <200507051703.j65H3hBm013423@sheep.berlios.de>

Author: deckrider
Date: 2005-07-05 19:03:40 +0200 (Tue, 05 Jul 2005)
New Revision: 148

Added:
   debian-qrc/
Log:
Debian packaging for qrc.




From deckrider at berlios.de  Tue Jul  5 19:06:37 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 5 Jul 2005 19:06:37 +0200
Subject: [Qrc-svn] r149 - in debian-qrc: . gaim-qrc gaim-qrc/branches gaim-qrc/branches/upstream
Message-ID: <200507051706.j65H6bAZ014893@sheep.berlios.de>

Author: deckrider
Date: 2005-07-05 19:06:16 +0200 (Tue, 05 Jul 2005)
New Revision: 149

Added:
   debian-qrc/gaim-qrc/
   debian-qrc/gaim-qrc/branches/
   debian-qrc/gaim-qrc/branches/upstream/
   debian-qrc/gaim-qrc/branches/upstream/current/
   debian-qrc/gaim-qrc/tags/
Log:
[svn-inject] Installing original source of gaim-qrc



From deckrider at berlios.de  Tue Jul  5 19:07:05 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 5 Jul 2005 19:07:05 +0200
Subject: [Qrc-svn] r150 - debian-qrc/gaim-qrc/branches/upstream
Message-ID: <200507051707.j65H756u014939@sheep.berlios.de>

Author: deckrider
Date: 2005-07-05 19:06:45 +0200 (Tue, 05 Jul 2005)
New Revision: 150

Added:
   debian-qrc/gaim-qrc/branches/upstream/0.34.0/
Log:
[svn-inject] Tagging upstream source version of gaim-qrc

Copied: debian-qrc/gaim-qrc/branches/upstream/0.34.0 (from rev 149, debian-qrc/gaim-qrc/branches/upstream/current)



From deckrider at berlios.de  Tue Jul  5 19:07:20 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 5 Jul 2005 19:07:20 +0200
Subject: [Qrc-svn] r151 - debian-qrc/gaim-qrc
Message-ID: <200507051707.j65H7KaJ014988@sheep.berlios.de>

Author: deckrider
Date: 2005-07-05 19:07:13 +0200 (Tue, 05 Jul 2005)
New Revision: 151

Added:
   debian-qrc/gaim-qrc/trunk/
Log:
[svn-inject] Forking gaim-qrc source to Trunk

Copied: debian-qrc/gaim-qrc/trunk (from rev 150, debian-qrc/gaim-qrc/branches/upstream/current)



From deckrider at berlios.de  Tue Jul  5 19:08:11 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 5 Jul 2005 19:08:11 +0200
Subject: [Qrc-svn] r152 - in debian-qrc/gaim-qrc/trunk: . debian
Message-ID: <200507051708.j65H8BEv015204@sheep.berlios.de>

Author: deckrider
Date: 2005-07-05 19:08:07 +0200 (Tue, 05 Jul 2005)
New Revision: 152

Added:
   debian-qrc/gaim-qrc/trunk/debian/
   debian-qrc/gaim-qrc/trunk/debian/changelog
   debian-qrc/gaim-qrc/trunk/debian/compat
   debian-qrc/gaim-qrc/trunk/debian/control
   debian-qrc/gaim-qrc/trunk/debian/copyright
   debian-qrc/gaim-qrc/trunk/debian/rules
Log:
Load newtrunk into debian-qrc/gaim-qrc/trunk.


Added: debian-qrc/gaim-qrc/trunk/debian/changelog
===================================================================
--- debian-qrc/gaim-qrc/trunk/debian/changelog	2005-07-05 17:07:13 UTC (rev 151)
+++ debian-qrc/gaim-qrc/trunk/debian/changelog	2005-07-05 17:08:07 UTC (rev 152)
@@ -0,0 +1,56 @@
+gaim-qrc (0.34.0-1) unstable; urgency=low
+
+  * New upstream release
+
+ -- David Everly <deckrider at yahoo.com>  Tue,  5 Jul 2005 10:01:19 -0600
+
+gaim-gaym (0.21+20050513-5) unstable; urgency=low
+
+  * Incorporating Jason LeBrun's excellent function to convert ASCII
+    based escaped unicode (from Java) back to native.  Among other
+    things, rooms containing special characters should now be displayed
+    properly.
+  * Break out formatting (gnu indent) into its own patch.
+  * Tweeked the icon I added earlier.
+
+ -- David Everly <deckrider at yahoo.com>  Tue, 24 May 2005 08:28:05 -0600
+
+gaim-gaym (0.21+20050513-4) unstable; urgency=low
+
+  * Added gaym.png which I made under the GNU Public License (GPL).
+    Hopefully someone else can make a better GPL'd one, since mine
+    sucks.
+
+ -- David Everly <deckrider at yahoo.com>  Mon, 23 May 2005 10:35:45 -0600
+
+gaim-gaym (0.21+20050513-3) unstable; urgency=low
+
+  * Use dh_gaim.
+
+ -- David Everly <deckrider at yahoo.com>  Mon, 23 May 2005 00:12:11 -0600
+
+gaim-gaym (0.21+20050513-2) unstable; urgency=low
+
+  * Worked a little more on the configure issues.  Not that I know that
+    much about autoconf.
+  * The title of rooms no longer have to be 'fixed' every time someone
+    goes in and out of a room.  This also eliminates conflicts related
+    to the notification plugin.
+  * Added retrieval of Member Created rooms to the roomlist.
+  * Added notification to the user for when the server is too busy to
+    retrieve the roomlist (Member Created rooms).
+  * Allow the #channel to be visible along with the room name.
+  * Give more control regarding which instance of a room is joined.
+    Currently (based on gay.com's own client) this amounts to instances
+    1 through 4 of every room in the static list.
+
+ -- David Everly <deckrider at yahoo.com>  Sun, 22 May 2005 21:15:33 -0600
+
+gaim-gaym (0.21+20050513-1) unstable; urgency=low
+
+  * Initial Release.
+  * Added autorconf patch to fix configure, make, make distclean.
+  * Added compile-warnings to eliminate warnings produced by gcc -Wall.
+
+ -- David Everly <deckrider at yahoo.com>  Sat, 14 May 2005 11:45:50 -0600
+

Added: debian-qrc/gaim-qrc/trunk/debian/compat
===================================================================
--- debian-qrc/gaim-qrc/trunk/debian/compat	2005-07-05 17:07:13 UTC (rev 151)
+++ debian-qrc/gaim-qrc/trunk/debian/compat	2005-07-05 17:08:07 UTC (rev 152)
@@ -0,0 +1 @@
+4

Added: debian-qrc/gaim-qrc/trunk/debian/control
===================================================================
--- debian-qrc/gaim-qrc/trunk/debian/control	2005-07-05 17:07:13 UTC (rev 151)
+++ debian-qrc/gaim-qrc/trunk/debian/control	2005-07-05 17:08:07 UTC (rev 152)
@@ -0,0 +1,17 @@
+Source: gaim-qrc
+Section: net
+Priority: optional
+Maintainer: David Everly <deckrider at yahoo.com>
+Build-Depends: debhelper (>= 4.0.0), dpatch (>= 1.11), gaim-dev (>= 1.2.0), sharutils
+Standards-Version: 3.6.1
+
+Package: gaim-qrc
+Architecture: any
+Conflicts: gaim-gaym
+Depends: ${shlibs:Depends}, ${misc:Depends}
+Description: gay.com-related plugins for gaim
+ gaym allows you to participate in group and private chat on gay.com
+ from within gaim, and helps with chat room spam control.
+ .
+ bot-challenger provides a simple challenge-response system to prevent
+ spam/bots from sending you instant messages. 

Added: debian-qrc/gaim-qrc/trunk/debian/copyright
===================================================================
--- debian-qrc/gaim-qrc/trunk/debian/copyright	2005-07-05 17:07:13 UTC (rev 151)
+++ debian-qrc/gaim-qrc/trunk/debian/copyright	2005-07-05 17:08:07 UTC (rev 152)
@@ -0,0 +1,19 @@
+This package was debianized by David Everly <deckrider at yahoo.com> on
+Fri, 13 May 2005 17:24:55 -0600.
+
+It was downloaded from svn://svn.berlios.de/qrc
+
+Copyright (C) 1998-1999, Mark Spencer <markster at marko.net>
+Copyright (C) 2000-2003, Rob Flynn <rob at tgflinux.com>
+Copyright (C) 2003, Ethan Blanton <eblanton at cs.purdue.edu>
+Copyright (C) 2003, Robbert Haarman <gaim at inglorion.net>
+Copyright (C) 2004, Timothy T Ringenbach <omarvo at hotmail.com>
+
+License:
+
+   You are free to distribute this software under the terms of
+   the GNU General Public License.
+
+   On Debian systems, the complete text of the GNU General Public
+   License can be found in the file `/usr/share/common-licenses/GPL'.
+

Added: debian-qrc/gaim-qrc/trunk/debian/rules
===================================================================
--- debian-qrc/gaim-qrc/trunk/debian/rules	2005-07-05 17:07:13 UTC (rev 151)
+++ debian-qrc/gaim-qrc/trunk/debian/rules	2005-07-05 17:08:07 UTC (rev 152)
@@ -0,0 +1,102 @@
+#!/usr/bin/make -f
+# -*- makefile -*-
+# Sample debian/rules that uses debhelper.
+# This file was originally written by Joey Hess and Craig Small.
+# As a special exception, when this file is copied by dh-make into a
+# dh-make output file, you may use that output file without restriction.
+# This special exception was added by Craig Small in version 0.37 of dh-make.
+
+# Uncomment this to turn on verbose mode.
+#export DH_VERBOSE=1
+
+# These are used for cross-compiling and for saving the configure script
+# from having to guess our platform (since we know it already)
+DEB_HOST_GNU_TYPE   ?= $(shell dpkg-architecture -qDEB_HOST_GNU_TYPE)
+DEB_BUILD_GNU_TYPE  ?= $(shell dpkg-architecture -qDEB_BUILD_GNU_TYPE)
+
+CFLAGS = -Wall -g
+
+ifneq (,$(findstring noopt,$(DEB_BUILD_OPTIONS)))
+	CFLAGS += -O0
+else
+	CFLAGS += -O2
+endif
+
+configure: configure-stamp
+configure-stamp:
+	dh_testdir
+	# Add here commands to configure the package.
+	CFLAGS="$(CFLAGS)" ./configure \
+		--host=$(DEB_HOST_GNU_TYPE) \
+		--build=$(DEB_BUILD_GNU_TYPE) \
+		--prefix=/usr
+	touch configure-stamp
+
+
+build: build-stamp
+
+build-stamp:  configure-stamp
+	dh_testdir
+
+	# Add here commands to compile the package.
+	$(MAKE)
+
+	touch build-stamp
+
+clean:
+	dh_testdir
+	dh_testroot
+	rm -f build-stamp configure-stamp
+
+	# Add here commands to clean up after the build process.
+	-make distclean
+
+	dh_clean 
+
+install: build
+	dh_testdir
+	dh_testroot
+	dh_clean -k 
+	dh_installdirs
+	dh_gaim
+
+	# Add here commands to install the package into debian/gaim-qrc.
+	$(MAKE) install DESTDIR=$(CURDIR)/debian/gaim-qrc
+
+# Build architecture-independent files here.
+binary-indep: build install
+# We have nothing to do by default.
+
+# Build architecture-dependent files here.
+binary-arch: build install
+	dh_testdir
+	dh_testroot
+	dh_installchangelogs ChangeLog
+	dh_installdocs README TODO
+	dh_installexamples
+#	dh_install
+#	dh_installmenu
+#	dh_installdebconf	
+#	dh_installlogrotate
+#	dh_installemacsen
+#	dh_installpam
+#	dh_installmime
+#	dh_installinit
+#	dh_installcron
+#	dh_installinfo
+	dh_installman
+	dh_link
+	dh_strip
+	dh_compress
+	dh_fixperms
+#	dh_perl
+#	dh_python
+#	dh_makeshlibs
+	dh_installdeb
+	dh_shlibdeps
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+
+binary: binary-indep binary-arch
+.PHONY: build clean binary-indep binary-arch binary install configure


Property changes on: debian-qrc/gaim-qrc/trunk/debian/rules
___________________________________________________________________
Name: svn:executable
   + *



From deckrider at berlios.de  Tue Jul  5 19:08:40 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 5 Jul 2005 19:08:40 +0200
Subject: [Qrc-svn] r153 - debian-qrc/gaim-qrc/trunk/debian
Message-ID: <200507051708.j65H8eFs015310@sheep.berlios.de>

Author: deckrider
Date: 2005-07-05 19:08:36 +0200 (Tue, 05 Jul 2005)
New Revision: 153

Modified:
   debian-qrc/gaim-qrc/trunk/debian/
Log:
[svn-inject] Setting properties of gaim-qrc/debian/


Property changes on: debian-qrc/gaim-qrc/trunk/debian
___________________________________________________________________
Name: mergeWithUpstream
   + 1



From deckrider at berlios.de  Tue Jul  5 19:13:36 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 5 Jul 2005 19:13:36 +0200
Subject: [Qrc-svn] r154 - /
Message-ID: <200507051713.j65HDawZ018736@sheep.berlios.de>

Author: deckrider
Date: 2005-07-05 19:13:32 +0200 (Tue, 05 Jul 2005)
New Revision: 154

Added:
   debian/
Removed:
   debian-qrc/
Log:
Actually, this should be the directory for any debian packages.


Copied: debian (from rev 153, debian-qrc)



From deckrider at berlios.de  Tue Jul  5 19:17:32 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 5 Jul 2005 19:17:32 +0200
Subject: [Qrc-svn] r155 - debian/gaim-qrc/tags
Message-ID: <200507051717.j65HHWo6023248@sheep.berlios.de>

Author: deckrider
Date: 2005-07-05 19:17:22 +0200 (Tue, 05 Jul 2005)
New Revision: 155

Added:
   debian/gaim-qrc/tags/0.34.0-1/
Log:
Tagging version 0.34.0-1

Copied: debian/gaim-qrc/tags/0.34.0-1 (from rev 154, debian/gaim-qrc/trunk)



From deckrider at berlios.de  Tue Jul  5 22:43:16 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 5 Jul 2005 22:43:16 +0200
Subject: [Qrc-svn] r156 - qrc/trunk
Message-ID: <200507052043.j65KhGDJ009762@sheep.berlios.de>

Author: deckrider
Date: 2005-07-05 22:43:15 +0200 (Tue, 05 Jul 2005)
New Revision: 156

Modified:
   qrc/trunk/ChangeLog
   qrc/trunk/README
   qrc/trunk/configure.ac
Log:
Prepare for new development cycle.
Remove obsolete text from README.

Modified: qrc/trunk/ChangeLog
===================================================================
--- qrc/trunk/ChangeLog	2005-07-05 17:17:22 UTC (rev 155)
+++ qrc/trunk/ChangeLog	2005-07-05 20:43:15 UTC (rev 156)
@@ -1,3 +1,13 @@
+0.34.0+svn:
+	New Features:
+	- none
+
+	Bug Fixes:
+	- none
+
+	Preference Changes:
+	- none
+
 0.34.0:
 	New Features:
 	- Full win32 support for autotools and packaging

Modified: qrc/trunk/README
===================================================================
--- qrc/trunk/README	2005-07-05 17:17:22 UTC (rev 155)
+++ qrc/trunk/README	2005-07-05 20:43:15 UTC (rev 156)
@@ -8,10 +8,6 @@
    Tools->Privacy->Block all users
    Tools->Privacy->Block only the users below (deny list)
 
-GayM Preferences that enhance privacy settings (enable/disable):
-
-   G1 = Preferences->GayM->Only buddies may open an IM session to me
-
 Widgets that interact with privacy settings:
 
    Chat Room->Ignore the user (ignore/unignore toggle)
@@ -23,22 +19,6 @@
    from them, either any chat rooms or in an instant message.  GayM
    Preferences will not override it.
 
-GayM Preferences (Only buddies may open an IM session to me):
-
-   When enabled, only members of your Gaim buddy list may INITIATE an IM
-   session with you.  However, you may initiate an IM session with
-   someone who is not on your buddy list, and then they will be able to
-   IM you.
-
-   An IM session is defined as a visibly open Instant Message window.
-   To initiate an IM session, simply double-click on the user to open
-   the IM window.  If you both have GayM and neither are on the other's
-   buddy list, agree in the chat room that you want to IM each other,
-   both open an IM window, and you both may begin speaking.
-
-   However, if Gaim Privacy already blocks a member, that member will
-   still not be able to communicate with you in any way.
-
 Chat Room->Ignore the user
 
    This will ignore the user in that chat room only, and only while that

Modified: qrc/trunk/configure.ac
===================================================================
--- qrc/trunk/configure.ac	2005-07-05 17:17:22 UTC (rev 155)
+++ qrc/trunk/configure.ac	2005-07-05 20:43:15 UTC (rev 156)
@@ -2,7 +2,7 @@
 # Process this file with autoconf to produce a configure script.
 
 AC_PREREQ(2.59)
-AC_INIT([qrc],[0.34.0],[gaymplugin at yahoogroups.com])
+AC_INIT([qrc],[0.34.0+svn],[gaymplugin at yahoogroups.com])
 AC_CANONICAL_TARGET([])
 AM_INIT_AUTOMAKE([1.9.5 no-dist-gzip dist-bzip2])
 



From deckrider at berlios.de  Tue Jul  5 23:09:43 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 5 Jul 2005 23:09:43 +0200
Subject: [Qrc-svn] r157 - debian/gaim-qrc/trunk/debian
Message-ID: <200507052109.j65L9h0q011560@sheep.berlios.de>

Author: deckrider
Date: 2005-07-05 23:09:42 +0200 (Tue, 05 Jul 2005)
New Revision: 157

Added:
   debian/gaim-qrc/trunk/debian/watch
Log:
Added watch file.

Added: debian/gaim-qrc/trunk/debian/watch
===================================================================
--- debian/gaim-qrc/trunk/debian/watch	2005-07-05 20:43:15 UTC (rev 156)
+++ debian/gaim-qrc/trunk/debian/watch	2005-07-05 21:09:42 UTC (rev 157)
@@ -0,0 +1,17 @@
+# Example watch control file for uscan
+# Rename this file to "watch" and then you can run the "uscan" command
+# to check for upstream updates and more.
+# See uscan(1) for format
+
+# Compulsory line, this is a version 2 file
+version=2
+
+# Uncomment to examine a Webpage 
+# <Webpage URL> <string match>
+#http://www.example.com/downloads.php #PACKAGE#-(.*)\.tar\.gz
+
+# Uncomment to examine a Webserver directory
+http://download.berlios.de/qrc/qrc-(.*)\.tar\.bz2
+
+# Uncommment to examine a FTP server
+#ftp://ftp.example.com/pub/#PACKAGE#-(.*)\.tar\.gz debian uupdate



From jblebrun at berlios.de  Wed Jul  6 08:37:37 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Wed, 6 Jul 2005 08:37:37 +0200
Subject: [Qrc-svn] r158 - qrc/trunk/gaym/src
Message-ID: <200507060637.j666bbhO014539@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-06 08:37:36 +0200 (Wed, 06 Jul 2005)
New Revision: 158

Modified:
   qrc/trunk/gaym/src/helpers.c
Log:
Fix the initial pipe in nicks problem.



Modified: qrc/trunk/gaym/src/helpers.c
===================================================================
--- qrc/trunk/gaym/src/helpers.c	2005-07-05 21:09:42 UTC (rev 157)
+++ qrc/trunk/gaym/src/helpers.c	2005-07-06 06:37:36 UTC (rev 158)
@@ -26,6 +26,13 @@
 void gaym_convert_nick_to_gaycom(char *name)
 {
     int i;
+    
+    //If the first character is a punctuation or a number,
+    //Gay.com inserts a | character in front. We remedy this by changing 
+    //it to a space. This changes it back.
+    if (name[0]==' ')
+	name[0]='|';
+    
     if (!name) {
         return;
     }
@@ -42,6 +49,9 @@
     char *start = 0;
     char *end = 0;
 
+    if(!source || !startbit || !endbit)
+	return 0;
+    
     start = strstr(source, startbit);
 
     if (start) {
@@ -59,6 +69,7 @@
     }
 }
 
+/*
 char *convert_nick_to_gc(char *nick)
 {
     int i;
@@ -68,18 +79,22 @@
             out[i] = '|';
         }
     }
-    /**
-     * gaim_debug_misc("gaym", "Converted %s to %s\n", nick, out);
-     */
     return out;
 }
-
+*/
 void convert_nick_from_gaycom(char *name)
 {
     int i;
+
     if (!name) {
         return;
     }
+
+    //If the first character is a punctuation or a number,
+    //Gay.com inserts a | character in front. Get rid of it.
+    if (name[0]=='|')
+	name[0]=' ';
+
     for (i = 0; i < strlen(name); i++) {
         if (name[i] == '|') {
             name[i] = '.';



From deckrider at berlios.de  Wed Jul  6 16:08:32 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Wed, 6 Jul 2005 16:08:32 +0200
Subject: [Qrc-svn] r159 - in qrc/trunk: . gaym/src
Message-ID: <200507061408.j66E8WnL026033@sheep.berlios.de>

Author: deckrider
Date: 2005-07-06 16:08:31 +0200 (Wed, 06 Jul 2005)
New Revision: 159

Modified:
   qrc/trunk/ChangeLog
   qrc/trunk/gaym/src/cmds.c
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/helpers.c
   qrc/trunk/gaym/src/helpers.h
   qrc/trunk/gaym/src/msgs.c
Log:
We can't count on users entering a nick with a space in front of it if
its needed.  Thus, I'm changing the nick conversion to work without
needing a space.  Part of this change is to make the conversion TO
gay.com allocate a string that must later be freed.  All invocations of
the old function do that anyway before calling it, so this eliminates an
extra line each time the function is called.  I've renamed the TO and
FROM functions to try to be mirrors of each other, except the TO has
_strdup as part of its name to be certain developers know that the
returned string must be freed when it is no longer needed.

Also relaxed the nick validation rules, in light of the above changes.

This commit adds some documentation tweaks and addresses some memory
leaks noticed while working on the above changes.


Modified: qrc/trunk/ChangeLog
===================================================================
--- qrc/trunk/ChangeLog	2005-07-06 06:37:36 UTC (rev 158)
+++ qrc/trunk/ChangeLog	2005-07-06 14:08:31 UTC (rev 159)
@@ -3,7 +3,8 @@
 	- none
 
 	Bug Fixes:
-	- none
+	- Fixed protocol interaction with member names containing
+	  certain characters
 
 	Preference Changes:
 	- none

Modified: qrc/trunk/gaym/src/cmds.c
===================================================================
--- qrc/trunk/gaym/src/cmds.c	2005-07-06 06:37:36 UTC (rev 158)
+++ qrc/trunk/gaym/src/cmds.c	2005-07-06 14:08:31 UTC (rev 159)
@@ -285,8 +285,7 @@
     if (!args || !args[0])
         return 0;
 
-    temp = g_strdup(args[0]);
-    gaym_convert_nick_to_gaycom(temp);
+    temp = gaym_nick_to_gcom_strdup(args[0]);
     buf = gaym_format(gaym, "v:", "NICK", temp);
     gaym_send(gaym, buf);
     g_free(buf);
@@ -392,8 +391,7 @@
     if (!args || !args[0] || !args[1])
         return 0;
 
-    nick = g_strdup(args[0]);
-    gaym_convert_nick_to_gaycom(nick);
+    nick = gaym_nick_to_gcom_strdup(args[0]);
     cur = args[1];
     end = args[1];
     while (*end && *cur) {
@@ -561,9 +559,8 @@
         return 0;
 
     gaym->whois.nick = g_strdup(args[0]);
-    converted_nick = g_strdup(args[0]);
-    convert_nick_from_gaycom(gaym->whois.nick);
-    gaym_convert_nick_to_gaycom(converted_nick);
+    gcom_nick_to_gaym(gaym->whois.nick);
+    converted_nick = gaym_nick_to_gcom_strdup(args[0]);
     buf = gaym_format(gaym, "vn", "WHOIS", converted_nick);
     gaym_send(gaym, buf);
     g_free(buf);

Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-06 06:37:36 UTC (rev 158)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-06 14:08:31 UTC (rev 159)
@@ -145,12 +145,11 @@
         ib->stale = TRUE;
         ib->done = TRUE;
         ib->flag = FALSE;
-        converted_name = g_strdup(name);
-        gaym_convert_nick_to_gaycom(converted_name);
+        converted_name = gaym_nick_to_gcom_strdup(name);
         g_string_append_printf(string, "%s ", converted_name);
+        g_free(converted_name);
         return;
     }
-
 }
 
 static void gaym_ison_one(struct gaym_conn *gaym, struct gaym_buddy *ib)
@@ -158,10 +157,10 @@
     char *buf;
     char *nick;
     ib->flag = FALSE;
-    nick = g_strdup(ib->name);
-    gaym_convert_nick_to_gaycom(nick);
+    nick = gaym_nick_to_gcom_strdup(ib->name);
     buf = gaym_format(gaym, "vn", "ISON", nick);
     gaym_send(gaym, buf);
+    g_free(nick);
     g_free(buf);
 }
 
@@ -474,8 +473,9 @@
                         "In login_cb, user_bioline: %x, gc->account=%x\n",
                         user_bioline, gc->account);
 
-        login_name = g_strdup(gaim_connection_get_display_name(gc));
-        gaym_convert_nick_to_gaycom(login_name);
+        login_name =
+            gaym_nick_to_gcom_strdup(gaim_connection_get_display_name(gc));
+
         bioline = g_strdup_printf("%s#%s",
                                   gaym->thumbnail,
                                   user_bioline ? user_bioline : "");
@@ -497,7 +497,7 @@
             gaim_connection_error(gc, "Error registering with server");
             return;
         }
-
+        g_free(login_name);
         g_free(buf);
 
         const char *server = gaim_account_get_string(gc->account, "server",
@@ -1039,14 +1039,14 @@
         gaym = (struct gaym_conn *) gc->proto_data;
 
         gaym->info_window_needed = FALSE;
-        name = g_strdup(conv->name);
 
-        gaym->whois.nick = g_strdup(name);
-        gaym_convert_nick_to_gaycom(name);
+        gaym->whois.nick = g_strdup(conv->name);
+        name = gaym_nick_to_gcom_strdup(conv->name);
         buf = gaym_format(gaym, "vn", "WHOIS", name);
         gaim_debug_misc("gaym", "Conversation triggered command: %s\n",
                         buf);
         gaym_send(gaym, buf);
+        g_free(name);
         g_free(buf);
     }
 }

Modified: qrc/trunk/gaym/src/helpers.c
===================================================================
--- qrc/trunk/gaym/src/helpers.c	2005-07-06 06:37:36 UTC (rev 158)
+++ qrc/trunk/gaym/src/helpers.c	2005-07-06 14:08:31 UTC (rev 159)
@@ -23,35 +23,69 @@
 
 #include "helpers.h"
 
-void gaym_convert_nick_to_gaycom(char *name)
+void gcom_nick_to_gaym(char *nick)
 {
-    int i;
-    
-    //If the first character is a punctuation or a number,
-    //Gay.com inserts a | character in front. We remedy this by changing 
-    //it to a space. This changes it back.
-    if (name[0]==' ')
-	name[0]='|';
-    
-    if (!name) {
+    int i = 0;
+
+    if (!nick) {
         return;
     }
-    for (i = 0; i < strlen(name); i++) {
-        if (name[i] == '.') {
-            name[i] = '|';
+
+    /**
+     * If there is a "|" in the first position, it must be removed.
+     */
+    if (nick[0] == '|') {
+        nick[0] = ' ';
+        nick = g_strchug(nick);
+    }
+
+    /**
+     * Any remaining "|" must be replaced with "."
+     */
+    for (i = 0; i < strlen(nick); i++) {
+        if (nick[i] == '|') {
+            nick[i] = '.';
         }
     }
+    return;
 }
 
+char *gaym_nick_to_gcom_strdup(const char *nick)
+{
+    int i = 0;
+    char *converted = NULL;
+
+    /**
+     * If the first character is not an upper or lower case letter
+     * then gay.com's IRC server requires "|" to be prepended
+     */
+    if (g_ascii_isalpha(nick[0])) {
+        converted = g_strdup_printf("%s", nick);
+    } else {
+        converted = g_strdup_printf("|%s", nick);
+    }
+
+    /**
+     * gay.com's IRC server requires all "." in nicks to be represented
+     * by "|"
+     */
+    for (i = 0; i < strlen(converted); i++) {
+        if (converted[i] == '.') {
+            converted[i] = '|';
+        }
+    }
+    return converted;
+}
+
 char *return_string_between(const char *startbit, const char *endbit,
                             const char *source)
 {
     char *start = 0;
     char *end = 0;
 
-    if(!source || !startbit || !endbit)
-	return 0;
-    
+    if (!source || !startbit || !endbit)
+        return 0;
+
     start = strstr(source, startbit);
 
     if (start) {
@@ -69,39 +103,6 @@
     }
 }
 
-/*
-char *convert_nick_to_gc(char *nick)
-{
-    int i;
-    char *out = g_strdup(nick);
-    for (i = 0; i < strlen(out); i++) {
-        if (out[i] == '.') {
-            out[i] = '|';
-        }
-    }
-    return out;
-}
-*/
-void convert_nick_from_gaycom(char *name)
-{
-    int i;
-
-    if (!name) {
-        return;
-    }
-
-    //If the first character is a punctuation or a number,
-    //Gay.com inserts a | character in front. Get rid of it.
-    if (name[0]=='|')
-	name[0]=' ';
-
-    for (i = 0; i < strlen(name); i++) {
-        if (name[i] == '|') {
-            name[i] = '.';
-        }
-    }
-}
-
 gchar *ascii2native(const gchar * str)
 {
     gint i;                     /* Temp variable */
@@ -166,30 +167,15 @@
         return retval;
     }
 
-    char *firstchar =
-        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\0";
     char *allowed =
         "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-\0";
     int i = 0;
     int j = 0;
 
     /**
-     * first character validation is different from the remaining
-     * characters
+     * validate characters
      */
-    for (i = 0; firstchar[i]; i++) {
-        if (nick[0] == firstchar[i]) {
-            retval = TRUE;
-            break;
-        }
-    }
-    if (!retval) {
-        return retval;
-    }
-    /**
-     * validate remaining characters (but not the first character)
-     */
-    for (i = 1; nick[i]; i++) {
+    for (i = 0; nick[i]; i++) {
         retval = FALSE;
         for (j = 0; allowed[j]; j++) {
             if (nick[i] == allowed[j]) {

Modified: qrc/trunk/gaym/src/helpers.h
===================================================================
--- qrc/trunk/gaym/src/helpers.h	2005-07-06 06:37:36 UTC (rev 158)
+++ qrc/trunk/gaym/src/helpers.h	2005-07-06 14:08:31 UTC (rev 159)
@@ -29,9 +29,26 @@
 char *return_string_between(const char *startbit, const char *endbit,
                             const char *source);
 
-void gaym_convert_nick_to_gaycom(char *);
+/**
+ * Convert a nick from gay.com to what GayM needs to see.
+ * The conversion is done in place.  The converted value
+ * is for use within GayM/Gaim as well as with http requests
+ * to gay.com. When interacting with gay.com's IRC server,
+ * the nick must be converted using gaym_nick_to_gcom_strdup().
+ *
+ * @param nick The nick to convert.
+ */
+void gcom_nick_to_gaym(char *nick);
 
-void convert_nick_from_gaycom(char *);
+/**
+ * Convert a nick to what the gay.com IRC server needs to see.
+ * The returned string should be freed when no longer needed.
+ *
+ * @param nick The nick to convert.
+ *
+ * @return The converted nick.
+ */
+char *gaym_nick_to_gcom_strdup(const char *nick);
 
 /**
  * Convert a string that is pure ascii, that uses a pure ascii approach

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-06 06:37:36 UTC (rev 158)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-06 14:08:31 UTC (rev 159)
@@ -156,7 +156,7 @@
         return;
     }
 
-    convert_nick_from_gaycom(args[1]);
+    gcom_nick_to_gaym(args[1]);
     serv_got_im(gc, args[1], args[2], GAIM_CONV_IM_AUTO_RESP, time(NULL));
 }
 
@@ -291,7 +291,7 @@
         return;
     }
 
-    convert_nick_from_gaycom(args[1]);
+    gcom_nick_to_gaym(args[1]);
     gaym->info_window_needed = 0;
     char *buf;
 
@@ -308,7 +308,7 @@
 {
     char *thumburl = NULL;
 
-    convert_nick_from_gaycom(args[1]);
+    gcom_nick_to_gaym(args[1]);
     if (!gaym->whois.nick) {
         gaim_debug(GAIM_DEBUG_WARNING, "gaym",
                    "Unexpected WHOIS reply for %s\n", args[1]);
@@ -934,7 +934,7 @@
     }
 
     g_hash_table_insert(components, strdup("channel"), strdup(args[1]));
-    convert_nick_from_gaycom(nick);
+    gcom_nick_to_gaym(nick);
     serv_got_chat_invite(gc, args[1], nick, NULL, components);
 
     g_free(nick);
@@ -966,7 +966,7 @@
         return;
     nicks = g_strsplit(args[1], " ", -1);
     for (i = 0; (nicks[i] != NULL) && (*nicks[i] != '\0'); i++) {
-        convert_nick_from_gaycom(nicks[i]);
+        gcom_nick_to_gaym(nicks[i]);
         if ((ib =
              g_hash_table_lookup(gaym->buddies,
                                  (gconstpointer) nicks[i])) == NULL) {
@@ -1040,7 +1040,7 @@
         return;
     }
 
-    convert_nick_from_gaycom(nick);
+    gcom_nick_to_gaym(nick);
     if (!gaim_utf8_strcasecmp(nick, gaim_connection_get_display_name(gc))) {
         /* We are joining a channel for the first time */
         if (gaym->persist_room && !strcmp(gaym->persist_room, args[0])) {
@@ -1242,7 +1242,7 @@
 
     convo = gaim_find_conversation_with_account(args[0], gaym->account);
 
-    convert_nick_from_gaycom(nick);
+    gcom_nick_to_gaym(nick);
     if (!gaim_utf8_strcasecmp(nick, gaim_connection_get_display_name(gc))) {
         msg = g_strdup_printf(_("You have parted the channel"));
 
@@ -1350,9 +1350,9 @@
         return;
     }
 
-    convert_nick_from_gaycom(args[1]);
-    convert_nick_from_gaycom(args[0]);
-    convert_nick_from_gaycom(nick);
+    gcom_nick_to_gaym(args[1]);
+    gcom_nick_to_gaym(args[0]);
+    gcom_nick_to_gaym(nick);
 
     convo = gaim_find_conversation_with_account(args[0], gaym->account);
 
@@ -1587,7 +1587,7 @@
         return;
     }
 
-    convert_nick_from_gaycom(nick);
+    gcom_nick_to_gaym(nick);
     gaim_debug(GAIM_DEBUG_INFO, "gaym",
                "gaym_msg_richnames_list() Channel: %s Nick: %s Extra: %s\n",
                channel, nick, extra);



From deckrider at berlios.de  Wed Jul  6 17:29:49 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Wed, 6 Jul 2005 17:29:49 +0200
Subject: [Qrc-svn] r160 - in qrc/trunk: . gaym/src
Message-ID: <200507061529.j66FTn4a031833@sheep.berlios.de>

Author: deckrider
Date: 2005-07-06 17:29:47 +0200 (Wed, 06 Jul 2005)
New Revision: 160

Modified:
   qrc/trunk/ChangeLog
   qrc/trunk/gaym/src/cmds.c
   qrc/trunk/gaym/src/msgs.c
Log:
Only convert nicks to/from the gay.com IRC format, not channels or
the contents of messages.


Modified: qrc/trunk/ChangeLog
===================================================================
--- qrc/trunk/ChangeLog	2005-07-06 14:08:31 UTC (rev 159)
+++ qrc/trunk/ChangeLog	2005-07-06 15:29:47 UTC (rev 160)
@@ -3,8 +3,10 @@
 	- none
 
 	Bug Fixes:
-	- Fixed protocol interaction with member names containing
-	  certain characters
+	- Fixed protocol problem affecting member names containing
+	  beginning with non-alpha characters
+	- Fixed problem where "|" was replaced by "." in Chat and IM
+	  messages
 
 	Preference Changes:
 	- none

Modified: qrc/trunk/gaym/src/cmds.c
===================================================================
--- qrc/trunk/gaym/src/cmds.c	2005-07-06 14:08:31 UTC (rev 159)
+++ qrc/trunk/gaym/src/cmds.c	2005-07-06 15:29:47 UTC (rev 160)
@@ -391,7 +391,15 @@
     if (!args || !args[0] || !args[1])
         return 0;
 
-    nick = gaym_nick_to_gcom_strdup(args[0]);
+    /**
+     * Only run gaym_nick_to_gcom_strdup() against nicks,
+     * never on channels (which begin with either "#" or "&")
+     */
+    if (!args[0] == '#' && !args[0] == '&') {
+        nick = gaym_nick_to_gcom_strdup(args[0]);
+    } else {
+        nick = g_strdup(args[0]);
+    }
     cur = args[1];
     end = args[1];
     while (*end && *cur) {

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-06 14:08:31 UTC (rev 159)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-06 15:29:47 UTC (rev 160)
@@ -1350,9 +1350,33 @@
         return;
     }
 
-    gcom_nick_to_gaym(args[1]);
-    gcom_nick_to_gaym(args[0]);
+    /**
+     * Only nicks (sender/receiver) should use gcom_nick_to_gaym().
+     *
+     * Channels (which begin with either "#" or "&") should not be
+     * converted.
+     *
+     * Messages should also not be converted.
+     *
+     * CHAT ROOM:
+     * nick = the sender
+     * args[0] = the receiving channel
+     * args[1] = the message
+     *
+     * INSTANT MESSAGE:
+     * nick = the sender
+     * args[0] = the receiver (me)
+     * args[1] = the message
+     *
+     * NOTICE:
+     * nick = the sender
+     * args[0] = " notice "
+     * args[1] = the message
+     */
     gcom_nick_to_gaym(nick);
+    if (!args[0] == '#' && !args[0] == '&') {
+        gcom_nick_to_gaym(args[0]);
+    }
 
     convo = gaim_find_conversation_with_account(args[0], gaym->account);
 



From deckrider at berlios.de  Wed Jul  6 17:40:33 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Wed, 6 Jul 2005 17:40:33 +0200
Subject: [Qrc-svn] r161 - qrc/trunk
Message-ID: <200507061540.j66FeXTR032484@sheep.berlios.de>

Author: deckrider
Date: 2005-07-06 17:40:32 +0200 (Wed, 06 Jul 2005)
New Revision: 161

Modified:
   qrc/trunk/ChangeLog
Log:
Fixed spelling (thanks r0bby1982).

Modified: qrc/trunk/ChangeLog
===================================================================
--- qrc/trunk/ChangeLog	2005-07-06 15:29:47 UTC (rev 160)
+++ qrc/trunk/ChangeLog	2005-07-06 15:40:32 UTC (rev 161)
@@ -16,7 +16,7 @@
 	- Full win32 support for autotools and packaging
 	- Enabled and implemented all Gaim privacy hooks, including
 	  synchronization of ignore list with gay.com's server
-	- New /trace command to opbain IP address of a user
+	- New /trace command to obtain IP address of a user
 	- New protocol icon
 	- Enabled "Warn", mapping it to gay.com's "Report User" web
 	  form.



From deckrider at berlios.de  Wed Jul  6 18:14:35 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Wed, 6 Jul 2005 18:14:35 +0200
Subject: [Qrc-svn] r162 - qrc/trunk
Message-ID: <200507061614.j66GEZtb002446@sheep.berlios.de>

Author: deckrider
Date: 2005-07-06 18:14:34 +0200 (Wed, 06 Jul 2005)
New Revision: 162

Modified:
   qrc/trunk/ChangeLog
Log:
Updated ChangeLog

Modified: qrc/trunk/ChangeLog
===================================================================
--- qrc/trunk/ChangeLog	2005-07-06 15:40:32 UTC (rev 161)
+++ qrc/trunk/ChangeLog	2005-07-06 16:14:34 UTC (rev 162)
@@ -7,6 +7,7 @@
 	  beginning with non-alpha characters
 	- Fixed problem where "|" was replaced by "." in Chat and IM
 	  messages
+	- Addressed several memory leaks
 
 	Preference Changes:
 	- none



From deckrider at berlios.de  Thu Jul  7 00:52:29 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Thu, 7 Jul 2005 00:52:29 +0200
Subject: [Qrc-svn] r163 - qrc/trunk/gaym/src
Message-ID: <200507062252.j66MqT8n023810@sheep.berlios.de>

Author: deckrider
Date: 2005-07-07 00:52:15 +0200 (Thu, 07 Jul 2005)
New Revision: 163

Modified:
   qrc/trunk/gaym/src/cmds.c
   qrc/trunk/gaym/src/msgs.c
Log:
Brown paper bag fix of my earlier commit.

Modified: qrc/trunk/gaym/src/cmds.c
===================================================================
--- qrc/trunk/gaym/src/cmds.c	2005-07-06 16:14:34 UTC (rev 162)
+++ qrc/trunk/gaym/src/cmds.c	2005-07-06 22:52:15 UTC (rev 163)
@@ -395,7 +395,7 @@
      * Only run gaym_nick_to_gcom_strdup() against nicks,
      * never on channels (which begin with either "#" or "&")
      */
-    if (!args[0] == '#' && !args[0] == '&') {
+    if (args[0][0] != '#' && args[0][0] != '&') {
         nick = gaym_nick_to_gcom_strdup(args[0]);
     } else {
         nick = g_strdup(args[0]);

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-06 16:14:34 UTC (rev 162)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-06 22:52:15 UTC (rev 163)
@@ -1374,7 +1374,7 @@
      * args[1] = the message
      */
     gcom_nick_to_gaym(nick);
-    if (!args[0] == '#' && !args[0] == '&') {
+    if (args[0][0] != '#' && args[0][0] != '&') {
         gcom_nick_to_gaym(args[0]);
     }
 



From deckrider at berlios.de  Thu Jul  7 18:15:49 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Thu, 7 Jul 2005 18:15:49 +0200
Subject: [Qrc-svn] r164 - qrc/trunk
Message-ID: <200507071615.j67GFnlY002196@sheep.berlios.de>

Author: deckrider
Date: 2005-07-07 18:15:48 +0200 (Thu, 07 Jul 2005)
New Revision: 164

Modified:
   qrc/trunk/ChangeLog
Log:
Fixed wording.

Modified: qrc/trunk/ChangeLog
===================================================================
--- qrc/trunk/ChangeLog	2005-07-06 22:52:15 UTC (rev 163)
+++ qrc/trunk/ChangeLog	2005-07-07 16:15:48 UTC (rev 164)
@@ -3,8 +3,8 @@
 	- none
 
 	Bug Fixes:
-	- Fixed protocol problem affecting member names containing
-	  beginning with non-alpha characters
+	- Fixed protocol problem affecting member names beginning with
+	  non-alpha characters
 	- Fixed problem where "|" was replaced by "." in Chat and IM
 	  messages
 	- Addressed several memory leaks



From deckrider at berlios.de  Fri Jul  8 02:59:02 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Fri, 8 Jul 2005 02:59:02 +0200
Subject: [Qrc-svn] r166 - qrc/trunk/gaym/src
Message-ID: <200507080059.j680x2QE018099@sheep.berlios.de>

Author: deckrider
Date: 2005-07-08 02:58:25 +0200 (Fri, 08 Jul 2005)
New Revision: 166

Modified:
   qrc/trunk/gaym/src/configtxt.c
Log:
Nicks coming from config.txt are in gay.com IRC server format and must
be converted to GayM internal format.


Modified: qrc/trunk/gaym/src/configtxt.c
===================================================================
--- qrc/trunk/gaym/src/configtxt.c	2005-07-07 20:22:08 UTC (rev 165)
+++ qrc/trunk/gaym/src/configtxt.c	2005-07-08 00:58:25 UTC (rev 166)
@@ -37,6 +37,7 @@
 /* local headers for this plugin */
 #include "gaympriv.h"
 #include "gaym.h"
+#include "helpers.h"
 
 void synchronize_deny_list(GaimConnection * gc, const char *configtxt)
 {
@@ -55,6 +56,14 @@
 
     srvdenylist = g_strsplit(srvdeny, ",", -1);
 
+    /**
+     * The nicks come in here as if they came from the IRC server
+     * so they need to be converted to GayM format
+     */
+    for (i = 0; srvdenylist[i]; i++) {
+        gcom_nick_to_gaym(srvdenylist[i]);
+    }
+
     /* Add server deny list from config.txt to local deny list */
     for (i = 0; srvdenylist[i]; i++) {
         needsync = TRUE;



From deckrider at berlios.de  Fri Jul  8 15:02:22 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Fri, 8 Jul 2005 15:02:22 +0200
Subject: [Qrc-svn] r167 - debian/gaim-qrc/branches/upstream
Message-ID: <200507081302.j68D2MDq022943@sheep.berlios.de>

Author: deckrider
Date: 2005-07-08 15:02:21 +0200 (Fri, 08 Jul 2005)
New Revision: 167

Added:
   debian/gaim-qrc/branches/upstream/0.34.0+2005-07-08/
Log:
[svn-upgrade] Tagging new upstream version, gaim-qrc (0.34.0+2005-07-08)

Copied: debian/gaim-qrc/branches/upstream/0.34.0+2005-07-08 (from rev 166, debian/gaim-qrc/branches/upstream/current)



From deckrider at berlios.de  Fri Jul  8 15:06:40 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Fri, 8 Jul 2005 15:06:40 +0200
Subject: [Qrc-svn] r168 - debian/gaim-qrc/branches/upstream
Message-ID: <200507081306.j68D6eOs023550@sheep.berlios.de>

Author: deckrider
Date: 2005-07-08 15:06:39 +0200 (Fri, 08 Jul 2005)
New Revision: 168

Removed:
   debian/gaim-qrc/branches/upstream/0.34.0+2005-07-08/
Log:
Removing directory accidentally added during testing.



From deckrider at berlios.de  Fri Jul  8 15:26:40 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Fri, 8 Jul 2005 15:26:40 +0200
Subject: [Qrc-svn] r169 - debian/gaim-qrc/trunk/debian
Message-ID: <200507081326.j68DQeY1025571@sheep.berlios.de>

Author: deckrider
Date: 2005-07-08 15:26:30 +0200 (Fri, 08 Jul 2005)
New Revision: 169

Removed:
   debian/gaim-qrc/trunk/debian/watch
Log:
When using svn-buildpackage, a watch file does not appear to be needed.

Deleted: debian/gaim-qrc/trunk/debian/watch
===================================================================
--- debian/gaim-qrc/trunk/debian/watch	2005-07-08 13:06:39 UTC (rev 168)
+++ debian/gaim-qrc/trunk/debian/watch	2005-07-08 13:26:30 UTC (rev 169)
@@ -1,17 +0,0 @@
-# Example watch control file for uscan
-# Rename this file to "watch" and then you can run the "uscan" command
-# to check for upstream updates and more.
-# See uscan(1) for format
-
-# Compulsory line, this is a version 2 file
-version=2
-
-# Uncomment to examine a Webpage 
-# <Webpage URL> <string match>
-#http://www.example.com/downloads.php #PACKAGE#-(.*)\.tar\.gz
-
-# Uncomment to examine a Webserver directory
-http://download.berlios.de/qrc/qrc-(.*)\.tar\.bz2
-
-# Uncommment to examine a FTP server
-#ftp://ftp.example.com/pub/#PACKAGE#-(.*)\.tar\.gz debian uupdate



From deckrider at berlios.de  Fri Jul  8 16:10:26 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Fri, 8 Jul 2005 16:10:26 +0200
Subject: [Qrc-svn] r170 - qrc/trunk
Message-ID: <200507081410.j68EAQl4029135@sheep.berlios.de>

Author: deckrider
Date: 2005-07-08 16:10:25 +0200 (Fri, 08 Jul 2005)
New Revision: 170

Modified:
   qrc/trunk/ChangeLog
   qrc/trunk/configure.ac
Log:
Preparing for 0.34.1 release

Modified: qrc/trunk/ChangeLog
===================================================================
--- qrc/trunk/ChangeLog	2005-07-08 13:26:30 UTC (rev 169)
+++ qrc/trunk/ChangeLog	2005-07-08 14:10:25 UTC (rev 170)
@@ -1,7 +1,4 @@
-0.34.0+svn:
-	New Features:
-	- none
-
+0.34.1:
 	Bug Fixes:
 	- Fixed protocol problem affecting member names beginning with
 	  non-alpha characters
@@ -9,9 +6,6 @@
 	  messages
 	- Addressed several memory leaks
 
-	Preference Changes:
-	- none
-
 0.34.0:
 	New Features:
 	- Full win32 support for autotools and packaging

Modified: qrc/trunk/configure.ac
===================================================================
--- qrc/trunk/configure.ac	2005-07-08 13:26:30 UTC (rev 169)
+++ qrc/trunk/configure.ac	2005-07-08 14:10:25 UTC (rev 170)
@@ -2,7 +2,7 @@
 # Process this file with autoconf to produce a configure script.
 
 AC_PREREQ(2.59)
-AC_INIT([qrc],[0.34.0+svn],[gaymplugin at yahoogroups.com])
+AC_INIT([qrc],[0.34.1],[gaymplugin at yahoogroups.com])
 AC_CANONICAL_TARGET([])
 AM_INIT_AUTOMAKE([1.9.5 no-dist-gzip dist-bzip2])
 



From deckrider at berlios.de  Fri Jul  8 16:43:51 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Fri, 8 Jul 2005 16:43:51 +0200
Subject: [Qrc-svn] r171 - in qrc/tags: . 0.34.1 0.34.1/gaym/src
Message-ID: <200507081443.j68EhpFr030944@sheep.berlios.de>

Author: deckrider
Date: 2005-07-08 16:43:50 +0200 (Fri, 08 Jul 2005)
New Revision: 171

Added:
   qrc/tags/0.34.1/
   qrc/tags/0.34.1/ChangeLog
   qrc/tags/0.34.1/configure.ac
   qrc/tags/0.34.1/gaym/src/configtxt.c
Removed:
   qrc/tags/0.34.1/ChangeLog
   qrc/tags/0.34.1/configure.ac
   qrc/tags/0.34.1/gaym/src/configtxt.c
Log:
Tagging 0.34.1


Copied: qrc/tags/0.34.1 (from rev 165, qrc/trunk)

Deleted: qrc/tags/0.34.1/ChangeLog
===================================================================
--- qrc/trunk/ChangeLog	2005-07-07 20:22:08 UTC (rev 165)
+++ qrc/tags/0.34.1/ChangeLog	2005-07-08 14:43:50 UTC (rev 171)
@@ -1,66 +0,0 @@
-0.34.0+svn:
-	New Features:
-	- none
-
-	Bug Fixes:
-	- Fixed protocol problem affecting member names beginning with
-	  non-alpha characters
-	- Fixed problem where "|" was replaced by "." in Chat and IM
-	  messages
-	- Addressed several memory leaks
-
-	Preference Changes:
-	- none
-
-0.34.0:
-	New Features:
-	- Full win32 support for autotools and packaging
-	- Enabled and implemented all Gaim privacy hooks, including
-	  synchronization of ignore list with gay.com's server
-	- New /trace command to obtain IP address of a user
-	- New protocol icon
-	- Enabled "Warn", mapping it to gay.com's "Report User" web
-	  form.
-	- New bot-challenger plugin to block unwanted IM pop-ups
-	- New roombrowse plugin (alpha).
-	- New chatsort plugin (alpha).
-	- Permit user to customize bot filtering strings (see preference
-	  changes below)
-
-	Bug Fixes:
-	- More cleanup/fix of autotools
-	- Code / documentation / repository cleanup / restructuring
-	- Fixed problems that caused invalid characters/commands to be
-	  sent to the server when checking to see if buddy list members
-	  were on line
-
-	Preference Changes:
-	- Number of chat room instances to display
-	- Enable/disable bot filtering in chat
-	- Modification of bot filtering strings
-	- Download and use GayBoi's spam list
-	- Removed entrance/exit notification option, since this is
-	  available in another plugin:  http://gaim-extprefs.sf.net/
-
-0.33.0:
-	New Features:
-	- Improved thumbnail grabs
-	- Green star in chat indicates photo
-	- Half green star in chat indicates adult photo
-	- Retrieve member created rooms
-	- Add protocol icon support
-
-	Bug Fixes:
-	- Fixed crash when user has no bio or profile
-	- Use copy for nick conversions
-	- Null/dangling pointer fixes
-	- Cleanup/fix of autotools
-	- Show special characters properly in roomlist
-	- Show error when non-member tries to create a new room
-
-	Preference Changes:
-	- Entrance/exit notification option
-	- Optional bio line in entrance notification
-
-0.21.0:
-	Initial Release.

Copied: qrc/tags/0.34.1/ChangeLog (from rev 170, qrc/trunk/ChangeLog)

Deleted: qrc/tags/0.34.1/configure.ac
===================================================================
--- qrc/trunk/configure.ac	2005-07-07 20:22:08 UTC (rev 165)
+++ qrc/tags/0.34.1/configure.ac	2005-07-08 14:43:50 UTC (rev 171)
@@ -1,149 +0,0 @@
-#                                               -*- Autoconf -*-
-# Process this file with autoconf to produce a configure script.
-
-AC_PREREQ(2.59)
-AC_INIT([qrc],[0.34.0+svn],[gaymplugin at yahoogroups.com])
-AC_CANONICAL_TARGET([])
-AM_INIT_AUTOMAKE([1.9.5 no-dist-gzip dist-bzip2])
-
-REQUIRED_PKG_CONFIG="0.15.0"
-AC_SUBST(REQUIRED_PKG_CONFIG)
-
-REQUIRED_GAIM="gaim >= 1.2 gaim < 2.0"
-AC_SUBST(REQUIRED_GAIM)
-
-REQUIRED_GTK="gtk+-2.0"
-AC_SUBST(REQUIRED_GTK)
-
-AC_CONFIG_SRCDIR([gaym/src/gaym.h])
-AC_CONFIG_HEADER([config.h])
-
-AC_DEFINE(GAIM_PLUGINS, 1, [Define if plugins are enabled.])
-
-# Checks for programs.
-AC_PROG_CC
-AC_DISABLE_STATIC
-AC_LIBTOOL_WIN32_DLL
-AC_PROG_LIBTOOL
-LIBTOOL="$LIBTOOL --silent"
-AC_PROG_INSTALL
-AC_PATH_PROG(PKG_CONFIG, [pkg-config], [no])
-
-if test x$PKG_CONFIG = xno ; then
-  AC_MSG_ERROR([*** pkg-config not found])
-fi
-
-# Build preferences
-AC_ARG_ENABLE([bot-challenger],
-	[AS_HELP_STRING(--enable-bot-challenger,build the bot-challenger plugin @<:@default=yes@:>@)],,
-	[enable_bot_challenger="yes"])
-
-AC_ARG_ENABLE([chatsort],
-	[AS_HELP_STRING(--enable-chatsort,build the chatsort plugin @<:@default=no@:>@)],,
-	[enable_chatsort="no"])
-
-AC_ARG_ENABLE([gaym],
-	[AS_HELP_STRING(--enable-gaym,build the gaym plugin @<:@default=yes@:>@)],,
-	[enable_gaym="yes"])
-
-AC_ARG_ENABLE([roombrowse],
-	[AS_HELP_STRING(--enable-roombrowse,build the roombrowse plugin @<:@default=no@:>@)],,
-	[enable_roombrowse="no"])
-
-AM_CONDITIONAL([COND_BOT_CHALLENGER], [test "$enable_bot_challenger" = "yes"])
-AM_CONDITIONAL([COND_CHATSORT], [test "$enable_chatsort" = "yes"])
-AM_CONDITIONAL([COND_GAYM], [test "$enable_gaym" = "yes"])
-AM_CONDITIONAL([COND_ROOMBROWSE], [test "$enable_roombrowse" = "yes"])
-
-if test "$enable_bot_challenger" != "yes" ; then
-	enable_bot_challener="no"
-fi
-
-if test "$enable_chatsort" != "yes" ; then
-	enable_chatsort="no"
-fi
-
-if test "$enable_gaym" != "yes" ; then
-	enable_gaym="no"
-fi
-
-if test "$enable_roombrowse" != "yes" ; then
-	enable_roombrowse="no"
-fi
-
-# Checks for libraries.
-PKG_PROG_PKG_CONFIG([$REQUIRED_PKG_CONFIG])
-if test "$enable_chatsort" = "yes" -o "$enable_roombrowse" = "yes" ; then
-	PKG_CHECK_MODULES([GTK], [$REQUIRED_GTK],
-		[
-		AC_SUBST(GTK_CFLAGS)
-		AC_SUBST(GTK_LIBS)
-		]
-	)
-fi
-PKG_CHECK_MODULES([GAIM], [$REQUIRED_GAIM],
-	[
-	AC_SUBST(GAIM_CFLAGS)
-	AC_SUBST(GAIM_LIBS)
-	]
-)
-AC_ARG_VAR([GAIM_DATADIR], [datadir of GAIM, overriding pkg-config])dnl
-AC_ARG_VAR([GAIM_LIBDIR], [libdir of GAIM, overriding pkg-config])dnl
-AC_CACHE_CHECK([for GAIM][_DATADIR], [pkg_cv_][GAIM][_DATADIR],
-	[_PKG_CONFIG([GAIM][_DATADIR], [variable=datadir], [gaim])])
-AC_CACHE_CHECK([for GAIM][_LIBDIR], [pkg_cv_][GAIM][_LIBDIR],
-	[_PKG_CONFIG([GAIM][_LIBDIR], [variable=libdir], [gaim])])
-GAIM[]_DATADIR=$pkg_cv_[]GAIM[]_DATADIR
-GAIM[]_LIBDIR=$pkg_cv_[]GAIM[]_LIBDIR
-AC_SUBST(GAIM_DATADIR)
-AC_SUBST(GAIM_LIBDIR)
-
-# Checks for header files.
-AC_HEADER_STDC
-AC_CHECK_HEADERS([stdlib.h string.h])
-
-# Checks for typedefs, structures, and compiler characteristics.
-AC_C_CONST
-AC_TYPE_SIZE_T
-
-# Checks for library functions.
-AC_CHECK_FUNCS([gethostname inet_ntoa memmove strcasecmp strchr strdup strerror strpbrk strrchr strstr strtoul])
-
-case "$host" in
-	*-*-mingw*)
-	CFLAGS="$CFLAGS -O2 -Wall -mno-cygwin -mms-bitfields"
-	LIBS="$LIBS -no-undefined -Wl,--enable-auto-image-base -lws2_32"
-	;;
-	*)
-	;;
-esac
-
-if test "x$GCC" = "xyes"; then
-	CFLAGS="$CFLAGS -Wall -g3"
-fi
-AC_SUBST(CFLAGS)
-
-
-AC_CONFIG_FILES([Makefile
-                 bot-challenger/Makefile
-                 chatsort/Makefile
-                 gaym/Makefile
-                 gaym/pixmaps/Makefile
-                 gaym/src/Makefile
-                 nsis/Makefile
-		 nsis/locale/Makefile
-                 roombrowse/Makefile])
-AC_OUTPUT
-
-echo
-echo $PACKAGE $VERSION
-echo
-echo Build bot-challenger plugin...... : $enable_bot_challenger
-echo Build chatsort plugin............ : $enable_chatsort
-echo Build gaym plugin................ : $enable_gaym
-echo Build roombrowse plugin.......... : $enable_roombrowse
-echo
-echo Installation directory........... : $GAIM_LIBDIR/gaim
-echo
-echo configure complete, now type \'make\'
-echo

Copied: qrc/tags/0.34.1/configure.ac (from rev 170, qrc/trunk/configure.ac)

Deleted: qrc/tags/0.34.1/gaym/src/configtxt.c
===================================================================
--- qrc/trunk/gaym/src/configtxt.c	2005-07-07 20:22:08 UTC (rev 165)
+++ qrc/tags/0.34.1/gaym/src/configtxt.c	2005-07-08 14:43:50 UTC (rev 171)
@@ -1,111 +0,0 @@
-/**
- * GayM
- *
- * GayM is the legal property of its developers, whose names are too numerous
- * to list here.  Please refer to the COPYRIGHT file distributed with this
- * source distribution.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-/* config.h */
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-/* system headers */
-#include <glib.h>
-
-/* gaim headers for this plugin */
-#include "util.h"
-#include "debug.h"
-#include "account.h"
-#include "privacy.h"
-
-/* local headers for this plugin */
-#include "gaympriv.h"
-#include "gaym.h"
-
-void synchronize_deny_list(GaimConnection * gc, const char *configtxt)
-{
-    char *srvdeny = NULL;
-    char *start = NULL;
-    char *end = NULL;
-    gchar **srvdenylist = NULL;
-    GSList *list;
-    gint i = 0;
-    gboolean needsync = FALSE;
-
-    start =
-        g_strstr_len(configtxt, -1, "connect-list.ignore.members=") + 28;
-    end = g_strstr_len(start, -1, "\n");
-    srvdeny = g_strndup(start, end - start);
-
-    srvdenylist = g_strsplit(srvdeny, ",", -1);
-
-    /* Add server deny list from config.txt to local deny list */
-    for (i = 0; srvdenylist[i]; i++) {
-        needsync = TRUE;
-        for (list = gc->account->deny; list != NULL; list = list->next) {
-            if (!gaim_utf8_strcasecmp
-                (srvdenylist[i],
-                 gaim_normalize(gc->account, (char *) list->data))) {
-                needsync = FALSE;
-                break;
-            }
-        }
-        if (needsync) {
-            if (!gaim_privacy_deny_add(gc->account, srvdenylist[i], TRUE)) {
-                gaim_debug_error("gaym",
-                                 "Failed to add %s to local deny list from server.\n",
-                                 srvdenylist[i]);
-            } else {
-                gaim_debug_misc("gaym",
-                                "Added %s to local deny list from server.\n",
-                                srvdenylist[i]);
-            }
-        }
-    }
-
-    /* Add local deny list not found in config.txt to server deny list */
-    for (list = gc->account->deny; list != NULL; list = list->next) {
-        needsync = TRUE;
-        for (i = 0; srvdenylist[i]; i++) {
-            if (!gaim_utf8_strcasecmp
-                (srvdenylist[i],
-                 gaim_normalize(gc->account, (char *) list->data))) {
-                needsync = FALSE;
-                break;
-            }
-        }
-        if (needsync) {
-            gaym_server_store_deny(gc, (char *) list->data, TRUE);
-        }
-    }
-
-    g_strfreev(srvdenylist);
-    g_free(srvdeny);
-    return;
-}
-
-void process_configtxt(GaimConnection * gc, const char *configtxt)
-{
-    synchronize_deny_list(gc, configtxt);
-    return;
-}
-
-/**
- * vim:tabstop=4:shiftwidth=4:expandtab:
- */

Copied: qrc/tags/0.34.1/gaym/src/configtxt.c (from rev 166, qrc/trunk/gaym/src/configtxt.c)



From deckrider at berlios.de  Fri Jul  8 16:51:54 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Fri, 8 Jul 2005 16:51:54 +0200
Subject: [Qrc-svn] r172 - debian/gaim-qrc/branches/upstream
Message-ID: <200507081451.j68Epsqa032350@sheep.berlios.de>

Author: deckrider
Date: 2005-07-08 16:51:52 +0200 (Fri, 08 Jul 2005)
New Revision: 172

Added:
   debian/gaim-qrc/branches/upstream/0.34.1/
Log:
[svn-upgrade] Tagging new upstream version, gaim-qrc (0.34.1)

Copied: debian/gaim-qrc/branches/upstream/0.34.1 (from rev 171, debian/gaim-qrc/branches/upstream/current)



From deckrider at berlios.de  Fri Jul  8 16:55:47 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Fri, 8 Jul 2005 16:55:47 +0200
Subject: [Qrc-svn] r173 - debian/gaim-qrc/trunk/debian
Message-ID: <200507081455.j68EtlG4032730@sheep.berlios.de>

Author: deckrider
Date: 2005-07-08 16:55:45 +0200 (Fri, 08 Jul 2005)
New Revision: 173

Modified:
   debian/gaim-qrc/trunk/debian/changelog
Log:
New upstream release

Modified: debian/gaim-qrc/trunk/debian/changelog
===================================================================
--- debian/gaim-qrc/trunk/debian/changelog	2005-07-08 14:51:52 UTC (rev 172)
+++ debian/gaim-qrc/trunk/debian/changelog	2005-07-08 14:55:45 UTC (rev 173)
@@ -1,3 +1,9 @@
+gaim-qrc (0.34.1-1) unstable; urgency=low
+
+  * New upstream release
+
+ -- David Everly <deckrider at yahoo.com>  Fri,  8 Jul 2005 08:52:10 -0600
+
 gaim-qrc (0.34.0-1) unstable; urgency=low
 
   * New upstream release



From deckrider at berlios.de  Fri Jul  8 17:19:51 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Fri, 8 Jul 2005 17:19:51 +0200
Subject: [Qrc-svn] r174 - debian/gaim-qrc/tags
Message-ID: <200507081519.j68FJpZa002444@sheep.berlios.de>

Author: deckrider
Date: 2005-07-08 17:19:36 +0200 (Fri, 08 Jul 2005)
New Revision: 174

Added:
   debian/gaim-qrc/tags/0.34.1-1/
Log:
[svn-buildpackage] Tagging gaim-qrc (0.34.1-1)

Copied: debian/gaim-qrc/tags/0.34.1-1 (from rev 173, debian/gaim-qrc/trunk)



From deckrider at berlios.de  Fri Jul  8 17:37:34 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Fri, 8 Jul 2005 17:37:34 +0200
Subject: [Qrc-svn] r175 - qrc/trunk
Message-ID: <200507081537.j68FbYb0003803@sheep.berlios.de>

Author: deckrider
Date: 2005-07-08 17:37:33 +0200 (Fri, 08 Jul 2005)
New Revision: 175

Modified:
   qrc/trunk/ChangeLog
   qrc/trunk/configure.ac
Log:
Resuming development cycle.

Modified: qrc/trunk/ChangeLog
===================================================================
--- qrc/trunk/ChangeLog	2005-07-08 15:19:36 UTC (rev 174)
+++ qrc/trunk/ChangeLog	2005-07-08 15:37:33 UTC (rev 175)
@@ -1,3 +1,13 @@
+0.34.1+svn:
+	New Features:
+	- none
+
+	Bug Fixes:
+	- none
+
+	Preference Changes:
+	- none
+
 0.34.1:
 	Bug Fixes:
 	- Fixed protocol problem affecting member names beginning with

Modified: qrc/trunk/configure.ac
===================================================================
--- qrc/trunk/configure.ac	2005-07-08 15:19:36 UTC (rev 174)
+++ qrc/trunk/configure.ac	2005-07-08 15:37:33 UTC (rev 175)
@@ -2,7 +2,7 @@
 # Process this file with autoconf to produce a configure script.
 
 AC_PREREQ(2.59)
-AC_INIT([qrc],[0.34.1],[gaymplugin at yahoogroups.com])
+AC_INIT([qrc],[0.34.1+svn],[gaymplugin at yahoogroups.com])
 AC_CANONICAL_TARGET([])
 AM_INIT_AUTOMAKE([1.9.5 no-dist-gzip dist-bzip2])
 



From deckrider at berlios.de  Sat Jul  9 03:28:22 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sat, 9 Jul 2005 03:28:22 +0200
Subject: [Qrc-svn] r176 - qrc/trunk/gaym/src
Message-ID: <200507090128.j691SMdY007774@sheep.berlios.de>

Author: deckrider
Date: 2005-07-09 03:28:11 +0200 (Sat, 09 Jul 2005)
New Revision: 176

Modified:
   qrc/trunk/gaym/src/parse.c
Log:
RAW output is commented out.  Doing the same for RAW input logging.

Modified: qrc/trunk/gaym/src/parse.c
===================================================================
--- qrc/trunk/gaym/src/parse.c	2005-07-08 15:37:33 UTC (rev 175)
+++ qrc/trunk/gaym/src/parse.c	2005-07-09 01:28:11 UTC (rev 176)
@@ -464,7 +464,7 @@
         NULL, *fmt = NULL, **args = NULL, *msg = NULL;
     guint i;
 
-    gaim_debug(GAIM_DEBUG_INFO, "gaym", "RAW Protocol: %s\n", input);
+    /* gaim_debug(GAIM_DEBUG_INFO, "gaym", "RAW Protocol: %s\n", input); */
 
     if (!strncmp(input, "PING ", 5)) {
         msg = gaym_format(gaym, "vv", "PONG", input + 5);



From deckrider at berlios.de  Sat Jul  9 03:37:53 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sat, 9 Jul 2005 03:37:53 +0200
Subject: [Qrc-svn] r177 - qrc/trunk/gaym/src
Message-ID: <200507090137.j691brb3008665@sheep.berlios.de>

Author: deckrider
Date: 2005-07-09 03:37:49 +0200 (Sat, 09 Jul 2005)
New Revision: 177

Modified:
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/msgs.c
Log:
Adding back the ability to supress the join and part channel messages.
Even though this is duplicated functionality with the another plugin,
that plugin does not let you turn suppresson on/off on a per-prpl basis.
So I'm now convinced it should be added back.  Sorry for removing it
earlier.


Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-09 01:28:11 UTC (rev 176)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-09 01:37:49 UTC (rev 177)
@@ -1063,12 +1063,22 @@
 
     ppref =
         gaim_plugin_pref_new_with_name_and_label
+        ("/plugins/prpl/gaym/show_join", _("Show entrance announcement"));
+    gaim_plugin_pref_frame_add(frame, ppref);
+
+    ppref =
+        gaim_plugin_pref_new_with_name_and_label
         ("/plugins/prpl/gaym/show_bio_with_join",
          _("Show member bio with entrance announcement"));
     gaim_plugin_pref_frame_add(frame, ppref);
 
     ppref =
         gaim_plugin_pref_new_with_name_and_label
+        ("/plugins/prpl/gaym/show_part", _("Show exit announcement"));
+    gaim_plugin_pref_frame_add(frame, ppref);
+
+    ppref =
+        gaim_plugin_pref_new_with_name_and_label
         ("/plugins/prpl/gaym/chat_room_instances",
          _("Number of chat room instances to display"));
     gaim_plugin_pref_set_bounds(ppref, 0, 9);
@@ -1177,6 +1187,8 @@
 
     gaim_prefs_add_none("/plugins/prpl/gaym");
     gaim_prefs_add_int("/plugins/prpl/gaym/chat_room_instances", 4);
+    gaim_prefs_add_bool("/plugins/prpl/gaym/show_join", TRUE);
+    gaim_prefs_add_bool("/plugins/prpl/gaym/show_part", TRUE);
     gaim_prefs_add_bool("/plugins/prpl/gaym/show_bio_with_join", TRUE);
 
     gaim_prefs_add_bool("/plugins/prpl/gaym/botfilter_enable", FALSE);

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-09 01:28:11 UTC (rev 176)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-09 01:37:49 UTC (rev 177)
@@ -1081,15 +1081,19 @@
     }
 
     gboolean gaym_privacy_permit = gaym_privacy_check(gc, nick);
+    gboolean show_join =
+        gaim_prefs_get_bool("/plugins/prpl/gaym/show_join");
 
     if (gaim_prefs_get_bool("/plugins/prpl/gaym/show_bio_with_join")) {
         gaim_conv_chat_add_user(GAIM_CONV_CHAT(convo), nick, bio_markedup,
                                 flags, (gaym_privacy_permit
-                                        && gaym_botfilter_permit));
+                                        && gaym_botfilter_permit
+                                        && show_join));
     } else {
         gaim_conv_chat_add_user(GAIM_CONV_CHAT(convo), nick, NULL,
                                 flags, (gaym_privacy_permit
-                                        && gaym_botfilter_permit));
+                                        && gaym_botfilter_permit
+                                        && show_join));
     }
 
     /**
@@ -1241,6 +1245,8 @@
     }
 
     convo = gaim_find_conversation_with_account(args[0], gaym->account);
+    gboolean show_part =
+        gaim_prefs_get_bool("/plugins/prpl/gaym/show_part");
 
     gcom_nick_to_gaym(nick);
     if (!gaim_utf8_strcasecmp(nick, gaim_connection_get_display_name(gc))) {
@@ -1252,7 +1258,8 @@
         serv_got_chat_left(gc,
                            gaim_conv_chat_get_id(GAIM_CONV_CHAT(convo)));
     } else {
-        if (!gaim_conv_chat_is_user_ignored(GAIM_CONV_CHAT(convo), nick)) {
+        if (!gaim_conv_chat_is_user_ignored(GAIM_CONV_CHAT(convo), nick)
+            && show_part) {
             gaim_conv_chat_remove_user(GAIM_CONV_CHAT(convo), nick, NULL);
         } else {
             GaimConversationUiOps *ops =



From deckrider at berlios.de  Sat Jul  9 23:23:10 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sat, 9 Jul 2005 23:23:10 +0200
Subject: [Qrc-svn] r178 - qrc/trunk/gaym/src
Message-ID: <200507092123.j69LNAQ0030645@sheep.berlios.de>

Author: deckrider
Date: 2005-07-09 23:23:07 +0200 (Sat, 09 Jul 2005)
New Revision: 178

Modified:
   qrc/trunk/gaym/src/cmds.c
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gaym.h
   qrc/trunk/gaym/src/msgs.c
   qrc/trunk/gaym/src/parse.c
Log:
Converted from using ISON to WHOIS to manage buddies.  This fixes a long
standing issue where the buddy's photo won't refresh on the buddy list
unless you do something that causes a WHOIS to be generated.  It also
lays the foundation for showing the Bio in the buddy list.

Moved GAYBOI_SPAM_URL from gaym/src/gaym.c to gaym/src/gaym.h.

Removed unnecessary forward declarations in msgs.c

Update the buddy list every 60 seconds instead of every 45 seconds.


Modified: qrc/trunk/gaym/src/cmds.c
===================================================================
--- qrc/trunk/gaym/src/cmds.c	2005-07-09 01:37:49 UTC (rev 177)
+++ qrc/trunk/gaym/src/cmds.c	2005-07-09 21:23:07 UTC (rev 178)
@@ -567,7 +567,7 @@
         return 0;
 
     gaym->whois.nick = g_strdup(args[0]);
-    gcom_nick_to_gaym(gaym->whois.nick);
+
     converted_nick = gaym_nick_to_gcom_strdup(args[0]);
     buf = gaym_format(gaym, "vn", "WHOIS", converted_nick);
     gaym_send(gaym, buf);

Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-09 01:37:49 UTC (rev 177)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-09 21:23:07 UTC (rev 178)
@@ -42,8 +42,6 @@
 #include "botfilter.h"
 #include "gaym.h"
 
-#define GAYBOI_SPAM_URL "http://gayboi.org/spam/spamlst.php"
-
 char *gaym_mask_bio(const char *biostring);
 static const char *gaym_blist_icon(GaimAccount * a, GaimBuddy * b);
 static void gaym_blist_emblems(GaimBuddy * b, char **se, char **sw,
@@ -67,7 +65,7 @@
 static void gaym_buddy_free(struct gaym_buddy *ib);
 
 static void gaym_buddy_append(char *name, struct gaym_buddy *ib,
-                              GString * string);
+                              BListWhois * blist_whois);
 static void gaym_buddy_clear_done(char *name, struct gaym_buddy *ib,
                                   gpointer nothing);
 
@@ -90,16 +88,24 @@
     return ret;
 }
 
-/* XXX I don't like messing directly with these buddies */
 gboolean gaym_blist_timeout(struct gaym_conn * gaym)
 {
-    GString *string = g_string_sized_new(512);
+    /**
+     * There are 510 characters available for an IRC command (512 if
+     * you count CR-LF).  "WHOIS " takes up 6 characters.  Assuming
+     * you need allow an extra character for the NULL when using
+     * g_string_sized_new(), we need to allocate (510-6)+1=505 here.
+     */
+    BListWhois *blist_whois = g_new0(BListWhois, 1);
+    blist_whois->count = 0;
+    blist_whois->string = g_string_sized_new(505);
+
     char *list, *buf;
 
     g_hash_table_foreach(gaym->buddies, (GHFunc) gaym_buddy_append,
-                         (gpointer) string);
+                         (gpointer) blist_whois);
 
-    list = g_string_free(string, FALSE);
+    list = g_string_free(blist_whois->string, FALSE);
     if (!list || !strlen(list)) {
         g_hash_table_foreach(gaym->buddies, (GHFunc) gaym_buddy_clear_done,
                              NULL);
@@ -109,11 +115,12 @@
                              (GSourceFunc) gaym_blist_timeout,
                              (gpointer) gaym);
         g_free(list);
+        g_free(blist_whois);
 
         return TRUE;
     }
     gaym->blist_updating = TRUE;
-    buf = gaym_format(gaym, "vn", "ISON", list);
+    buf = gaym_format(gaym, "vn", "WHOIS", list);
     gaym_send(gaym, buf);
     gaim_timeout_remove(gaym->timer);
     gaym->timer =
@@ -122,10 +129,9 @@
                          (gpointer) gaym);
 
     g_free(buf);
-
     g_free(list);
+    g_free(blist_whois);
 
-
     return TRUE;
 }
 
@@ -136,29 +142,41 @@
 }
 
 static void gaym_buddy_append(char *name, struct gaym_buddy *ib,
-                              GString * string)
+                              BListWhois * blist_whois)
 {
-    char *converted_name;
-    if ((strlen(name) + string->len) > CHUNK_SIZE)
-        return;
-    else if (ib->done == FALSE) {
-        ib->stale = TRUE;
+    char *converted_name = NULL;
+    converted_name = gaym_nick_to_gcom_strdup(name);
+
+    /**
+     * There are 510 characters available for an IRC command (512 if
+     * you count CR-LF).  "WHOIS " takes up 6 characters.  This means
+     * we have up to 504 characters available for comma separated
+     * converted_names
+     */
+    if (ib->done == FALSE && blist_whois->count < 10
+        && (strlen(converted_name) + blist_whois->string->len + 1) <=
+        504) {
+        blist_whois->count++;
         ib->done = TRUE;
-        ib->flag = FALSE;
-        converted_name = gaym_nick_to_gcom_strdup(name);
-        g_string_append_printf(string, "%s ", converted_name);
-        g_free(converted_name);
-        return;
+        if (blist_whois->string->len == 0) {
+            g_string_append_printf(blist_whois->string, "%s",
+                                   converted_name);
+        } else {
+            g_string_append_printf(blist_whois->string, ",%s",
+                                   converted_name);
+        }
     }
+
+    g_free(converted_name);
+    return;
 }
 
-static void gaym_ison_one(struct gaym_conn *gaym, struct gaym_buddy *ib)
+static void gaym_whois_one(struct gaym_conn *gaym, struct gaym_buddy *ib)
 {
     char *buf;
     char *nick;
-    ib->flag = FALSE;
     nick = gaym_nick_to_gcom_strdup(ib->name);
-    buf = gaym_format(gaym, "vn", "ISON", nick);
+    buf = gaym_format(gaym, "vn", "WHOIS", nick);
     gaym_send(gaym, buf);
     g_free(nick);
     g_free(buf);
@@ -613,22 +631,45 @@
     struct gaym_conn *gaym = (struct gaym_conn *) gc->proto_data;
     struct gaym_buddy *ib = g_new0(struct gaym_buddy, 1);
     ib->name = g_strdup(buddy->name);
+    ib->done = FALSE;
+    ib->online = FALSE;
+    ib->bio = NULL;
+    ib->thumbnail = NULL;
     g_hash_table_replace(gaym->buddies, ib->name, ib);
     gaim_debug_misc("gaym", "Add buddy: %s\n", buddy->name);
     /**
      * if the timer isn't set, this is during signon, so we don't want to
-     * flood ourself off with ISON's, so we don't, but after that we want
+     * flood ourself off with WHOIS's, so we don't, but after that we want
      * to know when someone's online asap
      */
     if (gaym->timer)
-        gaym_ison_one(gaym, ib);
+        gaym_whois_one(gaym, ib);
 }
 
 static void gaym_remove_buddy(GaimConnection * gc, GaimBuddy * buddy,
                               GaimGroup * group)
 {
     struct gaym_conn *gaym = (struct gaym_conn *) gc->proto_data;
-    g_hash_table_remove(gaym->buddies, buddy->name);
+
+    /**
+     * Only remove buddy->name from gaym->buddies if it doesn't
+     * exist in any other group on the buddy list.  This allows us
+     * to manage the buddy once, even though it might exist in
+     * several groups within the buddy list.
+     *
+     * To add to confusion, the buddy being deleted is not yet deleted,
+     * so we look for less than two identical buddies, and if so, then
+     * remove the buddy from gaym->buddies.
+     */
+
+    GSList *buddies = gaim_find_buddies(gaym->account, buddy->name);
+    guint length = g_slist_length(buddies);
+
+    if (length < 2) {
+        g_hash_table_remove(gaym->buddies, buddy->name);
+    }
+
+    g_slist_free(buddies);
 }
 
 static void gaym_input_cb(gpointer data, gint source,
@@ -852,6 +893,8 @@
 static void gaym_buddy_free(struct gaym_buddy *ib)
 {
     g_free(ib->name);
+    g_free(ib->bio);
+    g_free(ib->thumbnail);
     g_free(ib);
 }
 

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-09 01:37:49 UTC (rev 177)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-09 21:23:07 UTC (rev 178)
@@ -37,12 +37,17 @@
 
 #define IRC_INITIAL_BUFSIZE 1024
 
-#define CHUNK_SIZE 500
-
-#define BLIST_UPDATE_PERIOD 45000       // buddy list updated every 45s
+#define BLIST_UPDATE_PERIOD 60000       // buddy list updated every 45s
 #define BLIST_CHUNK_INTERVAL 5000       // 5s between ISON chunks
 
+#define GAYBOI_SPAM_URL "http://gayboi.org/spam/spamlst.php"
 
+typedef struct _BListWhois BListWhois;
+struct _BListWhois {
+    int count;
+    GString *string;
+};
+
 enum { IRC_USEROPT_SERVER, IRC_USEROPT_PORT, IRC_USEROPT_CHARSET };
 enum gaym_state { IRC_STATE_NEW, IRC_STATE_ESTABLISHED };
 
@@ -96,6 +101,7 @@
         int idle;
         time_t signon;
     } whois;
+
     GaimRoomlist *roomlist;
 
     GList **node_menu;
@@ -111,19 +117,13 @@
 };
 
 struct gaym_buddy {
-    char *name;
-    gboolean online;
-    gboolean flag;              // Marks an ISON response.
-
-    gboolean stale;             // Signifies ISON update needed
-    gboolean done;              // Keep track of which buddies have been
-    // checked.
-
+    char *name;                 /* gaym formatted nick */
+    gboolean done;              /* has been checked */
+    gboolean online;            /* is online */
+    char *bio;                  /* bio string */
+    char *thumbnail;            /* thumbnail string */
 };
 
-
-
-
 typedef int (*IRCCmdCallback) (struct gaym_conn * gaym, const char *cmd,
                                const char *target, const char **args);
 
@@ -158,8 +158,6 @@
                      const char *from, char **args);
 void gaym_msg_inviteonly(struct gaym_conn *gaym, const char *name,
                          const char *from, char **args);
-void gaym_msg_ison(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args);
 void gaym_msg_who(struct gaym_conn *gaym, const char *name,
                   const char *from, char **args);
 void gaym_msg_chanfull(struct gaym_conn *gaym, const char *name,

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-09 01:37:49 UTC (rev 177)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-09 21:23:07 UTC (rev 178)
@@ -38,22 +38,6 @@
 #include "botfilter.h"
 #include "gaym.h"
 
-/**
- * begin forward declarations
- */
-
-static char *gaym_mask_nick(const char *mask);
-
-static void gaym_chat_remove_buddy(GaimConversation * convo,
-                                   char *data[2]);
-
-static void gaym_buddy_status(char *name, struct gaym_buddy *ib,
-                              struct gaym_conn *gaym);
-
-/**
- * end forward declarations
- */
-
 char *gaym_mask_thumbnail(const char *biostring)
 {
     char *start = strchr(biostring, ':');
@@ -283,84 +267,129 @@
     }
 }
 
+static void gaym_buddy_status(struct gaym_conn *gaym, char *name,
+                              gboolean online, char *bio, char *thumbnail)
+{
+    char *url = NULL;
+    struct gaym_fetch_thumbnail_data *data;
 
+    if (!gaym || !gaym->account || !gaym->buddies || !name) {
+        return;
+    }
+
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+
+    if (!gc) {
+        return;
+    }
+
+    struct gaym_buddy *ib = g_hash_table_lookup(gaym->buddies, name);
+
+    if (thumbnail) {
+        if ((ib && gaim_utf8_strcasecmp(thumbnail, ib->thumbnail))
+            || (gaym->whois.nick
+                && !gaim_utf8_strcasecmp(gaym->whois.nick, name))) {
+            data = g_new0(struct gaym_fetch_thumbnail_data, 1);
+            data->gc = gaim_account_get_connection(gaym->account);
+            data->who = g_strdup(name);
+            url =
+                g_strdup_printf
+                ("http://gay.com/images/personals/pictures%s", thumbnail);
+            gaim_url_fetch(url, FALSE, "Mozilla/4.0", FALSE,
+                           gaym_fetch_thumbnail_cb, data);
+            g_free(url);
+        }
+    }
+
+    if (ib) {
+        ib->online = online;
+        if (bio) {
+            g_free(ib->bio);
+            ib->bio = g_strdup(bio);
+        }
+        if (thumbnail) {
+            g_free(ib->thumbnail);
+            ib->thumbnail = g_strdup(thumbnail);
+        }
+        GaimBuddy *buddy = gaim_find_buddy(gaym->account, name);
+        if (buddy) {
+            serv_got_update(gc, buddy->name, online, 0, 0, 0, 0);
+        }
+    }
+
+    return;
+}
+
 void gaym_msg_no_such_nick(struct gaym_conn *gaym, const char *name,
                            const char *from, char **args)
 {
-    if (!args || !args[1]) {
+    /**
+     * name = 701
+     * from = irc.server.name
+     * args[1] = the nick that wasn't found
+     */
+
+    if (!gaym || !args || !args[1]) {
         return;
     }
 
     gcom_nick_to_gaym(args[1]);
-    gaym->info_window_needed = 0;
-    char *buf;
 
-    buf =
-        g_strdup_printf
-        ("That user is not logged on. Check <a href='http://my.gay.com/%s'>here</a> to see if that user has a profile.",
-         args[1]);
-    gaim_notify_userinfo(gaim_account_get_connection(gaym->account), NULL,
-                         NULL, "No such user", NULL, buf, NULL, NULL);
+    gaym_buddy_status(gaym, args[1], FALSE, NULL, NULL);
+
+    if (gaym->info_window_needed == TRUE) {
+        gaym->info_window_needed = 0;
+        char *buf;
+
+        buf =
+            g_strdup_printf
+            ("That user is not logged on. Check <a href='http://my.gay.com/%s'>here</a> to see if that user has a profile.",
+             args[1]);
+        gaim_notify_userinfo(gaim_account_get_connection(gaym->account),
+                             NULL, NULL, "No such user", NULL, buf, NULL,
+                             NULL);
+    }
 }
 
 void gaym_msg_whois(struct gaym_conn *gaym, const char *name,
                     const char *from, char **args)
 {
-    char *thumburl = NULL;
+    /**
+     * name = 311
+     * from = irc.server.name
+     * args[1] = the nick that we have information about
+     */
 
-    gcom_nick_to_gaym(args[1]);
-    if (!gaym->whois.nick) {
-        gaim_debug(GAIM_DEBUG_WARNING, "gaym",
-                   "Unexpected WHOIS reply for %s\n", args[1]);
+    if (!gaym || !args || !args[1]) {
         return;
     }
+    struct gaym_fetch_thumbnail_data *data;
 
-    if (gaim_utf8_strcasecmp(gaym->whois.nick, args[1])) {
-        gaim_debug(GAIM_DEBUG_WARNING, "gaym",
-                   "Got WHOIS reply for %s while waiting for %s\n",
-                   args[1], gaym->whois.nick);
-        return;
-    }
-
-    struct gaym_fetch_thumbnail_data *data, *data2;
-
-    data = g_new0(struct gaym_fetch_thumbnail_data, 1);
-    data2 = g_new0(struct gaym_fetch_thumbnail_data, 1);
-    data->gc = gaim_account_get_connection(gaym->account);
-    data->who = g_strdup(gaym->whois.nick);
-
-    data2->gc = gaim_account_get_connection(gaym->account);
-    data2->who = g_strdup(gaym->whois.nick);
-
+    char *bio = gaym_mask_bio(args[5]);
     char *thumbpath = gaym_mask_thumbnail(args[5]);
-    data2->bio = gaym_mask_bio(args[5]);
-    data2->stats = gaym_mask_stats(args[5]);
 
-    if (thumbpath)
-        thumburl =
-            g_strdup_printf
-            ("http://www.gay.com/images/personals/pictures%s>", thumbpath);
-    if (thumburl) {
-        gaim_url_fetch(thumburl, FALSE,
-                       "Mozilla/4.0 (compatible; MSIE 5.0)", FALSE,
-                       gaym_fetch_thumbnail_cb, data);
-        g_free(thumburl);
-    }
+    gaym_buddy_status(gaym, args[1], TRUE, bio, thumbpath);
 
     if (gaym->info_window_needed == TRUE) {
         gaym->info_window_needed = 0;
+        data = g_new0(struct gaym_fetch_thumbnail_data, 1);
+        data->gc = gaim_account_get_connection(gaym->account);
+        data->who = g_strdup(gaym->whois.nick);
+        data->bio = gaym_mask_bio(args[5]);
+        data->stats = gaym_mask_stats(args[5]);
         char *infourl =
             g_strdup_printf
             ("http://www.gay.com/messenger/get-profile.txt?pw=%s&name=%s",
              gaym->hash_pw, gaym->whois.nick);
-
         if (infourl) {
             gaim_url_fetch(infourl, FALSE,
                            "Mozilla/4.0 (compatible; MSIE 5.0)", FALSE,
-                           gaym_fetch_info_cb, data2);
+                           gaym_fetch_info_cb, data);
             g_free(infourl);
         }
     }
+    g_free(bio);
+    g_free(thumbpath);
 }
 
 void gaym_msg_list(struct gaym_conn *gaym, const char *name,
@@ -955,62 +984,6 @@
     g_free(buf);
 }
 
-void gaym_msg_ison(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args)
-{
-    char **nicks;
-    struct gaym_buddy *ib;
-    int i;
-
-    if (!args || !args[1])
-        return;
-    nicks = g_strsplit(args[1], " ", -1);
-    for (i = 0; (nicks[i] != NULL) && (*nicks[i] != '\0'); i++) {
-        gcom_nick_to_gaym(nicks[i]);
-        if ((ib =
-             g_hash_table_lookup(gaym->buddies,
-                                 (gconstpointer) nicks[i])) == NULL) {
-            gaim_debug_misc("gaym", "Not found in buddylist\n");
-            continue;
-        }
-        ib->flag = TRUE;
-
-    }
-
-    g_strfreev(nicks);
-
-    g_hash_table_foreach(gaym->buddies, (GHFunc) gaym_buddy_status,
-                         (gpointer) gaym);
-}
-
-static void gaym_buddy_status(char *name, struct gaym_buddy *ib,
-                              struct gaym_conn *gaym)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    GaimBuddy *buddy = gaim_find_buddy(gaym->account, name);
-
-    if (!gc || !buddy || !ib->stale)
-        return;
-
-    if (ib->online && !ib->flag) {
-        /**
-         * FUTURE VERSION ALERT: This will become
-         * gaim_prpl_got_user_status.
-         * serv_got_update is being deprecated.
-         */
-        serv_got_update(gc, buddy->name, FALSE, 0, 0, 0, 0);
-        ib->online = FALSE;
-    }
-
-    if (!ib->online && ib->flag) {
-        serv_got_update(gc, buddy->name, TRUE, 0, 0, 0, 0);
-        ib->online = TRUE;
-        ib->flag = FALSE;
-    }
-    ib->stale = FALSE;
-    ib->flag = FALSE;
-}
-
 void gaym_msg_trace(struct gaym_conn *gaym, const char *name,
                     const char *from, char **args)
 {
@@ -1032,7 +1005,6 @@
     GaimConversation *convo;
     GaimConvChatBuddyFlags flags = GAIM_CBFLAGS_NONE;
     char *bio = NULL, *bio_markedup = NULL;
-    struct gaym_buddy *ib;
     static int id = 1;
 
     if (!gc) {
@@ -1107,10 +1079,8 @@
     }
     ops->chat_update_user((convo), nick);
 
-    if ((ib = g_hash_table_lookup(gaym->buddies, nick)) != NULL) {
-        ib->flag = TRUE;
-        gaym_buddy_status(nick, ib, gaym);
-    }
+    gaym_buddy_status(gaym, nick, TRUE, bio_markedup, NULL);
+
     g_free(bio_markedup);
     g_free(nick);
 }
@@ -1446,7 +1416,6 @@
                    const char *from, char **args)
 {
     GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    struct gaym_buddy *ib;
     char *data[2];
 
     if (!args || !args[0] || !gc)
@@ -1457,10 +1426,8 @@
     /* XXX this should have an API, I shouldn't grab this directly */
     g_slist_foreach(gc->buddy_chats, (GFunc) gaym_chat_remove_buddy, data);
 
-    if ((ib = g_hash_table_lookup(gaym->buddies, data[0])) != NULL) {
-        ib->flag = FALSE;
-        gaym_buddy_status(data[0], ib, gaym);
-    }
+    gaym_buddy_status(gaym, data[0], FALSE, NULL, NULL);
+
     g_free(data[0]);
 
     return;

Modified: qrc/trunk/gaym/src/parse.c
===================================================================
--- qrc/trunk/gaym/src/parse.c	2005-07-09 01:37:49 UTC (rev 177)
+++ qrc/trunk/gaym/src/parse.c	2005-07-09 21:23:07 UTC (rev 178)
@@ -50,14 +50,12 @@
     {
     "001", "n:", gaym_msg_endmotd},     /* login ok */
     {
-    "205", "nnvvvvv", gaym_msg_trace},    /* trace response */
+    "205", "nnvvvvv", gaym_msg_trace},  /* trace response */
     {
     "263", "n:", gaym_msg_list_busy},   /* Server load to heavy */
     {
     "301", "nn:", gaym_msg_away},       /* User is away */
     {
-    "303", "n:", gaym_msg_ison},        /* ISON reply */
-    {
     "311", "nnvvv:", gaym_msg_whois},   /* Whois user */
     {
     "312", "nnv:", gaym_msg_whois},     /* Whois server */
@@ -187,20 +185,17 @@
             ("quit [message]:  Disconnect from the server, with an optional message.")},
     {
     "quote", "*", gaym_cmd_quote,
-            N_("quote [...]:  Send a raw command to the server.")}, 
-    {
+            N_("quote [...]:  Send a raw command to the server.")}, {
     "umode", ":", gaym_cmd_mode,
             N_
             ("umode &lt;+|-&gt;&lt;A-Za-z&gt;:  Set or unset a user mode.")},
     {
     "trace", "n", gaym_cmd_trace,
-            N_("trace &lt;nick&gt;: Get trace information on a user.")}, 
-
-    {
+            N_("trace &lt;nick&gt;: Get trace information on a user.")}, {
     "whois", "n", gaym_cmd_whois,
             N_("whois &lt;nick&gt;:  Get information on a user.")}, {
     NULL, NULL, NULL}
-    
+
 };
 
 static GaimCmdRet gaym_parse_gaim_cmd(GaimConversation * conv,



From deckrider at berlios.de  Sat Jul  9 23:24:03 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sat, 9 Jul 2005 23:24:03 +0200
Subject: [Qrc-svn] r179 - qrc/trunk
Message-ID: <200507092124.j69LO3uF030681@sheep.berlios.de>

Author: deckrider
Date: 2005-07-09 23:24:02 +0200 (Sat, 09 Jul 2005)
New Revision: 179

Modified:
   qrc/trunk/ChangeLog
Log:
updating changelong

Modified: qrc/trunk/ChangeLog
===================================================================
--- qrc/trunk/ChangeLog	2005-07-09 21:23:07 UTC (rev 178)
+++ qrc/trunk/ChangeLog	2005-07-09 21:24:02 UTC (rev 179)
@@ -3,7 +3,7 @@
 	- none
 
 	Bug Fixes:
-	- none
+	- Better refreshing of stale buddy list photos
 
 	Preference Changes:
 	- none



From deckrider at berlios.de  Sun Jul 10 00:45:09 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sun, 10 Jul 2005 00:45:09 +0200
Subject: [Qrc-svn] r180 - qrc/trunk/gaym/src
Message-ID: <200507092245.j69Mj9lY019711@sheep.berlios.de>

Author: deckrider
Date: 2005-07-10 00:44:50 +0200 (Sun, 10 Jul 2005)
New Revision: 180

Modified:
   qrc/trunk/gaym/src/gaym.c
Log:
Added Bio to status and tooltip text within buddy list.


Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-09 21:24:02 UTC (rev 179)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-09 22:44:50 UTC (rev 180)
@@ -194,6 +194,63 @@
         *se = "offline";
 }
 
+static char *gaym_status_text(GaimBuddy * buddy)
+{
+    char *status;
+
+    struct gaym_conn *gaym =
+        (struct gaym_conn *) buddy->account->gc->proto_data;
+
+    if (!gaym) {
+        return g_strdup("");
+    }
+
+    struct gaym_buddy *ib =
+        g_hash_table_lookup(gaym->buddies, buddy->name);
+
+    if (!ib) {
+        return g_strdup("");
+    }
+
+    if (!ib->bio) {
+        return g_strdup("");
+    }
+
+    status = g_markup_escape_text(ib->bio, strlen(ib->bio));
+
+    return status;
+}
+
+static char *gaym_tooltip_text(GaimBuddy * buddy)
+{
+    char *escaped, *tooltip;
+
+    struct gaym_conn *gaym =
+        (struct gaym_conn *) buddy->account->gc->proto_data;
+
+    if (!gaym) {
+        return g_strdup("");
+    }
+
+    struct gaym_buddy *ib =
+        g_hash_table_lookup(gaym->buddies, buddy->name);
+
+    if (!ib) {
+        return g_strdup("");
+    }
+
+    if (!ib->bio) {
+        return g_strdup("");
+    }
+
+    escaped = g_markup_escape_text(ib->bio, strlen(ib->bio));
+    tooltip = g_strdup_printf(_("\n<b>%s:</b> %s"), _("Bio"), escaped);
+
+    g_free(escaped);
+
+    return tooltip;
+}
+
 static GList *gaym_away_states(GaimConnection * gc)
 {
     return g_list_append(NULL, (gpointer) GAIM_AWAY_CUSTOM);
@@ -1014,8 +1071,8 @@
     {"jpg", 55, 75, 55, 75},    /* icon_spec */
     gaym_blist_icon,            /* list_icon */
     gaym_blist_emblems,         /* list_emblems */
-    NULL,                       /* status_text */
-    NULL,                       /* tooltip_text */
+    gaym_status_text,           /* status_text */
+    gaym_tooltip_text,          /* tooltip_text */
     gaym_away_states,           /* away_states */
     gaym_blist_node_menu,       /* blist_node_menu */
     gaym_chat_join_info,        /* chat_info */



From deckrider at berlios.de  Sun Jul 10 00:56:03 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sun, 10 Jul 2005 00:56:03 +0200
Subject: [Qrc-svn] r181 - qrc/trunk
Message-ID: <200507092256.j69Mu3rL029376@sheep.berlios.de>

Author: deckrider
Date: 2005-07-10 00:55:51 +0200 (Sun, 10 Jul 2005)
New Revision: 181

Modified:
   qrc/trunk/ChangeLog
Log:
Updated changelog

Modified: qrc/trunk/ChangeLog
===================================================================
--- qrc/trunk/ChangeLog	2005-07-09 22:44:50 UTC (rev 180)
+++ qrc/trunk/ChangeLog	2005-07-09 22:55:51 UTC (rev 181)
@@ -1,6 +1,7 @@
 0.34.1+svn:
 	New Features:
-	- none
+	- Bio is now available from the buddy list via status and
+	  tooltip text
 
 	Bug Fixes:
 	- Better refreshing of stale buddy list photos



From deckrider at berlios.de  Sun Jul 10 02:01:03 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sun, 10 Jul 2005 02:01:03 +0200
Subject: [Qrc-svn] r182 - qrc/trunk/gaym/src
Message-ID: <200507100001.j6A013Dx024158@sheep.berlios.de>

Author: deckrider
Date: 2005-07-10 01:59:53 +0200 (Sun, 10 Jul 2005)
New Revision: 182

Modified:
   qrc/trunk/gaym/src/gaym.c
Log:
Parallel Yahoo and some of the other PRPLs in terms of layout and
appearance of status and tooltip messages on the buddy list.


Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-09 22:55:51 UTC (rev 181)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-09 23:59:53 UTC (rev 182)
@@ -202,18 +202,22 @@
         (struct gaym_conn *) buddy->account->gc->proto_data;
 
     if (!gaym) {
-        return g_strdup("");
+        return g_strdup(_("Offline"));
     }
 
     struct gaym_buddy *ib =
         g_hash_table_lookup(gaym->buddies, buddy->name);
 
     if (!ib) {
-        return g_strdup("");
+        return g_strdup(_("Offline"));
     }
 
+    if (!ib->online) {
+        return g_strdup(_("Offline"));
+    }
+
     if (!ib->bio) {
-        return g_strdup("");
+        return NULL;
     }
 
     status = g_markup_escape_text(ib->bio, strlen(ib->bio));
@@ -229,18 +233,18 @@
         (struct gaym_conn *) buddy->account->gc->proto_data;
 
     if (!gaym) {
-        return g_strdup("");
+        return NULL;
     }
 
     struct gaym_buddy *ib =
         g_hash_table_lookup(gaym->buddies, buddy->name);
 
     if (!ib) {
-        return g_strdup("");
+        return NULL;
     }
 
     if (!ib->bio) {
-        return g_strdup("");
+        return NULL;
     }
 
     escaped = g_markup_escape_text(ib->bio, strlen(ib->bio));



From deckrider at berlios.de  Sun Jul 10 05:26:01 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sun, 10 Jul 2005 05:26:01 +0200
Subject: [Qrc-svn] r183 - qrc/trunk/gaym/src
Message-ID: <200507100326.j6A3Q16o030452@sheep.berlios.de>

Author: deckrider
Date: 2005-07-10 05:25:48 +0200 (Sun, 10 Jul 2005)
New Revision: 183

Modified:
   qrc/trunk/gaym/src/msgs.c
Log:
Take advantage of data received from joining a channel to update buddy
buddy list.

Don't use gaim_markup_linkify(bio) in the buddy list  Only the plain
text one.



Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-09 23:59:53 UTC (rev 182)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-10 03:25:48 UTC (rev 183)
@@ -996,6 +996,7 @@
                             time(NULL));
 
 }
+
 void gaym_msg_join(struct gaym_conn *gaym, const char *name,
                    const char *from, char **args)
 {
@@ -1004,7 +1005,7 @@
 
     GaimConversation *convo;
     GaimConvChatBuddyFlags flags = GAIM_CBFLAGS_NONE;
-    char *bio = NULL, *bio_markedup = NULL;
+    char *bio = NULL, *bio_markedup = NULL, *thumbnail = NULL;
     static int id = 1;
 
     if (!gc) {
@@ -1037,13 +1038,19 @@
     }
 
     bio = gaym_mask_bio(args[1]);
+    thumbnail = gaym_mask_thumbnail(args[1]);
+
+    gaym_buddy_status(gaym, nick, TRUE, bio, thumbnail);
+
     gboolean gaym_botfilter_permit =
         gaym_botfilter_check(gc, nick, bio, FALSE);
 
+
     if (bio) {
         bio_markedup = gaim_markup_linkify(bio);
         g_free(bio);
     }
+    g_free(thumbnail);
 
     if (strstr(args[1], "thumb.jpg#")) {
         if (args[1][1] == '9')
@@ -1079,8 +1086,6 @@
     }
     ops->chat_update_user((convo), nick);
 
-    gaym_buddy_status(gaym, nick, TRUE, bio_markedup, NULL);
-
     g_free(bio_markedup);
     g_free(nick);
 }
@@ -1592,13 +1597,17 @@
 
     convo = gaim_find_conversation_with_account(channel, gaym->account);
 
-    char *masked_bio = gaym_mask_bio(extra);
+    char *bio = gaym_mask_bio(extra);
+    char *thumbnail = gaym_mask_thumbnail(extra);
 
     gboolean gaym_botfilter_permit =
-        gaym_botfilter_check(gc, nick, masked_bio, FALSE);
+        gaym_botfilter_check(gc, nick, bio, FALSE);
 
-    g_free(masked_bio);
+    gaym_buddy_status(gaym, nick, TRUE, bio, thumbnail);
 
+    g_free(thumbnail);
+    g_free(bio);
+
     if (convo == NULL) {
         gaim_debug(GAIM_DEBUG_ERROR, "gaym", "690 for %s failed\n",
                    args[1]);



From deckrider at berlios.de  Sun Jul 10 05:51:08 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sun, 10 Jul 2005 05:51:08 +0200
Subject: [Qrc-svn] r184 - qrc/trunk/gaym/src
Message-ID: <200507100351.j6A3p8bH002388@sheep.berlios.de>

Author: deckrider
Date: 2005-07-10 05:51:00 +0200 (Sun, 10 Jul 2005)
New Revision: 184

Modified:
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/msgs.c
Log:
No need to retrieve the thumbnail for IMs if the user is already
in the buddy list.


Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-10 03:25:48 UTC (rev 183)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-10 03:51:00 UTC (rev 184)
@@ -1137,11 +1137,33 @@
     if (strncmp(conv->account->protocol_id, "prpl-gaym", 9) == 0
         && gaim_conversation_get_type(conv) == GAIM_CONV_IM) {
 
+        /**
+         * First check to see if we already have the photo via
+         * the buddy list process.
+         */
+
         struct gaym_conn *gaym;
 
         GaimConnection *gc = gaim_conversation_get_gc(conv);
+
         gaym = (struct gaym_conn *) gc->proto_data;
 
+        if (!gaym) {
+            return;
+        }
+
+        struct gaym_buddy *ib =
+            g_hash_table_lookup(gaym->buddies, conv->name);
+
+        if (ib) {
+            return;
+        }
+
+        /**
+         * Since this person isn't in our buddy list, go ahead
+         * with the WHOIS to get the photo for the IM thumbnail
+         */
+
         gaym->info_window_needed = FALSE;
 
         gaym->whois.nick = g_strdup(conv->name);

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-10 03:25:48 UTC (rev 183)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-10 03:51:00 UTC (rev 184)
@@ -1448,7 +1448,6 @@
 
     struct gaym_conn *gaym = (struct gaym_conn *) data;
 
-
     gaym->cancelling_persist = TRUE;
     gaim_debug_misc("gaym", "Cancelling persist: %s\n",
                     gaym->persist_room);
@@ -1483,8 +1482,8 @@
     if (!args || !args[1] || !gc)
         return;
 
-
     joinargs[0] = args[1];
+
     if (gaym->persist_room && !strcmp(gaym->persist_room, args[1]))
         if (gaym->cancelling_persist) {
             if (gaym->persist_room) {



From deckrider at berlios.de  Sun Jul 10 14:48:12 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sun, 10 Jul 2005 14:48:12 +0200
Subject: [Qrc-svn] r185 - in qrc/trunk: . gaym/src
Message-ID: <200507101248.j6ACmCos012038@sheep.berlios.de>

Author: deckrider
Date: 2005-07-10 14:48:11 +0200 (Sun, 10 Jul 2005)
New Revision: 185

Modified:
   qrc/trunk/ChangeLog
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gaym.h
   qrc/trunk/gaym/src/msgs.c
Log:
Added Sex, Age, and Location to the Buddy List Tooltip.


Modified: qrc/trunk/ChangeLog
===================================================================
--- qrc/trunk/ChangeLog	2005-07-10 03:51:00 UTC (rev 184)
+++ qrc/trunk/ChangeLog	2005-07-10 12:48:11 UTC (rev 185)
@@ -1,7 +1,7 @@
 0.34.1+svn:
 	New Features:
-	- Bio is now available from the buddy list via status and
-	  tooltip text
+	- Bio displays in the buddy list status area
+	- Buddy list tooltip shows sex, age, location, and bio
 
 	Bug Fixes:
 	- Better refreshing of stale buddy list photos

Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-10 03:51:00 UTC (rev 184)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-10 12:48:11 UTC (rev 185)
@@ -227,8 +227,6 @@
 
 static char *gaym_tooltip_text(GaimBuddy * buddy)
 {
-    char *escaped, *tooltip;
-
     struct gaym_conn *gaym =
         (struct gaym_conn *) buddy->account->gc->proto_data;
 
@@ -243,16 +241,42 @@
         return NULL;
     }
 
-    if (!ib->bio) {
-        return NULL;
+    char *escaped;
+    GString *tooltip = g_string_new("");
+
+    if (ib->sex) {
+        escaped = g_markup_escape_text(ib->sex, strlen(ib->sex));
+        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"), _("Sex"),
+                               escaped);
+        g_free(escaped);
     }
 
-    escaped = g_markup_escape_text(ib->bio, strlen(ib->bio));
-    tooltip = g_strdup_printf(_("\n<b>%s:</b> %s"), _("Bio"), escaped);
+    if (ib->age) {
+        escaped = g_markup_escape_text(ib->age, strlen(ib->age));
+        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"), _("Age"),
+                               escaped);
+        g_free(escaped);
+    }
 
-    g_free(escaped);
+    if (ib->location) {
+        escaped = g_markup_escape_text(ib->location, strlen(ib->location));
+        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"),
+                               _("Location"), escaped);
+        g_free(escaped);
+    }
 
-    return tooltip;
+    if (ib->bio) {
+        escaped = g_markup_escape_text(ib->bio, strlen(ib->bio));
+        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"), _("Bio"),
+                               escaped);
+        g_free(escaped);
+    }
+
+    if (tooltip->len == 0) {
+        return g_string_free(tooltip, TRUE);
+    }
+
+    return g_string_free(tooltip, FALSE);
 }
 
 static GList *gaym_away_states(GaimConnection * gc)
@@ -696,6 +720,9 @@
     ib->online = FALSE;
     ib->bio = NULL;
     ib->thumbnail = NULL;
+    ib->sex = NULL;
+    ib->age = NULL;
+    ib->location = NULL;
     g_hash_table_replace(gaym->buddies, ib->name, ib);
     gaim_debug_misc("gaym", "Add buddy: %s\n", buddy->name);
     /**
@@ -956,6 +983,9 @@
     g_free(ib->name);
     g_free(ib->bio);
     g_free(ib->thumbnail);
+    g_free(ib->sex);
+    g_free(ib->age);
+    g_free(ib->location);
     g_free(ib);
 }
 

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-10 03:51:00 UTC (rev 184)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-10 12:48:11 UTC (rev 185)
@@ -122,6 +122,9 @@
     gboolean online;            /* is online */
     char *bio;                  /* bio string */
     char *thumbnail;            /* thumbnail string */
+    char *sex;                  /* sex string */
+    char *age;                  /* age string */
+    char *location;             /* location string */
 };
 
 typedef int (*IRCCmdCallback) (struct gaym_conn * gaym, const char *cmd,

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-10 03:51:00 UTC (rev 184)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-10 12:48:11 UTC (rev 185)
@@ -268,7 +268,8 @@
 }
 
 static void gaym_buddy_status(struct gaym_conn *gaym, char *name,
-                              gboolean online, char *bio, char *thumbnail)
+                              gboolean online, char *bio, char *thumbnail,
+                              char *stats)
 {
     char *url = NULL;
     struct gaym_fetch_thumbnail_data *data;
@@ -311,6 +312,22 @@
             g_free(ib->thumbnail);
             ib->thumbnail = g_strdup(thumbnail);
         }
+        if (stats) {
+            g_free(ib->sex);
+            g_free(ib->age);
+            g_free(ib->location);
+            gchar **s = g_strsplit(stats, "|", 3);
+            if (s[0] && strlen(s[0]) > 0) {
+                ib->sex = g_ascii_strup(s[0], -1);
+            }
+            if (s[1] && strlen(s[1]) > 0) {
+                ib->age = g_strdup(s[1]);
+            }
+            if (s[2] && strlen(s[2]) > 0) {
+                ib->location = g_strdup(s[2]);
+            }
+            g_strfreev(s);
+        }
         GaimBuddy *buddy = gaim_find_buddy(gaym->account, name);
         if (buddy) {
             serv_got_update(gc, buddy->name, online, 0, 0, 0, 0);
@@ -335,7 +352,7 @@
 
     gcom_nick_to_gaym(args[1]);
 
-    gaym_buddy_status(gaym, args[1], FALSE, NULL, NULL);
+    gaym_buddy_status(gaym, args[1], FALSE, NULL, NULL, NULL);
 
     if (gaym->info_window_needed == TRUE) {
         gaym->info_window_needed = 0;
@@ -367,8 +384,9 @@
 
     char *bio = gaym_mask_bio(args[5]);
     char *thumbpath = gaym_mask_thumbnail(args[5]);
+    char *stats = gaym_mask_stats(args[5]);
 
-    gaym_buddy_status(gaym, args[1], TRUE, bio, thumbpath);
+    gaym_buddy_status(gaym, args[1], TRUE, bio, thumbpath, stats);
 
     if (gaym->info_window_needed == TRUE) {
         gaym->info_window_needed = 0;
@@ -390,6 +408,7 @@
     }
     g_free(bio);
     g_free(thumbpath);
+    g_free(stats);
 }
 
 void gaym_msg_list(struct gaym_conn *gaym, const char *name,
@@ -1005,7 +1024,10 @@
 
     GaimConversation *convo;
     GaimConvChatBuddyFlags flags = GAIM_CBFLAGS_NONE;
-    char *bio = NULL, *bio_markedup = NULL, *thumbnail = NULL;
+    char *bio = NULL;
+    char *bio_markedup = NULL;
+    char *thumbnail = NULL;
+    char *stats = NULL;
     static int id = 1;
 
     if (!gc) {
@@ -1039,8 +1061,9 @@
 
     bio = gaym_mask_bio(args[1]);
     thumbnail = gaym_mask_thumbnail(args[1]);
+    stats = gaym_mask_stats(args[1]);
 
-    gaym_buddy_status(gaym, nick, TRUE, bio, thumbnail);
+    gaym_buddy_status(gaym, nick, TRUE, bio, thumbnail, stats);
 
     gboolean gaym_botfilter_permit =
         gaym_botfilter_check(gc, nick, bio, FALSE);
@@ -1051,6 +1074,7 @@
         g_free(bio);
     }
     g_free(thumbnail);
+    g_free(stats);
 
     if (strstr(args[1], "thumb.jpg#")) {
         if (args[1][1] == '9')
@@ -1417,6 +1441,7 @@
     g_free(msg);
 }
 
+/* I don't think gay.com ever sends this message */
 void gaym_msg_quit(struct gaym_conn *gaym, const char *name,
                    const char *from, char **args)
 {
@@ -1431,7 +1456,7 @@
     /* XXX this should have an API, I shouldn't grab this directly */
     g_slist_foreach(gc->buddy_chats, (GFunc) gaym_chat_remove_buddy, data);
 
-    gaym_buddy_status(gaym, data[0], FALSE, NULL, NULL);
+    gaym_buddy_status(gaym, data[0], FALSE, NULL, NULL, NULL);
 
     g_free(data[0]);
 
@@ -1598,11 +1623,12 @@
 
     char *bio = gaym_mask_bio(extra);
     char *thumbnail = gaym_mask_thumbnail(extra);
+    char *stats = gaym_mask_stats(extra);
 
     gboolean gaym_botfilter_permit =
         gaym_botfilter_check(gc, nick, bio, FALSE);
 
-    gaym_buddy_status(gaym, nick, TRUE, bio, thumbnail);
+    gaym_buddy_status(gaym, nick, TRUE, bio, thumbnail, stats);
 
     g_free(thumbnail);
     g_free(bio);



From deckrider at berlios.de  Mon Jul 11 15:45:43 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Mon, 11 Jul 2005 15:45:43 +0200
Subject: [Qrc-svn] r186 - qrc/trunk/gaym/src
Message-ID: <200507111345.j6BDjh6I017680@sheep.berlios.de>

Author: deckrider
Date: 2005-07-11 15:45:42 +0200 (Mon, 11 Jul 2005)
New Revision: 186

Added:
   qrc/trunk/gaym/src/gayminfo.c
   qrc/trunk/gaym/src/gayminfo.h
Modified:
   qrc/trunk/gaym/src/Makefile.am
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/msgs.c
Log:
Some refactoring of the IRC extra info - related stuff:  trying to put
it in gayminfo.[ch]


Modified: qrc/trunk/gaym/src/Makefile.am
===================================================================
--- qrc/trunk/gaym/src/Makefile.am	2005-07-10 12:48:11 UTC (rev 185)
+++ qrc/trunk/gaym/src/Makefile.am	2005-07-11 13:45:42 UTC (rev 186)
@@ -10,6 +10,8 @@
 	dcc_send.c \
 	gaym.c \
 	gaym.h \
+	gayminfo.c \
+	gayminfo.h \
 	gaympriv.c \
 	gaympriv.h \
 	helpers.c \

Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-10 12:48:11 UTC (rev 185)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-11 13:45:42 UTC (rev 186)
@@ -37,12 +37,12 @@
 #include "privacy.h"
 
 #include "helpers.h"
+#include "gayminfo.h"
 #include "gaympriv.h"
 #include "configtxt.h"
 #include "botfilter.h"
 #include "gaym.h"
 
-char *gaym_mask_bio(const char *biostring);
 static const char *gaym_blist_icon(GaimAccount * a, GaimBuddy * b);
 static void gaym_blist_emblems(GaimBuddy * b, char **se, char **sw,
                                char **nw, char **ne);
@@ -300,7 +300,7 @@
         gaym->bio = g_strdup(info);
     } else if (gaym->server_bioline && strlen(gaym->server_bioline) > 2) {
         gaim_debug_misc("gaym", "option2\n");
-        gaym->bio = g_strdup(gaym_mask_bio(gaym->server_bioline));
+        gaym->bio = gaym_bio_strdup(gaym->server_bioline);
     } else {
         gaim_debug_misc("gaym", "option3\n");
         gaym->bio = g_strdup("Gaim User");

Added: qrc/trunk/gaym/src/gayminfo.c
===================================================================
--- qrc/trunk/gaym/src/gayminfo.c	2005-07-10 12:48:11 UTC (rev 185)
+++ qrc/trunk/gaym/src/gayminfo.c	2005-07-11 13:45:42 UTC (rev 186)
@@ -0,0 +1,170 @@
+/**
+ * @file gayminfo.c
+ *
+ * GayM
+ *
+ * GayM is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "gayminfo.h"
+#include "util.h"
+
+char *gaym_thumbnail_strdup(const char *info)
+{
+    char *start = strchr(info, ':');
+    char *end = 0;
+    if (start) {
+        start++;
+        end = strchr(info, '#');
+    }
+    if (start != end && end) {
+        return g_strdup_printf("%.*s", end - start, start);
+    } else {
+        return 0;
+    }
+}
+
+char *gaym_bio_strdup(const char *info)
+{
+    char *start = strchr(info, '#');
+    char *end = 0;
+    if (start) {
+        start++;
+        end = strchr(start, 0x01);
+        if (!end)
+            end = strchr(start, 0);
+    }
+
+    if ((end) && (start < end)) {
+        return g_strdup_printf("%.*s", end - start, start);
+    } else {
+        return 0;
+    }
+}
+
+char *gaym_stats_strdup(const char *info)
+{
+
+    char *start = strchr(info, '#');
+
+    if (start)
+        start = strchr(start, 0x01);
+
+    char *end = 0;
+    if (start) {
+        start++;
+        end = strchr(info, '\0');
+    }
+
+    if (start != end && end) {
+        return g_strdup_printf("%.*s", end - start, start);
+    } else {
+        return 0;
+    }
+}
+
+void gaym_buddy_status(struct gaym_conn *gaym, char *name,
+                       gboolean online, char *info)
+{
+    char *bio = NULL;
+    char *thumbnail = NULL;
+    char *stats = NULL;
+    char *url = NULL;
+    struct gaym_fetch_thumbnail_data *data;
+
+    if (!gaym || !gaym->account || !gaym->buddies || !name) {
+        return;
+    }
+
+    if (info) {
+        bio = gaym_bio_strdup(info);
+        bio = g_strstrip(bio);
+
+        thumbnail = gaym_thumbnail_strdup(info);
+        thumbnail = g_strstrip(thumbnail);
+
+        stats = gaym_stats_strdup(info);
+        stats = g_strstrip(stats);
+    }
+
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+
+    if (!gc) {
+        return;
+    }
+
+    struct gaym_buddy *ib = g_hash_table_lookup(gaym->buddies, name);
+
+    if (thumbnail) {
+        if ((ib && gaim_utf8_strcasecmp(thumbnail, ib->thumbnail))
+            || (gaym->whois.nick
+                && !gaim_utf8_strcasecmp(gaym->whois.nick, name))) {
+            data = g_new0(struct gaym_fetch_thumbnail_data, 1);
+            data->gc = gaim_account_get_connection(gaym->account);
+            data->who = g_strdup(name);
+            url =
+                g_strdup_printf
+                ("http://gay.com/images/personals/pictures%s", thumbnail);
+            gaim_url_fetch(url, FALSE, "Mozilla/4.0", FALSE,
+                           gaym_fetch_thumbnail_cb, data);
+            g_free(url);
+        }
+    }
+
+    if (ib) {
+        ib->online = online;
+        if (bio) {
+            g_free(ib->bio);
+            ib->bio = bio;
+        }
+        if (thumbnail) {
+            g_free(ib->thumbnail);
+            ib->thumbnail = thumbnail;
+        }
+        if (stats) {
+            g_free(ib->sex);
+            g_free(ib->age);
+            g_free(ib->location);
+            gchar **s = g_strsplit(stats, "|", 3);
+            if (s[0] && strlen(s[0]) > 0) {
+                ib->sex = g_ascii_strup(s[0], -1);
+                ib->sex = g_strstrip(ib->sex);
+            }
+            if (s[1] && strlen(s[1]) > 0) {
+                ib->age = g_strdup(s[1]);
+                ib->age = g_strstrip(ib->age);
+            }
+            if (s[2] && strlen(s[2]) > 0) {
+                ib->location = g_strdup(s[2]);
+                ib->location = g_strstrip(ib->location);
+            }
+            g_strfreev(s);
+            g_free(stats);
+        }
+        GaimBuddy *buddy = gaim_find_buddy(gaym->account, name);
+        if (buddy) {
+            serv_got_update(gc, buddy->name, online, 0, 0, 0, 0);
+        }
+    }
+    return;
+}
+
+/**
+ * vim:tabstop=4:shiftwidth=4:expandtab:
+ */

Added: qrc/trunk/gaym/src/gayminfo.h
===================================================================
--- qrc/trunk/gaym/src/gayminfo.h	2005-07-10 12:48:11 UTC (rev 185)
+++ qrc/trunk/gaym/src/gayminfo.h	2005-07-11 13:45:42 UTC (rev 186)
@@ -0,0 +1,92 @@
+/**
+ * @file gayminfo.h GayM User Info (IRC-based) API
+ *
+ * GayM
+ *
+ * GayM is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _GAIM_GAYM_GAYMINFO_H_
+#define _GAIM_GAYM_GAYMINFO_H_
+
+#include <glib.h>
+
+#include "gaym.h"
+
+/**
+ * Begin temporary, pending further refactoring
+ */
+#include "connection.h"
+struct gaym_fetch_thumbnail_data {
+    GaimConnection *gc;
+    char *who;
+    char *bio;
+    char *stats;
+};
+void gaym_fetch_thumbnail_cb(void *user_data, const char *pic_data,
+                             size_t len);
+/**
+ * End temporary, pending further refactoring
+ */
+
+/**
+ * Extract the thumbnail string from the extra IRC info about the user.
+ * The returned string should be freed when no longer needed.
+ *
+ * @param info The extra IRC info string.
+ *
+ * @return The thumbnail string.
+ */
+char *gaym_thumbnail_strdup(const char *info);
+
+/**
+ * Extract the bio string from the extra IRC info about the user.
+ * The returned string should be freed when no longer needed.
+ *
+ * @param info The extra IRC info string.
+ *
+ * @return The bio string.
+ */
+char *gaym_bio_strdup(const char *info);
+
+/**
+ * Extract the stats string from the extra IRC info about the user.
+ * The returned string should be freed when no longer needed.
+ *
+ * @param info The extra IRC info string.
+ *
+ * @return The stats string.
+ */
+char *gaym_stats_strdup(const char *info);
+
+/**
+ * Process extra IRC information about a buddy
+ *
+ * @param gaym The protocol-specific data related to the connection.
+ * @param name The buddy name
+ * @param online Is the buddy on line.
+ * @param info The extra IRC info string about the buddy, if any.
+ */
+void gaym_buddy_status(struct gaym_conn *gaym, char *name,
+                       gboolean online, char *info);
+
+#endif                          /* _GAIM_GAYM_GAYMINFO_H_ */
+
+/**
+ * vim:tabstop=4:shiftwidth=4:expandtab:
+ */

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-10 12:48:11 UTC (rev 185)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-11 13:45:42 UTC (rev 186)
@@ -33,71 +33,18 @@
 #include "privacy.h"
 #include "prefs.h"
 
-#include "helpers.h"
-#include "gaympriv.h"
 #include "botfilter.h"
 #include "gaym.h"
+#include "gayminfo.h"
+#include "gaympriv.h"
+#include "helpers.h"
 
-char *gaym_mask_thumbnail(const char *biostring)
-{
-    char *start = strchr(biostring, ':');
-    char *end = 0;
-    if (start) {
-        start++;
-        end = strchr(biostring, '#');
-    }
-    if (start != end && end) {
-        return g_strdup_printf("%.*s", end - start, start);
-    } else {
-        return 0;
-    }
-}
-
 char *make_nick_profile_link(char *name)
 {
     return g_strdup_printf("<A href='http://my.gay.com/%s'>%s</A>", name,
                            name);
 }
 
-char *gaym_mask_bio(const char *biostring)
-{
-    char *start = strchr(biostring, '#');
-    char *end = 0;
-    if (start) {
-        start++;
-        end = strchr(start, 0x01);
-        if (!end)
-            end = strchr(start, 0);
-    }
-
-    if ((end) && (start < end)) {
-        return g_strdup_printf("%.*s", end - start, start);
-    } else {
-        return 0;
-    }
-}
-
-static char *gaym_mask_stats(const char *biostring)
-{
-
-    char *start = strchr(biostring, '#');
-
-    if (start)
-        start = strchr(start, 0x01);
-
-    char *end = 0;
-    if (start) {
-        start++;
-        end = strchr(biostring, '\0');
-    }
-
-    if (start != end && end) {
-        return g_strdup_printf("%.*s", end - start, start);
-    } else {
-        return 0;
-    }
-}
-
 static char *gaym_mask_nick(const char *mask)
 {
     char *end, *buf;
@@ -144,15 +91,8 @@
     serv_got_im(gc, args[1], args[2], GAIM_CONV_IM_AUTO_RESP, time(NULL));
 }
 
-struct gaym_fetch_thumbnail_data {
-    GaimConnection *gc;
-    char *who;
-    char *bio;
-    char *stats;
-};
-
-static void gaym_fetch_thumbnail_cb(void *user_data, const char *pic_data,
-                                    size_t len)
+void gaym_fetch_thumbnail_cb(void *user_data, const char *pic_data,
+                             size_t len)
 {
     if (!user_data || !pic_data) {
         return;
@@ -267,76 +207,6 @@
     }
 }
 
-static void gaym_buddy_status(struct gaym_conn *gaym, char *name,
-                              gboolean online, char *bio, char *thumbnail,
-                              char *stats)
-{
-    char *url = NULL;
-    struct gaym_fetch_thumbnail_data *data;
-
-    if (!gaym || !gaym->account || !gaym->buddies || !name) {
-        return;
-    }
-
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-
-    if (!gc) {
-        return;
-    }
-
-    struct gaym_buddy *ib = g_hash_table_lookup(gaym->buddies, name);
-
-    if (thumbnail) {
-        if ((ib && gaim_utf8_strcasecmp(thumbnail, ib->thumbnail))
-            || (gaym->whois.nick
-                && !gaim_utf8_strcasecmp(gaym->whois.nick, name))) {
-            data = g_new0(struct gaym_fetch_thumbnail_data, 1);
-            data->gc = gaim_account_get_connection(gaym->account);
-            data->who = g_strdup(name);
-            url =
-                g_strdup_printf
-                ("http://gay.com/images/personals/pictures%s", thumbnail);
-            gaim_url_fetch(url, FALSE, "Mozilla/4.0", FALSE,
-                           gaym_fetch_thumbnail_cb, data);
-            g_free(url);
-        }
-    }
-
-    if (ib) {
-        ib->online = online;
-        if (bio) {
-            g_free(ib->bio);
-            ib->bio = g_strdup(bio);
-        }
-        if (thumbnail) {
-            g_free(ib->thumbnail);
-            ib->thumbnail = g_strdup(thumbnail);
-        }
-        if (stats) {
-            g_free(ib->sex);
-            g_free(ib->age);
-            g_free(ib->location);
-            gchar **s = g_strsplit(stats, "|", 3);
-            if (s[0] && strlen(s[0]) > 0) {
-                ib->sex = g_ascii_strup(s[0], -1);
-            }
-            if (s[1] && strlen(s[1]) > 0) {
-                ib->age = g_strdup(s[1]);
-            }
-            if (s[2] && strlen(s[2]) > 0) {
-                ib->location = g_strdup(s[2]);
-            }
-            g_strfreev(s);
-        }
-        GaimBuddy *buddy = gaim_find_buddy(gaym->account, name);
-        if (buddy) {
-            serv_got_update(gc, buddy->name, online, 0, 0, 0, 0);
-        }
-    }
-
-    return;
-}
-
 void gaym_msg_no_such_nick(struct gaym_conn *gaym, const char *name,
                            const char *from, char **args)
 {
@@ -352,7 +222,7 @@
 
     gcom_nick_to_gaym(args[1]);
 
-    gaym_buddy_status(gaym, args[1], FALSE, NULL, NULL, NULL);
+    gaym_buddy_status(gaym, args[1], FALSE, NULL);
 
     if (gaym->info_window_needed == TRUE) {
         gaym->info_window_needed = 0;
@@ -380,21 +250,17 @@
     if (!gaym || !args || !args[1]) {
         return;
     }
-    struct gaym_fetch_thumbnail_data *data;
 
-    char *bio = gaym_mask_bio(args[5]);
-    char *thumbpath = gaym_mask_thumbnail(args[5]);
-    char *stats = gaym_mask_stats(args[5]);
+    gaym_buddy_status(gaym, args[1], TRUE, args[5]);
 
-    gaym_buddy_status(gaym, args[1], TRUE, bio, thumbpath, stats);
-
+    struct gaym_fetch_thumbnail_data *data;
     if (gaym->info_window_needed == TRUE) {
         gaym->info_window_needed = 0;
         data = g_new0(struct gaym_fetch_thumbnail_data, 1);
         data->gc = gaim_account_get_connection(gaym->account);
         data->who = g_strdup(gaym->whois.nick);
-        data->bio = gaym_mask_bio(args[5]);
-        data->stats = gaym_mask_stats(args[5]);
+        data->bio = gaym_bio_strdup(args[5]);
+        data->stats = gaym_stats_strdup(args[5]);
         char *infourl =
             g_strdup_printf
             ("http://www.gay.com/messenger/get-profile.txt?pw=%s&name=%s",
@@ -406,9 +272,6 @@
             g_free(infourl);
         }
     }
-    g_free(bio);
-    g_free(thumbpath);
-    g_free(stats);
 }
 
 void gaym_msg_list(struct gaym_conn *gaym, const char *name,
@@ -1026,8 +889,6 @@
     GaimConvChatBuddyFlags flags = GAIM_CBFLAGS_NONE;
     char *bio = NULL;
     char *bio_markedup = NULL;
-    char *thumbnail = NULL;
-    char *stats = NULL;
     static int id = 1;
 
     if (!gc) {
@@ -1059,22 +920,16 @@
         return;
     }
 
-    bio = gaym_mask_bio(args[1]);
-    thumbnail = gaym_mask_thumbnail(args[1]);
-    stats = gaym_mask_stats(args[1]);
+    gaym_buddy_status(gaym, nick, TRUE, args[1]);
 
-    gaym_buddy_status(gaym, nick, TRUE, bio, thumbnail, stats);
-
     gboolean gaym_botfilter_permit =
         gaym_botfilter_check(gc, nick, bio, FALSE);
 
-
+    bio = gaym_bio_strdup(args[1]);
     if (bio) {
         bio_markedup = gaim_markup_linkify(bio);
         g_free(bio);
     }
-    g_free(thumbnail);
-    g_free(stats);
 
     if (strstr(args[1], "thumb.jpg#")) {
         if (args[1][1] == '9')
@@ -1456,7 +1311,7 @@
     /* XXX this should have an API, I shouldn't grab this directly */
     g_slist_foreach(gc->buddy_chats, (GFunc) gaym_chat_remove_buddy, data);
 
-    gaym_buddy_status(gaym, data[0], FALSE, NULL, NULL, NULL);
+    gaym_buddy_status(gaym, data[0], FALSE, NULL);
 
     g_free(data[0]);
 
@@ -1621,18 +1476,13 @@
 
     convo = gaim_find_conversation_with_account(channel, gaym->account);
 
-    char *bio = gaym_mask_bio(extra);
-    char *thumbnail = gaym_mask_thumbnail(extra);
-    char *stats = gaym_mask_stats(extra);
-
+    char *bio = gaym_bio_strdup(extra);
     gboolean gaym_botfilter_permit =
         gaym_botfilter_check(gc, nick, bio, FALSE);
-
-    gaym_buddy_status(gaym, nick, TRUE, bio, thumbnail, stats);
-
-    g_free(thumbnail);
     g_free(bio);
 
+    gaym_buddy_status(gaym, nick, TRUE, extra);
+
     if (convo == NULL) {
         gaim_debug(GAIM_DEBUG_ERROR, "gaym", "690 for %s failed\n",
                    args[1]);



From deckrider at berlios.de  Mon Jul 11 15:50:41 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Mon, 11 Jul 2005 15:50:41 +0200
Subject: [Qrc-svn] r187 - qrc/trunk/gaym/src
Message-ID: <200507111350.j6BDofm1018116@sheep.berlios.de>

Author: deckrider
Date: 2005-07-11 15:50:40 +0200 (Mon, 11 Jul 2005)
New Revision: 187

Modified:
   qrc/trunk/gaym/src/msgs.c
Log:
removing unused function

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-11 13:45:42 UTC (rev 186)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-11 13:50:40 UTC (rev 187)
@@ -39,12 +39,6 @@
 #include "gaympriv.h"
 #include "helpers.h"
 
-char *make_nick_profile_link(char *name)
-{
-    return g_strdup_printf("<A href='http://my.gay.com/%s'>%s</A>", name,
-                           name);
-}
-
 static char *gaym_mask_nick(const char *mask)
 {
     char *end, *buf;



From deckrider at berlios.de  Mon Jul 11 16:58:13 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Mon, 11 Jul 2005 16:58:13 +0200
Subject: [Qrc-svn] r188 - qrc/trunk/gaym/src
Message-ID: <200507111458.j6BEwD2h023962@sheep.berlios.de>

Author: deckrider
Date: 2005-07-11 16:58:12 +0200 (Mon, 11 Jul 2005)
New Revision: 188

Modified:
   qrc/trunk/gaym/src/gaym.c
Log:
updated comments

Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-11 13:50:40 UTC (rev 187)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-11 14:58:12 UTC (rev 188)
@@ -286,7 +286,6 @@
 
 static void gaym_set_info(GaimConnection * gc, const char *info)
 {
-
     struct gaym_conn *gaym = gc->proto_data;
     GaimAccount *account = gaim_connection_get_account(gc);
     char *hostname = "none";
@@ -698,10 +697,19 @@
         gc->away = NULL;
     }
 
+    /**
+     * FIXME:  set the Bio to the away message; if the away message
+     * is NULL, then set the Bio to the original bio.
+     */
+
     if (msg)
         gc->away = g_strdup(msg);
 
     /**
+     *  The following would be great, and gay.com's server supports
+     *  it, but gay.com's clients don't see the result.  So even though
+     *  we can see the result, we won't bother.
+     *
      * args[0] = msg;
      * gaym_cmd_away(gaym, "away", NULL, args);
      */



From deckrider at berlios.de  Mon Jul 11 18:18:16 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Mon, 11 Jul 2005 18:18:16 +0200
Subject: [Qrc-svn] r189 - qrc/trunk/gaym/src
Message-ID: <200507111618.j6BGIGIx028359@sheep.berlios.de>

Author: deckrider
Date: 2005-07-11 18:18:14 +0200 (Mon, 11 Jul 2005)
New Revision: 189

Modified:
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gayminfo.c
Log:
Test for NULL before using g_strstrip() to avoid filling the log with
error messages.


Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-11 14:58:12 UTC (rev 188)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-11 16:18:14 UTC (rev 189)
@@ -718,9 +718,15 @@
 static void gaym_add_buddy(GaimConnection * gc, GaimBuddy * buddy,
                            GaimGroup * group)
 {
-    buddy->name = g_strstrip(buddy->name);
-    buddy->alias = g_strstrip(buddy->alias);
-    buddy->server_alias = g_strstrip(buddy->server_alias);
+    if (buddy->name) {
+        buddy->name = g_strstrip(buddy->name);
+    }
+    if (buddy->alias) {
+        buddy->alias = g_strstrip(buddy->alias);
+    }
+    if (buddy->server_alias) {
+        buddy->server_alias = g_strstrip(buddy->server_alias);
+    }
     struct gaym_conn *gaym = (struct gaym_conn *) gc->proto_data;
     struct gaym_buddy *ib = g_new0(struct gaym_buddy, 1);
     ib->name = g_strdup(buddy->name);

Modified: qrc/trunk/gaym/src/gayminfo.c
===================================================================
--- qrc/trunk/gaym/src/gayminfo.c	2005-07-11 14:58:12 UTC (rev 188)
+++ qrc/trunk/gaym/src/gayminfo.c	2005-07-11 16:18:14 UTC (rev 189)
@@ -94,13 +94,19 @@
 
     if (info) {
         bio = gaym_bio_strdup(info);
-        bio = g_strstrip(bio);
+        if (bio) {
+            bio = g_strstrip(bio);
+        }
 
         thumbnail = gaym_thumbnail_strdup(info);
-        thumbnail = g_strstrip(thumbnail);
+        if (thumbnail) {
+            thumbnail = g_strstrip(thumbnail);
+        }
 
         stats = gaym_stats_strdup(info);
-        stats = g_strstrip(stats);
+        if (stats) {
+            stats = g_strstrip(stats);
+        }
     }
 
     GaimConnection *gc = gaim_account_get_connection(gaym->account);
@@ -144,15 +150,21 @@
             gchar **s = g_strsplit(stats, "|", 3);
             if (s[0] && strlen(s[0]) > 0) {
                 ib->sex = g_ascii_strup(s[0], -1);
-                ib->sex = g_strstrip(ib->sex);
+                if (ib->sex) {
+                    ib->sex = g_strstrip(ib->sex);
+                }
             }
             if (s[1] && strlen(s[1]) > 0) {
                 ib->age = g_strdup(s[1]);
-                ib->age = g_strstrip(ib->age);
+                if (ib->age) {
+                    ib->age = g_strstrip(ib->age);
+                }
             }
             if (s[2] && strlen(s[2]) > 0) {
                 ib->location = g_strdup(s[2]);
-                ib->location = g_strstrip(ib->location);
+                if (ib->location) {
+                    ib->location = g_strstrip(ib->location);
+                }
             }
             g_strfreev(s);
             g_free(stats);



From deckrider at berlios.de  Tue Jul 12 01:50:44 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 12 Jul 2005 01:50:44 +0200
Subject: [Qrc-svn] r190 - qrc/trunk/gaym/src
Message-ID: <200507112350.j6BNoieS025889@sheep.berlios.de>

Author: deckrider
Date: 2005-07-12 01:50:31 +0200 (Tue, 12 Jul 2005)
New Revision: 190

Modified:
   qrc/trunk/gaym/src/gayminfo.c
Log:
Fixed possible crash if user had only certain stats.

Modified: qrc/trunk/gaym/src/gayminfo.c
===================================================================
--- qrc/trunk/gaym/src/gayminfo.c	2005-07-11 16:18:14 UTC (rev 189)
+++ qrc/trunk/gaym/src/gayminfo.c	2005-07-11 23:50:31 UTC (rev 190)
@@ -134,19 +134,26 @@
     }
 
     if (ib) {
+        g_free(ib->bio);
+        ib->bio = NULL;
+        g_free(ib->thumbnail);
+        ib->thumbnail = NULL;
+        g_free(ib->sex);
+        ib->sex = NULL;
+        g_free(ib->age);
+        ib->age = NULL;
+        g_free(ib->location);
+        ib->location = NULL;
+
         ib->online = online;
+
         if (bio) {
-            g_free(ib->bio);
             ib->bio = bio;
         }
         if (thumbnail) {
-            g_free(ib->thumbnail);
             ib->thumbnail = thumbnail;
         }
         if (stats) {
-            g_free(ib->sex);
-            g_free(ib->age);
-            g_free(ib->location);
             gchar **s = g_strsplit(stats, "|", 3);
             if (s[0] && strlen(s[0]) > 0) {
                 ib->sex = g_ascii_strup(s[0], -1);



From deckrider at berlios.de  Tue Jul 12 06:15:30 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 12 Jul 2005 06:15:30 +0200
Subject: [Qrc-svn] r191 - qrc/trunk/gaym/src
Message-ID: <200507120415.j6C4FUfS027922@sheep.berlios.de>

Author: deckrider
Date: 2005-07-12 06:15:19 +0200 (Tue, 12 Jul 2005)
New Revision: 191

Modified:
   qrc/trunk/gaym/src/gayminfo.c
Log:
more gayminfo cleanup of my earlier mess

Modified: qrc/trunk/gaym/src/gayminfo.c
===================================================================
--- qrc/trunk/gaym/src/gayminfo.c	2005-07-11 23:50:31 UTC (rev 190)
+++ qrc/trunk/gaym/src/gayminfo.c	2005-07-12 04:15:19 UTC (rev 191)
@@ -147,31 +147,22 @@
 
         ib->online = online;
 
-        if (bio) {
+        if (bio && strlen(g_strstrip(bio)) > 0) {
             ib->bio = bio;
         }
-        if (thumbnail) {
+        if (thumbnail && strlen(g_strstrip(thumbnail)) > 0) {
             ib->thumbnail = thumbnail;
         }
-        if (stats) {
+        if (stats && strlen(g_strstrip(stats)) > 0) {
             gchar **s = g_strsplit(stats, "|", 3);
-            if (s[0] && strlen(s[0]) > 0) {
+            if (s[0] && strlen(g_strstrip(s[0])) > 0) {
                 ib->sex = g_ascii_strup(s[0], -1);
-                if (ib->sex) {
-                    ib->sex = g_strstrip(ib->sex);
-                }
             }
-            if (s[1] && strlen(s[1]) > 0) {
+            if (s[1] && strlen(g_strstrip(s[1])) > 0) {
                 ib->age = g_strdup(s[1]);
-                if (ib->age) {
-                    ib->age = g_strstrip(ib->age);
-                }
             }
-            if (s[2] && strlen(s[2]) > 0) {
+            if (s[2] && strlen(g_strstrip(s[2])) > 0) {
                 ib->location = g_strdup(s[2]);
-                if (ib->location) {
-                    ib->location = g_strstrip(ib->location);
-                }
             }
             g_strfreev(s);
             g_free(stats);



From jblebrun at berlios.de  Tue Jul 12 06:54:21 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Tue, 12 Jul 2005 06:54:21 +0200
Subject: [Qrc-svn] r192 - qrc/trunk/gaym/src
Message-ID: <200507120454.j6C4sLi7014390@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-12 06:53:53 +0200 (Tue, 12 Jul 2005)
New Revision: 192

Modified:
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gaym.h
   qrc/trunk/gaym/src/weblogin.c
Log:
*Keeps age/location stats from server in your bioline.
*Strips HTML from away messages

gaym.h:
Add server_stats to gaym_conn struct.

gaym.c: 
Append stats to bioline when generating it.
Strip HTML from away message

weblogin.c:
Added a function that doesn't do anything yet,
but will be a part of the changed login process.



Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-12 04:15:19 UTC (rev 191)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-12 04:53:53 UTC (rev 192)
@@ -37,12 +37,12 @@
 #include "privacy.h"
 
 #include "helpers.h"
-#include "gayminfo.h"
 #include "gaympriv.h"
 #include "configtxt.h"
 #include "botfilter.h"
 #include "gaym.h"
 
+char *gaym_mask_bio(const char *biostring);
 static const char *gaym_blist_icon(GaimAccount * a, GaimBuddy * b);
 static void gaym_blist_emblems(GaimBuddy * b, char **se, char **sw,
                                char **nw, char **ne);
@@ -202,22 +202,18 @@
         (struct gaym_conn *) buddy->account->gc->proto_data;
 
     if (!gaym) {
-        return g_strdup(_("Offline"));
+        return g_strdup("");
     }
 
     struct gaym_buddy *ib =
         g_hash_table_lookup(gaym->buddies, buddy->name);
 
     if (!ib) {
-        return g_strdup(_("Offline"));
+        return g_strdup("");
     }
 
-    if (!ib->online) {
-        return g_strdup(_("Offline"));
-    }
-
     if (!ib->bio) {
-        return NULL;
+        return g_strdup("");
     }
 
     status = g_markup_escape_text(ib->bio, strlen(ib->bio));
@@ -227,56 +223,32 @@
 
 static char *gaym_tooltip_text(GaimBuddy * buddy)
 {
+    char *escaped, *tooltip;
+
     struct gaym_conn *gaym =
         (struct gaym_conn *) buddy->account->gc->proto_data;
 
     if (!gaym) {
-        return NULL;
+        return g_strdup("");
     }
 
     struct gaym_buddy *ib =
         g_hash_table_lookup(gaym->buddies, buddy->name);
 
     if (!ib) {
-        return NULL;
+        return g_strdup("");
     }
 
-    char *escaped;
-    GString *tooltip = g_string_new("");
-
-    if (ib->sex) {
-        escaped = g_markup_escape_text(ib->sex, strlen(ib->sex));
-        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"), _("Sex"),
-                               escaped);
-        g_free(escaped);
+    if (!ib->bio) {
+        return g_strdup("");
     }
 
-    if (ib->age) {
-        escaped = g_markup_escape_text(ib->age, strlen(ib->age));
-        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"), _("Age"),
-                               escaped);
-        g_free(escaped);
-    }
+    escaped = g_markup_escape_text(ib->bio, strlen(ib->bio));
+    tooltip = g_strdup_printf(_("\n<b>%s:</b> %s"), _("Bio"), escaped);
 
-    if (ib->location) {
-        escaped = g_markup_escape_text(ib->location, strlen(ib->location));
-        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"),
-                               _("Location"), escaped);
-        g_free(escaped);
-    }
+    g_free(escaped);
 
-    if (ib->bio) {
-        escaped = g_markup_escape_text(ib->bio, strlen(ib->bio));
-        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"), _("Bio"),
-                               escaped);
-        g_free(escaped);
-    }
-
-    if (tooltip->len == 0) {
-        return g_string_free(tooltip, TRUE);
-    }
-
-    return g_string_free(tooltip, FALSE);
+    return tooltip;
 }
 
 static GList *gaym_away_states(GaimConnection * gc)
@@ -286,6 +258,7 @@
 
 static void gaym_set_info(GaimConnection * gc, const char *info)
 {
+
     struct gaym_conn *gaym = gc->proto_data;
     GaimAccount *account = gaim_connection_get_account(gc);
     char *hostname = "none";
@@ -296,10 +269,10 @@
 
     if (info && strlen(info) > 2) {
         gaim_debug_misc("gaym", "option1, info=%x\n", info);
-        gaym->bio = g_strdup(info);
+        gaym->bio = g_strdup_printf("%s",info);
     } else if (gaym->server_bioline && strlen(gaym->server_bioline) > 2) {
         gaim_debug_misc("gaym", "option2\n");
-        gaym->bio = gaym_bio_strdup(gaym->server_bioline);
+        gaym->bio = g_strdup(gaym_mask_bio(gaym->server_bioline));
     } else {
         gaim_debug_misc("gaym", "option3\n");
         gaym->bio = g_strdup("Gaim User");
@@ -310,8 +283,9 @@
     gaim_debug_info("gaym", "INFO=%x BIO=%x\n", info, gaym->bio);
     gaim_debug_misc("gaym", "In login_cb, gc->account=%x\n", gc->account);
     bioline =
-        g_strdup_printf("%s#%s", gaym->thumbnail ? gaym->thumbnail : "",
-                        gaym->bio ? gaym->bio : "");
+        g_strdup_printf("%s#%s\001%s", gaym->thumbnail ? gaym->thumbnail : "",
+                        gaym->bio ? gaym->bio : "",
+			gaym->server_stats ? gaym->server_stats : "");
 
     buf = gaym_format(gaym, "vvvv:", "USER",
                       gaim_account_get_username(account),
@@ -493,6 +467,10 @@
     gaim_connection_update_progress(gc, buf, 1, 6);
     g_free(buf);
 
+    
+    //Making a change to try cached password first.
+    //gaym_try_cached_password(account, gaym_login_with_hash);
+   
     gaym_get_hash_from_weblogin(account, gaym_login_with_hash);
 }
 
@@ -575,13 +553,13 @@
                         "In login_cb, user_bioline: %x, gc->account=%x\n",
                         user_bioline, gc->account);
 
-        login_name =
+        login_name = 
             gaym_nick_to_gcom_strdup(gaim_connection_get_display_name(gc));
+        bioline = g_strdup_printf("%s#%s\001%s",
+                                gaym->thumbnail,
+                                user_bioline ? user_bioline : "",
+                                gaym->server_stats ? gaym->server_stats : "");
 
-        bioline = g_strdup_printf("%s#%s",
-                                  gaym->thumbnail,
-                                  user_bioline ? user_bioline : "");
-
         buf = gaym_format(gaym, "vn", "NICK", login_name);
         gaim_debug_misc("gaym", "Command: %s\n", buf);
 
@@ -652,6 +630,7 @@
     struct gaym_conn *gaym = gc->proto_data;
     const char *args[2];
     const char *awaymsg = NULL;
+    const char *stripped_msg = NULL;
     if (strchr(status_chars, *who) != NULL)
         args[0] = who + 1;
     else
@@ -659,13 +638,11 @@
 
 
     if (flags & GAIM_CONV_IM_AUTO_RESP) {
-        awaymsg = g_strdup_printf("<Auto-response> %s", what);
+	stripped_msg = gaim_markup_strip_html(what);
+        awaymsg = g_strdup_printf("<Auto-response> %s", stripped_msg);
+	g_free(stripped_msg);
+	gaim_debug_misc("gaym: sending away message -- %s\n",awaymsg);
         args[1] = awaymsg;
-        /**
-         * Prevent memory leak
-         * g_free(what);
-         * what=args[1];
-         */
 
     } else
         args[1] = what;
@@ -697,19 +674,10 @@
         gc->away = NULL;
     }
 
-    /**
-     * FIXME:  set the Bio to the away message; if the away message
-     * is NULL, then set the Bio to the original bio.
-     */
-
     if (msg)
         gc->away = g_strdup(msg);
 
     /**
-     *  The following would be great, and gay.com's server supports
-     *  it, but gay.com's clients don't see the result.  So even though
-     *  we can see the result, we won't bother.
-     *
      * args[0] = msg;
      * gaym_cmd_away(gaym, "away", NULL, args);
      */
@@ -718,15 +686,9 @@
 static void gaym_add_buddy(GaimConnection * gc, GaimBuddy * buddy,
                            GaimGroup * group)
 {
-    if (buddy->name) {
-        buddy->name = g_strstrip(buddy->name);
-    }
-    if (buddy->alias) {
-        buddy->alias = g_strstrip(buddy->alias);
-    }
-    if (buddy->server_alias) {
-        buddy->server_alias = g_strstrip(buddy->server_alias);
-    }
+    buddy->name = g_strstrip(buddy->name);
+    buddy->alias = g_strstrip(buddy->alias);
+    buddy->server_alias = g_strstrip(buddy->server_alias);
     struct gaym_conn *gaym = (struct gaym_conn *) gc->proto_data;
     struct gaym_buddy *ib = g_new0(struct gaym_buddy, 1);
     ib->name = g_strdup(buddy->name);
@@ -734,9 +696,6 @@
     ib->online = FALSE;
     ib->bio = NULL;
     ib->thumbnail = NULL;
-    ib->sex = NULL;
-    ib->age = NULL;
-    ib->location = NULL;
     g_hash_table_replace(gaym->buddies, ib->name, ib);
     gaim_debug_misc("gaym", "Add buddy: %s\n", buddy->name);
     /**
@@ -997,9 +956,6 @@
     g_free(ib->name);
     g_free(ib->bio);
     g_free(ib->thumbnail);
-    g_free(ib->sex);
-    g_free(ib->age);
-    g_free(ib->location);
     g_free(ib);
 }
 
@@ -1181,33 +1137,11 @@
     if (strncmp(conv->account->protocol_id, "prpl-gaym", 9) == 0
         && gaim_conversation_get_type(conv) == GAIM_CONV_IM) {
 
-        /**
-         * First check to see if we already have the photo via
-         * the buddy list process.
-         */
-
         struct gaym_conn *gaym;
 
         GaimConnection *gc = gaim_conversation_get_gc(conv);
-
         gaym = (struct gaym_conn *) gc->proto_data;
 
-        if (!gaym) {
-            return;
-        }
-
-        struct gaym_buddy *ib =
-            g_hash_table_lookup(gaym->buddies, conv->name);
-
-        if (ib) {
-            return;
-        }
-
-        /**
-         * Since this person isn't in our buddy list, go ahead
-         * with the WHOIS to get the photo for the IM thumbnail
-         */
-
         gaym->info_window_needed = FALSE;
 
         gaym->whois.nick = g_strdup(conv->name);

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-12 04:15:19 UTC (rev 191)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-12 04:53:53 UTC (rev 192)
@@ -77,6 +77,7 @@
     char *thumbnail;
     char *hash_pw;
     char *server_bioline;
+    char *server_stats;
     char *roomlist_filter;
     char *bio;
 
@@ -122,9 +123,6 @@
     gboolean online;            /* is online */
     char *bio;                  /* bio string */
     char *thumbnail;            /* thumbnail string */
-    char *sex;                  /* sex string */
-    char *age;                  /* age string */
-    char *location;             /* location string */
 };
 
 typedef int (*IRCCmdCallback) (struct gaym_conn * gaym, const char *cmd,

Modified: qrc/trunk/gaym/src/weblogin.c
===================================================================
--- qrc/trunk/gaym/src/weblogin.c	2005-07-12 04:15:19 UTC (rev 191)
+++ qrc/trunk/gaym/src/weblogin.c	2005-07-12 04:53:53 UTC (rev 192)
@@ -488,7 +488,11 @@
 
 
 
-
+	gaym->server_stats=NULL;
+	gaym->hash_pw=NULL;
+	gaym->server_bioline=NULL;
+	gaym->thumbnail=NULL;
+	
         // First, look for password
         match = "password\" value=\"";
         temp = strstr(text, match);
@@ -534,9 +538,13 @@
                     || (gaym->server_bioline = NULL);
                 g_free(bio);
 
-            }
-            // We have established a session. Call session callback.
-
+		//Parse out stats part of bio.
+		temp2 = strchr(result, (char)0x01);
+		if(temp2++) {
+		    gaim_debug_misc("gaym", "Stats: %s\n", temp2);
+		    gaym->server_stats = g_strdup(temp2);
+		}
+	    }
         } else {
             // gaim_connection_error(
             // gaim_account_get_connection(((struct
@@ -705,6 +713,18 @@
     }
 }
 
+void gaym_try_cached_password(GaimAccount * account,
+                            void (*callback) (GaimAccount * account))
+{
+
+    const char* pw;
+    pw=gaim_account_get_string(account, "password", NULL);
+    if (pw==NULL)
+        gaym_get_hash_from_weblogin(account, callback);
+    
+
+}
+
 /**
  * vim:tabstop=4:shiftwidth=4:expandtab:
  */



From deckrider at berlios.de  Tue Jul 12 07:45:44 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 12 Jul 2005 07:45:44 +0200
Subject: [Qrc-svn] r193 - qrc/trunk/gaym/src
Message-ID: <200507120545.j6C5jiVR008270@sheep.berlios.de>

Author: deckrider
Date: 2005-07-12 07:45:28 +0200 (Tue, 12 Jul 2005)
New Revision: 193

Modified:
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gaym.h
Log:
This commit is the result of "svn merge -r181:190" to merge back in
some things that commit 192 somehow removed.  I think the intent of
commit 192 remains, since chaning the Bio no longer deletes the S|A|L.

In addition, there is one small fix to a compiler warning.


Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-12 04:53:53 UTC (rev 192)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-12 05:45:28 UTC (rev 193)
@@ -37,12 +37,12 @@
 #include "privacy.h"
 
 #include "helpers.h"
+#include "gayminfo.h"
 #include "gaympriv.h"
 #include "configtxt.h"
 #include "botfilter.h"
 #include "gaym.h"
 
-char *gaym_mask_bio(const char *biostring);
 static const char *gaym_blist_icon(GaimAccount * a, GaimBuddy * b);
 static void gaym_blist_emblems(GaimBuddy * b, char **se, char **sw,
                                char **nw, char **ne);
@@ -202,18 +202,22 @@
         (struct gaym_conn *) buddy->account->gc->proto_data;
 
     if (!gaym) {
-        return g_strdup("");
+        return g_strdup(_("Offline"));
     }
 
     struct gaym_buddy *ib =
         g_hash_table_lookup(gaym->buddies, buddy->name);
 
     if (!ib) {
-        return g_strdup("");
+        return g_strdup(_("Offline"));
     }
 
+    if (!ib->online) {
+        return g_strdup(_("Offline"));
+    }
+
     if (!ib->bio) {
-        return g_strdup("");
+        return NULL;
     }
 
     status = g_markup_escape_text(ib->bio, strlen(ib->bio));
@@ -223,32 +227,56 @@
 
 static char *gaym_tooltip_text(GaimBuddy * buddy)
 {
-    char *escaped, *tooltip;
-
     struct gaym_conn *gaym =
         (struct gaym_conn *) buddy->account->gc->proto_data;
 
     if (!gaym) {
-        return g_strdup("");
+        return NULL;
     }
 
     struct gaym_buddy *ib =
         g_hash_table_lookup(gaym->buddies, buddy->name);
 
     if (!ib) {
-        return g_strdup("");
+        return NULL;
     }
 
-    if (!ib->bio) {
-        return g_strdup("");
+    char *escaped;
+    GString *tooltip = g_string_new("");
+
+    if (ib->sex) {
+        escaped = g_markup_escape_text(ib->sex, strlen(ib->sex));
+        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"), _("Sex"),
+                               escaped);
+        g_free(escaped);
     }
 
-    escaped = g_markup_escape_text(ib->bio, strlen(ib->bio));
-    tooltip = g_strdup_printf(_("\n<b>%s:</b> %s"), _("Bio"), escaped);
+    if (ib->age) {
+        escaped = g_markup_escape_text(ib->age, strlen(ib->age));
+        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"), _("Age"),
+                               escaped);
+        g_free(escaped);
+    }
 
-    g_free(escaped);
+    if (ib->location) {
+        escaped = g_markup_escape_text(ib->location, strlen(ib->location));
+        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"),
+                               _("Location"), escaped);
+        g_free(escaped);
+    }
 
-    return tooltip;
+    if (ib->bio) {
+        escaped = g_markup_escape_text(ib->bio, strlen(ib->bio));
+        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"), _("Bio"),
+                               escaped);
+        g_free(escaped);
+    }
+
+    if (tooltip->len == 0) {
+        return g_string_free(tooltip, TRUE);
+    }
+
+    return g_string_free(tooltip, FALSE);
 }
 
 static GList *gaym_away_states(GaimConnection * gc)
@@ -258,7 +286,6 @@
 
 static void gaym_set_info(GaimConnection * gc, const char *info)
 {
-
     struct gaym_conn *gaym = gc->proto_data;
     GaimAccount *account = gaim_connection_get_account(gc);
     char *hostname = "none";
@@ -269,10 +296,10 @@
 
     if (info && strlen(info) > 2) {
         gaim_debug_misc("gaym", "option1, info=%x\n", info);
-        gaym->bio = g_strdup_printf("%s",info);
+        gaym->bio = g_strdup_printf("%s", info);
     } else if (gaym->server_bioline && strlen(gaym->server_bioline) > 2) {
         gaim_debug_misc("gaym", "option2\n");
-        gaym->bio = g_strdup(gaym_mask_bio(gaym->server_bioline));
+        gaym->bio = gaym_bio_strdup(gaym->server_bioline);
     } else {
         gaim_debug_misc("gaym", "option3\n");
         gaym->bio = g_strdup("Gaim User");
@@ -283,9 +310,10 @@
     gaim_debug_info("gaym", "INFO=%x BIO=%x\n", info, gaym->bio);
     gaim_debug_misc("gaym", "In login_cb, gc->account=%x\n", gc->account);
     bioline =
-        g_strdup_printf("%s#%s\001%s", gaym->thumbnail ? gaym->thumbnail : "",
+        g_strdup_printf("%s#%s\001%s",
+                        gaym->thumbnail ? gaym->thumbnail : "",
                         gaym->bio ? gaym->bio : "",
-			gaym->server_stats ? gaym->server_stats : "");
+                        gaym->server_stats ? gaym->server_stats : "");
 
     buf = gaym_format(gaym, "vvvv:", "USER",
                       gaim_account_get_username(account),
@@ -467,10 +495,11 @@
     gaim_connection_update_progress(gc, buf, 1, 6);
     g_free(buf);
 
-    
-    //Making a change to try cached password first.
-    //gaym_try_cached_password(account, gaym_login_with_hash);
-   
+
+    /**
+     * Making a change to try cached password first.
+     * gaym_try_cached_password(account, gaym_login_with_hash);
+     */
     gaym_get_hash_from_weblogin(account, gaym_login_with_hash);
 }
 
@@ -553,12 +582,13 @@
                         "In login_cb, user_bioline: %x, gc->account=%x\n",
                         user_bioline, gc->account);
 
-        login_name = 
+        login_name =
             gaym_nick_to_gcom_strdup(gaim_connection_get_display_name(gc));
         bioline = g_strdup_printf("%s#%s\001%s",
-                                gaym->thumbnail,
-                                user_bioline ? user_bioline : "",
-                                gaym->server_stats ? gaym->server_stats : "");
+                                  gaym->thumbnail,
+                                  user_bioline ? user_bioline : "",
+                                  gaym->server_stats ? gaym->
+                                  server_stats : "");
 
         buf = gaym_format(gaym, "vn", "NICK", login_name);
         gaim_debug_misc("gaym", "Command: %s\n", buf);
@@ -630,7 +660,7 @@
     struct gaym_conn *gaym = gc->proto_data;
     const char *args[2];
     const char *awaymsg = NULL;
-    const char *stripped_msg = NULL;
+    char *stripped_msg = NULL;
     if (strchr(status_chars, *who) != NULL)
         args[0] = who + 1;
     else
@@ -638,10 +668,10 @@
 
 
     if (flags & GAIM_CONV_IM_AUTO_RESP) {
-	stripped_msg = gaim_markup_strip_html(what);
+        stripped_msg = gaim_markup_strip_html(what);
         awaymsg = g_strdup_printf("<Auto-response> %s", stripped_msg);
-	g_free(stripped_msg);
-	gaim_debug_misc("gaym: sending away message -- %s\n",awaymsg);
+        g_free(stripped_msg);
+        gaim_debug_misc("gaym: sending away message -- %s\n", awaymsg);
         args[1] = awaymsg;
 
     } else
@@ -674,10 +704,19 @@
         gc->away = NULL;
     }
 
+    /**
+     * FIXME:  set the Bio to the away message; if the away message
+     * is NULL, then set the Bio to the original bio.
+     */
+
     if (msg)
         gc->away = g_strdup(msg);
 
     /**
+     *  The following would be great, and gay.com's server supports
+     *  it, but gay.com's clients don't see the result.  So even though
+     *  we can see the result, we won't bother.
+     *
      * args[0] = msg;
      * gaym_cmd_away(gaym, "away", NULL, args);
      */
@@ -686,9 +725,15 @@
 static void gaym_add_buddy(GaimConnection * gc, GaimBuddy * buddy,
                            GaimGroup * group)
 {
-    buddy->name = g_strstrip(buddy->name);
-    buddy->alias = g_strstrip(buddy->alias);
-    buddy->server_alias = g_strstrip(buddy->server_alias);
+    if (buddy->name) {
+        buddy->name = g_strstrip(buddy->name);
+    }
+    if (buddy->alias) {
+        buddy->alias = g_strstrip(buddy->alias);
+    }
+    if (buddy->server_alias) {
+        buddy->server_alias = g_strstrip(buddy->server_alias);
+    }
     struct gaym_conn *gaym = (struct gaym_conn *) gc->proto_data;
     struct gaym_buddy *ib = g_new0(struct gaym_buddy, 1);
     ib->name = g_strdup(buddy->name);
@@ -696,6 +741,9 @@
     ib->online = FALSE;
     ib->bio = NULL;
     ib->thumbnail = NULL;
+    ib->sex = NULL;
+    ib->age = NULL;
+    ib->location = NULL;
     g_hash_table_replace(gaym->buddies, ib->name, ib);
     gaim_debug_misc("gaym", "Add buddy: %s\n", buddy->name);
     /**
@@ -956,6 +1004,9 @@
     g_free(ib->name);
     g_free(ib->bio);
     g_free(ib->thumbnail);
+    g_free(ib->sex);
+    g_free(ib->age);
+    g_free(ib->location);
     g_free(ib);
 }
 
@@ -1137,11 +1188,33 @@
     if (strncmp(conv->account->protocol_id, "prpl-gaym", 9) == 0
         && gaim_conversation_get_type(conv) == GAIM_CONV_IM) {
 
+        /**
+         * First check to see if we already have the photo via
+         * the buddy list process.
+         */
+
         struct gaym_conn *gaym;
 
         GaimConnection *gc = gaim_conversation_get_gc(conv);
+
         gaym = (struct gaym_conn *) gc->proto_data;
 
+        if (!gaym) {
+            return;
+        }
+
+        struct gaym_buddy *ib =
+            g_hash_table_lookup(gaym->buddies, conv->name);
+
+        if (ib) {
+            return;
+        }
+
+        /**
+         * Since this person isn't in our buddy list, go ahead
+         * with the WHOIS to get the photo for the IM thumbnail
+         */
+
         gaym->info_window_needed = FALSE;
 
         gaym->whois.nick = g_strdup(conv->name);

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-12 04:53:53 UTC (rev 192)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-12 05:45:28 UTC (rev 193)
@@ -123,6 +123,9 @@
     gboolean online;            /* is online */
     char *bio;                  /* bio string */
     char *thumbnail;            /* thumbnail string */
+    char *sex;                  /* sex string */
+    char *age;                  /* age string */
+    char *location;             /* location string */
 };
 
 typedef int (*IRCCmdCallback) (struct gaym_conn * gaym, const char *cmd,



From deckrider at berlios.de  Tue Jul 12 08:22:32 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 12 Jul 2005 08:22:32 +0200
Subject: [Qrc-svn] r194 - qrc/trunk/gaym/src
Message-ID: <200507120622.j6C6MWp7020852@sheep.berlios.de>

Author: deckrider
Date: 2005-07-12 08:22:10 +0200 (Tue, 12 Jul 2005)
New Revision: 194

Modified:
   qrc/trunk/gaym/src/gaym.c
Log:
Change Bio to Away Message when Away.  Restore the normal Bio upon
return.

There is still a bug in this:  changing the Bio while away, preempts
the away message.


Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-12 05:45:28 UTC (rev 193)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-12 06:22:10 UTC (rev 194)
@@ -694,10 +694,10 @@
 static void gaym_set_away(GaimConnection * gc, const char *state,
                           const char *msg)
 {
-    /**
-     * struct gaym_conn *gaym = gc->proto_data;
-     * const char *args[1];
-     */
+    char *bioline = NULL;
+    char *buf = NULL;
+    char *hostname = "none";
+    struct gaym_conn *gaym = gc->proto_data;
 
     if (gc->away) {
         g_free(gc->away);
@@ -705,13 +705,34 @@
     }
 
     /**
-     * FIXME:  set the Bio to the away message; if the away message
-     * is NULL, then set the Bio to the original bio.
+     * In addition to setting the away message, set the Bio to the
+     * away message; if the away message is NULL, then set the Bio
+     * to the original bio.
      */
-
-    if (msg)
+    if (msg) {
         gc->away = g_strdup(msg);
+        bioline =
+            g_strdup_printf("%s#%s\001%s",
+                            gaym->thumbnail ? gaym->thumbnail : "",
+                            msg,
+                            gaym->server_stats ? gaym->server_stats : "");
+    } else {
+        bioline =
+            g_strdup_printf("%s#%s\001%s",
+                            gaym->thumbnail ? gaym->thumbnail : "",
+                            gaym->bio ? gaym->bio : "",
+                            gaym->server_stats ? gaym->server_stats : "");
 
+    }
+
+    buf = gaym_format(gaym, "vvvv:", "USER",
+                      gaim_account_get_username(gc->account),
+                      hostname, gaym->server, bioline);
+
+    g_free(bioline);
+    gaym_send(gaym, buf);
+    g_free(buf);
+
     /**
      *  The following would be great, and gay.com's server supports
      *  it, but gay.com's clients don't see the result.  So even though



From deckrider at berlios.de  Tue Jul 12 15:58:59 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 12 Jul 2005 15:58:59 +0200
Subject: [Qrc-svn] r195 - qrc/trunk/gaym/src
Message-ID: <200507121358.j6CDwxmx032264@sheep.berlios.de>

Author: deckrider
Date: 2005-07-12 15:58:56 +0200 (Tue, 12 Jul 2005)
New Revision: 195

Modified:
   qrc/trunk/gaym/src/gaym.c
Log:
Fix memory leak.

Fix problem of setting bio while away causing away message to be
overruled.

The approach was to move more of the logic to gaym_set_info() instead
of setting the info in two places.  However, this did require
gaym_set_info to be aware of gaym->away.


Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-12 06:22:10 UTC (rev 194)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-12 13:58:56 UTC (rev 195)
@@ -291,28 +291,37 @@
     char *hostname = "none";
     char *buf, *bioline;
 
-    if (gaym->bio)
-        g_free(gaym->bio);
-
-    if (info && strlen(info) > 2) {
-        gaim_debug_misc("gaym", "option1, info=%x\n", info);
-        gaym->bio = g_strdup_printf("%s", info);
-    } else if (gaym->server_bioline && strlen(gaym->server_bioline) > 2) {
-        gaim_debug_misc("gaym", "option2\n");
-        gaym->bio = gaym_bio_strdup(gaym->server_bioline);
+    if (gc->away && !info) {
+        /**
+         * don't change any bio settings, since this is just
+         * setting an away message
+         */
     } else {
-        gaim_debug_misc("gaym", "option3\n");
-        gaym->bio = g_strdup("Gaim User");
+        if (gaym->bio) {
+            g_free(gaym->bio);
+        }
+        if (info && strlen(info) > 2) {
+            gaim_debug_misc("gaym", "option1, info=%x\n", info);
+            gaym->bio = g_strdup_printf("%s", info);
+        } else if (gaym->server_bioline
+                   && strlen(gaym->server_bioline) > 2) {
+            gaim_debug_misc("gaym", "option2\n");
+            gaym->bio = gaym_bio_strdup(gaym->server_bioline);
+        } else {
+            gaim_debug_misc("gaym", "option3\n");
+            gaym->bio = g_strdup("Gaim User");
+        }
+        gaim_account_set_user_info(account, gaym->bio);
+        gaim_account_set_string(account, "bioline", gaym->bio);
+        gaim_debug_info("gaym", "INFO=%x BIO=%x\n", info, gaym->bio);
+        gaim_debug_misc("gaym", "In login_cb, gc->account=%x\n",
+                        gc->account);
     }
 
-    gaim_account_set_user_info(account, gaym->bio);
-    gaim_account_set_string(account, "bioline", gaym->bio);
-    gaim_debug_info("gaym", "INFO=%x BIO=%x\n", info, gaym->bio);
-    gaim_debug_misc("gaym", "In login_cb, gc->account=%x\n", gc->account);
     bioline =
         g_strdup_printf("%s#%s\001%s",
                         gaym->thumbnail ? gaym->thumbnail : "",
-                        gaym->bio ? gaym->bio : "",
+                        gc->away ? gc->away : (gaym->bio ? gaym->bio : ""),
                         gaym->server_stats ? gaym->server_stats : "");
 
     buf = gaym_format(gaym, "vvvv:", "USER",
@@ -320,12 +329,15 @@
                       hostname, gaym->server, bioline);
 
     gaim_debug_misc("gaym", "BIO=%x\n", bioline);
-    g_free(bioline);
 
     if (gaym_send(gaym, buf) < 0) {
         gaim_connection_error(gc, "Error registering with server");
-        return;
     }
+
+    g_free(bioline);
+    g_free(buf);
+
+    return;
 }
 
 static void gaym_show_set_info(GaimPluginAction * action)
@@ -694,9 +706,7 @@
 static void gaym_set_away(GaimConnection * gc, const char *state,
                           const char *msg)
 {
-    char *bioline = NULL;
-    char *buf = NULL;
-    char *hostname = "none";
+    char *bio = NULL;
     struct gaym_conn *gaym = gc->proto_data;
 
     if (gc->away) {
@@ -709,30 +719,20 @@
      * away message; if the away message is NULL, then set the Bio
      * to the original bio.
      */
+
     if (msg) {
         gc->away = g_strdup(msg);
-        bioline =
-            g_strdup_printf("%s#%s\001%s",
-                            gaym->thumbnail ? gaym->thumbnail : "",
-                            msg,
-                            gaym->server_stats ? gaym->server_stats : "");
+        gaym_set_info(gc, NULL);
     } else {
-        bioline =
-            g_strdup_printf("%s#%s\001%s",
-                            gaym->thumbnail ? gaym->thumbnail : "",
-                            gaym->bio ? gaym->bio : "",
-                            gaym->server_stats ? gaym->server_stats : "");
-
+        if (gaym && gaym->bio) {
+            bio = g_strdup(gaym->bio);
+            gaym_set_info(gc, bio);
+            g_free(bio);
+        } else {
+            gaym_set_info(gc, NULL);
+        }
     }
 
-    buf = gaym_format(gaym, "vvvv:", "USER",
-                      gaim_account_get_username(gc->account),
-                      hostname, gaym->server, bioline);
-
-    g_free(bioline);
-    gaym_send(gaym, buf);
-    g_free(buf);
-
     /**
      *  The following would be great, and gay.com's server supports
      *  it, but gay.com's clients don't see the result.  So even though



From deckrider at berlios.de  Tue Jul 12 17:11:30 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 12 Jul 2005 17:11:30 +0200
Subject: [Qrc-svn] r196 - qrc/trunk/gaym/src
Message-ID: <200507121511.j6CFBUwn006729@sheep.berlios.de>

Author: deckrider
Date: 2005-07-12 17:11:23 +0200 (Tue, 12 Jul 2005)
New Revision: 196

Modified:
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gaym.h
Log:
Additional checks for Bio/Away messages:

Allow Bio/Away of only 1 character.
Strip newlines from Bio/Away.
Strip leading/trailing spaces from Bio/Away.
Maximum Bio/Away length is 150 characters (based on gay.com's java
client).


Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-12 13:58:56 UTC (rev 195)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-12 15:11:23 UTC (rev 196)
@@ -290,8 +290,20 @@
     GaimAccount *account = gaim_connection_get_account(gc);
     char *hostname = "none";
     char *buf, *bioline;
+    int i = 0;
 
-    if (gc->away && !info) {
+    char *tmpinfo = NULL;
+    if (info) {
+        tmpinfo = g_strdup(info);
+        for (i = 0; i < strlen(tmpinfo); i++) {
+            if (tmpinfo[i] == '\n') {
+                tmpinfo[i] = ' ';
+            }
+        }
+        tmpinfo = g_strstrip(tmpinfo);
+    }
+
+    if (gc->away && !tmpinfo) {
         /**
          * don't change any bio settings, since this is just
          * setting an away message
@@ -300,11 +312,12 @@
         if (gaym->bio) {
             g_free(gaym->bio);
         }
-        if (info && strlen(info) > 2) {
-            gaim_debug_misc("gaym", "option1, info=%x\n", info);
-            gaym->bio = g_strdup_printf("%s", info);
+        if (tmpinfo && strlen(tmpinfo) > 0) {
+            gaim_debug_misc("gaym", "option1, info=%x\n", tmpinfo);
+            /* java client allows MAX_BIO_LEN characters */
+            gaym->bio = g_strndup(tmpinfo, MAX_BIO_LEN);
         } else if (gaym->server_bioline
-                   && strlen(gaym->server_bioline) > 2) {
+                   && strlen(gaym->server_bioline) > 0) {
             gaim_debug_misc("gaym", "option2\n");
             gaym->bio = gaym_bio_strdup(gaym->server_bioline);
         } else {
@@ -313,7 +326,7 @@
         }
         gaim_account_set_user_info(account, gaym->bio);
         gaim_account_set_string(account, "bioline", gaym->bio);
-        gaim_debug_info("gaym", "INFO=%x BIO=%x\n", info, gaym->bio);
+        gaim_debug_info("gaym", "INFO=%x BIO=%x\n", tmpinfo, gaym->bio);
         gaim_debug_misc("gaym", "In login_cb, gc->account=%x\n",
                         gc->account);
     }
@@ -334,6 +347,9 @@
         gaim_connection_error(gc, "Error registering with server");
     }
 
+    if (tmpinfo) {
+        g_free(tmpinfo);
+    }
     g_free(bioline);
     g_free(buf);
 
@@ -707,6 +723,8 @@
                           const char *msg)
 {
     char *bio = NULL;
+    char *tmpmsg = NULL;
+    int i = 0;
     struct gaym_conn *gaym = gc->proto_data;
 
     if (gc->away) {
@@ -721,8 +739,17 @@
      */
 
     if (msg) {
-        gc->away = g_strdup(msg);
+        tmpmsg = g_strdup(msg);
+        for (i = 0; i < strlen(tmpmsg); i++) {
+            if (tmpmsg[i] == '\n') {
+                tmpmsg[i] = ' ';
+            }
+        }
+        tmpmsg = g_strstrip(tmpmsg);
+
+        gc->away = g_strndup(tmpmsg, MAX_BIO_LEN);
         gaym_set_info(gc, NULL);
+        g_free(tmpmsg);
     } else {
         if (gaym && gaym->bio) {
             bio = g_strdup(gaym->bio);

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-12 13:58:56 UTC (rev 195)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-12 15:11:23 UTC (rev 196)
@@ -37,9 +37,11 @@
 
 #define IRC_INITIAL_BUFSIZE 1024
 
-#define BLIST_UPDATE_PERIOD 60000       // buddy list updated every 45s
-#define BLIST_CHUNK_INTERVAL 5000       // 5s between ISON chunks
+#define BLIST_UPDATE_PERIOD 60000       /* buddy list updated every 45s */
+#define BLIST_CHUNK_INTERVAL 5000       /* 5s between ISON chunks */
 
+#define MAX_BIO_LEN 150         /* max number of characters in bio */
+
 #define GAYBOI_SPAM_URL "http://gayboi.org/spam/spamlst.php"
 
 typedef struct _BListWhois BListWhois;



From deckrider at berlios.de  Tue Jul 12 17:23:14 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Tue, 12 Jul 2005 17:23:14 +0200
Subject: [Qrc-svn] r197 - qrc/trunk
Message-ID: <200507121523.j6CFNEMj007526@sheep.berlios.de>

Author: deckrider
Date: 2005-07-12 17:23:13 +0200 (Tue, 12 Jul 2005)
New Revision: 197

Modified:
   qrc/trunk/ChangeLog
Log:
updated changelog

Modified: qrc/trunk/ChangeLog
===================================================================
--- qrc/trunk/ChangeLog	2005-07-12 15:11:23 UTC (rev 196)
+++ qrc/trunk/ChangeLog	2005-07-12 15:23:13 UTC (rev 197)
@@ -2,9 +2,11 @@
 	New Features:
 	- Bio displays in the buddy list status area
 	- Buddy list tooltip shows sex, age, location, and bio
+	- Your Bio is set to the Away Message when you are Away.
 
 	Bug Fixes:
 	- Better refreshing of stale buddy list photos
+	- Bio no longer replaces sex, age, and location values
 
 	Preference Changes:
 	- none



From deckrider at berlios.de  Wed Jul 13 17:12:09 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Wed, 13 Jul 2005 17:12:09 +0200
Subject: [Qrc-svn] r198 - qrc/trunk/gaym/src
Message-ID: <200507131512.j6DFC93s011871@sheep.berlios.de>

Author: deckrider
Date: 2005-07-13 17:12:08 +0200 (Wed, 13 Jul 2005)
New Revision: 198

Modified:
   qrc/trunk/gaym/src/helpers.c
   qrc/trunk/gaym/src/helpers.h
Log:
Add gaym_properties_new() helper function to be used with java properties
files.


Modified: qrc/trunk/gaym/src/helpers.c
===================================================================
--- qrc/trunk/gaym/src/helpers.c	2005-07-12 15:23:13 UTC (rev 197)
+++ qrc/trunk/gaym/src/helpers.c	2005-07-13 15:12:08 UTC (rev 198)
@@ -203,6 +203,52 @@
     return retval;
 }
 
+GHashTable *gaym_properties_new(const gchar * str)
+{
+    gchar *tmpstr = NULL;
+    gchar **tmparr = NULL;
+    gchar **proparr = NULL;
+    int i = 0;
+
+    GHashTable *props =
+        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
+
+    tmpstr = ascii2native(str);
+
+    tmparr = g_strsplit(tmpstr, "\\\n", -1);
+
+    g_free(tmpstr);
+
+    tmpstr = g_strjoinv(NULL, tmparr);
+
+    g_strfreev(tmparr);
+
+    tmparr = g_strsplit(tmpstr, "\n", -1);
+
+    for (i = 0; tmparr[i] != NULL; i++) {
+        /* do nothing if this is a blank line */
+        if (strlen(g_strstrip(tmparr[i])) == 0) {
+            continue;
+        }
+        /* do nothing if this is a comment line */
+        if (tmparr[i][0] == '#') {
+            continue;
+        }
+        /* this must be a property=value string */
+        proparr = g_strsplit(tmparr[i], "=", 2);
+        if (proparr[0] && strlen(g_strstrip(proparr[0])) > 0
+            && proparr[1] && strlen(g_strstrip(proparr[1])) > 0) {
+            g_hash_table_insert(props, g_strdup(proparr[0]),
+                                g_strdup(proparr[1]));
+            g_strfreev(proparr);
+        }
+    }
+
+    g_strfreev(tmparr);
+
+    return props;
+}
+
 /**
  * vim:tabstop=4:shiftwidth=4:expandtab:
  */

Modified: qrc/trunk/gaym/src/helpers.h
===================================================================
--- qrc/trunk/gaym/src/helpers.h	2005-07-12 15:23:13 UTC (rev 197)
+++ qrc/trunk/gaym/src/helpers.h	2005-07-13 15:12:08 UTC (rev 198)
@@ -78,6 +78,21 @@
  */
 gboolean gaym_nick_check(const char *nick);
 
+/**
+ * Build a GHashTable from a string that contains the contents of java
+ * properties file.
+ *
+ * This is built with g_hash_table_new_full() so when finished with
+ * the GHashTable, use only g_hash_table_destroy() to clean up.
+ *
+ * To retrieve a property, use g_hash_table_lookup().
+ *
+ * @param str The contents of the java properties file
+ *
+ * @return The GHashTable containing the properties
+ */
+GHashTable *gaym_properties_new(const char *str);
+
 #endif                          /* _GAIM_GAYM_HELPERS_H_ */
 
 /**



From deckrider at berlios.de  Wed Jul 13 17:51:50 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Wed, 13 Jul 2005 17:51:50 +0200
Subject: [Qrc-svn] r199 - qrc/trunk/gaym/src
Message-ID: <200507131551.j6DFpo2P016567@sheep.berlios.de>

Author: deckrider
Date: 2005-07-13 17:51:49 +0200 (Wed, 13 Jul 2005)
New Revision: 199

Modified:
   qrc/trunk/gaym/src/helpers.c
Log:
Translate $[0-9] into %s
Add more comments


Modified: qrc/trunk/gaym/src/helpers.c
===================================================================
--- qrc/trunk/gaym/src/helpers.c	2005-07-13 15:12:08 UTC (rev 198)
+++ qrc/trunk/gaym/src/helpers.c	2005-07-13 15:51:49 UTC (rev 199)
@@ -213,28 +213,65 @@
     GHashTable *props =
         g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
 
+    /**
+     * convert ascii-escaped to native
+     */
     tmpstr = ascii2native(str);
 
+    /**
+     * replace $[0-9] with %s, so we can use printf style
+     * processing with the provided property values
+     */
+    for (i = 0; i < strlen(tmpstr); i++) {
+        if (tmpstr[i] == '$') {
+            if (g_ascii_isdigit(tmpstr[i + 1])) {
+                tmpstr[i] = '%';
+                tmpstr[i + 1] = 's';
+                i++;
+            }
+        }
+    }
+
+    /**
+     * strip out continuation character followed by newline 
+     */
     tmparr = g_strsplit(tmpstr, "\\\n", -1);
-
     g_free(tmpstr);
-
     tmpstr = g_strjoinv(NULL, tmparr);
-
     g_strfreev(tmparr);
 
+    /**
+     * We're getting close.  Now we need an array as follows:
+     *
+     * property=value
+     * property=value
+     * ...
+     */
     tmparr = g_strsplit(tmpstr, "\n", -1);
 
     for (i = 0; tmparr[i] != NULL; i++) {
-        /* do nothing if this is a blank line */
+        /**
+         * do nothing if this is a blank line
+         */
         if (strlen(g_strstrip(tmparr[i])) == 0) {
             continue;
         }
-        /* do nothing if this is a comment line */
+        /**
+         * do nothing if this is a comment line
+         */
         if (tmparr[i][0] == '#') {
             continue;
         }
-        /* this must be a property=value string */
+        /**
+         * this must be a property=value string, so we make
+         * it into a 2-element array:
+         *
+         * property
+         * value
+         *
+         * but we won't store it in our hash table unless both
+         * have real values after stripping whitespace
+         */
         proparr = g_strsplit(tmparr[i], "=", 2);
         if (proparr[0] && strlen(g_strstrip(proparr[0])) > 0
             && proparr[1] && strlen(g_strstrip(proparr[1])) > 0) {



From deckrider at berlios.de  Wed Jul 13 22:00:29 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Wed, 13 Jul 2005 22:00:29 +0200
Subject: [Qrc-svn] r200 - qrc/trunk/gaym/src
Message-ID: <200507132000.j6DK0Tgg030393@sheep.berlios.de>

Author: deckrider
Date: 2005-07-13 22:00:29 +0200 (Wed, 13 Jul 2005)
New Revision: 200

Removed:
   qrc/trunk/gaym/src/configtxt.c
   qrc/trunk/gaym/src/configtxt.h
Modified:
   qrc/trunk/gaym/src/Makefile.am
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gaym.h
   qrc/trunk/gaym/src/gaympriv.c
   qrc/trunk/gaym/src/gaympriv.h
Log:
Converting from configtxt to confighash for connect-list.ignore.members
property.

Since both configtxt AND confighash systems are running we are
experiencing longer startup times.  After converting roomlist to
confighash and dropping configtxt, the startup time will not be as much
as it is now with this commit.


Modified: qrc/trunk/gaym/src/Makefile.am
===================================================================
--- qrc/trunk/gaym/src/Makefile.am	2005-07-13 15:51:49 UTC (rev 199)
+++ qrc/trunk/gaym/src/Makefile.am	2005-07-13 20:00:29 UTC (rev 200)
@@ -5,8 +5,6 @@
 	botfilter.c \
 	botfilter.h \
 	cmds.c \
-	configtxt.c \
-	configtxt.h \
 	dcc_send.c \
 	gaym.c \
 	gaym.h \

Deleted: qrc/trunk/gaym/src/configtxt.c
===================================================================
--- qrc/trunk/gaym/src/configtxt.c	2005-07-13 15:51:49 UTC (rev 199)
+++ qrc/trunk/gaym/src/configtxt.c	2005-07-13 20:00:29 UTC (rev 200)
@@ -1,120 +0,0 @@
-/**
- * GayM
- *
- * GayM is the legal property of its developers, whose names are too numerous
- * to list here.  Please refer to the COPYRIGHT file distributed with this
- * source distribution.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-/* config.h */
-#ifdef HAVE_CONFIG_H
-#include "config.h"
-#endif
-
-/* system headers */
-#include <glib.h>
-
-/* gaim headers for this plugin */
-#include "util.h"
-#include "debug.h"
-#include "account.h"
-#include "privacy.h"
-
-/* local headers for this plugin */
-#include "gaympriv.h"
-#include "gaym.h"
-#include "helpers.h"
-
-void synchronize_deny_list(GaimConnection * gc, const char *configtxt)
-{
-    char *srvdeny = NULL;
-    char *start = NULL;
-    char *end = NULL;
-    gchar **srvdenylist = NULL;
-    GSList *list;
-    gint i = 0;
-    gboolean needsync = FALSE;
-
-    start =
-        g_strstr_len(configtxt, -1, "connect-list.ignore.members=") + 28;
-    end = g_strstr_len(start, -1, "\n");
-    srvdeny = g_strndup(start, end - start);
-
-    srvdenylist = g_strsplit(srvdeny, ",", -1);
-
-    /**
-     * The nicks come in here as if they came from the IRC server
-     * so they need to be converted to GayM format
-     */
-    for (i = 0; srvdenylist[i]; i++) {
-        gcom_nick_to_gaym(srvdenylist[i]);
-    }
-
-    /* Add server deny list from config.txt to local deny list */
-    for (i = 0; srvdenylist[i]; i++) {
-        needsync = TRUE;
-        for (list = gc->account->deny; list != NULL; list = list->next) {
-            if (!gaim_utf8_strcasecmp
-                (srvdenylist[i],
-                 gaim_normalize(gc->account, (char *) list->data))) {
-                needsync = FALSE;
-                break;
-            }
-        }
-        if (needsync) {
-            if (!gaim_privacy_deny_add(gc->account, srvdenylist[i], TRUE)) {
-                gaim_debug_error("gaym",
-                                 "Failed to add %s to local deny list from server.\n",
-                                 srvdenylist[i]);
-            } else {
-                gaim_debug_misc("gaym",
-                                "Added %s to local deny list from server.\n",
-                                srvdenylist[i]);
-            }
-        }
-    }
-
-    /* Add local deny list not found in config.txt to server deny list */
-    for (list = gc->account->deny; list != NULL; list = list->next) {
-        needsync = TRUE;
-        for (i = 0; srvdenylist[i]; i++) {
-            if (!gaim_utf8_strcasecmp
-                (srvdenylist[i],
-                 gaim_normalize(gc->account, (char *) list->data))) {
-                needsync = FALSE;
-                break;
-            }
-        }
-        if (needsync) {
-            gaym_server_store_deny(gc, (char *) list->data, TRUE);
-        }
-    }
-
-    g_strfreev(srvdenylist);
-    g_free(srvdeny);
-    return;
-}
-
-void process_configtxt(GaimConnection * gc, const char *configtxt)
-{
-    synchronize_deny_list(gc, configtxt);
-    return;
-}
-
-/**
- * vim:tabstop=4:shiftwidth=4:expandtab:
- */

Deleted: qrc/trunk/gaym/src/configtxt.h
===================================================================
--- qrc/trunk/gaym/src/configtxt.h	2005-07-13 15:51:49 UTC (rev 199)
+++ qrc/trunk/gaym/src/configtxt.h	2005-07-13 20:00:29 UTC (rev 200)
@@ -1,54 +0,0 @@
-/**
- * @file configtxt.h GayM Privacy API
- *
- * GayM
- *
- * GayM is the legal property of its developers, whose names are too numerous
- * to list here.  Please refer to the COPYRIGHT file distributed with this
- * source distribution.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-#ifndef _GAIM_GAYM_CONFIGTXT_H_
-#define _GAIM_GAYM_CONFIGTXT_H_
-
-#include "connection.h"
-
-/**
- * Try to synchronize the server's deny list with gaim's local deny
- * list.  Because there may be a limit to the number of people you can
- * store on the server's deny list, this function's goal so to put the
- * superset of the two on both.
- *
- * @param gc        The connection.
- * @param configtxt The config.txt java properties retrieved from Gay.com.
- */
-void synchronize_deny_list(GaimConnection * gc, const char *configtxt);
-
-/**
- * This is the driver function to do all the processing of the config.txt
- * java properties file upon retrieval from Gay.com.  It should perform
- * each of the above functions.
- *
- * @param gc        The connection.
- * @param configtxt The config.txt java properties retrieved from Gay.com.
- */
-void process_configtxt(GaimConnection * gc, const char *configtxt);
-
-#endif                          /* _GAIM_GAYM_CONFIGTXT_H_ */
-
-/**
- * vim:tabstop=4:shiftwidth=4:expandtab:
- */

Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-13 15:51:49 UTC (rev 199)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-13 20:00:29 UTC (rev 200)
@@ -39,7 +39,6 @@
 #include "helpers.h"
 #include "gayminfo.h"
 #include "gaympriv.h"
-#include "configtxt.h"
 #include "botfilter.h"
 #include "gaym.h"
 
@@ -550,9 +549,17 @@
     if (!gaym->configtxt) {
         gaim_debug(GAIM_DEBUG_ERROR, "gaym",
                    "Could not convert config.txt to utf-8.\n");
+    }
+
+    gaym->confighash = gaym_properties_new(config_text);
+
+    if (!gaym->confighash) {
+        gaim_debug(GAIM_DEBUG_ERROR, "gaym",
+                   "Could not convert config.txt to hash table.\n");
     } else {
-        process_configtxt(gc, gaym->configtxt);
+        synchronize_deny_list(gc, gaym->confighash);
     }
+
     return;
 }
 

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-13 15:51:49 UTC (rev 199)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-13 20:00:29 UTC (rev 200)
@@ -111,6 +111,7 @@
     gboolean quitting;
     char *subroom;
     gchar *configtxt;
+    GHashTable *confighash;
     GaimUrlSession *session;
 
     char *persist_room;

Modified: qrc/trunk/gaym/src/gaympriv.c
===================================================================
--- qrc/trunk/gaym/src/gaympriv.c	2005-07-13 15:51:49 UTC (rev 199)
+++ qrc/trunk/gaym/src/gaympriv.c	2005-07-13 20:00:29 UTC (rev 200)
@@ -19,14 +19,26 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
-#include "internal.h"
+
+/* config.h */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+/* system headers */
+#include <glib.h>
+
+/* gaim headers for this plugin */
+#include "account.h"
 #include "debug.h"
 #include "privacy.h"
 #include "util.h"
 
-#include "gaympriv.h"
+/* local headers for this plugin */
 #include "botfilter.h"
 #include "gaym.h"
+#include "gaympriv.h"
+#include "helpers.h"
 
 gboolean gaym_privacy_check(GaimConnection * gc, const char *nick)
 {
@@ -202,6 +214,73 @@
     return;
 }
 
+void synchronize_deny_list(GaimConnection * gc, GHashTable * confighash)
+{
+    char *srvdeny = NULL;
+    gchar **srvdenylist = NULL;
+    GSList *list;
+    gint i = 0;
+    gboolean needsync = FALSE;
+
+    srvdeny =
+        g_hash_table_lookup(confighash, "connect-list.ignore.members");
+    if (!srvdeny) {
+        srvdeny = "";
+    }
+    srvdenylist = g_strsplit(srvdeny, ",", -1);
+
+    /**
+     * The nicks come in here as if they came from the IRC server
+     * so they need to be converted to GayM format
+     */
+    for (i = 0; srvdenylist[i]; i++) {
+        gcom_nick_to_gaym(srvdenylist[i]);
+    }
+
+    /* Add server deny list from config.txt to local deny list */
+    for (i = 0; srvdenylist[i]; i++) {
+        needsync = TRUE;
+        for (list = gc->account->deny; list != NULL; list = list->next) {
+            if (!gaim_utf8_strcasecmp
+                (srvdenylist[i],
+                 gaim_normalize(gc->account, (char *) list->data))) {
+                needsync = FALSE;
+                break;
+            }
+        }
+        if (needsync) {
+            if (!gaim_privacy_deny_add(gc->account, srvdenylist[i], TRUE)) {
+                gaim_debug_error("gaym",
+                                 "Failed to add %s to local deny list from server.\n",
+                                 srvdenylist[i]);
+            } else {
+                gaim_debug_misc("gaym",
+                                "Added %s to local deny list from server.\n",
+                                srvdenylist[i]);
+            }
+        }
+    }
+
+    /* Add local deny list not found in config.txt to server deny list */
+    for (list = gc->account->deny; list != NULL; list = list->next) {
+        needsync = TRUE;
+        for (i = 0; srvdenylist[i]; i++) {
+            if (!gaim_utf8_strcasecmp
+                (srvdenylist[i],
+                 gaim_normalize(gc->account, (char *) list->data))) {
+                needsync = FALSE;
+                break;
+            }
+        }
+        if (needsync) {
+            gaym_server_store_deny(gc, (char *) list->data, TRUE);
+        }
+    }
+
+    g_strfreev(srvdenylist);
+    return;
+}
+
 /**
  * vim:tabstop=4:shiftwidth=4:expandtab:
  */

Modified: qrc/trunk/gaym/src/gaympriv.h
===================================================================
--- qrc/trunk/gaym/src/gaympriv.h	2005-07-13 15:51:49 UTC (rev 199)
+++ qrc/trunk/gaym/src/gaympriv.h	2005-07-13 20:00:29 UTC (rev 200)
@@ -73,6 +73,17 @@
 void gaym_server_store_deny(GaimConnection * gc, const char *name,
                             gboolean add);
 
+/**
+ * Try to synchronize the server's deny list with gaim's local deny
+ * list.  Because there may be a limit to the number of people you can
+ * store on the server's deny list, this function's goal so to put the
+ * superset of the two on both.
+ *
+ * @param gc          The connection.
+ * @param confighash The config.txt java properties retrieved from Gay.com.
+ */
+void synchronize_deny_list(GaimConnection * gc, GHashTable * confighash);
+
 #endif                          /* _GAIM_GAYM_GAYMPRIV_H_ */
 
 /**



From deckrider at berlios.de  Thu Jul 14 05:02:01 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Thu, 14 Jul 2005 05:02:01 +0200
Subject: [Qrc-svn] r201 - qrc/trunk/gaym/src
Message-ID: <200507140302.j6E321FN030204@sheep.berlios.de>

Author: deckrider
Date: 2005-07-14 05:01:59 +0200 (Thu, 14 Jul 2005)
New Revision: 201

Modified:
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gaym.h
   qrc/trunk/gaym/src/helpers.c
   qrc/trunk/gaym/src/helpers.h
   qrc/trunk/gaym/src/msgs.c
Log:
Converted static roomlist processing to use confighash instead of configtxt.
Simplified(?) static roomlist processing and moved it to helpers.[ch].
Removed gaym->configtxt since converstion to gaym->confighash is complete.


Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-13 20:00:29 UTC (rev 200)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-14 03:01:59 UTC (rev 201)
@@ -541,16 +541,7 @@
                    "Could not retrieve config.txt.\n");
         return;
     }
-    /**
-     * Call Jason's cool function to do away with java madness
-     */
-    gaym->configtxt = ascii2native(config_text);
 
-    if (!gaym->configtxt) {
-        gaim_debug(GAIM_DEBUG_ERROR, "gaym",
-                   "Could not convert config.txt to utf-8.\n");
-    }
-
     gaym->confighash = gaym_properties_new(config_text);
 
     if (!gaym->confighash) {

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-13 20:00:29 UTC (rev 200)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-14 03:01:59 UTC (rev 201)
@@ -110,7 +110,6 @@
     GList **node_menu;
     gboolean quitting;
     char *subroom;
-    gchar *configtxt;
     GHashTable *confighash;
     GaimUrlSession *session;
 

Modified: qrc/trunk/gaym/src/helpers.c
===================================================================
--- qrc/trunk/gaym/src/helpers.c	2005-07-13 20:00:29 UTC (rev 200)
+++ qrc/trunk/gaym/src/helpers.c	2005-07-14 03:01:59 UTC (rev 201)
@@ -286,6 +286,148 @@
     return props;
 }
 
+int roomlist_level_strip(char *description)
+{
+    int val = 0;
+    int i = 0;
+
+    if (!description) {
+        return val;
+    }
+
+    for (i = 0; i < strlen(description); i++) {
+        if (description[i] == '+') {
+            description[i] = ' ';
+        } else {
+            break;
+        }
+        val++;
+    }
+
+    description = g_strchug(description);
+
+    return val;
+}
+
+GaimRoomlistRoom *find_parent(int level, int old_level,
+                              GaimRoomlistRoom * last_room)
+{
+    GaimRoomlistRoom *parent = NULL;
+    int i = 0;
+
+    if (level == 0) {
+        /* do nothing */
+    } else if (level == old_level) {
+        parent = last_room->parent;
+    } else if (level > old_level) {
+        parent = last_room;
+    } else if (level < old_level) {
+        parent = last_room;
+        for (i = old_level - level; i >= 0; i--) {
+            parent = parent->parent;
+        }
+    }
+    return parent;
+}
+
+void build_roomlist_from_config(GaimRoomlist * roomlist,
+                                GHashTable * confighash)
+{
+    gchar **roominst = NULL;
+    gchar *altname = NULL;
+    gchar *altchan = NULL;
+    int level = 0;
+    int old_level = 0;
+    int i = 0;
+    int j = 0;
+    GaimRoomlistRoom *room = NULL;
+    GaimRoomlistRoom *parent = NULL;
+
+    if (!roomlist || !confighash) {
+        return;
+    }
+
+    int max = gaim_prefs_get_int("/plugins/prpl/gaym/chat_room_instances");
+
+    gchar *roomstr = g_hash_table_lookup(confighash, "roomlist");
+    if (!roomstr) {
+        return;
+    }
+
+    gchar **roomarr = g_strsplit(roomstr, "|", -1);
+
+    /**
+     * We need to skip the first instance, because they start
+     * with a "|", which we've just split by, leaving a blank
+     * at the beginning of the list
+     */
+    for (i = 1; roomarr[i] != NULL; i++) {
+        if (roomarr[i][0] == '#') {
+            /**
+             * This is an actual room string, break it into its
+             * component parts, determine the level and the parent,
+             * and add the room as a cateory
+             */
+            roominst = g_strsplit(roomarr[i], " ", 2);
+            level = roomlist_level_strip(roominst[1]);
+            parent = find_parent(level, old_level, room);
+            room =
+                gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_CATEGORY,
+                                       roominst[1], parent);
+            gaim_roomlist_room_add(roomlist, room);
+            old_level = level;
+
+            /**
+             * Now add the 999=* instance of the room as a child
+             * of the category we just added
+             */
+            level++;
+            parent = find_parent(level, old_level, room);
+            altname = g_strdup_printf("%s:*", roominst[1]);
+            room = gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_ROOM,
+                                          altname, parent);
+            gaim_roomlist_room_add_field(roomlist, room, altname);
+            gaim_roomlist_room_add_field(roomlist, room, roominst[0]);
+            gaim_roomlist_room_add(roomlist, room);
+            g_free(altname);
+
+            /**
+             * And finally add the 999=1, 999=2, ... instances
+             * as siblings of the above room, based on the user's
+             * configuration of how many instances need to be
+             * represented
+             */
+            for (j = 1; j <= max; j++) {
+                altname = g_strdup_printf("%s:%d", roominst[1], j);
+                altchan =
+                    g_strdup_printf("%.*s%d", strlen(roominst[0]) - 1,
+                                    roominst[0], j);
+                room = gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_ROOM,
+                                              altname, parent);
+                gaim_roomlist_room_add_field(roomlist, room, altname);
+                gaim_roomlist_room_add_field(roomlist, room, altchan);
+                gaim_roomlist_room_add(roomlist, room);
+                g_free(altname);
+                g_free(altchan);
+            }
+            g_strfreev(roominst);
+        } else {
+            /**
+             * This is a plain category, determine the level and
+             * the parent and add it.
+             */
+            level = roomlist_level_strip(roomarr[i]);
+            parent = find_parent(level, old_level, room);
+            room =
+                gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_CATEGORY,
+                                       roomarr[i], parent);
+            gaim_roomlist_room_add(roomlist, room);
+        }
+        old_level = level;
+    }
+    g_strfreev(roomarr);
+}
+
 /**
  * vim:tabstop=4:shiftwidth=4:expandtab:
  */

Modified: qrc/trunk/gaym/src/helpers.h
===================================================================
--- qrc/trunk/gaym/src/helpers.h	2005-07-13 20:00:29 UTC (rev 200)
+++ qrc/trunk/gaym/src/helpers.h	2005-07-14 03:01:59 UTC (rev 201)
@@ -26,6 +26,8 @@
 
 #include <glib.h>
 
+#include "roomlist.h"
+
 char *return_string_between(const char *startbit, const char *endbit,
                             const char *source);
 
@@ -93,6 +95,45 @@
  */
 GHashTable *gaym_properties_new(const char *str);
 
+/**
+ * Gay.com provides a java property that contains instructions for
+ * building a hierarchical roomlist.  The level is shown by
+ * appending a number of '+' characters to the beginning of the
+ * room description.  This function strips the '+' characters
+ * and also returns the number of '+' characters found.
+ *
+ * @param description The string to strip and from which to calculate
+ *                    the level.
+ *
+ * @return The level (number of '+' characters found).
+ */
+int roomlist_level_strip(char *description);
+
+/**
+ * Take the level of the room to be added, the level of the last
+ * added room, and the last added room; and return the roomlist
+ * parent of the room to be added.
+ *
+ * @param level The level of the room to be added.
+ * @param old_level The level of the last added room.
+ * @param last_room The last added room.
+ *
+ * @return The parent of the room to be added.
+ */
+GaimRoomlistRoom *find_parent(int level, int old_level,
+                              GaimRoomlistRoom * last_room);
+
+/**
+ * Build the portion of the roomlist that is provided in the
+ * config.txt java properties file within the property "roomlist".
+ *
+ * @param roomlist The GaimRoomlist that these rooms should be loaded
+ *                 into.
+ * @param confighash The GHashTable that config.txt was converted into
+ */
+void build_roomlist_from_config(GaimRoomlist * roomlist,
+                                GHashTable * confighash);
+
 #endif                          /* _GAIM_GAYM_HELPERS_H_ */
 
 /**

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-13 20:00:29 UTC (rev 200)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-14 03:01:59 UTC (rev 201)
@@ -290,6 +290,7 @@
         gaim_roomlist_set_in_progress(gaym->roomlist, TRUE);
         return;
     }
+
     /**
      * The list of member created rooms
      */
@@ -344,251 +345,15 @@
         gaim_roomlist_room_add(gaym->roomlist, room);
         g_free(field_name);
     }
+
     /**
-     * Begin result of member created room list
+     * End result of member created room list
      * This is our trigger to add the static rooms
      */
     if (!strcmp(name, "323")) {
-
-        /**
-         * The following shoul be done just before every "return"
-         * 
-         * gaim_roomlist_set_in_progress(gaym->roomlist, FALSE);
-         * gaim_roomlist_unref(gaym->roomlist);
-         * gaym->roomlist = NULL;
-         * return;
-         * 
-         * Perhaps this can be simplified, but not worrying with
-         * it right now
-         */
-
-        int current_level = 0;
-        char *list_position = NULL;
-        char *field_end = NULL;
-        const char *match = "roomlist=|";
-        size_t field_len = 0;
-        char *name = NULL;
-        char *num = NULL;
-        GaimRoomlistRoom *room = NULL;
-        GaimRoomlistRoom *current_parent = NULL;
-        GaimRoomlistRoom *last_room = NULL;
-        GaimRoomlistRoom *room_title = NULL;
-
-        int level;
-        int room_inst = 0;
-        char *name_inst = NULL;
-        char *num_inst = NULL;
-
-        int max =
-            gaim_prefs_get_int("/plugins/prpl/gaym/chat_room_instances");
-
-        if (!gaym->configtxt) {
-            gaim_debug_fatal("gaym",
-                             "Room list parsing error: No config webpage\n");
-            gaim_roomlist_set_in_progress(gaym->roomlist, FALSE);
-            gaim_roomlist_unref(gaym->roomlist);
-            gaym->roomlist = NULL;
-            return;
-        }
-
-        list_position = strstr(gaym->configtxt, match);
-
-        if (!list_position) {
-            gaim_debug_fatal("gaym",
-                             "Room list parsing error: No roomlist found\n");
-            gaim_roomlist_set_in_progress(gaym->roomlist, FALSE);
-            gaim_roomlist_unref(gaym->roomlist);
-            gaym->roomlist = NULL;
-            return;
-        }
-
-        while ((list_position = strstr(list_position, "\n|"))) {
-            level = 0;
-            list_position += 2;
-
-            /**
-             * This is a room
-             */
-            if (*list_position == '#') {
-                /**
-                 * First, parse the room number
-                 */
-                field_end = strchr(list_position, '=');
-                if (!field_end) {
-                    gaim_debug_error("gaym",
-                                     "Room list parsing error: room number not properly terminated\n");
-                    gaim_roomlist_set_in_progress(gaym->roomlist, FALSE);
-                    gaim_roomlist_unref(gaym->roomlist);
-                    gaym->roomlist = NULL;
-                    return;
-                }
-
-                field_end++;
-                field_len = field_end - list_position;
-                num = g_strndup(list_position, field_len);
-                list_position = field_end + 2;
-
-                /**
-                 * Next, the +'s indicate the level in the tree
-                 */
-                while (*list_position == '+') {
-                    level++;
-                    list_position++;
-                }
-                if (level > current_level) {
-                    current_level = level;
-                    current_parent = last_room;
-                }
-                if (level < current_level) {
-                    while (level < current_level) {
-                        current_level--;
-                        current_parent =
-                            current_parent ? current_parent->parent : NULL;
-                    }
-                }
-                /**
-                 * Finally, the readable room name
-                 */
-                field_end = strstr(list_position, "\\\n");
-                if (!field_end) {
-                    gaim_debug_error("gaym", "Room list parsing error!");
-                    gaim_roomlist_set_in_progress(gaym->roomlist, FALSE);
-                    gaim_roomlist_unref(gaym->roomlist);
-                    gaym->roomlist = NULL;
-                    return;
-                }
-                field_len = field_end - list_position;
-                name = g_strndup(list_position, field_len);
-
-                if (gaym->roomlist_filter) {
-                    current_parent = NULL;
-                }
-                list_position = field_end;
-
-                char *lname = g_strdown(g_strdup(name));
-
-                if (!gaym->roomlist_filter
-                    || strstr(lname, gaym->roomlist_filter) != 0) {
-
-                    /**
-                     * create and add the room folder
-                     */
-                    room =
-                        gaim_roomlist_room_new
-                        (GAIM_ROOMLIST_ROOMTYPE_CATEGORY, name,
-                         current_parent);
-                    gaim_roomlist_room_add(gaym->roomlist, room);
-
-                    room_title = room;
-
-                    name_inst = g_strdup_printf("%s:*", name);
-                    num_inst = g_strdup_printf("%s*", num);
-
-                    room =
-                        gaim_roomlist_room_new
-                        (GAIM_ROOMLIST_ROOMTYPE_ROOM, name_inst,
-                         room_title);
-                    gaim_roomlist_room_add_field(gaym->roomlist, room,
-                                                 name_inst);
-                    gaim_roomlist_room_add_field(gaym->roomlist, room,
-                                                 num_inst);
-                    gaim_roomlist_room_add(gaym->roomlist, room);
-                    g_free(name_inst);
-                    g_free(num_inst);
-                    name_inst = NULL;
-                    num_inst = NULL;
-                    /**
-                     * and now the room instances (1, 2, 3 ...)
-                     */
-                    room_inst = 0;
-                    for (room_inst = 1; room_inst <= max; room_inst++) {
-                        name_inst =
-                            g_strdup_printf("%s:%i", name, room_inst);
-                        num_inst = g_strdup_printf("%s%i", num, room_inst);
-
-                        room =
-                            gaim_roomlist_room_new
-                            (GAIM_ROOMLIST_ROOMTYPE_ROOM, name_inst,
-                             room_title);
-                        gaim_roomlist_room_add_field(gaym->roomlist, room,
-                                                     name_inst);
-                        gaim_roomlist_room_add_field(gaym->roomlist, room,
-                                                     num_inst);
-                        gaim_roomlist_room_add(gaym->roomlist, room);
-
-                        g_free(name_inst);
-                        g_free(num_inst);
-                        name_inst = NULL;
-                        num_inst = NULL;
-                    }
-                    g_free(name);
-                    g_free(num);
-                    if (lname) {
-                        g_free(lname);
-                    }
-                }
-                /**
-                 * This is a category
-                 */
-            } else if (!gaym->roomlist_filter) {
-
-                /**
-                 * This code is duplicated above. Should probably make a
-                 * function.
-                 */
-                while (*list_position == '+') {
-                    level++;
-                    list_position++;
-                }
-
-                if (level > current_level) {
-                    current_level = level;
-                    current_parent = last_room;
-                }
-                if (level < current_level) {
-                    while (level < current_level) {
-                        current_level--;
-                        current_parent =
-                            current_parent ? current_parent->parent : NULL;
-                    }
-                }
-                /**
-                 * end duplicate
-                 */
-                field_end = strstr(list_position, "\\\n");
-                if (!field_end) {
-                    gaim_debug_error("gaym", "Room list parsing error!");
-                    gaim_roomlist_set_in_progress(gaym->roomlist, FALSE);
-                    gaim_roomlist_unref(gaym->roomlist);
-                    gaym->roomlist = NULL;
-                    return;
-                }
-                field_len = field_end - list_position;
-                name = g_strndup(list_position, field_len);
-                room =
-                    gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_CATEGORY,
-                                           name, current_parent);
-                gaim_roomlist_room_add(gaym->roomlist, room);
-
-                g_free(name);
-                list_position = field_end;
-            } else {
-                list_position = strstr(list_position, "\\\n");
-            }
-            if (*(list_position + 2) != '|') {
-                if (gaym->roomlist_filter) {
-                    g_free(gaym->roomlist_filter);
-                }
-                gaim_roomlist_set_in_progress(gaym->roomlist, FALSE);
-                gaim_roomlist_unref(gaym->roomlist);
-                gaym->roomlist = NULL;
-                return;
-            }
-            last_room = room;
-        }
+        gaim_roomlist_set_in_progress(gaym->roomlist, TRUE);
+        build_roomlist_from_config(gaym->roomlist, gaym->confighash);
         gaim_roomlist_set_in_progress(gaym->roomlist, FALSE);
-        gaim_roomlist_unref(gaym->roomlist);
-        gaym->roomlist = NULL;
         return;
     }
 }



From deckrider at berlios.de  Thu Jul 14 06:57:48 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Thu, 14 Jul 2005 06:57:48 +0200
Subject: [Qrc-svn] r202 - qrc/trunk/gaym/src
Message-ID: <200507140457.j6E4vmSW002267@sheep.berlios.de>

Author: deckrider
Date: 2005-07-14 06:57:11 +0200 (Thu, 14 Jul 2005)
New Revision: 202

Modified:
   qrc/trunk/gaym/src/helpers.c
   qrc/trunk/gaym/src/helpers.h
Log:
Performance improvement for gaym_properties_new():  only search/replace
the values after the hashtable has been loaded, not the entire config.txt


Modified: qrc/trunk/gaym/src/helpers.c
===================================================================
--- qrc/trunk/gaym/src/helpers.c	2005-07-14 03:01:59 UTC (rev 201)
+++ qrc/trunk/gaym/src/helpers.c	2005-07-14 04:57:11 UTC (rev 202)
@@ -203,22 +203,11 @@
     return retval;
 }
 
-GHashTable *gaym_properties_new(const gchar * str)
+void replace_dollar_n(gpointer key, gpointer value, gpointer user_data)
 {
-    gchar *tmpstr = NULL;
-    gchar **tmparr = NULL;
-    gchar **proparr = NULL;
     int i = 0;
-
-    GHashTable *props =
-        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
-
+    gchar *tmpstr = (gchar *) value;
     /**
-     * convert ascii-escaped to native
-     */
-    tmpstr = ascii2native(str);
-
-    /**
      * replace $[0-9] with %s, so we can use printf style
      * processing with the provided property values
      */
@@ -231,8 +220,24 @@
             }
         }
     }
+}
 
+GHashTable *gaym_properties_new(const gchar * str)
+{
+    gchar *tmpstr = NULL;
+    gchar **tmparr = NULL;
+    gchar **proparr = NULL;
+    int i = 0;
+
+    GHashTable *props =
+        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
+
     /**
+     * convert ascii-escaped to native
+     */
+    tmpstr = ascii2native(str);
+
+    /**
      * strip out continuation character followed by newline 
      */
     tmparr = g_strsplit(tmpstr, "\\\n", -1);
@@ -283,6 +288,8 @@
 
     g_strfreev(tmparr);
 
+    g_hash_table_foreach(props, replace_dollar_n, NULL);
+
     return props;
 }
 

Modified: qrc/trunk/gaym/src/helpers.h
===================================================================
--- qrc/trunk/gaym/src/helpers.h	2005-07-14 03:01:59 UTC (rev 201)
+++ qrc/trunk/gaym/src/helpers.h	2005-07-14 04:57:11 UTC (rev 202)
@@ -81,6 +81,18 @@
 gboolean gaym_nick_check(const char *nick);
 
 /**
+ * This function is for use by g_hash_table_foreach() from within
+ * gaym_properties_new().  It is to replace $0, $1, ... with %s
+ * so we can use printf style processing with the provided property
+ * values.
+ *
+ * @param key       Not used.
+ * @param value     The string to search/replace.
+ * @param user_data Not used.
+ */
+void replace_dollar_n(gpointer key, gpointer value, gpointer user_data);
+
+/**
  * Build a GHashTable from a string that contains the contents of java
  * properties file.
  *



From deckrider at berlios.de  Thu Jul 14 15:09:05 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Thu, 14 Jul 2005 15:09:05 +0200
Subject: [Qrc-svn] r203 - in qrc/trunk: . gaym/src
Message-ID: <200507141309.j6ED95aG022240@sheep.berlios.de>

Author: deckrider
Date: 2005-07-14 15:08:27 +0200 (Thu, 14 Jul 2005)
New Revision: 203

Modified:
   qrc/trunk/ChangeLog
   qrc/trunk/gaym/src/helpers.c
Log:
Improvement to the Room List layout:  First Available Room (Room Name:*)
is both a Category (which can be expanded) and a Room (which can be
joined), with the individual Room Instances as children.


Modified: qrc/trunk/ChangeLog
===================================================================
--- qrc/trunk/ChangeLog	2005-07-14 04:57:11 UTC (rev 202)
+++ qrc/trunk/ChangeLog	2005-07-14 13:08:27 UTC (rev 203)
@@ -2,7 +2,11 @@
 	New Features:
 	- Bio displays in the buddy list status area
 	- Buddy list tooltip shows sex, age, location, and bio
-	- Your Bio is set to the Away Message when you are Away.
+	- Your Bio is set to the Away Message when you are Away
+	- Improvement to the Room List layout:  First Available Room
+	  (Room Name:*) is both a Category (which can be expanded) and a
+	  Room (which can be joined), with the individual Room Instances
+	  as children
 
 	Bug Fixes:
 	- Better refreshing of stale buddy list photos

Modified: qrc/trunk/gaym/src/helpers.c
===================================================================
--- qrc/trunk/gaym/src/helpers.c	2005-07-14 04:57:11 UTC (rev 202)
+++ qrc/trunk/gaym/src/helpers.c	2005-07-14 13:08:27 UTC (rev 203)
@@ -373,37 +373,38 @@
             /**
              * This is an actual room string, break it into its
              * component parts, determine the level and the parent,
-             * and add the room as a cateory
+             * and add this as both a room and a category
              */
             roominst = g_strsplit(roomarr[i], " ", 2);
             level = roomlist_level_strip(roominst[1]);
             parent = find_parent(level, old_level, room);
-            room =
-                gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_CATEGORY,
-                                       roominst[1], parent);
-            gaim_roomlist_room_add(roomlist, room);
-            old_level = level;
-
-            /**
-             * Now add the 999=* instance of the room as a child
-             * of the category we just added
-             */
-            level++;
-            parent = find_parent(level, old_level, room);
             altname = g_strdup_printf("%s:*", roominst[1]);
-            room = gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_ROOM,
-                                          altname, parent);
+            if (max == 0) {
+                room =
+                    gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_ROOM,
+                                           altname, parent);
+            } else {
+                room =
+                    gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_CATEGORY
+                                           | GAIM_ROOMLIST_ROOMTYPE_ROOM,
+                                           altname, parent);
+            }
             gaim_roomlist_room_add_field(roomlist, room, altname);
             gaim_roomlist_room_add_field(roomlist, room, roominst[0]);
             gaim_roomlist_room_add(roomlist, room);
             g_free(altname);
+            old_level = level;
 
             /**
              * And finally add the 999=1, 999=2, ... instances
-             * as siblings of the above room, based on the user's
+             * as children of the above room, based on the user's
              * configuration of how many instances need to be
              * represented
              */
+            if (max > 0) {
+                level++;
+                parent = find_parent(level, old_level, room);
+            }
             for (j = 1; j <= max; j++) {
                 altname = g_strdup_printf("%s:%d", roominst[1], j);
                 altchan =



From deckrider at berlios.de  Thu Jul 14 17:52:05 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Thu, 14 Jul 2005 17:52:05 +0200
Subject: [Qrc-svn] r204 - in qrc/trunk: . gaym/src
Message-ID: <200507141552.j6EFq5Em024120@sheep.berlios.de>

Author: deckrider
Date: 2005-07-14 17:52:04 +0200 (Thu, 14 Jul 2005)
New Revision: 204

Modified:
   qrc/trunk/ChangeLog
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gayminfo.c
   qrc/trunk/gaym/src/gaympriv.c
   qrc/trunk/gaym/src/helpers.c
   qrc/trunk/gaym/src/msgs.c
Log:
Converted to using gaym->confighash (config.txt) instead of hard coded
information to replace the following hard coded values:

   http://www.gay.com/messenger/lists.txt
   http://my.gay.com/
   http://www.gay.com/messenger/get-profile.txt
   http://gay.com/images/personals/pictures

Small changes to use g_return_if_fail() for some NULL checking.


Modified: qrc/trunk/ChangeLog
===================================================================
--- qrc/trunk/ChangeLog	2005-07-14 13:08:27 UTC (rev 203)
+++ qrc/trunk/ChangeLog	2005-07-14 15:52:04 UTC (rev 204)
@@ -11,6 +11,9 @@
 	Bug Fixes:
 	- Better refreshing of stale buddy list photos
 	- Bio no longer replaces sex, age, and location values
+	- Less hard-coded information, more use of Gay.com's own
+	  configuration file (less susceptible to breakage if Gay.com
+	  changes something)
 
 	Preference Changes:
 	- none

Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-14 13:08:27 UTC (rev 203)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-14 15:52:04 UTC (rev 204)
@@ -536,20 +536,12 @@
     struct gaym_conn *gaym = (struct gaym_conn *) proto_data;
     GaimConnection *gc = gaim_account_get_connection(gaym->account);
 
-    if (!config_text) {
-        gaim_debug(GAIM_DEBUG_ERROR, "gaym",
-                   "Could not retrieve config.txt.\n");
-        return;
-    }
+    g_return_if_fail(config_text != NULL);
 
     gaym->confighash = gaym_properties_new(config_text);
+    g_return_if_fail(gaym->confighash != NULL);
 
-    if (!gaym->confighash) {
-        gaim_debug(GAIM_DEBUG_ERROR, "gaym",
-                   "Could not convert config.txt to hash table.\n");
-    } else {
-        synchronize_deny_list(gc, gaym->confighash);
-    }
+    synchronize_deny_list(gc, gaym->confighash);
 
     return;
 }

Modified: qrc/trunk/gaym/src/gayminfo.c
===================================================================
--- qrc/trunk/gaym/src/gayminfo.c	2005-07-14 13:08:27 UTC (rev 203)
+++ qrc/trunk/gaym/src/gayminfo.c	2005-07-14 15:52:04 UTC (rev 204)
@@ -121,12 +121,15 @@
         if ((ib && gaim_utf8_strcasecmp(thumbnail, ib->thumbnail))
             || (gaym->whois.nick
                 && !gaim_utf8_strcasecmp(gaym->whois.nick, name))) {
+            char *hashurl = NULL;
+            hashurl =
+                g_hash_table_lookup(gaym->confighash,
+                                    "mini-profile-panel.thumbnail-prefix");
+            g_return_if_fail(hashurl != NULL);
             data = g_new0(struct gaym_fetch_thumbnail_data, 1);
             data->gc = gaim_account_get_connection(gaym->account);
             data->who = g_strdup(name);
-            url =
-                g_strdup_printf
-                ("http://gay.com/images/personals/pictures%s", thumbnail);
+            url = g_strdup_printf("%s%s", hashurl, thumbnail);
             gaim_url_fetch(url, FALSE, "Mozilla/4.0", FALSE,
                            gaym_fetch_thumbnail_cb, data);
             g_free(url);

Modified: qrc/trunk/gaym/src/gaympriv.c
===================================================================
--- qrc/trunk/gaym/src/gaympriv.c	2005-07-14 13:08:27 UTC (rev 203)
+++ qrc/trunk/gaym/src/gaympriv.c	2005-07-14 15:52:04 UTC (rev 204)
@@ -197,13 +197,14 @@
     }
 
     struct gaym_conn *gaym = gc->proto_data;
-    const char *server =
-        gaim_account_get_string(gc->account, "server", IRC_DEFAULT_SERVER);
 
+    char *hashurl =
+        g_hash_table_lookup(gaym->confighash, "list-operations-url");
+    g_return_if_fail(hashurl != NULL);
+
     char *url =
-        g_strdup_printf
-        ("http://%s/messenger/lists.txt?name=%s&key=%s&list=ignore&op=%s",
-         server, name, gaym->hash_pw, action);
+        g_strdup_printf("%s?name=%s&key=%s&list=ignore&op=%s", hashurl,
+                        name, gaym->hash_pw, action);
 
     char *user_agent = "Mozilla/4.0";
 
@@ -222,6 +223,8 @@
     gint i = 0;
     gboolean needsync = FALSE;
 
+    g_return_if_fail(confighash != NULL);
+
     srvdeny =
         g_hash_table_lookup(confighash, "connect-list.ignore.members");
     if (!srvdeny) {

Modified: qrc/trunk/gaym/src/helpers.c
===================================================================
--- qrc/trunk/gaym/src/helpers.c	2005-07-14 13:08:27 UTC (rev 203)
+++ qrc/trunk/gaym/src/helpers.c	2005-07-14 15:52:04 UTC (rev 204)
@@ -350,16 +350,13 @@
     GaimRoomlistRoom *room = NULL;
     GaimRoomlistRoom *parent = NULL;
 
-    if (!roomlist || !confighash) {
-        return;
-    }
+    g_return_if_fail(roomlist != NULL);
+    g_return_if_fail(confighash != NULL);
 
     int max = gaim_prefs_get_int("/plugins/prpl/gaym/chat_room_instances");
 
     gchar *roomstr = g_hash_table_lookup(confighash, "roomlist");
-    if (!roomstr) {
-        return;
-    }
+    g_return_if_fail(roomstr != NULL);
 
     gchar **roomarr = g_strsplit(roomstr, "|", -1);
 

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-14 13:08:27 UTC (rev 203)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-14 15:52:04 UTC (rev 204)
@@ -116,27 +116,33 @@
 
     char *info, *t;
 
+    struct gaym_conn *gaym = d->gc->proto_data;
+
+    char *hashurl =
+        g_hash_table_lookup(gaym->confighash, "view-profile-url");
+    g_return_if_fail(hashurl != NULL);
+
     int id = gaim_imgstore_add(info_data, len, NULL);
     if (d->stats && d->bio)
         info =
             g_strdup_printf
-            ("<b>Stats:</b> %s<br><b>Bio:</b> %s<br><img id=%d><br><a href='http://my.gay.com/%s'>Full Profile</a>",
-             d->stats, d->bio, id, d->who);
+            ("<b>Stats:</b> %s<br><b>Bio:</b> %s<br><img id=%d><br><a href='%s%s'>Full Profile</a>",
+             d->stats, d->bio, id, hashurl, d->who);
     else if (d->stats)
         info =
             g_strdup_printf
-            ("<b>Stats:</b> %s<br><img id=%d><br><a href='http://my.gay.com/%s'>Full Profile</a>",
-             d->stats, id, d->who);
+            ("<b>Stats:</b> %s<br><img id=%d><br><a href='%s%s'>Full Profile</a>",
+             d->stats, id, hashurl, d->who);
     else if (d->bio)
         info =
             g_strdup_printf
-            ("<b>Bio:</b> %s<br><img id=%d><br><a href='http://my.gay.com/%s'>Full Profile</a>",
-             d->bio, id, d->who);
+            ("<b>Bio:</b> %s<br><img id=%d><br><a href='%s%s'>Full Profile</a>",
+             d->bio, id, hashurl, d->who);
     else
         info =
             g_strdup_printf
-            ("No Info Found<br><img id=%d><br><a href='http://my.gay.com/%s'>Full Profile</a>",
-             id, d->who);
+            ("No Info Found<br><img id=%d><br><a href='%s%s'>Full Profile</a>",
+             id, hashurl, d->who);
 
     gaim_notify_userinfo(d->gc, d->who,
                          t = g_strdup_printf("Gay.com - %s", d->who),
@@ -163,26 +169,32 @@
     char *info, *t;
     char *match = "pictures.0.url=";
 
+    struct gaym_conn *gaym = d->gc->proto_data;
+
+    char *hashurl =
+        g_hash_table_lookup(gaym->confighash, "view-profile-url");
+    g_return_if_fail(hashurl != NULL);
+
     if (d->stats && d->bio)
         info =
             g_strdup_printf
-            ("<b>Stats:</b> %s<br><b>Bio:</b> %s<br><a href='http://my.gay.com/%s'>Full Profile</a>",
-             d->stats, d->bio, d->who);
+            ("<b>Stats:</b> %s<br><b>Bio:</b> %s<br><a href='%s%s'>Full Profile</a>",
+             d->stats, d->bio, hashurl, d->who);
     else if (d->stats)
         info =
             g_strdup_printf
-            ("<b>Stats:</b> %s<br><a href='http://my.gay.com/%s'>Full Profile</a>",
-             d->stats, d->who);
+            ("<b>Stats:</b> %s<br><a href='%s%s'>Full Profile</a>",
+             d->stats, hashurl, d->who);
     else if (d->bio)
         info =
             g_strdup_printf
-            ("<b>Bio:</b> %s<br><a href='http://my.gay.com/%s'>Full Profile</a>",
-             d->bio, d->who);
+            ("<b>Bio:</b> %s<br><a href='%s%s'>Full Profile</a>",
+             d->bio, hashurl, d->who);
     else
         info =
             g_strdup_printf
-            ("No Info Found<br><a href='http://my.gay.com/%s'>Full Profile</a>",
-             d->who);
+            ("No Info Found<br><a href='%s%s'>Full Profile</a>",
+             hashurl, d->who);
 
     picpath = return_string_between(match, "\n", info_data);
     if (!picpath || strlen(picpath) == 0) {
@@ -222,10 +234,14 @@
         gaym->info_window_needed = 0;
         char *buf;
 
+        char *hashurl =
+            g_hash_table_lookup(gaym->confighash, "view-profile-url");
+        g_return_if_fail(hashurl != NULL);
+
         buf =
             g_strdup_printf
-            ("That user is not logged on. Check <a href='http://my.gay.com/%s'>here</a> to see if that user has a profile.",
-             args[1]);
+            ("That user is not logged on. Check <a href='%s%s'>here</a> to see if that user has a profile.",
+             hashurl, args[1]);
         gaim_notify_userinfo(gaim_account_get_connection(gaym->account),
                              NULL, NULL, "No such user", NULL, buf, NULL,
                              NULL);
@@ -249,16 +265,18 @@
 
     struct gaym_fetch_thumbnail_data *data;
     if (gaym->info_window_needed == TRUE) {
+        char *hashurl = g_hash_table_lookup(gaym->confighash,
+                                            "ohm.profile-url");
+        g_return_if_fail(hashurl != NULL);
         gaym->info_window_needed = 0;
         data = g_new0(struct gaym_fetch_thumbnail_data, 1);
         data->gc = gaim_account_get_connection(gaym->account);
         data->who = g_strdup(gaym->whois.nick);
         data->bio = gaym_bio_strdup(args[5]);
         data->stats = gaym_stats_strdup(args[5]);
-        char *infourl =
-            g_strdup_printf
-            ("http://www.gay.com/messenger/get-profile.txt?pw=%s&name=%s",
-             gaym->hash_pw, gaym->whois.nick);
+
+        char *infourl = g_strdup_printf("%s?pw=%s&name=%s", hashurl,
+                                        gaym->hash_pw, gaym->whois.nick);
         if (infourl) {
             gaim_url_fetch(infourl, FALSE,
                            "Mozilla/4.0 (compatible; MSIE 5.0)", FALSE,



From deckrider at berlios.de  Fri Jul 15 05:12:55 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Fri, 15 Jul 2005 05:12:55 +0200
Subject: [Qrc-svn] r205 - in qrc/trunk: . gaym/src
Message-ID: <200507150312.j6F3Ct7Q012918@sheep.berlios.de>

Author: deckrider
Date: 2005-07-15 05:12:51 +0200 (Fri, 15 Jul 2005)
New Revision: 205

Modified:
   qrc/trunk/ChangeLog
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gaym.h
   qrc/trunk/gaym/src/msgs.c
Log:
This commit fixes a long standing bug, made worse by the conversion to
polling WHOIS to manage the buddy list.  Basically there was one boolean
info_window_needed variable set by the WHOIS request that the WHOIS
result looked at.  If a request was being replied to for some other
reason (for instance, managing the buddy list) and "Get Info" was
clicked, then the current reply might look at the flag and pop up the
window, even though it didn't belong to any "Get Info" request.  There
were also more subtle race conditions that I won't go into here.

So now gaym->info_window_needed is a hashtable (currently using no
value, although this may change with future enhancements).  This
hashtable serves as a kind of queue so that only whois replies matching
a user in the queue will pop up the information display window.


Modified: qrc/trunk/ChangeLog
===================================================================
--- qrc/trunk/ChangeLog	2005-07-14 15:52:04 UTC (rev 204)
+++ qrc/trunk/ChangeLog	2005-07-15 03:12:51 UTC (rev 205)
@@ -14,6 +14,8 @@
 	- Less hard-coded information, more use of Gay.com's own
 	  configuration file (less susceptible to breakage if Gay.com
 	  changes something)
+	- Fixed a bug where certain "Get Info" requests were lost or
+	  returned info for the wrong person
 
 	Preference Changes:
 	- none

Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-14 15:52:04 UTC (rev 204)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-15 03:12:51 UTC (rev 205)
@@ -517,6 +517,8 @@
     gaym_cmd_table_build(gaym);
     gaym->msgs = g_hash_table_new(g_str_hash, g_str_equal);
     gaym_msg_table_build(gaym);
+    gaym->info_window_needed =
+        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
 
     buf = g_strdup_printf(_("Signon: %s"), username);
     gaim_connection_update_progress(gc, buf, 1, 6);
@@ -666,6 +668,7 @@
         gaim_timeout_remove(gaym->timer);
     g_hash_table_destroy(gaym->cmds);
     g_hash_table_destroy(gaym->msgs);
+    g_hash_table_destroy(gaym->info_window_needed);
     if (gaym->motd)
         g_string_free(gaym->motd, TRUE);
     g_free(gaym->server);
@@ -705,7 +708,8 @@
     struct gaym_conn *gaym = gc->proto_data;
     const char *args[1];
     args[0] = who;
-    gaym->info_window_needed = TRUE;
+    char *normalized = g_strdup(gaim_normalize(gc->account, who));
+    g_hash_table_insert(gaym->info_window_needed, normalized, NULL);
     gaym_cmd_whois(gaym, "whois", NULL, args);
 }
 
@@ -1253,8 +1257,6 @@
          * with the WHOIS to get the photo for the IM thumbnail
          */
 
-        gaym->info_window_needed = FALSE;
-
         gaym->whois.nick = g_strdup(conv->name);
         name = gaym_nick_to_gcom_strdup(conv->name);
         buf = gaym_format(gaym, "vn", "WHOIS", name);

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-14 15:52:04 UTC (rev 204)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-15 03:12:51 UTC (rev 205)
@@ -84,7 +84,7 @@
     char *bio;
 
     gboolean blist_updating;
-    gboolean info_window_needed;
+    GHashTable *info_window_needed;
 
     GString *motd;
     GString *names;

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-14 15:52:04 UTC (rev 204)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-15 03:12:51 UTC (rev 205)
@@ -230,14 +230,24 @@
 
     gaym_buddy_status(gaym, args[1], FALSE, NULL);
 
-    if (gaym->info_window_needed == TRUE) {
-        gaym->info_window_needed = 0;
-        char *buf;
+    gboolean info_needed = FALSE;
+    gchar *orig_key = NULL;
+    gchar *value = NULL;
+    char *normalized = g_strdup(gaim_normalize(gaym->account, args[1]));
+    info_needed =
+        g_hash_table_lookup_extended(gaym->info_window_needed, normalized,
+                                     (gpointer *) orig_key,
+                                     (gpointer *) value);
 
+    if (info_needed == TRUE) {
+        info_needed =
+            g_hash_table_remove(gaym->info_window_needed, normalized);
+
         char *hashurl =
             g_hash_table_lookup(gaym->confighash, "view-profile-url");
         g_return_if_fail(hashurl != NULL);
 
+        char *buf;
         buf =
             g_strdup_printf
             ("That user is not logged on. Check <a href='%s%s'>here</a> to see if that user has a profile.",
@@ -246,6 +256,7 @@
                              NULL, NULL, "No such user", NULL, buf, NULL,
                              NULL);
     }
+    g_free(normalized);
 }
 
 void gaym_msg_whois(struct gaym_conn *gaym, const char *name,
@@ -263,12 +274,23 @@
 
     gaym_buddy_status(gaym, args[1], TRUE, args[5]);
 
+    gboolean info_needed = FALSE;
+    gchar *orig_key = NULL;
+    gchar *value = NULL;
+    char *normalized = g_strdup(gaim_normalize(gaym->account, args[1]));
+    info_needed = g_hash_table_lookup_extended(gaym->info_window_needed,
+                                               normalized,
+                                               (gpointer *) orig_key,
+                                               (gpointer *) value);
+
     struct gaym_fetch_thumbnail_data *data;
-    if (gaym->info_window_needed == TRUE) {
+
+    if (info_needed == TRUE) {
+        info_needed =
+            g_hash_table_remove(gaym->info_window_needed, normalized);
         char *hashurl = g_hash_table_lookup(gaym->confighash,
                                             "ohm.profile-url");
         g_return_if_fail(hashurl != NULL);
-        gaym->info_window_needed = 0;
         data = g_new0(struct gaym_fetch_thumbnail_data, 1);
         data->gc = gaim_account_get_connection(gaym->account);
         data->who = g_strdup(gaym->whois.nick);
@@ -284,6 +306,7 @@
             g_free(infourl);
         }
     }
+    g_free(normalized);
 }
 
 void gaym_msg_list(struct gaym_conn *gaym, const char *name,



From deckrider at berlios.de  Fri Jul 15 05:37:50 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Fri, 15 Jul 2005 05:37:50 +0200
Subject: [Qrc-svn] r206 - qrc/trunk/gaym/src
Message-ID: <200507150337.j6F3bowb017245@sheep.berlios.de>

Author: deckrider
Date: 2005-07-15 05:37:49 +0200 (Fri, 15 Jul 2005)
New Revision: 206

Modified:
   qrc/trunk/gaym/src/gaym.c
Log:
Adding back the g_free() for the cleanup of the value in case we use it
in the future to pass the Bio to the fetch mini profile function.


Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-15 03:12:51 UTC (rev 205)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-15 03:37:49 UTC (rev 206)
@@ -518,7 +518,7 @@
     gaym->msgs = g_hash_table_new(g_str_hash, g_str_equal);
     gaym_msg_table_build(gaym);
     gaym->info_window_needed =
-        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
+        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
 
     buf = g_strdup_printf(_("Signon: %s"), username);
     gaim_connection_update_progress(gc, buf, 1, 6);



From deckrider at berlios.de  Fri Jul 15 15:35:24 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Fri, 15 Jul 2005 15:35:24 +0200
Subject: [Qrc-svn] r207 - qrc/trunk/gaym/src
Message-ID: <200507151335.j6FDZOCb021705@sheep.berlios.de>

Author: deckrider
Date: 2005-07-15 15:35:16 +0200 (Fri, 15 Jul 2005)
New Revision: 207

Modified:
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/msgs.c
Log:
Simplification of earlier info_window_needed fix

Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-15 03:37:49 UTC (rev 206)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-15 13:35:16 UTC (rev 207)
@@ -517,8 +517,13 @@
     gaym_cmd_table_build(gaym);
     gaym->msgs = g_hash_table_new(g_str_hash, g_str_equal);
     gaym_msg_table_build(gaym);
+    /**
+     * The last parameter needs to be NULL here, since the same
+     * field is added for both the key and the value (and if we
+     * free it twice, thats bad and causes crashing!).
+     */
     gaym->info_window_needed =
-        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
+        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
 
     buf = g_strdup_printf(_("Signon: %s"), username);
     gaim_connection_update_progress(gc, buf, 1, 6);
@@ -709,7 +714,13 @@
     const char *args[1];
     args[0] = who;
     char *normalized = g_strdup(gaim_normalize(gc->account, who));
-    g_hash_table_insert(gaym->info_window_needed, normalized, NULL);
+    /**
+     * We are adding the same char* to both the key and the value.
+     * If this changes, we need to change the corresponding
+     * g_hash_table_new_full() so that things are properly cleaned
+     * up during the remove/destroy phase.
+     */
+    g_hash_table_insert(gaym->info_window_needed, normalized, normalized);
     gaym_cmd_whois(gaym, "whois", NULL, args);
 }
 

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-15 03:37:49 UTC (rev 206)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-15 13:35:16 UTC (rev 207)
@@ -230,18 +230,10 @@
 
     gaym_buddy_status(gaym, args[1], FALSE, NULL);
 
-    gboolean info_needed = FALSE;
-    gchar *orig_key = NULL;
-    gchar *value = NULL;
     char *normalized = g_strdup(gaim_normalize(gaym->account, args[1]));
-    info_needed =
-        g_hash_table_lookup_extended(gaym->info_window_needed, normalized,
-                                     (gpointer *) orig_key,
-                                     (gpointer *) value);
 
-    if (info_needed == TRUE) {
-        info_needed =
-            g_hash_table_remove(gaym->info_window_needed, normalized);
+    if (g_hash_table_lookup(gaym->info_window_needed, normalized)) {
+        g_hash_table_remove(gaym->info_window_needed, normalized);
 
         char *hashurl =
             g_hash_table_lookup(gaym->confighash, "view-profile-url");
@@ -274,20 +266,12 @@
 
     gaym_buddy_status(gaym, args[1], TRUE, args[5]);
 
-    gboolean info_needed = FALSE;
-    gchar *orig_key = NULL;
-    gchar *value = NULL;
     char *normalized = g_strdup(gaim_normalize(gaym->account, args[1]));
-    info_needed = g_hash_table_lookup_extended(gaym->info_window_needed,
-                                               normalized,
-                                               (gpointer *) orig_key,
-                                               (gpointer *) value);
 
     struct gaym_fetch_thumbnail_data *data;
 
-    if (info_needed == TRUE) {
-        info_needed =
-            g_hash_table_remove(gaym->info_window_needed, normalized);
+    if (g_hash_table_lookup(gaym->info_window_needed, normalized)) {
+        g_hash_table_remove(gaym->info_window_needed, normalized);
         char *hashurl = g_hash_table_lookup(gaym->confighash,
                                             "ohm.profile-url");
         g_return_if_fail(hashurl != NULL);



From deckrider at berlios.de  Fri Jul 15 18:48:46 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Fri, 15 Jul 2005 18:48:46 +0200
Subject: [Qrc-svn] r208 - qrc/trunk/gaym/src
Message-ID: <200507151648.j6FGmkKE004149@sheep.berlios.de>

Author: deckrider
Date: 2005-07-15 18:48:28 +0200 (Fri, 15 Jul 2005)
New Revision: 208

Modified:
   qrc/trunk/gaym/src/gaym.c
Log:
Withing gaym_im_send(), changed awaymsg to automsg, since
GAIM_CONV_IM_AUTO_RESP is used for more than just away messages;
synchronized the text to use "<AUTO-REPLY>" in parallel with the rest of
Gaim; only free automsg if it was used.


Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-15 13:35:16 UTC (rev 207)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-15 16:48:28 UTC (rev 208)
@@ -685,26 +685,26 @@
 {
     struct gaym_conn *gaym = gc->proto_data;
     const char *args[2];
-    const char *awaymsg = NULL;
+    char *automsg = NULL;
     char *stripped_msg = NULL;
-    if (strchr(status_chars, *who) != NULL)
+    if (strchr(status_chars, *who) != NULL) {
         args[0] = who + 1;
-    else
+    } else {
         args[0] = who;
-
-
+    }
     if (flags & GAIM_CONV_IM_AUTO_RESP) {
         stripped_msg = gaim_markup_strip_html(what);
-        awaymsg = g_strdup_printf("<Auto-response> %s", stripped_msg);
+        automsg = g_strdup_printf("<AUTO-REPLY> %s", stripped_msg);
         g_free(stripped_msg);
-        gaim_debug_misc("gaym: sending away message -- %s\n", awaymsg);
-        args[1] = awaymsg;
+        args[1] = automsg;
 
-    } else
+    } else {
         args[1] = what;
-
+    }
     gaym_cmd_privmsg(gaym, "msg", NULL, args);
-    g_free((char *) awaymsg);
+    if (automsg) {
+        g_free(automsg);
+    }
     return 1;
 }
 



From deckrider at berlios.de  Fri Jul 15 19:45:07 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Fri, 15 Jul 2005 19:45:07 +0200
Subject: [Qrc-svn] r209 - qrc/trunk/gaym/src
Message-ID: <200507151745.j6FHj7TQ018969@sheep.berlios.de>

Author: deckrider
Date: 2005-07-15 19:44:57 +0200 (Fri, 15 Jul 2005)
New Revision: 209

Modified:
   qrc/trunk/gaym/src/msgs.c
Log:
Run gcom_nick_to_gaym() on nicks within gaym_msg_whois().


Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-15 16:48:28 UTC (rev 208)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-15 17:44:57 UTC (rev 209)
@@ -264,6 +264,8 @@
         return;
     }
 
+    gcom_nick_to_gaym(args[1]);
+
     gaym_buddy_status(gaym, args[1], TRUE, args[5]);
 
     char *normalized = g_strdup(gaim_normalize(gaym->account, args[1]));



From deckrider at berlios.de  Sat Jul 16 00:46:20 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sat, 16 Jul 2005 00:46:20 +0200
Subject: [Qrc-svn] r210 - qrc/trunk/gaym/src
Message-ID: <200507152246.j6FMkKSx001472@sheep.berlios.de>

Author: deckrider
Date: 2005-07-16 00:45:53 +0200 (Sat, 16 Jul 2005)
New Revision: 210

Modified:
   qrc/trunk/gaym/src/helpers.c
   qrc/trunk/gaym/src/helpers.h
   qrc/trunk/gaym/src/msgs.c
Log:
Re-organize chat room flags, and make a function for deciding what they
should be:

This commit is experimental, subject to comment.  It currently uses the
following order:

   ICON        CODE MEANING
   ----------- ---- -----------------------------------------------
   founder.png   18 profile and g-rated photo 
   op.png        19 profile and x-rated photo
   halfop.png     8 profile only
   voice.png        unknown flag (we must need to do more analysis)
   [none]         0 no profile and no photo

While working on this, I wanted to more or less preserve the current order
but use halfop.png to mean profile but no photo (i.e. "half"), provide
a visual distinction between "profile without photo" and "nothing at all",
and provide a visual cue if there is some code we are not aware of.


Modified: qrc/trunk/gaym/src/helpers.c
===================================================================
--- qrc/trunk/gaym/src/helpers.c	2005-07-15 17:44:57 UTC (rev 209)
+++ qrc/trunk/gaym/src/helpers.c	2005-07-15 22:45:53 UTC (rev 210)
@@ -433,6 +433,28 @@
     g_strfreev(roomarr);
 }
 
+GaimConvChatBuddyFlags chat_pecking_order(const char *extra)
+{
+    GaimConvChatBuddyFlags flags = GAIM_CBFLAGS_NONE;
+    if (extra[0] == '1' && extra[1] == '8') {
+        /* profile and g-rated photo */
+        flags = GAIM_CBFLAGS_FOUNDER;
+    } else if (extra[0] == '1' && extra[1] == '9') {
+        /* profile and x-rated photo */
+        flags = GAIM_CBFLAGS_OP;
+    } else if (extra[0] == '8') {
+        /* profile but no photo */
+        flags = GAIM_CBFLAGS_HALFOP;
+    } else if (extra[0] == '0') {
+        /* no profile and no photo */
+        flags = GAIM_CBFLAGS_NONE;
+    } else {
+        /* unknown */
+        flags = GAIM_CBFLAGS_VOICE;
+    }
+    return flags;
+}
+
 /**
  * vim:tabstop=4:shiftwidth=4:expandtab:
  */

Modified: qrc/trunk/gaym/src/helpers.h
===================================================================
--- qrc/trunk/gaym/src/helpers.h	2005-07-15 17:44:57 UTC (rev 209)
+++ qrc/trunk/gaym/src/helpers.h	2005-07-15 22:45:53 UTC (rev 210)
@@ -146,6 +146,16 @@
 void build_roomlist_from_config(GaimRoomlist * roomlist,
                                 GHashTable * confighash);
 
+/**
+ * Determine the correct GaimConvChatBuddyFlags based on the "extra"
+ * information that is provided during join, whois, etc.
+ *
+ * @param extra The string containing the information about the flags.
+ *
+ * @return The correct GaimConvChatBuddyFlags.
+ */
+GaimConvChatBuddyFlags chat_pecking_order(const char *extra);
+
 #endif                          /* _GAIM_GAYM_HELPERS_H_ */
 
 /**

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-15 17:44:57 UTC (rev 209)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-15 22:45:53 UTC (rev 210)
@@ -717,12 +717,7 @@
         g_free(bio);
     }
 
-    if (strstr(args[1], "thumb.jpg#")) {
-        if (args[1][1] == '9')
-            flags = GAIM_CBFLAGS_HALFOP;
-        else
-            flags = GAIM_CBFLAGS_OP;
-    }
+    flags = chat_pecking_order(args[1]);
 
     gboolean gaym_privacy_permit = gaym_privacy_check(gc, nick);
     gboolean show_join =
@@ -1275,12 +1270,8 @@
         return;
     }
 
-    if (strstr(extra, "thumb.jpg#")) {
-        if (extra[1] == '9')
-            flags = GAIM_CBFLAGS_HALFOP;
-        else
-            flags = GAIM_CBFLAGS_OP;
-    }
+    flags = chat_pecking_order(extra);
+
     gaim_conv_chat_add_user(GAIM_CONV_CHAT(convo), nick, NULL, flags,
                             FALSE);
 



From deckrider at berlios.de  Sat Jul 16 00:53:25 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sat, 16 Jul 2005 00:53:25 +0200
Subject: [Qrc-svn] r211 - qrc/trunk
Message-ID: <200507152253.j6FMrPut010072@sheep.berlios.de>

Author: deckrider
Date: 2005-07-16 00:53:09 +0200 (Sat, 16 Jul 2005)
New Revision: 211

Modified:
   qrc/trunk/README
Log:
Documenting symbols that display next to users in a chat room.


Modified: qrc/trunk/README
===================================================================
--- qrc/trunk/README	2005-07-15 22:45:53 UTC (rev 210)
+++ qrc/trunk/README	2005-07-15 22:53:09 UTC (rev 211)
@@ -1,3 +1,21 @@
+An explanation of the symbols that display next to users in a chat
+room:
+
+   Circular symbol:
+      User has a profile and a G-rated photo.
+
+   Star:
+      User has a profile and an X-rated photo.
+
+   Half Star:
+      User has a profile but no photo.
+
+   Triangle:
+      Unknown:  please report a bug.
+
+   No Symbol:
+      User has no profile and no photo.
+
 An explanation of privacy settings as implemented in GayM:
 
 Gaim Privacy Setting Options (only one of the following may be selected):



From deckrider at berlios.de  Sat Jul 16 14:46:29 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sat, 16 Jul 2005 14:46:29 +0200
Subject: [Qrc-svn] r212 - in qrc/trunk: bot-challenger gaym/src
Message-ID: <200507161246.j6GCkTxF004942@sheep.berlios.de>

Author: deckrider
Date: 2005-07-16 14:46:27 +0200 (Sat, 16 Jul 2005)
New Revision: 212

Modified:
   qrc/trunk/bot-challenger/bot-challenger.c
   qrc/trunk/gaym/src/botfilter.c
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/msgs.c
Log:
g_list_append() and g_slist_append() get slower (in linear fashion)
as the size of the list increases.  Change to g_list_prepend() or
g_slist_prepend() and use g_list_reverse() or g_slist_reverse() if
the order is important (as in the case of gaym_msg_names()).  Else
change the logic to work in reverse.


Modified: qrc/trunk/bot-challenger/bot-challenger.c
===================================================================
--- qrc/trunk/bot-challenger/bot-challenger.c	2005-07-15 22:53:09 UTC (rev 211)
+++ qrc/trunk/bot-challenger/bot-challenger.c	2005-07-16 12:46:27 UTC (rev 212)
@@ -256,7 +256,7 @@
         newpend->username = g_strdup(account->username);
         newpend->sender = g_strdup(*sender);
         newpend->message = g_strdup(*buffer);
-        pending_list = g_slist_append(pending_list, newpend);
+        pending_list = g_slist_prepend(pending_list, newpend);
 
         botmsg =
             g_strdup_printf(_

Modified: qrc/trunk/gaym/src/botfilter.c
===================================================================
--- qrc/trunk/gaym/src/botfilter.c	2005-07-15 22:53:09 UTC (rev 211)
+++ qrc/trunk/gaym/src/botfilter.c	2005-07-16 12:46:27 UTC (rev 212)
@@ -62,7 +62,7 @@
         if (!found) {
             FilteredBot *bot = g_new0(FilteredBot, 1);
             bot->username = g_strdup(nick);
-            filtered_bots = g_slist_append(filtered_bots, bot);
+            filtered_bots = g_slist_prepend(filtered_bots, bot);
         }
     }
 }

Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-15 22:53:09 UTC (rev 211)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-16 12:46:27 UTC (rev 212)
@@ -280,7 +280,7 @@
 
 static GList *gaym_away_states(GaimConnection * gc)
 {
-    return g_list_append(NULL, (gpointer) GAIM_AWAY_CUSTOM);
+    return g_list_prepend(NULL, (gpointer) GAIM_AWAY_CUSTOM);
 }
 
 static void gaym_set_info(GaimConnection * gc, const char *info)
@@ -367,7 +367,7 @@
     GaimPluginAction *act = NULL;
 
     act = gaim_plugin_action_new(_("Change Bio"), gaym_show_set_info);
-    list = g_list_append(list, act);
+    list = g_list_prepend(list, act);
 
     return list;
 }
@@ -412,14 +412,14 @@
 
     int max = gaim_prefs_get_int("/plugins/prpl/gaym/chat_room_instances");
 
-    for (i = 1; i <= max; i++) {
+    for (i = max; i > 0; i--) {
         label = g_strdup_printf(_("Join Room %d"), i);
         instance =
             g_strdup_printf("%.*s%d", strlen(channel) - 1, channel, i);
         act =
             gaim_blist_node_action_new(label, gaym_blist_join_chat_cb,
                                        instance);
-        m = g_list_append(m, act);
+        m = g_list_prepend(m, act);
     }
     return m;
 }
@@ -432,7 +432,7 @@
     pce = g_new0(struct proto_chat_entry, 1);
     pce->label = _("_Room:");
     pce->identifier = "channel";
-    m = g_list_append(m, pce);
+    m = g_list_prepend(m, pce);
 
     return m;
 }
@@ -1130,14 +1130,14 @@
 
     gaym->roomlist = gaim_roomlist_new(gaim_connection_get_account(gc));
 
+    f = gaim_roomlist_field_new(GAIM_ROOMLIST_FIELD_STRING, _("Channel"),
+                                "channel", FALSE);
+    fields = g_list_prepend(fields, f);
+
     f = gaim_roomlist_field_new(GAIM_ROOMLIST_FIELD_STRING, "",
                                 "description", TRUE);
-    fields = g_list_append(fields, f);
+    fields = g_list_prepend(fields, f);
 
-    f = gaim_roomlist_field_new(GAIM_ROOMLIST_FIELD_STRING, _("Channel"),
-                                "channel", FALSE);
-    fields = g_list_append(fields, f);
-
     gaim_roomlist_set_fields(gaym->roomlist, fields);
 
     /**
@@ -1390,20 +1390,20 @@
 
     GaimAccountOption *option;
 
-    option =
-        gaim_account_option_string_new(_("Server"), "server",
-                                       IRC_DEFAULT_SERVER);
+    option = gaim_account_option_string_new(_("Bio Line"), "bioline", "");
     prpl_info.protocol_options =
-        g_list_append(prpl_info.protocol_options, option);
+        g_list_prepend(prpl_info.protocol_options, option);
 
     option =
         gaim_account_option_int_new(_("Port"), "port", IRC_DEFAULT_PORT);
     prpl_info.protocol_options =
-        g_list_append(prpl_info.protocol_options, option);
+        g_list_prepend(prpl_info.protocol_options, option);
 
-    option = gaim_account_option_string_new(_("Bio Line"), "bioline", "");
+    option =
+        gaim_account_option_string_new(_("Server"), "server",
+                                       IRC_DEFAULT_SERVER);
     prpl_info.protocol_options =
-        g_list_append(prpl_info.protocol_options, option);
+        g_list_prepend(prpl_info.protocol_options, option);
 
     /**
      * We have to pull thumbnails, since they aren't pushed like with

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-15 22:53:09 UTC (rev 211)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-16 12:46:27 UTC (rev 212)
@@ -461,12 +461,14 @@
                     cur++;
                 }
                 tmp = g_strndup(cur, end - cur);
-                users = g_list_append(users, tmp);
-                flags = g_list_append(flags, GINT_TO_POINTER(f));
+                users = g_list_prepend(users, tmp);
+                flags = g_list_prepend(flags, GINT_TO_POINTER(f));
                 cur = end;
                 if (*cur)
                     cur++;
             }
+            users = g_list_reverse(users);
+            flags = g_list_reverse(flags);
 
             if (users != NULL) {
                 GList *l;



From deckrider at berlios.de  Sun Jul 17 05:11:18 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sun, 17 Jul 2005 05:11:18 +0200
Subject: [Qrc-svn] r213 - in qrc/trunk: . gaym/src
Message-ID: <200507170311.j6H3BItE013176@sheep.berlios.de>

Author: deckrider
Date: 2005-07-17 05:10:48 +0200 (Sun, 17 Jul 2005)
New Revision: 213

Modified:
   qrc/trunk/ChangeLog
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/helpers.c
   qrc/trunk/gaym/src/msgs.c
Log:
Room List performance fixes.  Added roomlist_expand_category() to deal
with the individual room instances.


Modified: qrc/trunk/ChangeLog
===================================================================
--- qrc/trunk/ChangeLog	2005-07-16 12:46:27 UTC (rev 212)
+++ qrc/trunk/ChangeLog	2005-07-17 03:10:48 UTC (rev 213)
@@ -10,6 +10,7 @@
 
 	Bug Fixes:
 	- Better refreshing of stale buddy list photos
+	- Room List performance fixes
 	- Bio no longer replaces sex, age, and location values
 	- Less hard-coded information, more use of Gay.com's own
 	  configuration file (less susceptible to breakage if Gay.com

Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-16 12:46:27 UTC (rev 212)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-17 03:10:48 UTC (rev 213)
@@ -1153,7 +1153,7 @@
     return gaym->roomlist;
 }
 
-static void gaym_roomlist_cancel(GaimRoomlist * list)
+static void gaym_roomlist_cancel(struct _GaimRoomlist *list)
 {
     GaimConnection *gc = gaim_account_get_connection(list->account);
     struct gaym_conn *gaym;
@@ -1172,6 +1172,43 @@
     }
 }
 
+void gaym_roomlist_expand_category(struct _GaimRoomlist *list,
+                                   struct _GaimRoomlistRoom *category)
+{
+    GaimRoomlistRoom *room = NULL;
+    gchar *altname = NULL;
+    gchar *altchan = NULL;
+    int i = 0;
+
+    if (category->type & GAIM_ROOMLIST_ROOMTYPE_ROOM
+        && !category->expanded_once) {
+
+        category->expanded_once = TRUE;
+
+        int max =
+            gaim_prefs_get_int("/plugins/prpl/gaym/chat_room_instances");
+
+        gchar *name = category->fields->data;
+        gchar *chan = category->fields->next->data;
+
+        for (i = 1; i <= max; i++) {
+            altname = g_strdup_printf("%.*s%d", strlen(name) - 1, name, i);
+            altchan = g_strdup_printf("%.*s%d", strlen(chan) - 1, chan, i);
+
+            room =
+                gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_ROOM,
+                                       altname, category);
+
+            gaim_roomlist_room_add_field(list, room, altname);
+            gaim_roomlist_room_add_field(list, room, altchan);
+            gaim_roomlist_room_add(list, room);
+            g_free(altname);
+            g_free(altchan);
+        }
+    }
+    gaim_roomlist_set_in_progress(list, FALSE);
+}
+
 static GaimPluginProtocolInfo prpl_info = {
     0,                          /* options */
     NULL,                       /* user_splits */
@@ -1228,7 +1265,7 @@
     gaym_find_blist_chat,       /* find_blist_chat */
     gaym_roomlist_get_list,     /* roomlist_get_list */
     gaym_roomlist_cancel,       /* roomlist_cancel */
-    NULL,                       /* roomlist_expand_category */
+    gaym_roomlist_expand_category,      /* roomlist_expand_category */
     NULL,                       /* can_receive_file */
     gaym_dccsend_send_file      /* send_file */
 };

Modified: qrc/trunk/gaym/src/helpers.c
===================================================================
--- qrc/trunk/gaym/src/helpers.c	2005-07-16 12:46:27 UTC (rev 212)
+++ qrc/trunk/gaym/src/helpers.c	2005-07-17 03:10:48 UTC (rev 213)
@@ -342,11 +342,9 @@
 {
     gchar **roominst = NULL;
     gchar *altname = NULL;
-    gchar *altchan = NULL;
     int level = 0;
     int old_level = 0;
     int i = 0;
-    int j = 0;
     GaimRoomlistRoom *room = NULL;
     GaimRoomlistRoom *parent = NULL;
 
@@ -391,30 +389,6 @@
             gaim_roomlist_room_add(roomlist, room);
             g_free(altname);
             old_level = level;
-
-            /**
-             * And finally add the 999=1, 999=2, ... instances
-             * as children of the above room, based on the user's
-             * configuration of how many instances need to be
-             * represented
-             */
-            if (max > 0) {
-                level++;
-                parent = find_parent(level, old_level, room);
-            }
-            for (j = 1; j <= max; j++) {
-                altname = g_strdup_printf("%s:%d", roominst[1], j);
-                altchan =
-                    g_strdup_printf("%.*s%d", strlen(roominst[0]) - 1,
-                                    roominst[0], j);
-                room = gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_ROOM,
-                                              altname, parent);
-                gaim_roomlist_room_add_field(roomlist, room, altname);
-                gaim_roomlist_room_add_field(roomlist, room, altchan);
-                gaim_roomlist_room_add(roomlist, room);
-                g_free(altname);
-                g_free(altchan);
-            }
             g_strfreev(roominst);
         } else {
             /**
@@ -431,6 +405,8 @@
         old_level = level;
     }
     g_strfreev(roomarr);
+    gaim_roomlist_set_in_progress(roomlist, FALSE);
+
 }
 
 GaimConvChatBuddyFlags chat_pecking_order(const char *extra)

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-16 12:46:27 UTC (rev 212)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-17 03:10:48 UTC (rev 213)
@@ -378,9 +378,7 @@
      * This is our trigger to add the static rooms
      */
     if (!strcmp(name, "323")) {
-        gaim_roomlist_set_in_progress(gaym->roomlist, TRUE);
         build_roomlist_from_config(gaym->roomlist, gaym->confighash);
-        gaim_roomlist_set_in_progress(gaym->roomlist, FALSE);
         return;
     }
 }



From deckrider at berlios.de  Sun Jul 17 14:11:19 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sun, 17 Jul 2005 14:11:19 +0200
Subject: [Qrc-svn] r214 - in qrc/trunk: . gaym/src
Message-ID: <200507171211.j6HCBJRM022495@sheep.berlios.de>

Author: deckrider
Date: 2005-07-17 14:11:18 +0200 (Sun, 17 Jul 2005)
New Revision: 214

Modified:
   qrc/trunk/ChangeLog
   qrc/trunk/gaym/src/msgs.c
Log:
Use gaim_imgstore_unref() after finished using the ID returned from
gaim_imgstore_add().


Modified: qrc/trunk/ChangeLog
===================================================================
--- qrc/trunk/ChangeLog	2005-07-17 03:10:48 UTC (rev 213)
+++ qrc/trunk/ChangeLog	2005-07-17 12:11:18 UTC (rev 214)
@@ -17,6 +17,7 @@
 	  changes something)
 	- Fixed a bug where certain "Get Info" requests were lost or
 	  returned info for the wrong person
+	- Addressed several memory leaks
 
 	Preference Changes:
 	- none

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-17 03:10:48 UTC (rev 213)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-17 12:11:18 UTC (rev 214)
@@ -158,6 +158,7 @@
             g_free(d->stats);
         g_free(d);
     }
+    gaim_imgstore_unref(id);
 }
 
 static void gaym_fetch_info_cb(void *user_data, const char *info_data,



From deckrider at berlios.de  Sun Jul 17 16:21:44 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sun, 17 Jul 2005 16:21:44 +0200
Subject: [Qrc-svn] r215 - qrc/trunk/gaym/src
Message-ID: <200507171421.j6HELi6P028553@sheep.berlios.de>

Author: deckrider
Date: 2005-07-17 16:21:43 +0200 (Sun, 17 Jul 2005)
New Revision: 215

Modified:
   qrc/trunk/gaym/src/cmds.c
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gaym.h
   qrc/trunk/gaym/src/gayminfo.c
   qrc/trunk/gaym/src/msgs.c
Log:
Fixed a problem introduced with the new WHOIS method of maintaining the
buddy list state that caused looping of the thumbnail fetch of the last
buddy that the user did "Get Info" on.

Added the same mechanism used for "info_window_needed" to replace
gaym->whois for instances when a thumbnail is needed within an IM window
for a user that isn't already on the buddy list.  The new GHashTable is
gaym->im_thumbnail_needed.


Modified: qrc/trunk/gaym/src/cmds.c
===================================================================
--- qrc/trunk/gaym/src/cmds.c	2005-07-17 12:11:18 UTC (rev 214)
+++ qrc/trunk/gaym/src/cmds.c	2005-07-17 14:21:43 UTC (rev 215)
@@ -566,8 +566,6 @@
     if (!args || !args[0])
         return 0;
 
-    gaym->whois.nick = g_strdup(args[0]);
-
     converted_nick = gaym_nick_to_gcom_strdup(args[0]);
     buf = gaym_format(gaym, "vn", "WHOIS", converted_nick);
     gaym_send(gaym, buf);

Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-17 12:11:18 UTC (rev 214)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-17 14:21:43 UTC (rev 215)
@@ -525,6 +525,14 @@
     gaym->info_window_needed =
         g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
 
+    /**
+     * This is similar to gaym->info_window_needed, except this is
+     * for thumbails inside the IM conversation window if the
+     * person is not already on the buddy list
+     */
+    gaym->im_thumbnail_needed =
+        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
+
     buf = g_strdup_printf(_("Signon: %s"), username);
     gaim_connection_update_progress(gc, buf, 1, 6);
     g_free(buf);
@@ -674,6 +682,7 @@
     g_hash_table_destroy(gaym->cmds);
     g_hash_table_destroy(gaym->msgs);
     g_hash_table_destroy(gaym->info_window_needed);
+    g_hash_table_destroy(gaym->im_thumbnail_needed);
     if (gaym->motd)
         g_string_free(gaym->motd, TRUE);
     g_free(gaym->server);
@@ -713,6 +722,7 @@
     struct gaym_conn *gaym = gc->proto_data;
     const char *args[1];
     args[0] = who;
+
     char *normalized = g_strdup(gaim_normalize(gc->account, who));
     /**
      * We are adding the same char* to both the key and the value.
@@ -1305,7 +1315,11 @@
          * with the WHOIS to get the photo for the IM thumbnail
          */
 
-        gaym->whois.nick = g_strdup(conv->name);
+        char *normalized =
+            g_strdup(gaim_normalize(gc->account, conv->name));
+        g_hash_table_insert(gaym->im_thumbnail_needed, normalized,
+                            normalized);
+
         name = gaym_nick_to_gcom_strdup(conv->name);
         buf = gaym_format(gaym, "vn", "WHOIS", name);
         gaim_debug_misc("gaym", "Conversation triggered command: %s\n",

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-17 12:11:18 UTC (rev 214)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-17 14:21:43 UTC (rev 215)
@@ -85,26 +85,13 @@
 
     gboolean blist_updating;
     GHashTable *info_window_needed;
+    GHashTable *im_thumbnail_needed;
 
     GString *motd;
     GString *names;
     char *nameconv;
     char *traceconv;
 
-    struct _whois {
-        char *nick;
-        char *away;
-        char *userhost;
-        char *name;
-        char *server;
-        char *serverinfo;
-        char *channels;
-        int gaymop;
-        int identified;
-        int idle;
-        time_t signon;
-    } whois;
-
     GaimRoomlist *roomlist;
 
     GList **node_menu;

Modified: qrc/trunk/gaym/src/gayminfo.c
===================================================================
--- qrc/trunk/gaym/src/gayminfo.c	2005-07-17 12:11:18 UTC (rev 214)
+++ qrc/trunk/gaym/src/gayminfo.c	2005-07-17 14:21:43 UTC (rev 215)
@@ -117,10 +117,14 @@
 
     struct gaym_buddy *ib = g_hash_table_lookup(gaym->buddies, name);
 
+    char *normalized = g_strdup(gaim_normalize(gaym->account, name));
+    char *im_thumbnail =
+        g_hash_table_lookup(gaym->im_thumbnail_needed, normalized);
+
     if (thumbnail) {
         if ((ib && gaim_utf8_strcasecmp(thumbnail, ib->thumbnail))
-            || (gaym->whois.nick
-                && !gaim_utf8_strcasecmp(gaym->whois.nick, name))) {
+            || im_thumbnail) {
+
             char *hashurl = NULL;
             hashurl =
                 g_hash_table_lookup(gaym->confighash,
@@ -136,6 +140,11 @@
         }
     }
 
+    if (im_thumbnail) {
+        g_hash_table_remove(gaym->im_thumbnail_needed, normalized);
+    }
+    g_free(normalized);
+
     if (ib) {
         g_free(ib->bio);
         ib->bio = NULL;

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-17 12:11:18 UTC (rev 214)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-17 14:21:43 UTC (rev 215)
@@ -280,12 +280,12 @@
         g_return_if_fail(hashurl != NULL);
         data = g_new0(struct gaym_fetch_thumbnail_data, 1);
         data->gc = gaim_account_get_connection(gaym->account);
-        data->who = g_strdup(gaym->whois.nick);
+        data->who = g_strdup(args[1]);
         data->bio = gaym_bio_strdup(args[5]);
         data->stats = gaym_stats_strdup(args[5]);
 
         char *infourl = g_strdup_printf("%s?pw=%s&name=%s", hashurl,
-                                        gaym->hash_pw, gaym->whois.nick);
+                                        gaym->hash_pw, args[1]);
         if (infourl) {
             gaim_url_fetch(infourl, FALSE,
                            "Mozilla/4.0 (compatible; MSIE 5.0)", FALSE,
@@ -561,12 +561,6 @@
             return;
         gaim_notify_error(gc, NULL, _("No such nick or channel"), args[1]);
     }
-
-    if (gaym->whois.nick
-        && !gaim_utf8_strcasecmp(gaym->whois.nick, args[1])) {
-        g_free(gaym->whois.nick);
-        gaym->whois.nick = NULL;
-    }
 }
 
 void gaym_msg_nosend(struct gaym_conn *gaym, const char *name,



From jblebrun at berlios.de  Wed Jul 20 06:39:37 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Wed, 20 Jul 2005 06:39:37 +0200
Subject: [Qrc-svn] r217 - qrc/branches
Message-ID: <200507200439.j6K4dbE4003131@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-20 06:39:04 +0200 (Wed, 20 Jul 2005)
New Revision: 217

Added:
   qrc/branches/thumbnail_in_chat/
Removed:
   qrc/branches/thumnail_in_chat/
Log:
Oops, I made a typo. 


Copied: qrc/branches/thumbnail_in_chat (from rev 216, qrc/branches/thumnail_in_chat)



From jblebrun at berlios.de  Thu Jul 21 04:10:41 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Thu, 21 Jul 2005 04:10:41 +0200
Subject: [Qrc-svn] r218 - qrc/trunk/gaym/src
Message-ID: <200507210210.j6L2Afax018075@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-21 04:10:29 +0200 (Thu, 21 Jul 2005)
New Revision: 218

Modified:
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gaym.h
   qrc/trunk/gaym/src/weblogin.c
Log:
Modified the login process to fix some memory leaks.

In particular, the GaimUrlSession struct contains a reference to struct gaym_conn, instead of vice versa. This allows sessions to be easily cleaned on login aborts. Sessions are also deleted at the end of login process. 

file changes:

gaym.h:
*add a gaym member to GaimUrlSession, remove GaimUrlSession member from gaym_conn

weblogin.c:
*pass GaimUrlSession between steps, instead of gaym_conn
*make sure to destroy sessions if login is cancelled.
*always destroy session after step 5 finishes.

gaym.c:
*added some frees to gaym_close to free up additional memory that may be allocated in gaym_conn




Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-20 04:39:04 UTC (rev 217)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-21 02:10:29 UTC (rev 218)
@@ -662,11 +662,11 @@
             gaim_input_add(gaym->fd, GAIM_INPUT_READ, gaym_input_cb, gc);
     }
 }
-
 static void gaym_close(GaimConnection * gc)
 {
     struct gaym_conn *gaym = gc->proto_data;
 
+    gaim_debug_misc("gaym","gaym close function has been called\n");
     if (gaym == NULL)
         return;
 
@@ -676,15 +676,50 @@
         gaim_input_remove(gc->inpa);
 
     g_free(gaym->inbuf);
+    gaim_debug_misc("gaym","closing fd %i\n",gaym->fd);
     close(gaym->fd);
+
     if (gaym->timer)
         gaim_timeout_remove(gaym->timer);
+
+    if (gaym->thumbnail)
+	g_free(gaym->thumbnail);
+
+    if (gaym->hash_pw)
+	g_free(gaym->hash_pw);
+
+    if (gaym->server_bioline)
+	g_free(gaym->server_bioline);
+
+    if (gaym->server_stats)
+	g_free(gaym->server_stats);
+
+    if (gaym->roomlist_filter)
+	g_free(gaym->roomlist_filter);
+
+    if (gaym->bio)
+	g_free(gaym->bio);
+    
     g_hash_table_destroy(gaym->cmds);
     g_hash_table_destroy(gaym->msgs);
     g_hash_table_destroy(gaym->info_window_needed);
     g_hash_table_destroy(gaym->im_thumbnail_needed);
     if (gaym->motd)
         g_string_free(gaym->motd, TRUE);
+
+    if (gaym->names)
+	g_string_free(gaym->names, TRUE);
+    
+    if (gaym->nameconv)
+	g_free(gaym->nameconv);
+    if (gaym->subroom)
+	g_free(gaym->subroom);
+
+    g_hash_table_destroy(gaym->confighash);
+
+    if (gaym->hammer_cancel_dialog)
+	gaim_request_close(GAIM_REQUEST_ACTION, gaym->hammer_cancel_dialog);
+
     g_free(gaym->server);
     g_free(gaym);
 }

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-20 04:39:04 UTC (rev 217)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-21 02:10:29 UTC (rev 218)
@@ -53,16 +53,7 @@
 enum { IRC_USEROPT_SERVER, IRC_USEROPT_PORT, IRC_USEROPT_CHARSET };
 enum gaym_state { IRC_STATE_NEW, IRC_STATE_ESTABLISHED };
 
-typedef struct {
 
-    char *cookies;
-    void (*session_cb) (GaimAccount *);
-    GaimAccount *account;
-    char *username;
-    char *password;
-    gboolean hasFormData;
-
-} GaimUrlSession;
 struct gaym_conn {
     GaimAccount *account;
     GHashTable *msgs;
@@ -98,7 +89,6 @@
     gboolean quitting;
     char *subroom;
     GHashTable *confighash;
-    GaimUrlSession *session;
 
     char *persist_room;
     gboolean cancelling_persist;
@@ -106,6 +96,20 @@
 
 };
 
+typedef struct {
+
+    char *cookies;
+    void (*session_cb) (GaimAccount *);
+    GaimAccount *account;
+    char *username;
+    char *password;
+    struct gaym_conn *gaym;
+    gboolean hasFormData;
+    
+
+} GaimUrlSession;
+
+
 struct gaym_buddy {
     char *name;                 /* gaym formatted nick */
     gboolean done;              /* has been checked */

Modified: qrc/trunk/gaym/src/weblogin.c
===================================================================
--- qrc/trunk/gaym/src/weblogin.c	2005-07-20 04:39:04 UTC (rev 217)
+++ qrc/trunk/gaym/src/weblogin.c	2005-07-21 02:10:29 UTC (rev 218)
@@ -62,6 +62,16 @@
 
 } GaimFetchUrlData;
 
+static void gaym_session_destroy(GaimUrlSession* session) {
+    if (session->cookies)
+	g_free(session->cookies);
+    if (session->username)
+	g_free(session->username);
+    if (session->password)
+	g_free(session->password);
+    gaim_debug_misc("gaym","freeing session: %x\n",session);
+    g_free(session);
+}
 /* gaim_url_decode doesn't change pluses to spaces - edit in place */
 static const char *gaym_url_decode(const char *string)
 {
@@ -79,6 +89,7 @@
 
 static void destroy_fetch_url_data(GaimFetchUrlData * gfud)
 {
+    gaim_debug_misc("gaym","destroy_fetch_url_data called\n");
     if (gfud->webdata != NULL)
         g_free(gfud->webdata);
     if (gfud->url != NULL)
@@ -93,7 +104,7 @@
         g_free(gfud->website.user);
     if (gfud->website.passwd != NULL)
         g_free(gfud->website.passwd);
-
+   
     g_free(gfud);
 }
 
@@ -222,6 +233,9 @@
                     g_strdup_printf("%s; %.*s", session->cookies,
                                     cookie_size, next_token);
             else
+
+	    //FIXME: I think there is a function for resizing the memory
+	    //which is more efficient then a allocation and freeing.
                 new_cookie =
                     g_strdup_printf("%.*s", cookie_size, next_token);
             if (new_cookie) {
@@ -472,12 +486,13 @@
 }
 
 static void
-gaym_weblogin_step5(gpointer session, const char *text, size_t len)
+gaym_weblogin_step5(gpointer data, const char *text, size_t len)
 {
 
-    struct gaym_conn *gaym = (struct gaym_conn *) session;
+    GaimUrlSession *session = (GaimUrlSession *) data;
+    struct gaym_conn* gaym = session->gaym;
     // Get hash from text
-    if (gaym->session && GAIM_CONNECTION_IS_VALID(gaym->account->gc)) {
+    if (session && GAIM_CONNECTION_IS_VALID(session->account->gc)) {
         // char *pw_hash;
         char *bio;
         char *thumbnail;
@@ -504,7 +519,7 @@
             (temp && temp2 && temp != temp2
              && (gaym->hash_pw =
                  g_strndup(temp, (temp2 - temp) * sizeof(char))))) {
-            gaim_connection_error((gaym->account->gc),
+            gaim_connection_error((session->account->gc),
                                   _
                                   ("Problem parsing password from web. Report a bug."));
             return;
@@ -551,13 +566,15 @@
             // gaym_conn*)((GaimUrlSession*)session)->account),
             // _("Problem parsing password from web. Report a bug."));
         }
-        gaym->session->session_cb(gaym->account);
+        session->session_cb(gaym->account);
 
     } else {
         gaim_debug_misc("gaym", "Connection was cancelled before step5\n");
-        gaim_debug_misc("gaym", "gaym->sessoin: %x\n", gaym->session);
+        gaim_debug_misc("gaym", "gaym->session: %x\n", session);
     }
 
+    //We don't need the session info anymore.
+    gaym_session_destroy(session);
 
 }
 
@@ -565,10 +582,10 @@
 gaym_weblogin_step4(gpointer data, const char *text, size_t len)
 {
 
-    struct gaym_conn *gaym = (struct gaym_conn *) data;
-    gaim_debug_misc("gaym", "Step 4: gaym->sessoin: %x\n", gaym->session);
-    if (gaym->session
-        && GAIM_CONNECTION_IS_VALID(gaym->session->account->gc)) {
+    GaimUrlSession *session = (GaimUrlSession *) data;
+    gaim_debug_misc("gaym", "Step 4: session: %x\n", session);
+    if (session
+        && GAIM_CONNECTION_IS_VALID(session->account->gc)) {
         // The fourth step is to parse a rand=# value out of the message
         // text from
         // The previous step.
@@ -576,20 +593,22 @@
         char url[512];
         int nonce;
         char *buf = g_strdup_printf(_("Signon: %s"),
-                                    (gaym->session->account->username));
-        gaim_connection_update_progress(gaym->session->account->gc, buf, 5,
+                                    (session->account->username));
+        gaim_connection_update_progress(session->account->gc, buf, 5,
                                         6);
         sscanf(text, "?rand=%d", &nonce);
         snprintf(url, 512,
                  "http://www.gay.com/messenger/applet.html?rand=%d",
                  nonce);
 
-        gaym->session->hasFormData = TRUE;
+        session->hasFormData = TRUE;
         gaim_session_fetch(url, FALSE, NULL, FALSE, gaym_weblogin_step5,
-                           gaym, gaym->session);
+                           session, session);
     } else {
         gaim_debug_misc("gaym", "Connection was cancelled before step4\n");
-        gaim_debug_misc("gaym", "gaym->sessoin: %x\n", gaym->session);
+        gaim_debug_misc("gaym", "session: %x\n", session);
+	gaym_session_destroy(session);	
+	
         // g_free(gaym->session);
     }
 }
@@ -602,14 +621,12 @@
 
 
 
-    struct gaym_conn *gaym = (struct gaym_conn *) data;
+    GaimUrlSession *session = (GaimUrlSession *) data;
 
-    gaim_debug_misc("gaym", "Step 3: gaym->sessoin: %x\n", gaym->session);
-    if (gaym && gaym->session
-        && GAIM_CONNECTION_IS_VALID(gaym->session->account->gc)) {
-        if (!strstr(gaym->session->cookies, "MEMBERX")) {
-            g_free(gaym->session);
-            gaim_connection_error((gaym->account->gc),
+    gaim_debug_misc("gaym", "Step 3: session: %x\n", session);
+    if (session && GAIM_CONNECTION_IS_VALID(session->account->gc)) {
+        if (!strstr(session->cookies, "MEMBERX")) {
+            gaim_connection_error((session->account->gc),
                                   _
                                   ("Problem during login. Are you sure your password is correct?"));
             return;
@@ -621,16 +638,17 @@
         // values.
         char *url = "http://www.gay.com/messenger/frameset.html";
         char *buf = g_strdup_printf(_("Signon: %s"),
-                                    (gaym->session->account->username));
-        gaim_connection_update_progress(gaym->session->account->gc, buf, 4,
+                                    (session->account->username));
+        gaim_connection_update_progress(session->account->gc, buf, 4,
                                         6);
-        gaym->session->hasFormData = FALSE;
+        session->hasFormData = FALSE;
         gaim_session_fetch(url, FALSE, NULL, FALSE, gaym_weblogin_step4,
-                           gaym, gaym->session);
+                           session, session);
     } else {
 
         gaim_debug_misc("gaym", "Connection was cancelled before step3\n");
-        gaim_debug_misc("gaym", "gaym->sessoin: %x\n", gaym->session);
+        gaim_debug_misc("gaym", "session: %x\n", session);
+	gaym_session_destroy(session);	
         // g_free(gaym->session);
 
     }
@@ -639,29 +657,31 @@
 gaym_weblogin_step2(gpointer data, const char *text, size_t len)
 {
 
-    struct gaym_conn *gaym = (struct gaym_conn *) data;
-    gaim_debug_misc("gaym", "Step 2: gaym->sessoin: %x\n", gaym->session);
-    if (gaym->session
-        && GAIM_CONNECTION_IS_VALID(gaym->session->account->gc)) {
+    
+    GaimUrlSession *session = (GaimUrlSession *) data;
+    if (session
+        && GAIM_CONNECTION_IS_VALID(session->account->gc)) {
+	gaim_debug_misc("gaym","Step 2: connection is valid.\n");
         // The second step is to do the actual login.
         // We connect to misc/dologin.html, using cookies set from step 1
         // And add a few more cookie values.
         char url[1024];
         char *buf = g_strdup_printf(_("Signon: %s"),
-                                    gaym->session->account->username);
-        gaim_connection_update_progress(gaym->session->account->gc, buf, 3,
+                                    session->account->username);
+        gaim_connection_update_progress(session->account->gc, buf, 3,
                                         6);
 
         snprintf(url, 1024,
                  "http://www.gay.com/misc/dologin.html?__login_haveForm=1&__login_save=1&__login_member=%s&redir=%%2Findex.html&__login_basepage=%%2Fmisc%%2Fdologin.html&__login_password=%s",
-                 gaym->session->username, gaym->session->password);
+                 session->username, session->password);
 
-        gaym->session->hasFormData = TRUE;
+        session->hasFormData = TRUE;
         gaim_session_fetch(url, FALSE, NULL, FALSE, gaym_weblogin_step3,
-                           gaym, gaym->session);
+                           session, session);
     } else {
         gaim_debug_misc("gaym", "Connection was cancelled before step2\n");
-        gaim_debug_misc("gaym", "gaym->sessoin: %x\n", gaym->session);
+        gaim_debug_misc("gaym", "session: %x\n", session);
+	gaym_session_destroy(session);
         // g_free(gaym->session);
     }
 }
@@ -686,12 +706,10 @@
         session->account = account;
         session->username = g_strdup(account->username);
         session->password = g_strdup(account->password);
-        if (gaym->session)
-            g_free(gaym->session);
+	session->gaym = gaym;
 
-        gaym->session = session;
 
-        gaim_debug_misc("gaym", "Made gaym->session: %x\n", gaym->session);
+        gaim_debug_misc("gaym", "Made session: %x\n", session);
         if (GAIM_CONNECTION_IS_VALID
             (((GaimUrlSession *) session)->account->gc)) {
             // The first step is to establish the initial sesion
@@ -704,10 +722,11 @@
                                             account->gc, buf, 2, 6);
             ((GaimUrlSession *) session)->hasFormData = FALSE;
             gaim_session_fetch(url, FALSE, NULL, FALSE,
-                               gaym_weblogin_step2, gaym, gaym->session);
+                               gaym_weblogin_step2, session, session);
         } else {
             gaim_debug_misc("gaym", "cancelled before step1\n");
-            gaim_debug_misc("gaym", "gaym->sessoin: %x\n", gaym->session);
+            gaim_debug_misc("gaym", "gaym->sessoin: %x\n", session);
+	    gaym_session_destroy(session);
         }
 
     }



From jblebrun at berlios.de  Thu Jul 21 19:58:08 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Thu, 21 Jul 2005 19:58:08 +0200
Subject: [Qrc-svn] r219 - qrc/trunk/gaym/src
Message-ID: <200507211758.j6LHw8jW012383@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-21 19:58:07 +0200 (Thu, 21 Jul 2005)
New Revision: 219

Modified:
   qrc/trunk/gaym/src/gaym.h
   qrc/trunk/gaym/src/gayminfo.h
   qrc/trunk/gaym/src/msgs.c
Log:
*THIS REVISION NOT SUITABLE FOR RELEASE! 

*Changed the way the room list is populated initially. It is more inefficient, but it allows for proper sorting by entry order, via the chatsort plugin. This method is a point of debate, due to the notable change in roomlist formation. I will fork this code if people are unhappy with it.

*Info dialog shows thumbnail instead of full photo, if no full photo is available (adult photos)

gaym.h: added join_flags to gaym_conn struct, which is populated during richnames list, but USED during the subsequent "Names" messages that allows us to populate roomlist in entry order.

gayminfo.h: added thumbnail field to fetch_thumbail_data struct. (Why the hell did I name it that, if it didn't even have a thumbnail in it?)

msgs.c:
*richnames messages no longer populate roomlist, they just populate a flags list. 

*info_needed_callback fallsback to thumbnail photo if no full photo exists.

*msgs_names now populates the list if gaym->nameconv is null. So, on a join_msg, indicating a successful room join, a names command is immediately sent out. The response of that names message is what triggers list population.






Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-21 02:10:29 UTC (rev 218)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-21 17:58:07 UTC (rev 219)
@@ -77,7 +77,7 @@
     gboolean blist_updating;
     GHashTable *info_window_needed;
     GHashTable *im_thumbnail_needed;
-
+    GList *join_flags; //Temporary holding space for join flags. 
     GString *motd;
     GString *names;
     char *nameconv;

Modified: qrc/trunk/gaym/src/gayminfo.h
===================================================================
--- qrc/trunk/gaym/src/gayminfo.h	2005-07-21 02:10:29 UTC (rev 218)
+++ qrc/trunk/gaym/src/gayminfo.h	2005-07-21 17:58:07 UTC (rev 219)
@@ -37,6 +37,7 @@
     char *who;
     char *bio;
     char *stats;
+    char *thumbnail;
 };
 void gaym_fetch_thumbnail_cb(void *user_data, const char *pic_data,
                              size_t len);

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-21 02:10:29 UTC (rev 218)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-21 17:58:07 UTC (rev 219)
@@ -199,6 +199,20 @@
 
     picpath = return_string_between(match, "\n", info_data);
     if (!picpath || strlen(picpath) == 0) {
+
+	if(d->thumbnail) {
+            hashurl =
+                g_hash_table_lookup(gaym->confighash,
+                                    "mini-profile-panel.thumbnail-prefix");
+	    picurl = g_strdup_printf("%s%s",hashurl,d->thumbnail);
+	    if(picurl) {
+		gaim_url_fetch(picurl, FALSE, "Mozilla/4.0 (compatible; MSIE 5.0)",
+                       FALSE, gaym_fetch_photo_cb, user_data);
+	    
+		return; 
+	    }
+	    
+	}
         gaim_notify_userinfo(d->gc, d->who,
                              t = g_strdup_printf("Gay.com - %s", d->who),
                              d->who, NULL, info, NULL, NULL);
@@ -207,6 +221,7 @@
     }
 
     picurl = g_strdup_printf("http://www.gay.com%s", picpath);
+   
     if (picurl) {
         gaim_url_fetch(picurl, FALSE, "Mozilla/4.0 (compatible; MSIE 5.0)",
                        FALSE, gaym_fetch_photo_cb, user_data);
@@ -283,6 +298,7 @@
         data->who = g_strdup(args[1]);
         data->bio = gaym_bio_strdup(args[5]);
         data->stats = gaym_stats_strdup(args[5]);
+	data->thumbnail = gaym_thumbnail_strdup(args[5]);
 
         char *infourl = g_strdup_printf("%s?pw=%s&name=%s", hashurl,
                                         gaym->hash_pw, args[1]);
@@ -414,7 +430,7 @@
         if (!convo) {
             gaim_debug(GAIM_DEBUG_ERROR, "gaym",
                        "Got a NAMES list for %s, which doesn't exist\n",
-                       args[2]);
+                       args[1]);
             g_string_free(gaym->names, TRUE);
             gaym->names = NULL;
             g_free(gaym->nameconv);
@@ -442,44 +458,47 @@
             gaym->nameconv = NULL;
         } else {
             GList *users = NULL;
-            GList *flags = NULL;
 
-            while (*cur) {
-                GaimConvChatBuddyFlags f = GAIM_CBFLAGS_NONE;
+	    gaim_debug_misc("gaym","Using names for initial list population");
+	    while (*cur) {
                 end = strchr(cur, ' ');
-                if (!end)
-                    end = cur + strlen(cur);
-                if (*cur == '@') {
-                    f = GAIM_CBFLAGS_OP;
-                    cur++;
-                } else if (*cur == '%') {
-                    f = GAIM_CBFLAGS_HALFOP;
-                    cur++;
-                } else if (*cur == '+') {
-                    f = GAIM_CBFLAGS_VOICE;
-                    cur++;
-                }
+                //if (!end)
+                //    end = cur + strlen(cur);
+                //if (*cur == '@') {
+                //    f = GAIM_CBFLAGS_OP;
+                //    cur++;
+                //} else if (*cur == '%') {
+                //    f = GAIM_CBFLAGS_HALFOP;
+                //    cur++;
+                //} else if (*cur == '+') {
+                //    f = GAIM_CBFLAGS_VOICE;
+                //    cur++;
+                // }
                 tmp = g_strndup(cur, end - cur);
+
+		gcom_nick_to_gaym(tmp);
                 users = g_list_prepend(users, tmp);
-                flags = g_list_prepend(flags, GINT_TO_POINTER(f));
+                //flags = g_list_prepend(flags, GINT_TO_POINTER(f));
                 cur = end;
                 if (*cur)
                     cur++;
             }
-            users = g_list_reverse(users);
-            flags = g_list_reverse(flags);
+	    //users = g_list_reverse(users);
+            //flags = g_list_reverse(flags);
 
             if (users != NULL) {
                 GList *l;
 
                 gaim_conv_chat_add_users(GAIM_CONV_CHAT(convo), users,
-                                         flags);
+                                         gaym->join_flags);
 
+		
                 for (l = users; l != NULL; l = l->next)
                     g_free(l->data);
 
                 g_list_free(users);
-                g_list_free(flags);
+                g_list_free(gaym->join_flags);
+		gaym->join_flags=NULL;
             }
         }
         g_free(names);
@@ -689,6 +708,8 @@
         }
 
         serv_got_joined_chat(gc, id++, args[0]);
+	
+	gaym_cmd_names(gaym, "names", NULL, args);
         g_free(nick);
         return;
     }
@@ -1236,7 +1257,7 @@
 {
     GaimConnection *gc = gaim_account_get_connection(gaym->account);
     GaimConversation *convo;
-    GaimConvChatBuddyFlags flags = GAIM_CBFLAGS_NONE;
+    GaimConvChatBuddyFlags flags;
     char *channel = args[1];
     char *nick = args[2];
     char *extra = args[4];
@@ -1266,10 +1287,12 @@
     }
 
     flags = chat_pecking_order(extra);
+    
+    //g_hash_table_insert(gaym->join_flags, g_strdup(nick), flags);
+    gaym->join_flags=g_list_prepend(gaym->join_flags, GINT_TO_POINTER(flags));
+    //gaim_conv_chat_add_user(GAIM_CONV_CHAT(convo), nick, NULL, flags,
+    //                        FALSE);
 
-    gaim_conv_chat_add_user(GAIM_CONV_CHAT(convo), nick, NULL, flags,
-                            FALSE);
-
     /**
      * Make the ignore.png icon appear next to the nick.
      */



From jblebrun at berlios.de  Fri Jul 22 06:15:53 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Fri, 22 Jul 2005 06:15:53 +0200
Subject: [Qrc-svn] r220 - in qrc/trunk: . chaticon
Message-ID: <200507220415.j6M4FrWM027792@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-22 06:15:45 +0200 (Fri, 22 Jul 2005)
New Revision: 220

Added:
   qrc/trunk/chaticon/
   qrc/trunk/chaticon/Makefile.am
   qrc/trunk/chaticon/chaticon.c
Log:
Adding a plugin that will display a thumbnail under the name list in a room window.
The framework is there, we just need a clean way to get the buddy icon data from gaym.
For proof-of-concept for the gui stuff, a button that shows the name of whoever you click
is included.



Added: qrc/trunk/chaticon/Makefile.am
===================================================================
--- qrc/trunk/chaticon/Makefile.am	2005-07-21 17:58:07 UTC (rev 219)
+++ qrc/trunk/chaticon/Makefile.am	2005-07-22 04:15:45 UTC (rev 220)
@@ -0,0 +1,25 @@
+pkgdir = \
+	$(GAIM_LIBDIR)/gaim
+
+GAYMSOURCES = \
+	chaticon.c
+
+AM_CFLAGS = \
+	$(st)
+
+libchaticon_la_LDFLAGS = \
+	-module \
+	-avoid-version \
+	$(GTK_LIBS) \
+	$(GAIM_LIBS)
+
+pkg_LTLIBRARIES = \
+	libchaticon.la
+
+libchaticon_la_SOURCES = \
+	$(GAYMSOURCES)
+
+AM_CPPFLAGS = \
+	$(DEBUG_CFLAGS) \
+	$(GTK_CFLAGS) \
+	$(GAIM_CFLAGS)

Added: qrc/trunk/chaticon/chaticon.c
===================================================================
--- qrc/trunk/chaticon/chaticon.c	2005-07-21 17:58:07 UTC (rev 219)
+++ qrc/trunk/chaticon/chaticon.c	2005-07-22 04:15:45 UTC (rev 220)
@@ -0,0 +1,106 @@
+/* Show icons in chat room windows */
+
+#include "internal.h"
+#include "gtkgaim.h"
+
+#include "conversation.h"
+#include "debug.h"
+#include "log.h"
+#include "prefs.h"
+#include "signals.h"
+#include "util.h"
+#include "version.h"
+
+#include "gtkconv.h"
+#include "gtkimhtml.h"
+#include "gtkplugin.h"
+
+#define CHATSORT_PLUGIN_ID "gtk-chaticon"
+
+GHashTable* icons;
+GHashTable* icon_spots;
+static void clear_icon() {
+
+}
+static void changed_cb(GtkTreeSelection* selection, gpointer data){
+
+	GaimConversation* c = (GaimConversation*)data;
+	GtkTreeIter iter;
+	GtkTreeModel* model;
+	gchar* name;
+	GaimConversation *temp;
+	gtk_tree_selection_get_selected(selection, &model, &iter);
+	gtk_tree_model_get(model,&iter,CHAT_USERS_NAME_COLUMN, &name, -1);
+
+	gaim_debug_misc("chatsort","Click: %s\n",name);
+	gtk_button_set_label(g_hash_table_lookup(icon_spots, c), name);
+	//Look in local icon cache here.
+	//If the icon isn't here, get it from gaym
+	//Update the widget
+}
+//This gets called BEFORE a chatlist is populated... just creates a new type of chat window.
+static void redochatwindow(GaimConversation *c) {
+
+	GtkTreeModel *oldls;
+	
+	//Get a handle to the chat pane for the conversation
+	GaimGtkConversation* gtkconv = GAIM_GTK_CONVERSATION(c);
+	GaimGtkChatPane* gtkchat = gtkconv->u.chat;
+	GtkTreeSelection* select = gtk_tree_view_get_selection(GTK_TREE_VIEW(gtkchat->list));
+	gtk_tree_selection_set_mode(select, GTK_SELECTION_SINGLE);
+
+	oldls = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));	
+	GtkBox* vbox = GTK_BOX(gtkchat->list->parent->parent);
+	GtkWidget* button = gtk_button_new_with_label("A Button");
+	g_signal_connect(G_OBJECT(select), "changed", G_CALLBACK(changed_cb), c);
+
+	gtk_box_pack_end(vbox, GTK_WIDGET(button), FALSE, FALSE, 0);
+	gtk_widget_show(button);
+	g_hash_table_insert(icon_spots, c, button);
+	
+
+}
+
+
+static gboolean plugin_load(GaimPlugin *plugin)
+{
+	icons=g_hash_table_new(g_direct_hash, g_direct_equal);
+	icon_spots=g_hash_table_new(g_direct_hash, g_direct_equal);
+	
+	gaim_signal_connect(gaim_conversations_get_handle(), "chat-joined", plugin, GAIM_CALLBACK(redochatwindow), NULL);
+	gaim_signal_connect(gaim_conversations_get_handle(), "chat-buddy-left", plugin, GAIM_CALLBACK(clear_icon), NULL);
+
+	return TRUE;
+}
+
+static GaimPluginInfo info =
+{
+	GAIM_PLUGIN_MAGIC,
+	GAIM_MAJOR_VERSION,
+	GAIM_MINOR_VERSION,
+	GAIM_PLUGIN_STANDARD,
+	GAIM_GTK_PLUGIN_TYPE,
+	0,
+	NULL,
+	GAIM_PRIORITY_DEFAULT,
+	CHATSORT_PLUGIN_ID,
+	N_("Chatroom Icons"),
+	VERSION,
+	N_("Shows user thumbnails below the names list in a chatroom."),
+	N_("Shows user thumbnails below the names list in a chatroom."),
+	"Jason LeBrun <gaim at jasonlebrun.info",
+	GAIM_WEBSITE,
+	plugin_load,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static void
+init_plugin(GaimPlugin *plugin)
+{
+}
+
+GAIM_INIT_PLUGIN(history, init_plugin, info)



From jblebrun at berlios.de  Fri Jul 22 06:22:34 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Fri, 22 Jul 2005 06:22:34 +0200
Subject: [Qrc-svn] r221 - in qrc/trunk: . chatsort
Message-ID: <200507220422.j6M4MY99027956@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-22 06:22:19 +0200 (Fri, 22 Jul 2005)
New Revision: 221

Modified:
   qrc/trunk/chatsort/chatsort.c
   qrc/trunk/configure.ac
Log:
Added chaticon option to the configure script.
Cleaned up chatsort code.



Modified: qrc/trunk/chatsort/chatsort.c
===================================================================
--- qrc/trunk/chatsort/chatsort.c	2005-07-22 04:15:45 UTC (rev 220)
+++ qrc/trunk/chatsort/chatsort.c	2005-07-22 04:22:19 UTC (rev 221)
@@ -1,6 +1,4 @@
-/* Puts last 4k of log in new conversations a la Everybuddy (and then
- * stolen by Trillian "Pro") */
-
+/* Attempt to sort chat users by entry order, instead of alpha */
 #include "internal.h"
 #include "gtkgaim.h"
 
@@ -17,10 +15,9 @@
 #include "gtkplugin.h"
 
 #define CHATSORT_PLUGIN_ID "gtk-chatsort"
-#define CHATSORT_USERS_COLUMNS 4
-#define CHATSORT_USERS_ENTRY_COLUMN 4
 
-gint entry_id=0;
+
+//A dummy sort function... don't sort at all!
 static gint sort_chat_users(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer userdata) {
 return 1;
 }
@@ -28,82 +25,33 @@
 //This gets called BEFORE a chatlist is populated... just creates a new type of chat window.
 static void redochatwindow(GaimConversation *c) {
 
-	GtkListStore *ls;
-	/**
-	 * Unused variables:
-	 *
-	 * GtkCellRenderer *rend;
-	 * GtkTreeViewColumn *col;
-	 */
 	GtkTreeModel *oldls;
+	GtkTreeSelection *select;
 	GtkTreeIter iter;
-	
+
 	//Get a handle to the chat pane for the conversation
 	GaimGtkConversation* gtkconv = GAIM_GTK_CONVERSATION(c);
 	GaimGtkChatPane* gtkchat = gtkconv->u.chat;
 
 	
-	//Remember the list in case the plugin is unloaded.
 	oldls = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
+	select = gtk_tree_view_get_selection(GTK_TREE_VIEW(gtkchat->list));
 
-	//Make a new tree list
-
-	//Columns: Icon, Name, Flags, Entry order
-	ls = gtk_list_store_new(CHATSORT_USERS_COLUMNS, GDK_TYPE_PIXBUF, G_TYPE_STRING,
-                                                        G_TYPE_INT, G_TYPE_INT);
-	gtk_list_store_append(ls, &iter);
-        gtk_list_store_set(ls, &iter, CHAT_USERS_NAME_COLUMN, "ChatSort", CHATSORT_USERS_ENTRY_COLUMN, 1, -1);
-	//Eventually, should have an entry for default.
-        gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(ls), CHAT_USERS_NAME_COLUMN, sort_chat_users, NULL, NULL);
+	//This is a dummy "root" item. If it's not here,
+	//then the first name entered into the list gets "stucK" at the
+	//top. This is a hack.
+	gtk_list_store_append(GTK_LIST_STORE(oldls), &iter);
+	gtk_list_store_set(GTK_LIST_STORE(oldls), &iter, CHAT_USERS_NAME_COLUMN, " ", -1);
+        gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(oldls), CHAT_USERS_NAME_COLUMN, sort_chat_users, NULL, NULL);
 	
-	gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(ls), CHAT_USERS_NAME_COLUMN,
-                                                                               GTK_SORT_DESCENDING);
-
-        gtk_tree_view_set_model(GTK_TREE_VIEW(gtkchat->list), GTK_TREE_MODEL(ls));
-
-	//rend = gtk_cell_renderer_pixbuf_new();
-        //col = gtk_tree_view_column_new_with_attributes(NULL, rend, "pixbuf", CHAT_USERS_ICON_COLUMN, NULL);
-        //gtk_tree_view_column_set_clickable(GTK_TREE_VIEW_COLUMN(col), TRUE);
-        //gtk_tree_view_append_column(GTK_TREE_VIEW(list), col);
-
-	//Maybe eventually make our own menu.
-	//g_signal_connect(G_OBJECT(list), "button_press_event",
-        //                                 G_CALLBACK(right_click_chat_cb), conv);
-        //g_signal_connect(G_OBJECT(list), "popup-menu",
-        //                 G_CALLBACK(gtkconv_chat_popup_menu_cb), conv);
-
-        //rend = gtk_cell_renderer_text_new();
-        //col = gtk_tree_view_column_new_with_attributes(NULL, rend, "text", CHAT_USERS_NAME_COLUMN, NULL); 
-        //gtk_tree_view_column_set_clickable(GTK_TREE_VIEW_COLUMN(col), TRUE);
-        //gtk_tree_view_append_column(GTK_TREE_VIEW(list), col);
-       
-       //gtk_widget_set_size_request(list, 150, -1);
-        //gtk_tree_view_set_headers_visible(GTK_TREE_VIEW(list), FALSE);
-
-	gaim_debug_misc("chatsort","redo window\n");
-
-	
-
 }
 
-static void joined(GaimConversation *c, const char* name, GaimConvChatBuddyFlags flags) {
-
-	gaim_debug_misc("chatsort","Joined: %s\n",name);
-	gaim_debug_misc("chatsort","Flags: %x\n",flags);
-	
-}
-
 static gboolean plugin_load(GaimPlugin *plugin)
 {
 	gaim_signal_connect(gaim_conversations_get_handle(),
 						"chat-joined",
 						plugin, GAIM_CALLBACK(redochatwindow), NULL);
 	
-	gaim_signal_connect(gaim_conversations_get_handle(),
-						"chat-buddy-joined",
-						plugin, GAIM_CALLBACK(joined), NULL);
-	
-
 	return TRUE;
 }
 

Modified: qrc/trunk/configure.ac
===================================================================
--- qrc/trunk/configure.ac	2005-07-22 04:15:45 UTC (rev 220)
+++ qrc/trunk/configure.ac	2005-07-22 04:22:19 UTC (rev 221)
@@ -63,6 +63,10 @@
 	enable_chatsort="no"
 fi
 
+if test "$enable_chaticon" != "yes" ; then
+	enable_chaticon="no"
+fi
+
 if test "$enable_gaym" != "yes" ; then
 	enable_gaym="no"
 fi
@@ -73,7 +77,7 @@
 
 # Checks for libraries.
 PKG_PROG_PKG_CONFIG([$REQUIRED_PKG_CONFIG])
-if test "$enable_chatsort" = "yes" -o "$enable_roombrowse" = "yes" ; then
+if test "$enable_chatsort" = "yes" -o "$enable_roombrowse" = "yes" -o "$enable_chaticon" = "yes"; then
 	PKG_CHECK_MODULES([GTK], [$REQUIRED_GTK],
 		[
 		AC_SUBST(GTK_CFLAGS)
@@ -127,6 +131,7 @@
 AC_CONFIG_FILES([Makefile
                  bot-challenger/Makefile
                  chatsort/Makefile
+                 chaticon/Makefile
                  gaym/Makefile
                  gaym/pixmaps/Makefile
                  gaym/src/Makefile
@@ -140,6 +145,7 @@
 echo
 echo Build bot-challenger plugin...... : $enable_bot_challenger
 echo Build chatsort plugin............ : $enable_chatsort
+echo Build chaticon plugin............ : $enable_chaticon
 echo Build gaym plugin................ : $enable_gaym
 echo Build roombrowse plugin.......... : $enable_roombrowse
 echo



From deckrider at berlios.de  Fri Jul 22 14:19:21 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Fri, 22 Jul 2005 14:19:21 +0200
Subject: [Qrc-svn] r222 - in qrc/trunk: . chaticon
Message-ID: <200507221219.j6MCJLNY022122@sheep.berlios.de>

Author: deckrider
Date: 2005-07-22 14:19:20 +0200 (Fri, 22 Jul 2005)
New Revision: 222

Modified:
   qrc/trunk/Makefile.am
   qrc/trunk/chaticon/chaticon.c
   qrc/trunk/configure.ac
Log:
Integrated chaticon into the automake/autoconf process.
Fixed a compiler warning in chaticon/chaticon.c.


Modified: qrc/trunk/Makefile.am
===================================================================
--- qrc/trunk/Makefile.am	2005-07-22 04:22:19 UTC (rev 221)
+++ qrc/trunk/Makefile.am	2005-07-22 12:19:20 UTC (rev 222)
@@ -2,6 +2,10 @@
 MAYBE_BOT_CHALLENGER = bot-challenger
 endif
 
+if COND_CHATICON
+MAYBE_CHATICON = chaticon
+endif
+
 if COND_CHATSORT
 MAYBE_CHATSORT = chatsort
 endif
@@ -21,6 +25,7 @@
 SUBDIRS = \
 	nsis \
 	$(MAYBE_BOT_CHALLENGER) \
+	$(MAYBE_CHATICON) \
 	$(MAYBE_CHATSORT) \
 	$(MAYBE_GAYM) \
 	$(MAYBE_ROOMBROWSE)

Modified: qrc/trunk/chaticon/chaticon.c
===================================================================
--- qrc/trunk/chaticon/chaticon.c	2005-07-22 04:22:19 UTC (rev 221)
+++ qrc/trunk/chaticon/chaticon.c	2005-07-22 12:19:20 UTC (rev 222)
@@ -17,89 +17,99 @@
 
 #define CHATSORT_PLUGIN_ID "gtk-chaticon"
 
-GHashTable* icons;
-GHashTable* icon_spots;
-static void clear_icon() {
+GHashTable *icons;
+GHashTable *icon_spots;
+static void clear_icon()
+{
 
 }
-static void changed_cb(GtkTreeSelection* selection, gpointer data){
+static void changed_cb(GtkTreeSelection * selection, gpointer data)
+{
 
-	GaimConversation* c = (GaimConversation*)data;
-	GtkTreeIter iter;
-	GtkTreeModel* model;
-	gchar* name;
-	GaimConversation *temp;
-	gtk_tree_selection_get_selected(selection, &model, &iter);
-	gtk_tree_model_get(model,&iter,CHAT_USERS_NAME_COLUMN, &name, -1);
+    GaimConversation *c = (GaimConversation *) data;
+    GtkTreeIter iter;
+    GtkTreeModel *model;
+    gchar *name;
+    gtk_tree_selection_get_selected(selection, &model, &iter);
+    gtk_tree_model_get(model, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
 
-	gaim_debug_misc("chatsort","Click: %s\n",name);
-	gtk_button_set_label(g_hash_table_lookup(icon_spots, c), name);
-	//Look in local icon cache here.
-	//If the icon isn't here, get it from gaym
-	//Update the widget
+    gaim_debug_misc("chatsort", "Click: %s\n", name);
+    gtk_button_set_label(g_hash_table_lookup(icon_spots, c), name);
+    /**
+     * Look in local icon cache here.
+     * If the icon isn't here, get it from gaym
+     * Update the widget
+     */
 }
-//This gets called BEFORE a chatlist is populated... just creates a new type of chat window.
-static void redochatwindow(GaimConversation *c) {
 
-	GtkTreeModel *oldls;
-	
-	//Get a handle to the chat pane for the conversation
-	GaimGtkConversation* gtkconv = GAIM_GTK_CONVERSATION(c);
-	GaimGtkChatPane* gtkchat = gtkconv->u.chat;
-	GtkTreeSelection* select = gtk_tree_view_get_selection(GTK_TREE_VIEW(gtkchat->list));
-	gtk_tree_selection_set_mode(select, GTK_SELECTION_SINGLE);
+/**
+ * This gets called BEFORE a chatlist is populated... just creates a new
+ * type of chat window.
+ */
+static void redochatwindow(GaimConversation * c)
+{
 
-	oldls = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));	
-	GtkBox* vbox = GTK_BOX(gtkchat->list->parent->parent);
-	GtkWidget* button = gtk_button_new_with_label("A Button");
-	g_signal_connect(G_OBJECT(select), "changed", G_CALLBACK(changed_cb), c);
+    GtkTreeModel *oldls;
 
-	gtk_box_pack_end(vbox, GTK_WIDGET(button), FALSE, FALSE, 0);
-	gtk_widget_show(button);
-	g_hash_table_insert(icon_spots, c, button);
-	
+    /* Get a handle to the chat pane for the conversation */
+    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
+    GaimGtkChatPane *gtkchat = gtkconv->u.chat;
+    GtkTreeSelection *select =
+        gtk_tree_view_get_selection(GTK_TREE_VIEW(gtkchat->list));
+    gtk_tree_selection_set_mode(select, GTK_SELECTION_SINGLE);
 
+    oldls = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
+    GtkBox *vbox = GTK_BOX(gtkchat->list->parent->parent);
+    GtkWidget *button = gtk_button_new_with_label("A Button");
+    g_signal_connect(G_OBJECT(select), "changed", G_CALLBACK(changed_cb),
+                     c);
+
+    gtk_box_pack_end(vbox, GTK_WIDGET(button), FALSE, FALSE, 0);
+    gtk_widget_show(button);
+    g_hash_table_insert(icon_spots, c, button);
+
+
 }
 
 
-static gboolean plugin_load(GaimPlugin *plugin)
+static gboolean plugin_load(GaimPlugin * plugin)
 {
-	icons=g_hash_table_new(g_direct_hash, g_direct_equal);
-	icon_spots=g_hash_table_new(g_direct_hash, g_direct_equal);
-	
-	gaim_signal_connect(gaim_conversations_get_handle(), "chat-joined", plugin, GAIM_CALLBACK(redochatwindow), NULL);
-	gaim_signal_connect(gaim_conversations_get_handle(), "chat-buddy-left", plugin, GAIM_CALLBACK(clear_icon), NULL);
+    icons = g_hash_table_new(g_direct_hash, g_direct_equal);
+    icon_spots = g_hash_table_new(g_direct_hash, g_direct_equal);
 
-	return TRUE;
+    gaim_signal_connect(gaim_conversations_get_handle(), "chat-joined",
+                        plugin, GAIM_CALLBACK(redochatwindow), NULL);
+    gaim_signal_connect(gaim_conversations_get_handle(), "chat-buddy-left",
+                        plugin, GAIM_CALLBACK(clear_icon), NULL);
+
+    return TRUE;
 }
 
-static GaimPluginInfo info =
-{
-	GAIM_PLUGIN_MAGIC,
-	GAIM_MAJOR_VERSION,
-	GAIM_MINOR_VERSION,
-	GAIM_PLUGIN_STANDARD,
-	GAIM_GTK_PLUGIN_TYPE,
-	0,
-	NULL,
-	GAIM_PRIORITY_DEFAULT,
-	CHATSORT_PLUGIN_ID,
-	N_("Chatroom Icons"),
-	VERSION,
-	N_("Shows user thumbnails below the names list in a chatroom."),
-	N_("Shows user thumbnails below the names list in a chatroom."),
-	"Jason LeBrun <gaim at jasonlebrun.info",
-	GAIM_WEBSITE,
-	plugin_load,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL
+static GaimPluginInfo info = {
+    GAIM_PLUGIN_MAGIC,
+    GAIM_MAJOR_VERSION,
+    GAIM_MINOR_VERSION,
+    GAIM_PLUGIN_STANDARD,
+    GAIM_GTK_PLUGIN_TYPE,
+    0,
+    NULL,
+    GAIM_PRIORITY_DEFAULT,
+    CHATSORT_PLUGIN_ID,
+    N_("Chatroom Icons"),
+    VERSION,
+    N_("Shows user thumbnails below the names list in a chatroom."),
+    N_("Shows user thumbnails below the names list in a chatroom."),
+    "Jason LeBrun <gaim at jasonlebrun.info",
+    GAIM_WEBSITE,
+    plugin_load,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL
 };
 
-static void
-init_plugin(GaimPlugin *plugin)
+static void init_plugin(GaimPlugin * plugin)
 {
 }
 

Modified: qrc/trunk/configure.ac
===================================================================
--- qrc/trunk/configure.ac	2005-07-22 04:22:19 UTC (rev 221)
+++ qrc/trunk/configure.ac	2005-07-22 12:19:20 UTC (rev 222)
@@ -38,6 +38,10 @@
 	[AS_HELP_STRING(--enable-bot-challenger,build the bot-challenger plugin @<:@default=yes@:>@)],,
 	[enable_bot_challenger="yes"])
 
+AC_ARG_ENABLE([chaticon],
+	[AS_HELP_STRING(--enable-chaticon,build the chaticon plugin @<:@default=no@:>@)],,
+	[enable_chaticon="no"])
+
 AC_ARG_ENABLE([chatsort],
 	[AS_HELP_STRING(--enable-chatsort,build the chatsort plugin @<:@default=no@:>@)],,
 	[enable_chatsort="no"])
@@ -51,6 +55,7 @@
 	[enable_roombrowse="no"])
 
 AM_CONDITIONAL([COND_BOT_CHALLENGER], [test "$enable_bot_challenger" = "yes"])
+AM_CONDITIONAL([COND_CHATICON], [test "$enable_chaticon" = "yes"])
 AM_CONDITIONAL([COND_CHATSORT], [test "$enable_chatsort" = "yes"])
 AM_CONDITIONAL([COND_GAYM], [test "$enable_gaym" = "yes"])
 AM_CONDITIONAL([COND_ROOMBROWSE], [test "$enable_roombrowse" = "yes"])
@@ -59,14 +64,14 @@
 	enable_bot_challener="no"
 fi
 
+if test "$enable_chaticon" != "yes" ; then
+	enable_chaticon="no"
+fi
+
 if test "$enable_chatsort" != "yes" ; then
 	enable_chatsort="no"
 fi
 
-if test "$enable_chaticon" != "yes" ; then
-	enable_chaticon="no"
-fi
-
 if test "$enable_gaym" != "yes" ; then
 	enable_gaym="no"
 fi
@@ -77,7 +82,7 @@
 
 # Checks for libraries.
 PKG_PROG_PKG_CONFIG([$REQUIRED_PKG_CONFIG])
-if test "$enable_chatsort" = "yes" -o "$enable_roombrowse" = "yes" -o "$enable_chaticon" = "yes"; then
+if test "$enable_chaticon" = "yes" -o "$enable_chatsort" = "yes" -o "$enable_roombrowse" = "yes"; then
 	PKG_CHECK_MODULES([GTK], [$REQUIRED_GTK],
 		[
 		AC_SUBST(GTK_CFLAGS)
@@ -130,8 +135,8 @@
 
 AC_CONFIG_FILES([Makefile
                  bot-challenger/Makefile
+                 chaticon/Makefile
                  chatsort/Makefile
-                 chaticon/Makefile
                  gaym/Makefile
                  gaym/pixmaps/Makefile
                  gaym/src/Makefile
@@ -144,8 +149,8 @@
 echo $PACKAGE $VERSION
 echo
 echo Build bot-challenger plugin...... : $enable_bot_challenger
+echo Build chaticon plugin............ : $enable_chaticon
 echo Build chatsort plugin............ : $enable_chatsort
-echo Build chaticon plugin............ : $enable_chaticon
 echo Build gaym plugin................ : $enable_gaym
 echo Build roombrowse plugin.......... : $enable_roombrowse
 echo



From deckrider at berlios.de  Fri Jul 22 14:34:50 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Fri, 22 Jul 2005 14:34:50 +0200
Subject: [Qrc-svn] r223 - qrc/trunk/gaym/src
Message-ID: <200507221234.j6MCYo5Q023016@sheep.berlios.de>

Author: deckrider
Date: 2005-07-22 14:34:48 +0200 (Fri, 22 Jul 2005)
New Revision: 223

Modified:
   qrc/trunk/gaym/src/msgs.c
Log:
Fixed compiler warning.


Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-22 12:19:20 UTC (rev 222)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-22 12:34:48 UTC (rev 223)
@@ -200,19 +200,20 @@
     picpath = return_string_between(match, "\n", info_data);
     if (!picpath || strlen(picpath) == 0) {
 
-	if(d->thumbnail) {
+        if (d->thumbnail) {
             hashurl =
                 g_hash_table_lookup(gaym->confighash,
                                     "mini-profile-panel.thumbnail-prefix");
-	    picurl = g_strdup_printf("%s%s",hashurl,d->thumbnail);
-	    if(picurl) {
-		gaim_url_fetch(picurl, FALSE, "Mozilla/4.0 (compatible; MSIE 5.0)",
-                       FALSE, gaym_fetch_photo_cb, user_data);
-	    
-		return; 
-	    }
-	    
-	}
+            picurl = g_strdup_printf("%s%s", hashurl, d->thumbnail);
+            if (picurl) {
+                gaim_url_fetch(picurl, FALSE,
+                               "Mozilla/4.0 (compatible; MSIE 5.0)", FALSE,
+                               gaym_fetch_photo_cb, user_data);
+
+                return;
+            }
+
+        }
         gaim_notify_userinfo(d->gc, d->who,
                              t = g_strdup_printf("Gay.com - %s", d->who),
                              d->who, NULL, info, NULL, NULL);
@@ -221,7 +222,7 @@
     }
 
     picurl = g_strdup_printf("http://www.gay.com%s", picpath);
-   
+
     if (picurl) {
         gaim_url_fetch(picurl, FALSE, "Mozilla/4.0 (compatible; MSIE 5.0)",
                        FALSE, gaym_fetch_photo_cb, user_data);
@@ -298,7 +299,7 @@
         data->who = g_strdup(args[1]);
         data->bio = gaym_bio_strdup(args[5]);
         data->stats = gaym_stats_strdup(args[5]);
-	data->thumbnail = gaym_thumbnail_strdup(args[5]);
+        data->thumbnail = gaym_thumbnail_strdup(args[5]);
 
         char *infourl = g_strdup_printf("%s?pw=%s&name=%s", hashurl,
                                         gaym->hash_pw, args[1]);
@@ -459,32 +460,37 @@
         } else {
             GList *users = NULL;
 
-	    gaim_debug_misc("gaym","Using names for initial list population");
-	    while (*cur) {
+            gaim_debug_misc("gaym",
+                            "Using names for initial list population");
+            while (*cur) {
                 end = strchr(cur, ' ');
-                //if (!end)
-                //    end = cur + strlen(cur);
-                //if (*cur == '@') {
-                //    f = GAIM_CBFLAGS_OP;
-                //    cur++;
-                //} else if (*cur == '%') {
-                //    f = GAIM_CBFLAGS_HALFOP;
-                //    cur++;
-                //} else if (*cur == '+') {
-                //    f = GAIM_CBFLAGS_VOICE;
-                //    cur++;
-                // }
+                /**
+                 * if (!end)
+                 * end = cur + strlen(cur);
+                 * if (*cur == '@') {
+                 * f = GAIM_CBFLAGS_OP;
+                 * cur++;
+                 * } else if (*cur == '%') {
+                 * f = GAIM_CBFLAGS_HALFOP;
+                 * cur++;
+                 * } else if (*cur == '+') {
+                 * f = GAIM_CBFLAGS_VOICE;
+                 * cur++;
+                 * }
+                 */
                 tmp = g_strndup(cur, end - cur);
 
-		gcom_nick_to_gaym(tmp);
+                gcom_nick_to_gaym(tmp);
                 users = g_list_prepend(users, tmp);
-                //flags = g_list_prepend(flags, GINT_TO_POINTER(f));
+                /* flags = g_list_prepend(flags, GINT_TO_POINTER(f)); */
                 cur = end;
                 if (*cur)
                     cur++;
             }
-	    //users = g_list_reverse(users);
-            //flags = g_list_reverse(flags);
+            /**
+             * users = g_list_reverse(users);
+             * flags = g_list_reverse(flags);
+             */
 
             if (users != NULL) {
                 GList *l;
@@ -492,13 +498,13 @@
                 gaim_conv_chat_add_users(GAIM_CONV_CHAT(convo), users,
                                          gaym->join_flags);
 
-		
+
                 for (l = users; l != NULL; l = l->next)
                     g_free(l->data);
 
                 g_list_free(users);
                 g_list_free(gaym->join_flags);
-		gaym->join_flags=NULL;
+                gaym->join_flags = NULL;
             }
         }
         g_free(names);
@@ -708,8 +714,8 @@
         }
 
         serv_got_joined_chat(gc, id++, args[0]);
-	
-	gaym_cmd_names(gaym, "names", NULL, args);
+
+        gaym_cmd_names(gaym, "names", NULL, (const char **)args);
         g_free(nick);
         return;
     }
@@ -1287,13 +1293,18 @@
     }
 
     flags = chat_pecking_order(extra);
-    
-    //g_hash_table_insert(gaym->join_flags, g_strdup(nick), flags);
-    gaym->join_flags=g_list_prepend(gaym->join_flags, GINT_TO_POINTER(flags));
-    //gaim_conv_chat_add_user(GAIM_CONV_CHAT(convo), nick, NULL, flags,
-    //                        FALSE);
 
     /**
+     * g_hash_table_insert(gaym->join_flags, g_strdup(nick), flags);
+     */
+    gaym->join_flags =
+        g_list_prepend(gaym->join_flags, GINT_TO_POINTER(flags));
+    /**
+     * gaim_conv_chat_add_user(GAIM_CONV_CHAT(convo), nick, NULL, flags,
+     * FALSE);
+     */
+
+    /**
      * Make the ignore.png icon appear next to the nick.
      */
     GaimConversationUiOps *ops = gaim_conversation_get_ui_ops(convo);



From jblebrun at berlios.de  Sat Jul 23 05:07:05 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Sat, 23 Jul 2005 05:07:05 +0200
Subject: [Qrc-svn] r224 - qrc/trunk/gaym/src
Message-ID: <200507230307.j6N375xf008046@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-23 05:06:59 +0200 (Sat, 23 Jul 2005)
New Revision: 224

Modified:
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gaym.h
   qrc/trunk/gaym/src/helpers.c
   qrc/trunk/gaym/src/helpers.h
   qrc/trunk/gaym/src/msgs.c
Log:
Woohoo! Sort by entry without any pesky plugins, by hijacking the buddy flags!
There may be one follow-up revision to check for memory leaks.



Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-22 12:34:48 UTC (rev 223)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-23 03:06:59 UTC (rev 224)
@@ -524,6 +524,10 @@
      */
     gaym->info_window_needed =
         g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
+    
+    gaym->entry_order =
+	g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
+	
 
     /**
      * This is similar to gaym->info_window_needed, except this is

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-22 12:34:48 UTC (rev 223)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-23 03:06:59 UTC (rev 224)
@@ -89,6 +89,7 @@
     gboolean quitting;
     char *subroom;
     GHashTable *confighash;
+    GHashTable *entry_order;
 
     char *persist_room;
     gboolean cancelling_persist;

Modified: qrc/trunk/gaym/src/helpers.c
===================================================================
--- qrc/trunk/gaym/src/helpers.c	2005-07-22 12:34:48 UTC (rev 223)
+++ qrc/trunk/gaym/src/helpers.c	2005-07-23 03:06:59 UTC (rev 224)
@@ -431,6 +431,10 @@
     return flags;
 }
 
+GaimConvChatBuddyFlags include_chat_entry_order(GaimConvChatBuddyFlags flags, gint entry) {
+    
+    return (flags | (entry << 4));
+}
 /**
  * vim:tabstop=4:shiftwidth=4:expandtab:
  */

Modified: qrc/trunk/gaym/src/helpers.h
===================================================================
--- qrc/trunk/gaym/src/helpers.h	2005-07-22 12:34:48 UTC (rev 223)
+++ qrc/trunk/gaym/src/helpers.h	2005-07-23 03:06:59 UTC (rev 224)
@@ -156,6 +156,7 @@
  */
 GaimConvChatBuddyFlags chat_pecking_order(const char *extra);
 
+GaimConvChatBuddyFlags include_chat_entry_order(GaimConvChatBuddyFlags flags, gint entry);
 #endif                          /* _GAIM_GAYM_HELPERS_H_ */
 
 /**

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-22 12:34:48 UTC (rev 223)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-23 03:06:59 UTC (rev 224)
@@ -715,8 +715,12 @@
 
         serv_got_joined_chat(gc, id++, args[0]);
 
-        gaym_cmd_names(gaym, "names", NULL, (const char **)args);
-        g_free(nick);
+	gint* entry=g_new(gint, 1);
+	gaim_debug_misc("gaym","Made int: %x\n",entry);
+	*entry=200;
+	
+        g_hash_table_insert(gaym->entry_order, g_strdup(args[0]), entry); 
+	g_free(nick);
         return;
     }
 
@@ -739,7 +743,13 @@
         g_free(bio);
     }
 
+    gint* entry=g_hash_table_lookup(gaym->entry_order, args[0]);
+
+    if (*entry<201)
+	*entry=201;
+    
     flags = chat_pecking_order(args[1]);
+    flags = include_chat_entry_order(flags, (*entry)++);
 
     gboolean gaym_privacy_permit = gaym_privacy_check(gc, nick);
     gboolean show_join =
@@ -907,6 +917,8 @@
 
     gcom_nick_to_gaym(nick);
     if (!gaim_utf8_strcasecmp(nick, gaim_connection_get_display_name(gc))) {
+
+	g_hash_table_remove(gaym->entry_order, args[0]);
         msg = g_strdup_printf(_("You have parted the channel"));
 
         gaim_conv_chat_write(GAIM_CONV_CHAT(convo), args[0], msg,
@@ -1293,16 +1305,21 @@
     }
 
     flags = chat_pecking_order(extra);
+    gint* entry = g_hash_table_lookup(gaym->entry_order, channel);
 
+    gaim_debug_misc("gaym","looked up int: %x, %i\n",entry,*entry);
+    flags = include_chat_entry_order(flags, (*entry)--);
+    
+    gaim_debug_misc("gaym","flags: %i\n",flags);
     /**
      * g_hash_table_insert(gaym->join_flags, g_strdup(nick), flags);
      */
-    gaym->join_flags =
-        g_list_prepend(gaym->join_flags, GINT_TO_POINTER(flags));
-    /**
-     * gaim_conv_chat_add_user(GAIM_CONV_CHAT(convo), nick, NULL, flags,
-     * FALSE);
-     */
+    //gaym->join_flags =
+    //    g_list_prepend(gaym->join_flags, GINT_TO_POINTER(flags));
+   
+    gaim_conv_chat_add_user(GAIM_CONV_CHAT(convo), nick, NULL, flags,
+      FALSE);
+     
 
     /**
      * Make the ignore.png icon appear next to the nick.



From deckrider at berlios.de  Sat Jul 23 14:25:27 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sat, 23 Jul 2005 14:25:27 +0200
Subject: [Qrc-svn] r225 - in qrc/trunk: . gaym/src
Message-ID: <200507231225.j6NCPRB7001207@sheep.berlios.de>

Author: deckrider
Date: 2005-07-23 14:25:21 +0200 (Sat, 23 Jul 2005)
New Revision: 225

Removed:
   qrc/trunk/chatsort/
Modified:
   qrc/trunk/Makefile.am
   qrc/trunk/configure.ac
   qrc/trunk/gaym/src/gaym.h
   qrc/trunk/gaym/src/gayminfo.h
   qrc/trunk/gaym/src/msgs.c
Log:
There have been lots of commits in the recent period, which have
introduced duplicate functionality with respect to room sorting and
chatroom icons.  This commit is an attempt to clean this up by doing the
following:

   within gaym/src:  svn merge -r 224:218
   within gaym/src:  svn merge -r 223:224

The first command backs out all chatsort and chaticon changes from gaym.
The second command adds back Jason's latest chatsort changes to gaym.

In addition, the chatsort plugin has been removed, since sorting is now
easily achieved within the gaym prpl (yay Jason!), and the corresponding
chatsort plugin logic has been removed from configure.ac and
Makefile.am.

Other commits are probably needed after this to restore the fix to
gaym_msg_join() within gaym/src/msg.c, but I thought it is worthwhile to
commit the merge separately.


Modified: qrc/trunk/Makefile.am
===================================================================
--- qrc/trunk/Makefile.am	2005-07-23 03:06:59 UTC (rev 224)
+++ qrc/trunk/Makefile.am	2005-07-23 12:25:21 UTC (rev 225)
@@ -6,10 +6,6 @@
 MAYBE_CHATICON = chaticon
 endif
 
-if COND_CHATSORT
-MAYBE_CHATSORT = chatsort
-endif
-
 if COND_GAYM
 MAYBE_GAYM = gaym
 endif
@@ -26,6 +22,5 @@
 	nsis \
 	$(MAYBE_BOT_CHALLENGER) \
 	$(MAYBE_CHATICON) \
-	$(MAYBE_CHATSORT) \
 	$(MAYBE_GAYM) \
 	$(MAYBE_ROOMBROWSE)

Modified: qrc/trunk/configure.ac
===================================================================
--- qrc/trunk/configure.ac	2005-07-23 03:06:59 UTC (rev 224)
+++ qrc/trunk/configure.ac	2005-07-23 12:25:21 UTC (rev 225)
@@ -42,10 +42,6 @@
 	[AS_HELP_STRING(--enable-chaticon,build the chaticon plugin @<:@default=no@:>@)],,
 	[enable_chaticon="no"])
 
-AC_ARG_ENABLE([chatsort],
-	[AS_HELP_STRING(--enable-chatsort,build the chatsort plugin @<:@default=no@:>@)],,
-	[enable_chatsort="no"])
-
 AC_ARG_ENABLE([gaym],
 	[AS_HELP_STRING(--enable-gaym,build the gaym plugin @<:@default=yes@:>@)],,
 	[enable_gaym="yes"])
@@ -56,7 +52,6 @@
 
 AM_CONDITIONAL([COND_BOT_CHALLENGER], [test "$enable_bot_challenger" = "yes"])
 AM_CONDITIONAL([COND_CHATICON], [test "$enable_chaticon" = "yes"])
-AM_CONDITIONAL([COND_CHATSORT], [test "$enable_chatsort" = "yes"])
 AM_CONDITIONAL([COND_GAYM], [test "$enable_gaym" = "yes"])
 AM_CONDITIONAL([COND_ROOMBROWSE], [test "$enable_roombrowse" = "yes"])
 
@@ -68,10 +63,6 @@
 	enable_chaticon="no"
 fi
 
-if test "$enable_chatsort" != "yes" ; then
-	enable_chatsort="no"
-fi
-
 if test "$enable_gaym" != "yes" ; then
 	enable_gaym="no"
 fi
@@ -82,7 +73,7 @@
 
 # Checks for libraries.
 PKG_PROG_PKG_CONFIG([$REQUIRED_PKG_CONFIG])
-if test "$enable_chaticon" = "yes" -o "$enable_chatsort" = "yes" -o "$enable_roombrowse" = "yes"; then
+if test "$enable_chaticon" = "yes" -o "$enable_roombrowse" = "yes"; then
 	PKG_CHECK_MODULES([GTK], [$REQUIRED_GTK],
 		[
 		AC_SUBST(GTK_CFLAGS)
@@ -136,7 +127,6 @@
 AC_CONFIG_FILES([Makefile
                  bot-challenger/Makefile
                  chaticon/Makefile
-                 chatsort/Makefile
                  gaym/Makefile
                  gaym/pixmaps/Makefile
                  gaym/src/Makefile
@@ -150,7 +140,6 @@
 echo
 echo Build bot-challenger plugin...... : $enable_bot_challenger
 echo Build chaticon plugin............ : $enable_chaticon
-echo Build chatsort plugin............ : $enable_chatsort
 echo Build gaym plugin................ : $enable_gaym
 echo Build roombrowse plugin.......... : $enable_roombrowse
 echo

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-23 03:06:59 UTC (rev 224)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-23 12:25:21 UTC (rev 225)
@@ -77,7 +77,7 @@
     gboolean blist_updating;
     GHashTable *info_window_needed;
     GHashTable *im_thumbnail_needed;
-    GList *join_flags; //Temporary holding space for join flags. 
+
     GString *motd;
     GString *names;
     char *nameconv;
@@ -106,7 +106,6 @@
     char *password;
     struct gaym_conn *gaym;
     gboolean hasFormData;
-    
 
 } GaimUrlSession;
 

Modified: qrc/trunk/gaym/src/gayminfo.h
===================================================================
--- qrc/trunk/gaym/src/gayminfo.h	2005-07-23 03:06:59 UTC (rev 224)
+++ qrc/trunk/gaym/src/gayminfo.h	2005-07-23 12:25:21 UTC (rev 225)
@@ -37,7 +37,6 @@
     char *who;
     char *bio;
     char *stats;
-    char *thumbnail;
 };
 void gaym_fetch_thumbnail_cb(void *user_data, const char *pic_data,
                              size_t len);

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-23 03:06:59 UTC (rev 224)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-23 12:25:21 UTC (rev 225)
@@ -199,21 +199,6 @@
 
     picpath = return_string_between(match, "\n", info_data);
     if (!picpath || strlen(picpath) == 0) {
-
-        if (d->thumbnail) {
-            hashurl =
-                g_hash_table_lookup(gaym->confighash,
-                                    "mini-profile-panel.thumbnail-prefix");
-            picurl = g_strdup_printf("%s%s", hashurl, d->thumbnail);
-            if (picurl) {
-                gaim_url_fetch(picurl, FALSE,
-                               "Mozilla/4.0 (compatible; MSIE 5.0)", FALSE,
-                               gaym_fetch_photo_cb, user_data);
-
-                return;
-            }
-
-        }
         gaim_notify_userinfo(d->gc, d->who,
                              t = g_strdup_printf("Gay.com - %s", d->who),
                              d->who, NULL, info, NULL, NULL);
@@ -222,7 +207,6 @@
     }
 
     picurl = g_strdup_printf("http://www.gay.com%s", picpath);
-
     if (picurl) {
         gaim_url_fetch(picurl, FALSE, "Mozilla/4.0 (compatible; MSIE 5.0)",
                        FALSE, gaym_fetch_photo_cb, user_data);
@@ -299,7 +283,6 @@
         data->who = g_strdup(args[1]);
         data->bio = gaym_bio_strdup(args[5]);
         data->stats = gaym_stats_strdup(args[5]);
-        data->thumbnail = gaym_thumbnail_strdup(args[5]);
 
         char *infourl = g_strdup_printf("%s?pw=%s&name=%s", hashurl,
                                         gaym->hash_pw, args[1]);
@@ -431,7 +414,7 @@
         if (!convo) {
             gaim_debug(GAIM_DEBUG_ERROR, "gaym",
                        "Got a NAMES list for %s, which doesn't exist\n",
-                       args[1]);
+                       args[2]);
             g_string_free(gaym->names, TRUE);
             gaym->names = NULL;
             g_free(gaym->nameconv);
@@ -459,52 +442,44 @@
             gaym->nameconv = NULL;
         } else {
             GList *users = NULL;
+            GList *flags = NULL;
 
-            gaim_debug_misc("gaym",
-                            "Using names for initial list population");
             while (*cur) {
+                GaimConvChatBuddyFlags f = GAIM_CBFLAGS_NONE;
                 end = strchr(cur, ' ');
-                /**
-                 * if (!end)
-                 * end = cur + strlen(cur);
-                 * if (*cur == '@') {
-                 * f = GAIM_CBFLAGS_OP;
-                 * cur++;
-                 * } else if (*cur == '%') {
-                 * f = GAIM_CBFLAGS_HALFOP;
-                 * cur++;
-                 * } else if (*cur == '+') {
-                 * f = GAIM_CBFLAGS_VOICE;
-                 * cur++;
-                 * }
-                 */
+                if (!end)
+                    end = cur + strlen(cur);
+                if (*cur == '@') {
+                    f = GAIM_CBFLAGS_OP;
+                    cur++;
+                } else if (*cur == '%') {
+                    f = GAIM_CBFLAGS_HALFOP;
+                    cur++;
+                } else if (*cur == '+') {
+                    f = GAIM_CBFLAGS_VOICE;
+                    cur++;
+                }
                 tmp = g_strndup(cur, end - cur);
-
-                gcom_nick_to_gaym(tmp);
                 users = g_list_prepend(users, tmp);
-                /* flags = g_list_prepend(flags, GINT_TO_POINTER(f)); */
+                flags = g_list_prepend(flags, GINT_TO_POINTER(f));
                 cur = end;
                 if (*cur)
                     cur++;
             }
-            /**
-             * users = g_list_reverse(users);
-             * flags = g_list_reverse(flags);
-             */
+            users = g_list_reverse(users);
+            flags = g_list_reverse(flags);
 
             if (users != NULL) {
                 GList *l;
 
                 gaim_conv_chat_add_users(GAIM_CONV_CHAT(convo), users,
-                                         gaym->join_flags);
+                                         flags);
 
-
                 for (l = users; l != NULL; l = l->next)
                     g_free(l->data);
 
                 g_list_free(users);
-                g_list_free(gaym->join_flags);
-                gaym->join_flags = NULL;
+                g_list_free(flags);
             }
         }
         g_free(names);
@@ -715,12 +690,12 @@
 
         serv_got_joined_chat(gc, id++, args[0]);
 
-	gint* entry=g_new(gint, 1);
-	gaim_debug_misc("gaym","Made int: %x\n",entry);
-	*entry=200;
-	
-        g_hash_table_insert(gaym->entry_order, g_strdup(args[0]), entry); 
-	g_free(nick);
+        gint *entry = g_new(gint, 1);
+        gaim_debug_misc("gaym", "Made int: %x\n", entry);
+        *entry = 200;
+
+        g_hash_table_insert(gaym->entry_order, g_strdup(args[0]), entry);
+        g_free(nick);
         return;
     }
 
@@ -743,11 +718,11 @@
         g_free(bio);
     }
 
-    gint* entry=g_hash_table_lookup(gaym->entry_order, args[0]);
+    gint *entry = g_hash_table_lookup(gaym->entry_order, args[0]);
 
-    if (*entry<201)
-	*entry=201;
-    
+    if (*entry < 201)
+        *entry = 201;
+
     flags = chat_pecking_order(args[1]);
     flags = include_chat_entry_order(flags, (*entry)++);
 
@@ -918,7 +893,7 @@
     gcom_nick_to_gaym(nick);
     if (!gaim_utf8_strcasecmp(nick, gaim_connection_get_display_name(gc))) {
 
-	g_hash_table_remove(gaym->entry_order, args[0]);
+        g_hash_table_remove(gaym->entry_order, args[0]);
         msg = g_strdup_printf(_("You have parted the channel"));
 
         gaim_conv_chat_write(GAIM_CONV_CHAT(convo), args[0], msg,
@@ -1275,7 +1250,7 @@
 {
     GaimConnection *gc = gaim_account_get_connection(gaym->account);
     GaimConversation *convo;
-    GaimConvChatBuddyFlags flags;
+    GaimConvChatBuddyFlags flags = GAIM_CBFLAGS_NONE;
     char *channel = args[1];
     char *nick = args[2];
     char *extra = args[4];
@@ -1305,22 +1280,17 @@
     }
 
     flags = chat_pecking_order(extra);
-    gint* entry = g_hash_table_lookup(gaym->entry_order, channel);
+    gint *entry = g_hash_table_lookup(gaym->entry_order, channel);
 
-    gaim_debug_misc("gaym","looked up int: %x, %i\n",entry,*entry);
+    gaim_debug_misc("gaym", "looked up int: %x, %i\n", entry, *entry);
     flags = include_chat_entry_order(flags, (*entry)--);
-    
-    gaim_debug_misc("gaym","flags: %i\n",flags);
-    /**
-     * g_hash_table_insert(gaym->join_flags, g_strdup(nick), flags);
-     */
-    //gaym->join_flags =
-    //    g_list_prepend(gaym->join_flags, GINT_TO_POINTER(flags));
-   
+
+    gaim_debug_misc("gaym", "flags: %i\n", flags);
+
     gaim_conv_chat_add_user(GAIM_CONV_CHAT(convo), nick, NULL, flags,
-      FALSE);
-     
+                            FALSE);
 
+
     /**
      * Make the ignore.png icon appear next to the nick.
      */



From deckrider at berlios.de  Sat Jul 23 14:54:47 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sat, 23 Jul 2005 14:54:47 +0200
Subject: [Qrc-svn] r226 - qrc/trunk/gaym/src
Message-ID: <200507231254.j6NCsllN004010@sheep.berlios.de>

Author: deckrider
Date: 2005-07-23 14:54:46 +0200 (Sat, 23 Jul 2005)
New Revision: 226

Modified:
   qrc/trunk/gaym/src/msgs.c
Log:
Adding back Jason's fix to gaym_msg_names():
   nick needs to be converted to internal format
   no flag information is received from the names command


Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-23 12:25:21 UTC (rev 225)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-23 12:54:46 UTC (rev 226)
@@ -442,44 +442,28 @@
             gaym->nameconv = NULL;
         } else {
             GList *users = NULL;
-            GList *flags = NULL;
 
             while (*cur) {
-                GaimConvChatBuddyFlags f = GAIM_CBFLAGS_NONE;
                 end = strchr(cur, ' ');
-                if (!end)
-                    end = cur + strlen(cur);
-                if (*cur == '@') {
-                    f = GAIM_CBFLAGS_OP;
-                    cur++;
-                } else if (*cur == '%') {
-                    f = GAIM_CBFLAGS_HALFOP;
-                    cur++;
-                } else if (*cur == '+') {
-                    f = GAIM_CBFLAGS_VOICE;
-                    cur++;
-                }
                 tmp = g_strndup(cur, end - cur);
+                gcom_nick_to_gaym(tmp);
                 users = g_list_prepend(users, tmp);
-                flags = g_list_prepend(flags, GINT_TO_POINTER(f));
                 cur = end;
                 if (*cur)
                     cur++;
             }
             users = g_list_reverse(users);
-            flags = g_list_reverse(flags);
 
             if (users != NULL) {
                 GList *l;
 
                 gaim_conv_chat_add_users(GAIM_CONV_CHAT(convo), users,
-                                         flags);
+                                         NULL);
 
                 for (l = users; l != NULL; l = l->next)
                     g_free(l->data);
 
                 g_list_free(users);
-                g_list_free(flags);
             }
         }
         g_free(names);



From deckrider at berlios.de  Sat Jul 23 15:27:48 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sat, 23 Jul 2005 15:27:48 +0200
Subject: [Qrc-svn] r227 - qrc/trunk/gaym/src
Message-ID: <200507231327.j6NDRmqS006562@sheep.berlios.de>

Author: deckrider
Date: 2005-07-23 15:27:44 +0200 (Sat, 23 Jul 2005)
New Revision: 227

Modified:
   qrc/trunk/gaym/src/gaym.c
Log:
Added g_hash_table_destroy(gaym->entry_order) for gaym_close() cleanup.


Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-23 12:54:46 UTC (rev 226)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-23 13:27:44 UTC (rev 227)
@@ -524,10 +524,9 @@
      */
     gaym->info_window_needed =
         g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
-    
+
     gaym->entry_order =
-	g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
-	
+        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
 
     /**
      * This is similar to gaym->info_window_needed, except this is
@@ -670,7 +669,7 @@
 {
     struct gaym_conn *gaym = gc->proto_data;
 
-    gaim_debug_misc("gaym","gaym close function has been called\n");
+    gaim_debug_misc("gaym", "gaym close function has been called\n");
     if (gaym == NULL)
         return;
 
@@ -680,49 +679,51 @@
         gaim_input_remove(gc->inpa);
 
     g_free(gaym->inbuf);
-    gaim_debug_misc("gaym","closing fd %i\n",gaym->fd);
+    gaim_debug_misc("gaym", "closing fd %i\n", gaym->fd);
     close(gaym->fd);
 
     if (gaym->timer)
         gaim_timeout_remove(gaym->timer);
 
     if (gaym->thumbnail)
-	g_free(gaym->thumbnail);
+        g_free(gaym->thumbnail);
 
     if (gaym->hash_pw)
-	g_free(gaym->hash_pw);
+        g_free(gaym->hash_pw);
 
     if (gaym->server_bioline)
-	g_free(gaym->server_bioline);
+        g_free(gaym->server_bioline);
 
     if (gaym->server_stats)
-	g_free(gaym->server_stats);
+        g_free(gaym->server_stats);
 
     if (gaym->roomlist_filter)
-	g_free(gaym->roomlist_filter);
+        g_free(gaym->roomlist_filter);
 
     if (gaym->bio)
-	g_free(gaym->bio);
-    
+        g_free(gaym->bio);
+
     g_hash_table_destroy(gaym->cmds);
     g_hash_table_destroy(gaym->msgs);
     g_hash_table_destroy(gaym->info_window_needed);
+    g_hash_table_destroy(gaym->entry_order);
     g_hash_table_destroy(gaym->im_thumbnail_needed);
     if (gaym->motd)
         g_string_free(gaym->motd, TRUE);
 
     if (gaym->names)
-	g_string_free(gaym->names, TRUE);
-    
+        g_string_free(gaym->names, TRUE);
+
     if (gaym->nameconv)
-	g_free(gaym->nameconv);
+        g_free(gaym->nameconv);
     if (gaym->subroom)
-	g_free(gaym->subroom);
+        g_free(gaym->subroom);
 
     g_hash_table_destroy(gaym->confighash);
 
     if (gaym->hammer_cancel_dialog)
-	gaim_request_close(GAIM_REQUEST_ACTION, gaym->hammer_cancel_dialog);
+        gaim_request_close(GAIM_REQUEST_ACTION,
+                           gaym->hammer_cancel_dialog);
 
     g_free(gaym->server);
     g_free(gaym);
@@ -1055,6 +1056,7 @@
     gaym_cmd_part(gaym, "part", gaim_conversation_get_name(convo), args);
     serv_got_chat_left(gc, id);
 }
+
 static int gaym_chat_send(GaimConnection * gc, int id, const char *what)
 {
     struct gaym_conn *gaym = gc->proto_data;



From deckrider at berlios.de  Sat Jul 23 18:34:14 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sat, 23 Jul 2005 18:34:14 +0200
Subject: [Qrc-svn] r228 - in qrc/trunk: . gaym/src
Message-ID: <200507231634.j6NGYEAL026561@sheep.berlios.de>

Author: deckrider
Date: 2005-07-23 18:33:58 +0200 (Sat, 23 Jul 2005)
New Revision: 228

Modified:
   qrc/trunk/ChangeLog
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gaym.h
   qrc/trunk/gaym/src/msgs.c
Log:
Add preference to allow members to be sorted either by entrance time
or by category + name.

Add and use MAX_CHANNEL_MEMBERS (currently set to 200).


Modified: qrc/trunk/ChangeLog
===================================================================
--- qrc/trunk/ChangeLog	2005-07-23 13:27:44 UTC (rev 227)
+++ qrc/trunk/ChangeLog	2005-07-23 16:33:58 UTC (rev 228)
@@ -7,6 +7,8 @@
 	  (Room Name:*) is both a Category (which can be expanded) and a
 	  Room (which can be joined), with the individual Room Instances
 	  as children
+	- Room members can now be sorted by length of time in the
+	  room (longest in the room at the bottom)
 
 	Bug Fixes:
 	- Better refreshing of stale buddy list photos
@@ -20,7 +22,7 @@
 	- Addressed several memory leaks
 
 	Preference Changes:
-	- none
+	- Sort chat room members by entrance time or category + name
 
 0.34.1:
 	Bug Fixes:

Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-23 13:27:44 UTC (rev 227)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-23 16:33:58 UTC (rev 228)
@@ -1399,6 +1399,18 @@
 
     ppref =
         gaim_plugin_pref_new_with_name_and_label
+        ("/plugins/prpl/gaym/chat_member_sorting",
+         _
+         ("Sort members by\n\t(changes do not affect rooms you are already in)"));
+    gaim_plugin_pref_set_type(ppref, GAIM_PLUGIN_PREF_CHOICE);
+    gaim_plugin_pref_add_choice(ppref, _("Entrance time"),
+                                GINT_TO_POINTER(1));
+    gaim_plugin_pref_add_choice(ppref, _("Category + Name"),
+                                GINT_TO_POINTER(2));
+    gaim_plugin_pref_frame_add(frame, ppref);
+
+    ppref =
+        gaim_plugin_pref_new_with_name_and_label
         ("/plugins/prpl/gaym/chat_room_instances",
          _("Number of chat room instances to display"));
     gaim_plugin_pref_set_bounds(ppref, 0, 9);
@@ -1506,6 +1518,7 @@
                         GAIM_CALLBACK(gaym_get_photo_info), NULL);
 
     gaim_prefs_add_none("/plugins/prpl/gaym");
+    gaim_prefs_add_int("/plugins/prpl/gaym/chat_member_sorting", 1);
     gaim_prefs_add_int("/plugins/prpl/gaym/chat_room_instances", 4);
     gaim_prefs_add_bool("/plugins/prpl/gaym/show_join", TRUE);
     gaim_prefs_add_bool("/plugins/prpl/gaym/show_part", TRUE);

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-23 13:27:44 UTC (rev 227)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-23 16:33:58 UTC (rev 228)
@@ -42,8 +42,21 @@
 
 #define MAX_BIO_LEN 150         /* max number of characters in bio */
 
+#define MAX_CHANNEL_MEMBERS 200
+
 #define GAYBOI_SPAM_URL "http://gayboi.org/spam/spamlst.php"
 
+typedef enum {
+    GAYM_CHAT_SORT_TIME = 1,    /* Entrance time */
+    GAYM_CHAT_SORT_FLAGS        /* Category + Nick/Name */
+} GaymChatSortType;
+
+typedef struct _ChatSort ChatSort;
+struct _ChatSort {
+    gint type;
+    gint counter;
+};
+
 typedef struct _BListWhois BListWhois;
 struct _BListWhois {
     int count;

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-23 13:27:44 UTC (rev 227)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-23 16:33:58 UTC (rev 228)
@@ -648,6 +648,8 @@
                    const char *from, char **args)
 {
     GaimConnection *gc = gaim_account_get_connection(gaym->account);
+    g_return_if_fail(gc != NULL);
+
     char *nick = gaym_mask_nick(from);
 
     GaimConversation *convo;
@@ -656,11 +658,6 @@
     char *bio_markedup = NULL;
     static int id = 1;
 
-    if (!gc) {
-        g_free(nick);
-        return;
-    }
-
     gcom_nick_to_gaym(nick);
     if (!gaim_utf8_strcasecmp(nick, gaim_connection_get_display_name(gc))) {
         /* We are joining a channel for the first time */
@@ -674,11 +671,14 @@
 
         serv_got_joined_chat(gc, id++, args[0]);
 
-        gint *entry = g_new(gint, 1);
-        gaim_debug_misc("gaym", "Made int: %x\n", entry);
-        *entry = 200;
+        ChatSort *chat_sort = g_new0(ChatSort, 1);
 
-        g_hash_table_insert(gaym->entry_order, g_strdup(args[0]), entry);
+        chat_sort->type =
+            gaim_prefs_get_int("/plugins/prpl/gaym/chat_member_sorting");
+        chat_sort->counter = MAX_CHANNEL_MEMBERS;
+
+        g_hash_table_insert(gaym->entry_order, g_strdup(args[0]),
+                            chat_sort);
         g_free(nick);
         return;
     }
@@ -691,6 +691,9 @@
         return;
     }
 
+    ChatSort *chat_sort = g_hash_table_lookup(gaym->entry_order, args[0]);
+    g_return_if_fail(chat_sort != NULL);
+
     gaym_buddy_status(gaym, nick, TRUE, args[1]);
 
     gboolean gaym_botfilter_permit =
@@ -702,14 +705,16 @@
         g_free(bio);
     }
 
-    gint *entry = g_hash_table_lookup(gaym->entry_order, args[0]);
+    if (chat_sort->counter <= MAX_CHANNEL_MEMBERS) {
+        chat_sort->counter = MAX_CHANNEL_MEMBERS + 1;
+    }
 
-    if (*entry < 201)
-        *entry = 201;
-
     flags = chat_pecking_order(args[1]);
-    flags = include_chat_entry_order(flags, (*entry)++);
 
+    if (chat_sort->type == GAYM_CHAT_SORT_TIME) {
+        flags = include_chat_entry_order(flags, chat_sort->counter++);
+    }
+
     gboolean gaym_privacy_permit = gaym_privacy_check(gc, nick);
     gboolean show_join =
         gaim_prefs_get_bool("/plugins/prpl/gaym/show_join");
@@ -1263,18 +1268,18 @@
         return;
     }
 
+    ChatSort *chat_sort = g_hash_table_lookup(gaym->entry_order, channel);
+    g_return_if_fail(chat_sort != NULL);
+
     flags = chat_pecking_order(extra);
-    gint *entry = g_hash_table_lookup(gaym->entry_order, channel);
 
-    gaim_debug_misc("gaym", "looked up int: %x, %i\n", entry, *entry);
-    flags = include_chat_entry_order(flags, (*entry)--);
+    if (chat_sort->type == GAYM_CHAT_SORT_TIME) {
+        flags = include_chat_entry_order(flags, chat_sort->counter--);
+    }
 
-    gaim_debug_misc("gaym", "flags: %i\n", flags);
-
     gaim_conv_chat_add_user(GAIM_CONV_CHAT(convo), nick, NULL, flags,
                             FALSE);
 
-
     /**
      * Make the ignore.png icon appear next to the nick.
      */



From jblebrun at berlios.de  Sat Jul 23 19:36:45 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Sat, 23 Jul 2005 19:36:45 +0200
Subject: [Qrc-svn] r229 - in qrc/trunk: . gaym-extras
Message-ID: <200507231736.j6NHajRh009172@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-23 19:36:35 +0200 (Sat, 23 Jul 2005)
New Revision: 229

Added:
   qrc/trunk/gaym-extras/
   qrc/trunk/gaym-extras/chatsort.c
   qrc/trunk/gaym-extras/gaym-extras.c
   qrc/trunk/gaym-extras/roombrowse.c
Removed:
   qrc/trunk/chaticon/
   qrc/trunk/roombrowse/
Log:
Combining all gtk-specific plugins into one plugin, for simplicity.
The current planned functionalities for this plugin are:

1. The ability to show icons and bios in the chat room.
2. A new kind of conversation window that previews a room.
3. The ability to change sort criteria.




Added: qrc/trunk/gaym-extras/chatsort.c
===================================================================
--- qrc/trunk/gaym-extras/chatsort.c	2005-07-23 16:33:58 UTC (rev 228)
+++ qrc/trunk/gaym-extras/chatsort.c	2005-07-23 17:36:35 UTC (rev 229)
@@ -0,0 +1,88 @@
+/* Attempt to sort chat users by entry order, instead of alpha */
+#include "internal.h"
+#include "gtkgaim.h"
+
+#include "conversation.h"
+#include "debug.h"
+#include "log.h"
+#include "prefs.h"
+#include "signals.h"
+#include "util.h"
+#include "version.h"
+
+#include "gtkconv.h"
+#include "gtkimhtml.h"
+#include "gtkplugin.h"
+
+#define CHATSORT_PLUGIN_ID "gtk-chatsort"
+
+
+//A dummy sort function... don't sort at all!
+static gint sort_chat_users(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer userdata) {
+return 1;
+}
+
+//This gets called BEFORE a chatlist is populated... just creates a new type of chat window.
+static void redochatwindow(GaimConversation *c) {
+
+	GtkTreeModel *oldls;
+	GtkTreeSelection *select;
+	GtkTreeIter iter;
+
+	//Get a handle to the chat pane for the conversation
+	GaimGtkConversation* gtkconv = GAIM_GTK_CONVERSATION(c);
+	GaimGtkChatPane* gtkchat = gtkconv->u.chat;
+
+	
+	oldls = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
+	select = gtk_tree_view_get_selection(GTK_TREE_VIEW(gtkchat->list));
+
+	//This is a dummy "root" item. If it's not here,
+	//then the first name entered into the list gets "stucK" at the
+	//top. This is a hack.
+	gtk_list_store_append(GTK_LIST_STORE(oldls), &iter);
+	gtk_list_store_set(GTK_LIST_STORE(oldls), &iter, CHAT_USERS_NAME_COLUMN, " ", -1);
+        gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(oldls), CHAT_USERS_NAME_COLUMN, sort_chat_users, NULL, NULL);
+	
+}
+
+static gboolean plugin_load(GaimPlugin *plugin)
+{
+	gaim_signal_connect(gaim_conversations_get_handle(),
+						"chat-joined",
+						plugin, GAIM_CALLBACK(redochatwindow), NULL);
+	
+	return TRUE;
+}
+
+static GaimPluginInfo info =
+{
+	GAIM_PLUGIN_MAGIC,
+	GAIM_MAJOR_VERSION,
+	GAIM_MINOR_VERSION,
+	GAIM_PLUGIN_STANDARD,
+	GAIM_GTK_PLUGIN_TYPE,
+	0,
+	NULL,
+	GAIM_PRIORITY_DEFAULT,
+	CHATSORT_PLUGIN_ID,
+	N_("Chatroom Sort options"),
+	VERSION,
+	N_("Changes the sorting options of chatroom lists."),
+	N_("When a new conversation is opened this plugin will insert the last conversation into the current conversation."),
+	"Jason LeBrun <gaim at jasonlebrun.info",
+	GAIM_WEBSITE,
+	plugin_load,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static void
+init_plugin(GaimPlugin *plugin)
+{
+}
+
+GAIM_INIT_PLUGIN(history, init_plugin, info)

Added: qrc/trunk/gaym-extras/gaym-extras.c
===================================================================
--- qrc/trunk/gaym-extras/gaym-extras.c	2005-07-23 16:33:58 UTC (rev 228)
+++ qrc/trunk/gaym-extras/gaym-extras.c	2005-07-23 17:36:35 UTC (rev 229)
@@ -0,0 +1,106 @@
+/* Show icons in chat room windows */
+
+#include "internal.h"
+#include "gtkgaim.h"
+
+#include "conversation.h"
+#include "debug.h"
+#include "log.h"
+#include "prefs.h"
+#include "signals.h"
+#include "util.h"
+#include "version.h"
+
+#include "gtkconv.h"
+#include "gtkimhtml.h"
+#include "gtkplugin.h"
+
+#define CHATSORT_PLUGIN_ID "gtk-chaticon"
+
+GHashTable* icons;
+GHashTable* icon_spots;
+static void clear_icon() {
+
+}
+static void changed_cb(GtkTreeSelection* selection, gpointer data){
+
+	GaimConversation* c = (GaimConversation*)data;
+	GtkTreeIter iter;
+	GtkTreeModel* model;
+	gchar* name;
+	GaimConversation *temp;
+	gtk_tree_selection_get_selected(selection, &model, &iter);
+	gtk_tree_model_get(model,&iter,CHAT_USERS_NAME_COLUMN, &name, -1);
+
+	gaim_debug_misc("chatsort","Click: %s\n",name);
+	gtk_button_set_label(g_hash_table_lookup(icon_spots, c), name);
+	//Look in local icon cache here.
+	//If the icon isn't here, get it from gaym
+	//Update the widget
+}
+//This gets called BEFORE a chatlist is populated... just creates a new type of chat window.
+static void redochatwindow(GaimConversation *c) {
+
+	GtkTreeModel *oldls;
+	
+	//Get a handle to the chat pane for the conversation
+	GaimGtkConversation* gtkconv = GAIM_GTK_CONVERSATION(c);
+	GaimGtkChatPane* gtkchat = gtkconv->u.chat;
+	GtkTreeSelection* select = gtk_tree_view_get_selection(GTK_TREE_VIEW(gtkchat->list));
+	gtk_tree_selection_set_mode(select, GTK_SELECTION_SINGLE);
+
+	oldls = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));	
+	GtkBox* vbox = GTK_BOX(gtkchat->list->parent->parent);
+	GtkWidget* button = gtk_button_new_with_label("A Button");
+	g_signal_connect(G_OBJECT(select), "changed", G_CALLBACK(changed_cb), c);
+
+	gtk_box_pack_end(vbox, GTK_WIDGET(button), FALSE, FALSE, 0);
+	gtk_widget_show(button);
+	g_hash_table_insert(icon_spots, c, button);
+	
+
+}
+
+
+static gboolean plugin_load(GaimPlugin *plugin)
+{
+	icons=g_hash_table_new(g_direct_hash, g_direct_equal);
+	icon_spots=g_hash_table_new(g_direct_hash, g_direct_equal);
+	
+	gaim_signal_connect(gaim_conversations_get_handle(), "chat-joined", plugin, GAIM_CALLBACK(redochatwindow), NULL);
+	gaim_signal_connect(gaim_conversations_get_handle(), "chat-buddy-left", plugin, GAIM_CALLBACK(clear_icon), NULL);
+
+	return TRUE;
+}
+
+static GaimPluginInfo info =
+{
+	GAIM_PLUGIN_MAGIC,
+	GAIM_MAJOR_VERSION,
+	GAIM_MINOR_VERSION,
+	GAIM_PLUGIN_STANDARD,
+	GAIM_GTK_PLUGIN_TYPE,
+	0,
+	NULL,
+	GAIM_PRIORITY_DEFAULT,
+	CHATSORT_PLUGIN_ID,
+	N_("Chatroom Icons"),
+	VERSION,
+	N_("Shows user thumbnails below the names list in a chatroom."),
+	N_("Shows user thumbnails below the names list in a chatroom."),
+	"Jason LeBrun <gaim at jasonlebrun.info",
+	GAIM_WEBSITE,
+	plugin_load,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static void
+init_plugin(GaimPlugin *plugin)
+{
+}
+
+GAIM_INIT_PLUGIN(history, init_plugin, info)

Added: qrc/trunk/gaym-extras/roombrowse.c
===================================================================
--- qrc/trunk/gaym-extras/roombrowse.c	2005-07-23 16:33:58 UTC (rev 228)
+++ qrc/trunk/gaym-extras/roombrowse.c	2005-07-23 17:36:35 UTC (rev 229)
@@ -0,0 +1,455 @@
+/* Puts last 4k of log in new conversations a la Everybuddy (and then
+ * stolen by Trillian "Pro") */
+
+#include "internal.h"
+#include "gtkgaim.h"
+
+#include "conversation.h"
+#include "debug.h"
+#include "log.h"
+#include "prefs.h"
+#include "signals.h"
+#include "util.h"
+#include "version.h"
+#include "prpl.h"
+
+#include "gtkconv.h"
+#include "gtkimhtml.h"
+#include "gtkplugin.h"
+#include "gtkdialogs.h"
+#include "gtkutils.h"
+#include "gtkblist.h"
+#include "gtkimhtmltoolbar.h"
+#include <gdk/gdkkeysyms.h>
+
+#define CHATSORT_PLUGIN_ID "gtk-chatsort"
+#define CHATSORT_USERS_COLUMNS 4
+#define CHATSORT_USERS_ENTRY_COLUMN 3
+
+/**
+ * Unused variables:
+ *
+ * static GList *browsers = NULL;
+ */
+
+struct RoomBrowseInfo {
+
+	GaimAccount *account;
+	GaimConnection *gc;
+};
+	
+static GtkWidget *
+setup_roombrowse_pane(GaimConversation *conv)
+{
+	GaimGtkConversation *gtkconv;
+	GaimGtkChatPane *gtkchat;
+	GaimConnection *gc;
+	GtkWidget *vpaned, *hpaned;
+	GtkWidget *vbox;
+
+	/**
+	 * Unused variables:
+	 *
+	 * GaimPluginProtocolInfo *prpl_info = NULL;
+	 * GtkWidget *hbox;
+	 * GtkWidget *lbox, *bbox;
+	 * GtkWidget *label;
+	 * GtkWidget *list;
+	 * GtkWidget *button;
+	 * GtkWidget *sw;
+	 * GtkListStore *ls;
+	 * GtkCellRenderer *rend;
+	 * GtkTreeViewColumn *col;
+	 * GList *focus_chain = NULL;
+	 */
+
+	gtkconv = GAIM_GTK_CONVERSATION(conv);
+	gtkchat = gtkconv->u.chat;
+	gc      = gaim_conversation_get_gc(conv);
+
+	/* Setup the outer pane. */
+	vpaned = gtk_vpaned_new();
+	gtk_widget_show(vpaned);
+	/* Setup the top part of the pane. */
+	vbox = gtk_vbox_new(FALSE, 6);
+	gtk_paned_pack1(GTK_PANED(vpaned), vbox, TRUE, TRUE);
+	gtk_widget_show(vbox);
+
+	/* Setup the horizontal pane. */
+	hpaned = gtk_hpaned_new();
+	gtk_box_pack_start(GTK_BOX(vbox), hpaned, TRUE, TRUE, 0);
+	gtk_widget_show(hpaned);
+
+	/* Setup the scrolled window to put gtkimhtml in. */
+	gtkconv->sw = gtk_scrolled_window_new(NULL, NULL);
+	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(gtkconv->sw),
+								   GTK_POLICY_AUTOMATIC, GTK_POLICY_ALWAYS);
+	gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(gtkconv->sw),
+										GTK_SHADOW_IN);
+	gtk_paned_pack1(GTK_PANED(hpaned), gtkconv->sw, TRUE, TRUE);
+
+	gtk_widget_set_size_request(gtkconv->sw,
+			gaim_prefs_get_int("/gaim/gtk/conversations/chat/default_width"),
+			gaim_prefs_get_int("/gaim/gtk/conversations/chat/default_height"));
+
+//	g_signal_connect(G_OBJECT(gtkconv->sw), "size-allocate",
+//					 G_CALLBACK(size_allocate_cb), conv);
+
+	gtk_widget_show(gtkconv->sw);
+
+	return vpaned;
+}
+
+static gint
+close_conv_cb(GtkWidget *w, gpointer d)
+{
+        GaimConversation *conv = (GaimConversation *)d;
+	
+        gaim_conversation_destroy(conv);
+
+        return TRUE;
+}
+GdkPixbuf* get_tab_icon(GaimConversation *conv, gboolean small_icon)
+{
+        GaimAccount *account = NULL;
+        const char *name = NULL;
+        GdkPixbuf *status = NULL;
+
+        g_return_val_if_fail( conv != NULL, NULL);
+
+        account = gaim_conversation_get_account(conv);
+        name = gaim_conversation_get_name(conv);
+
+        g_return_val_if_fail( account != NULL, NULL);
+        g_return_val_if_fail( name != NULL, NULL);
+
+
+        if (gaim_conversation_get_type(conv) == GAIM_CONV_IM) {
+                GaimBuddy *b = gaim_find_buddy(account, name);
+                if (b != NULL) {
+                        status = gaim_gtk_blist_get_status_icon((GaimBlistNode*)b,
+                                (small_icon ? GAIM_STATUS_ICON_SMALL : GAIM_STATUS_ICON_LARGE));
+                }
+        }
+
+        if (!status) {
+                GdkPixbuf *pixbuf;
+                pixbuf = create_prpl_icon(account);
+
+                if (small_icon && pixbuf != NULL)
+                {
+                        status = gdk_pixbuf_scale_simple(pixbuf, 15, 15,
+                                        GDK_INTERP_BILINEAR);
+                        g_object_unref(pixbuf);
+                }
+                else
+                        status = pixbuf;
+        }
+ return status;
+}
+
+/**
+ * Unused function
+ */
+#if 0
+static void
+update_tab_icon(GaimConversation *conv)
+{
+        GaimGtkConversation *gtkconv;
+        GaimConvWindow *win = gaim_conversation_get_window(conv);
+        GaimAccount *account;
+        const char *name;
+        GdkPixbuf *status = NULL;
+
+        g_return_if_fail(conv != NULL);
+
+        gtkconv = GAIM_GTK_CONVERSATION(conv);
+        name = gaim_conversation_get_name(conv);
+        account = gaim_conversation_get_account(conv);
+
+        status = get_tab_icon(conv, TRUE);
+
+        g_return_if_fail(status != NULL);
+
+        gtk_image_set_from_pixbuf(GTK_IMAGE(gtkconv->icon), status);
+        gtk_image_set_from_pixbuf(GTK_IMAGE(gtkconv->menu_icon), status);
+
+        if (status != NULL)
+                g_object_unref(status);
+
+        if (gaim_conv_window_get_active_conversation(win) == conv &&
+                gtkconv->u.im->anim == NULL)
+        {
+                status = get_tab_icon(conv, FALSE);
+
+                gtk_window_set_icon(GTK_WINDOW(GAIM_GTK_WINDOW(win)->window), status);
+
+                if (status != NULL)
+                        g_object_unref(status);
+        }
+}
+#endif
+
+/* Courtesy of Galeon! */
+static void
+tab_close_button_state_changed_cb(GtkWidget *widget, GtkStateType prev_state)
+{
+        if (GTK_WIDGET_STATE(widget) == GTK_STATE_ACTIVE)
+                gtk_widget_set_state(widget, GTK_STATE_NORMAL);
+}
+
+static void
+roombrowse_gtk_add_conversation(GaimConvWindow *win, GaimConversation *conv)
+{
+	GaimGtkWindow *gtkwin;
+	GaimGtkConversation *gtkconv, *focus_gtkconv;
+	GaimConversation *focus_conv;
+	GtkWidget *pane = NULL;
+	GtkWidget *tab_cont;
+	GtkWidget *tabby, *menu_tabby;
+	GtkWidget *close_image;
+	gboolean new_ui;
+	GaimConversationType conv_type;
+	const char *name;
+
+	name      = gaim_conversation_get_name(conv);
+	conv_type = gaim_conversation_get_type(conv);
+	gtkwin    = GAIM_GTK_WINDOW(win);
+
+	if (conv->ui_data != NULL) {
+		gtkconv = (GaimGtkConversation *)conv->ui_data;
+
+		tab_cont = gtkconv->tab_cont;
+
+		new_ui = FALSE;
+	}
+	else {
+		gtkconv = g_malloc0(sizeof(GaimGtkConversation));
+		conv->ui_data = gtkconv;
+
+		/* Setup some initial variables. */
+		gtkconv->sg       = gtk_size_group_new(GTK_SIZE_GROUP_BOTH);
+		gtkconv->tooltips = gtk_tooltips_new();
+
+	gaim_debug_misc("roombrowse","setting up pane\n");	
+		pane = setup_roombrowse_pane(conv);
+		
+	gaim_debug_misc("roombrowse","set up pane\n");	
+
+		if (pane == NULL) {
+			g_free(gtkconv);
+			conv->ui_data = NULL;
+
+			return;
+		}
+
+		
+		
+		/* Setup the container for the tab. */
+		gtkconv->tab_cont = tab_cont = gtk_vbox_new(FALSE, 6);
+		gtk_container_set_border_width(GTK_CONTAINER(tab_cont), 6);
+		gtk_container_add(GTK_CONTAINER(tab_cont), pane);
+		gtk_widget_show(pane);
+
+		new_ui = TRUE;
+
+		gtkconv->make_sound = FALSE;
+		gtkconv->show_formatting_toolbar = FALSE;
+		gtkconv->show_timestamps = FALSE;
+		
+		g_signal_connect_swapped(G_OBJECT(pane), "focus",
+					 G_CALLBACK(gtk_widget_grab_focus),
+					 gtkconv->entry);
+	}
+
+	gaim_debug_misc("roombrowse","Setting up tabs\n");
+	gtkconv->tabby = tabby = gtk_hbox_new(FALSE, 6);
+        gtkconv->menu_tabby = menu_tabby = gtk_hbox_new(FALSE, 6);
+	gtkconv->entry = gtk_imhtml_new(NULL, NULL);
+		gtkconv->toolbar = gtk_imhtmltoolbar_new();
+
+	gaim_debug_misc("roombrowse","Setting up close button\n");
+	/* Close button. */
+	gtkconv->close = gtk_button_new();
+	gtk_widget_set_size_request(GTK_WIDGET(gtkconv->close), 16, 16);
+	gtk_button_set_relief(GTK_BUTTON(gtkconv->close), GTK_RELIEF_NONE);
+	close_image = gtk_image_new_from_stock(GTK_STOCK_CLOSE, GTK_ICON_SIZE_MENU);
+	gtk_widget_show(close_image);
+	gtk_container_add(GTK_CONTAINER(gtkconv->close), close_image);
+	gtk_tooltips_set_tip(gtkconv->tooltips, gtkconv->close,
+			     _("Close conversation"), NULL);
+
+	g_signal_connect(G_OBJECT(gtkconv->close), "clicked",
+		 G_CALLBACK(close_conv_cb), conv);
+
+	/*
+	* I love Galeon. They have a fix for that stupid annoying visible
+	* border bug. I love you guys! -- ChipX86
+	*/
+	g_signal_connect(G_OBJECT(gtkconv->close), "state_changed",
+			 G_CALLBACK(tab_close_button_state_changed_cb), NULL);
+
+	/* Status icon. */
+	gtkconv->icon = gtk_image_new();
+	gtkconv->menu_icon = gtk_image_new();
+//	update_tab_icon(conv);
+
+	/* Tab label. */
+	gtkconv->tab_label = gtk_label_new(gaim_conversation_get_title(conv));
+	gtkconv->menu_label = gtk_label_new(gaim_conversation_get_title(conv));
+#if 0
+	gtk_misc_set_alignment(GTK_MISC(gtkconv->tab_label), 0.00, 0.5);
+	gtk_misc_set_padding(GTK_MISC(gtkconv->tab_label), 4, 0);
+#endif
+
+	gaim_debug_misc("roombrowse","Packing\n");
+	/* Pack it all together. */
+	gtk_box_pack_start(GTK_BOX(tabby), gtkconv->icon, FALSE, FALSE, 0);
+	gtk_box_pack_start(GTK_BOX(menu_tabby), gtkconv->menu_icon,
+			   FALSE, FALSE, 0);
+
+	gtk_widget_show_all(gtkconv->icon);
+	gtk_widget_show_all(gtkconv->menu_icon);
+
+	gtk_box_pack_start(GTK_BOX(tabby), gtkconv->tab_label, TRUE, TRUE, 0);
+	gtk_box_pack_start(GTK_BOX(menu_tabby), gtkconv->menu_label, TRUE, TRUE, 0);
+	gtk_widget_show(gtkconv->tab_label);
+	gtk_widget_show(gtkconv->menu_label);
+	gtk_misc_set_alignment(GTK_MISC(gtkconv->menu_label), 0, 0);
+
+	gtk_box_pack_start(GTK_BOX(tabby), gtkconv->close, FALSE, FALSE, 0);
+	if (gaim_prefs_get_bool("/gaim/gtk/conversations/close_on_tabs"))
+		gtk_widget_show(gtkconv->close);
+
+	gtk_widget_show(tabby);
+	gtk_widget_show(menu_tabby);
+
+	if (gaim_conversation_get_type(conv) == GAIM_CONV_IM)
+		gaim_gtkconv_update_buddy_icon(conv);
+
+	gaim_debug_misc("roombrowse","Adding to notebook\n");
+	gaim_debug_misc("roombrowse","gtkwin->notebook=%x\n",gtkwin->notebook);
+	gaim_debug_misc("roombrowse","gtkwin=%x\n",gtkwin);
+	gaim_debug_misc("roombrowse","tabby=%x\n",tabby);
+	gaim_debug_misc("roombrowse","menu_tabby=%x\n",menu_tabby);
+	gaim_debug_misc("roombrowse","tab_cont=%x\n",tab_cont);
+
+	/* Add this pane to the conversation's notebook. */
+	int n=	gtk_notebook_get_n_pages(GTK_NOTEBOOK(gtkwin->notebook));
+	gaim_debug_misc("roombrowse:","Notebook has %d pages\n",n);
+	gtk_notebook_append_page_menu(GTK_NOTEBOOK(gtkwin->notebook), tab_cont, tabby, menu_tabby);
+	gaim_debug_misc("roombrowse","Got through append_page_menu\n");
+	gtk_widget_show(tab_cont);
+	
+	if (gaim_conv_window_get_conversation_count(win) == 1) {
+		/* Er, bug in notebooks? Switch to the page manually. */
+		gtk_notebook_set_current_page(GTK_NOTEBOOK(gtkwin->notebook), 0);
+
+		gtk_notebook_set_show_tabs(GTK_NOTEBOOK(gtkwin->notebook),
+					   gaim_prefs_get_bool("/gaim/gtk/conversations/tabs"));
+	}
+	else
+		gtk_notebook_set_show_tabs(GTK_NOTEBOOK(gtkwin->notebook), TRUE);
+	gaim_debug_misc("roombrowse","FOcus stuff\n");
+	focus_conv = g_list_nth_data(gaim_conv_window_get_conversations(win),
+				     gtk_notebook_get_current_page(GTK_NOTEBOOK(gtkwin->notebook)));
+	focus_gtkconv = GAIM_GTK_CONVERSATION(focus_conv);
+	gtk_widget_grab_focus(focus_gtkconv->entry);
+
+	if (!new_ui)
+		g_object_unref(gtkconv->tab_cont);
+}
+
+
+static void roombrowse_menu_cb(GaimBlistNode* node, gpointer data) {
+	GaimConvWindow *win=gaim_get_first_window_with_type(GAIM_CONV_MISC);
+	GaimConversation *conv=g_new0(GaimConversation, 1);
+
+	GaimAccount* account=((GaimChat*)node)->account;
+	if(!win)
+		win=gaim_conv_window_new();
+	GaimChat* chat = ((GaimChat*)node);
+	char *room= g_strdup(g_hash_table_lookup(chat->components,"name"));
+
+	
+	gaim_debug_misc("roombrowser","In cb with node=%x, account=%x\n",node,account);
+	conv=gaim_conversation_new(GAIM_CONV_MISC, account, room);
+	
+	gaim_conversation_set_logging(conv, FALSE);
+		
+	roombrowse_gtk_add_conversation(conv->window, conv);
+	gaim_conv_window_show(conv->window);
+
+	g_free(room);
+	
+}
+static void roombrowse_menu_create(GaimBlistNode *node, GList **menu)
+{
+  
+	char *label,*room;	
+  
+	struct gaym_conn *gaym;
+	GaimChat *chat=(GaimChat*)node;
+  
+	gaim_debug_misc("roombrowse","In callback\n");
+	if(node->type != GAIM_BLIST_CHAT_NODE)
+		return;
+  
+	gaym=chat->account->gc->proto_data;
+  
+	room=g_strdup(g_hash_table_lookup(chat->components,"name"));
+	gaim_debug_misc("roombrowse","Room name: %s\n",room);
+	if(!room)
+		return;
+  
+    
+		label = g_strdup_printf("Lurk in %s",room);
+		GaimBlistNodeAction* act=gaim_blist_node_action_new(label,
+				roombrowse_menu_cb,
+				chat->account);
+  
+		*menu=g_list_append(*menu,act);
+    //g_free(label);
+}
+static gboolean plugin_load(GaimPlugin *plugin)
+{
+	gaim_signal_connect(gaim_blist_get_handle(),
+						"blist-node-extended-menu",
+						plugin, GAIM_CALLBACK(roombrowse_menu_create), NULL);
+
+	
+	gaim_debug_misc("roombrowse","Callback registered!\n");	
+	return TRUE;
+}
+
+static GaimPluginInfo info =
+{
+	GAIM_PLUGIN_MAGIC,
+	GAIM_MAJOR_VERSION,
+	GAIM_MINOR_VERSION,
+	GAIM_PLUGIN_STANDARD,
+	GAIM_GTK_PLUGIN_TYPE,
+	0,
+	NULL,
+	GAIM_PRIORITY_DEFAULT,
+	CHATSORT_PLUGIN_ID,
+	N_("Gay.Com Room Browser"),
+	VERSION,
+	N_("Browse rooms in gay.com"),
+	N_("Adds a right-click item to context menu."),
+	"Jason LeBrun <gaim at jasonlebrun.info",
+	GAIM_WEBSITE,
+	plugin_load,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+static void
+init_plugin(GaimPlugin *plugin)
+{
+}
+
+GAIM_INIT_PLUGIN(history, init_plugin, info)



From deckrider at berlios.de  Sat Jul 23 20:12:25 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sat, 23 Jul 2005 20:12:25 +0200
Subject: [Qrc-svn] r230 - qrc/trunk
Message-ID: <200507231812.j6NICPIf008493@sheep.berlios.de>

Author: deckrider
Date: 2005-07-23 20:12:24 +0200 (Sat, 23 Jul 2005)
New Revision: 230

Modified:
   qrc/trunk/Makefile.am
   qrc/trunk/configure.ac
Log:
Automake/autoconf framework for gaym-extras


Modified: qrc/trunk/Makefile.am
===================================================================
--- qrc/trunk/Makefile.am	2005-07-23 17:36:35 UTC (rev 229)
+++ qrc/trunk/Makefile.am	2005-07-23 18:12:24 UTC (rev 230)
@@ -2,16 +2,12 @@
 MAYBE_BOT_CHALLENGER = bot-challenger
 endif
 
-if COND_CHATICON
-MAYBE_CHATICON = chaticon
-endif
-
 if COND_GAYM
 MAYBE_GAYM = gaym
 endif
 
-if COND_ROOMBROWSE
-MAYBE_ROOMBROWSE = roombrowse
+if COND_GAYM_EXTRAS
+MAYBE_GAYM_EXTRAS = gaym-extras
 endif
 
 EXTRA_DIST = \
@@ -23,4 +19,4 @@
 	$(MAYBE_BOT_CHALLENGER) \
 	$(MAYBE_CHATICON) \
 	$(MAYBE_GAYM) \
-	$(MAYBE_ROOMBROWSE)
+	$(MAYBE_GAYM_EXTRAS)

Modified: qrc/trunk/configure.ac
===================================================================
--- qrc/trunk/configure.ac	2005-07-23 17:36:35 UTC (rev 229)
+++ qrc/trunk/configure.ac	2005-07-23 18:12:24 UTC (rev 230)
@@ -38,42 +38,33 @@
 	[AS_HELP_STRING(--enable-bot-challenger,build the bot-challenger plugin @<:@default=yes@:>@)],,
 	[enable_bot_challenger="yes"])
 
-AC_ARG_ENABLE([chaticon],
-	[AS_HELP_STRING(--enable-chaticon,build the chaticon plugin @<:@default=no@:>@)],,
-	[enable_chaticon="no"])
-
 AC_ARG_ENABLE([gaym],
 	[AS_HELP_STRING(--enable-gaym,build the gaym plugin @<:@default=yes@:>@)],,
 	[enable_gaym="yes"])
 
-AC_ARG_ENABLE([roombrowse],
-	[AS_HELP_STRING(--enable-roombrowse,build the roombrowse plugin @<:@default=no@:>@)],,
-	[enable_roombrowse="no"])
+AC_ARG_ENABLE([gaym-extras],
+	[AS_HELP_STRING(--enable-gaym-extras,build the gaym-extras plugin @<:@default=yes@:>@)],,
+	[enable_gaym_extras="yes"])
 
 AM_CONDITIONAL([COND_BOT_CHALLENGER], [test "$enable_bot_challenger" = "yes"])
-AM_CONDITIONAL([COND_CHATICON], [test "$enable_chaticon" = "yes"])
 AM_CONDITIONAL([COND_GAYM], [test "$enable_gaym" = "yes"])
-AM_CONDITIONAL([COND_ROOMBROWSE], [test "$enable_roombrowse" = "yes"])
+AM_CONDITIONAL([COND_GAYM_EXTRAS], [test "$enable_gaym_extras" = "yes"])
 
 if test "$enable_bot_challenger" != "yes" ; then
 	enable_bot_challener="no"
 fi
 
-if test "$enable_chaticon" != "yes" ; then
-	enable_chaticon="no"
-fi
-
 if test "$enable_gaym" != "yes" ; then
 	enable_gaym="no"
 fi
 
-if test "$enable_roombrowse" != "yes" ; then
-	enable_roombrowse="no"
+if test "$enable_gaym_extras" != "yes" ; then
+	enable_gaym_extras="no"
 fi
 
 # Checks for libraries.
 PKG_PROG_PKG_CONFIG([$REQUIRED_PKG_CONFIG])
-if test "$enable_chaticon" = "yes" -o "$enable_roombrowse" = "yes"; then
+if test "$enable_gaym_extras" = "yes" ; then
 	PKG_CHECK_MODULES([GTK], [$REQUIRED_GTK],
 		[
 		AC_SUBST(GTK_CFLAGS)
@@ -126,22 +117,20 @@
 
 AC_CONFIG_FILES([Makefile
                  bot-challenger/Makefile
-                 chaticon/Makefile
                  gaym/Makefile
                  gaym/pixmaps/Makefile
                  gaym/src/Makefile
+                 gaym-extras/Makefile
                  nsis/Makefile
-		 nsis/locale/Makefile
-                 roombrowse/Makefile])
+		 nsis/locale/Makefile])
 AC_OUTPUT
 
 echo
 echo $PACKAGE $VERSION
 echo
 echo Build bot-challenger plugin...... : $enable_bot_challenger
-echo Build chaticon plugin............ : $enable_chaticon
 echo Build gaym plugin................ : $enable_gaym
-echo Build roombrowse plugin.......... : $enable_roombrowse
+echo Build gaym-extras plugin......... : $enable_gaym_extras
 echo
 echo Installation directory........... : $GAIM_LIBDIR/gaim
 echo



From deckrider at berlios.de  Sat Jul 23 20:13:03 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sat, 23 Jul 2005 20:13:03 +0200
Subject: [Qrc-svn] r231 - qrc/trunk/gaym-extras
Message-ID: <200507231813.j6NID3Zq008530@sheep.berlios.de>

Author: deckrider
Date: 2005-07-23 20:13:02 +0200 (Sat, 23 Jul 2005)
New Revision: 231

Added:
   qrc/trunk/gaym-extras/Makefile.am
Log:
More automake framework for gaym-extras


Added: qrc/trunk/gaym-extras/Makefile.am
===================================================================
--- qrc/trunk/gaym-extras/Makefile.am	2005-07-23 18:12:24 UTC (rev 230)
+++ qrc/trunk/gaym-extras/Makefile.am	2005-07-23 18:13:02 UTC (rev 231)
@@ -0,0 +1,25 @@
+pkgdir = \
+	$(GAIM_LIBDIR)/gaim
+
+GAYMSOURCES = \
+	gaym-extras.c
+
+AM_CFLAGS = \
+	$(st)
+
+libgaym_extras_la_LDFLAGS = \
+	-module \
+	-avoid-version \
+	$(GTK_LIBS) \
+	$(GAIM_LIBS)
+
+pkg_LTLIBRARIES = \
+	libgaym-extras.la
+
+libgaym_extras_la_SOURCES = \
+	$(GAYMSOURCES)
+
+AM_CPPFLAGS = \
+	$(DEBUG_CFLAGS) \
+	$(GTK_CFLAGS) \
+	$(GAIM_CFLAGS)



From deckrider at berlios.de  Sat Jul 23 20:20:20 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sat, 23 Jul 2005 20:20:20 +0200
Subject: [Qrc-svn] r232 - qrc/trunk
Message-ID: <200507231820.j6NIKKfO009061@sheep.berlios.de>

Author: deckrider
Date: 2005-07-23 20:20:19 +0200 (Sat, 23 Jul 2005)
New Revision: 232

Modified:
   qrc/trunk/README.svn
Log:
Adding code formatting information.

Modified: qrc/trunk/README.svn
===================================================================
--- qrc/trunk/README.svn	2005-07-23 18:13:02 UTC (rev 231)
+++ qrc/trunk/README.svn	2005-07-23 18:20:19 UTC (rev 232)
@@ -16,4 +16,15 @@
    libtool    1.5.6  (not needed by source packages)
    pkg-config 0.17.2 (source packages may use pkg-config >= 0.15.0)
 
+Before committing your work or submitting a patch, please make sure you have
+only used c-style comments, and run indent on any .c or .h files you are
+committing with the following options (you can put these in your
+~/.indent.pro file):
+
+   -kr
+   -lc75
+   -fc1
+   -fca
+   -nut
+
 # this README.svn should not be included in the source package



From deckrider at berlios.de  Sat Jul 23 20:40:08 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sat, 23 Jul 2005 20:40:08 +0200
Subject: [Qrc-svn] r233 - qrc/trunk/gaym/src
Message-ID: <200507231840.j6NIe85Q010204@sheep.berlios.de>

Author: deckrider
Date: 2005-07-23 20:40:07 +0200 (Sat, 23 Jul 2005)
New Revision: 233

Modified:
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gaym.h
   qrc/trunk/gaym/src/msgs.c
Log:
Removed chat sorting preferences, since this will be handled in the
gaym-extras plugin.


Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-23 18:20:19 UTC (rev 232)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-23 18:40:07 UTC (rev 233)
@@ -1399,18 +1399,6 @@
 
     ppref =
         gaim_plugin_pref_new_with_name_and_label
-        ("/plugins/prpl/gaym/chat_member_sorting",
-         _
-         ("Sort members by\n\t(changes do not affect rooms you are already in)"));
-    gaim_plugin_pref_set_type(ppref, GAIM_PLUGIN_PREF_CHOICE);
-    gaim_plugin_pref_add_choice(ppref, _("Entrance time"),
-                                GINT_TO_POINTER(1));
-    gaim_plugin_pref_add_choice(ppref, _("Category + Name"),
-                                GINT_TO_POINTER(2));
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_name_and_label
         ("/plugins/prpl/gaym/chat_room_instances",
          _("Number of chat room instances to display"));
     gaim_plugin_pref_set_bounds(ppref, 0, 9);
@@ -1518,7 +1506,6 @@
                         GAIM_CALLBACK(gaym_get_photo_info), NULL);
 
     gaim_prefs_add_none("/plugins/prpl/gaym");
-    gaim_prefs_add_int("/plugins/prpl/gaym/chat_member_sorting", 1);
     gaim_prefs_add_int("/plugins/prpl/gaym/chat_room_instances", 4);
     gaim_prefs_add_bool("/plugins/prpl/gaym/show_join", TRUE);
     gaim_prefs_add_bool("/plugins/prpl/gaym/show_part", TRUE);

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-23 18:20:19 UTC (rev 232)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-23 18:40:07 UTC (rev 233)
@@ -46,17 +46,6 @@
 
 #define GAYBOI_SPAM_URL "http://gayboi.org/spam/spamlst.php"
 
-typedef enum {
-    GAYM_CHAT_SORT_TIME = 1,    /* Entrance time */
-    GAYM_CHAT_SORT_FLAGS        /* Category + Nick/Name */
-} GaymChatSortType;
-
-typedef struct _ChatSort ChatSort;
-struct _ChatSort {
-    gint type;
-    gint counter;
-};
-
 typedef struct _BListWhois BListWhois;
 struct _BListWhois {
     int count;

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-23 18:20:19 UTC (rev 232)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-23 18:40:07 UTC (rev 233)
@@ -671,14 +671,10 @@
 
         serv_got_joined_chat(gc, id++, args[0]);
 
-        ChatSort *chat_sort = g_new0(ChatSort, 1);
+        gint *entry = g_new(gint, 1);
+        *entry = MAX_CHANNEL_MEMBERS;
+        g_hash_table_insert(gaym->entry_order, g_strdup(args[0]), entry);
 
-        chat_sort->type =
-            gaim_prefs_get_int("/plugins/prpl/gaym/chat_member_sorting");
-        chat_sort->counter = MAX_CHANNEL_MEMBERS;
-
-        g_hash_table_insert(gaym->entry_order, g_strdup(args[0]),
-                            chat_sort);
         g_free(nick);
         return;
     }
@@ -691,8 +687,8 @@
         return;
     }
 
-    ChatSort *chat_sort = g_hash_table_lookup(gaym->entry_order, args[0]);
-    g_return_if_fail(chat_sort != NULL);
+    gint *entry = g_hash_table_lookup(gaym->entry_order, args[0]);
+    g_return_if_fail(entry != NULL);
 
     gaym_buddy_status(gaym, nick, TRUE, args[1]);
 
@@ -705,16 +701,13 @@
         g_free(bio);
     }
 
-    if (chat_sort->counter <= MAX_CHANNEL_MEMBERS) {
-        chat_sort->counter = MAX_CHANNEL_MEMBERS + 1;
+    if (*entry <= MAX_CHANNEL_MEMBERS) {
+        *entry = MAX_CHANNEL_MEMBERS + 1;
     }
 
     flags = chat_pecking_order(args[1]);
+    flags = include_chat_entry_order(flags, (*entry)++);
 
-    if (chat_sort->type == GAYM_CHAT_SORT_TIME) {
-        flags = include_chat_entry_order(flags, chat_sort->counter++);
-    }
-
     gboolean gaym_privacy_permit = gaym_privacy_check(gc, nick);
     gboolean show_join =
         gaim_prefs_get_bool("/plugins/prpl/gaym/show_join");
@@ -1268,15 +1261,12 @@
         return;
     }
 
-    ChatSort *chat_sort = g_hash_table_lookup(gaym->entry_order, channel);
-    g_return_if_fail(chat_sort != NULL);
+    gint *entry = g_hash_table_lookup(gaym->entry_order, channel);
+    g_return_if_fail(entry != NULL);
 
     flags = chat_pecking_order(extra);
+    flags = include_chat_entry_order(flags, (*entry)--);
 
-    if (chat_sort->type == GAYM_CHAT_SORT_TIME) {
-        flags = include_chat_entry_order(flags, chat_sort->counter--);
-    }
-
     gaim_conv_chat_add_user(GAIM_CONV_CHAT(convo), nick, NULL, flags,
                             FALSE);
 



From deckrider at berlios.de  Sun Jul 24 01:59:37 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sun, 24 Jul 2005 01:59:37 +0200
Subject: [Qrc-svn] r234 - qrc/trunk/gaym/src
Message-ID: <200507232359.j6NNxb4u022393@sheep.berlios.de>

Author: deckrider
Date: 2005-07-24 01:58:55 +0200 (Sun, 24 Jul 2005)
New Revision: 234

Modified:
   qrc/trunk/gaym/src/cmds.c
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/helpers.c
   qrc/trunk/gaym/src/helpers.h
   qrc/trunk/gaym/src/msgs.c
Log:
Fixing the ability to run "/list [filter]" which I accidentally broke
when refactoring the roomlist mechanisms.


Modified: qrc/trunk/gaym/src/cmds.c
===================================================================
--- qrc/trunk/gaym/src/cmds.c	2005-07-23 18:40:07 UTC (rev 233)
+++ qrc/trunk/gaym/src/cmds.c	2005-07-23 23:58:55 UTC (rev 234)
@@ -213,12 +213,14 @@
 int gaym_cmd_list(struct gaym_conn *gaym, const char *cmd,
                   const char *target, const char **args)
 {
-
-
-    if (args[0])
-        gaym->roomlist_filter = g_strdown(g_strdup(args[0]));
-    else
+    if (args[0]) {
+        gchar *tmp = g_utf8_strdown(args[0], -1);
+        gaym->roomlist_filter =
+            g_utf8_normalize(args[0], -1, G_NORMALIZE_ALL);
+        g_free(tmp);
+    } else {
         gaym->roomlist_filter = NULL;
+    }
     gaim_roomlist_show_with_account(gaym->account);
 
     return 0;

Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-23 18:40:07 UTC (rev 233)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-23 23:58:55 UTC (rev 234)
@@ -517,6 +517,7 @@
     gaym_cmd_table_build(gaym);
     gaym->msgs = g_hash_table_new(g_str_hash, g_str_equal);
     gaym_msg_table_build(gaym);
+    gaym->roomlist_filter = NULL;
     /**
      * The last parameter needs to be NULL here, since the same
      * field is added for both the key and the value (and if we
@@ -1221,6 +1222,11 @@
         gaym->roomlist = NULL;
         gaim_roomlist_unref(list);
     }
+
+    if (gaym->roomlist_filter) {
+        g_free(gaym->roomlist_filter);
+        gaym->roomlist_filter = NULL;
+    }
 }
 
 void gaym_roomlist_expand_category(struct _GaimRoomlist *list,

Modified: qrc/trunk/gaym/src/helpers.c
===================================================================
--- qrc/trunk/gaym/src/helpers.c	2005-07-23 18:40:07 UTC (rev 233)
+++ qrc/trunk/gaym/src/helpers.c	2005-07-23 23:58:55 UTC (rev 234)
@@ -338,10 +338,13 @@
 }
 
 void build_roomlist_from_config(GaimRoomlist * roomlist,
-                                GHashTable * confighash)
+                                GHashTable * confighash, gchar * pattern)
 {
     gchar **roominst = NULL;
     gchar *altname = NULL;
+    gchar *normalized = NULL;
+    gchar *lowercase = NULL;
+    gchar *found = NULL;
     int level = 0;
     int old_level = 0;
     int i = 0;
@@ -370,27 +373,38 @@
              * component parts, determine the level and the parent,
              * and add this as both a room and a category
              */
-            roominst = g_strsplit(roomarr[i], " ", 2);
-            level = roomlist_level_strip(roominst[1]);
-            parent = find_parent(level, old_level, room);
-            altname = g_strdup_printf("%s:*", roominst[1]);
-            if (max == 0) {
-                room =
-                    gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_ROOM,
-                                           altname, parent);
-            } else {
-                room =
-                    gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_CATEGORY
-                                           | GAIM_ROOMLIST_ROOMTYPE_ROOM,
-                                           altname, parent);
+            if (pattern != NULL) {
+                lowercase = g_utf8_strdown(roomarr[i], -1);
+                normalized =
+                    g_utf8_normalize(lowercase, -1, G_NORMALIZE_ALL);
+                found = g_strstr_len(normalized, -1, pattern);
+                g_free(normalized);
+                g_free(lowercase);
             }
-            gaim_roomlist_room_add_field(roomlist, room, altname);
-            gaim_roomlist_room_add_field(roomlist, room, roominst[0]);
-            gaim_roomlist_room_add(roomlist, room);
-            g_free(altname);
-            old_level = level;
-            g_strfreev(roominst);
-        } else {
+            if (found != NULL || pattern == NULL) {
+                found = NULL;
+                roominst = g_strsplit(roomarr[i], " ", 2);
+                level = roomlist_level_strip(roominst[1]);
+                parent = find_parent(level, old_level, room);
+                altname = g_strdup_printf("%s:*", roominst[1]);
+                if (max == 0) {
+                    room =
+                        gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_ROOM,
+                                               altname, parent);
+                } else {
+                    room =
+                        gaim_roomlist_room_new
+                        (GAIM_ROOMLIST_ROOMTYPE_CATEGORY |
+                         GAIM_ROOMLIST_ROOMTYPE_ROOM, altname, parent);
+                }
+                gaim_roomlist_room_add_field(roomlist, room, altname);
+                gaim_roomlist_room_add_field(roomlist, room, roominst[0]);
+                gaim_roomlist_room_add(roomlist, room);
+                g_free(altname);
+                g_strfreev(roominst);
+                old_level = level;
+            }
+        } else if (pattern == NULL) {
             /**
              * This is a plain category, determine the level and
              * the parent and add it.
@@ -406,7 +420,6 @@
     }
     g_strfreev(roomarr);
     gaim_roomlist_set_in_progress(roomlist, FALSE);
-
 }
 
 GaimConvChatBuddyFlags chat_pecking_order(const char *extra)
@@ -431,10 +444,13 @@
     return flags;
 }
 
-GaimConvChatBuddyFlags include_chat_entry_order(GaimConvChatBuddyFlags flags, gint entry) {
-    
+GaimConvChatBuddyFlags include_chat_entry_order(GaimConvChatBuddyFlags
+                                                flags, gint entry)
+{
+
     return (flags | (entry << 4));
 }
+
 /**
  * vim:tabstop=4:shiftwidth=4:expandtab:
  */

Modified: qrc/trunk/gaym/src/helpers.h
===================================================================
--- qrc/trunk/gaym/src/helpers.h	2005-07-23 18:40:07 UTC (rev 233)
+++ qrc/trunk/gaym/src/helpers.h	2005-07-23 23:58:55 UTC (rev 234)
@@ -142,9 +142,10 @@
  * @param roomlist The GaimRoomlist that these rooms should be loaded
  *                 into.
  * @param confighash The GHashTable that config.txt was converted into
+ * @param pattern The pattern to match against or NULL for everythying
  */
 void build_roomlist_from_config(GaimRoomlist * roomlist,
-                                GHashTable * confighash);
+                                GHashTable * confighash, gchar * pattern);
 
 /**
  * Determine the correct GaimConvChatBuddyFlags based on the "extra"
@@ -156,7 +157,8 @@
  */
 GaimConvChatBuddyFlags chat_pecking_order(const char *extra);
 
-GaimConvChatBuddyFlags include_chat_entry_order(GaimConvChatBuddyFlags flags, gint entry);
+GaimConvChatBuddyFlags include_chat_entry_order(GaimConvChatBuddyFlags
+                                                flags, gint entry);
 #endif                          /* _GAIM_GAYM_HELPERS_H_ */
 
 /**

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-23 18:40:07 UTC (rev 233)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-23 23:58:55 UTC (rev 234)
@@ -310,7 +310,7 @@
     /**
      * Begin result of member created room list
      */
-    if (!strcmp(name, "321")) {
+    if (!strcmp(name, "321") && gaym->roomlist_filter == NULL) {
         GaimRoomlistRoom *room;
         room = gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_CATEGORY,
                                       _("Member Created"), NULL);
@@ -364,13 +364,22 @@
          */
         field_name[i - 2] = ':';
 
-        room = gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_ROOM,
-                                      field_name,
-                                      g_list_nth_data(gaym->roomlist->
-                                                      rooms, 0));
-        gaim_roomlist_room_add_field(gaym->roomlist, room, field_name);
-        gaim_roomlist_room_add_field(gaym->roomlist, room, args[1]);
-        gaim_roomlist_room_add(gaym->roomlist, room);
+        gchar *lowercase = g_utf8_strdown(field_name, -1);
+        gchar *normalized =
+            g_utf8_normalize(lowercase, -1, G_NORMALIZE_ALL);
+        g_free(lowercase);
+        if (gaym->roomlist_filter == NULL ||
+            g_strstr_len(normalized, -1, gaym->roomlist_filter) != NULL) {
+
+            room = gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_ROOM,
+                                          field_name,
+                                          g_list_nth_data(gaym->roomlist->
+                                                          rooms, 0));
+            gaim_roomlist_room_add_field(gaym->roomlist, room, field_name);
+            gaim_roomlist_room_add_field(gaym->roomlist, room, args[1]);
+            gaim_roomlist_room_add(gaym->roomlist, room);
+        }
+        g_free(normalized);
         g_free(field_name);
     }
 
@@ -379,7 +388,12 @@
      * This is our trigger to add the static rooms
      */
     if (!strcmp(name, "323")) {
-        build_roomlist_from_config(gaym->roomlist, gaym->confighash);
+        build_roomlist_from_config(gaym->roomlist, gaym->confighash,
+                                   gaym->roomlist_filter);
+        if (gaym->roomlist_filter) {
+            g_free(gaym->roomlist_filter);
+            gaym->roomlist_filter = NULL;
+        }
         return;
     }
 }



From deckrider at berlios.de  Sun Jul 24 02:16:29 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Sun, 24 Jul 2005 02:16:29 +0200
Subject: [Qrc-svn] r235 - qrc/trunk/gaym/src
Message-ID: <200507240016.j6O0GTQR027784@sheep.berlios.de>

Author: deckrider
Date: 2005-07-24 02:15:50 +0200 (Sun, 24 Jul 2005)
New Revision: 235

Modified:
   qrc/trunk/gaym/src/cmds.c
Log:
Brown paper bag fix of my earlier commit.  This fixes the case-sensitivity
issue for "/list" (it should be case-insensitive).


Modified: qrc/trunk/gaym/src/cmds.c
===================================================================
--- qrc/trunk/gaym/src/cmds.c	2005-07-23 23:58:55 UTC (rev 234)
+++ qrc/trunk/gaym/src/cmds.c	2005-07-24 00:15:50 UTC (rev 235)
@@ -215,8 +215,7 @@
 {
     if (args[0]) {
         gchar *tmp = g_utf8_strdown(args[0], -1);
-        gaym->roomlist_filter =
-            g_utf8_normalize(args[0], -1, G_NORMALIZE_ALL);
+        gaym->roomlist_filter = g_utf8_normalize(tmp, -1, G_NORMALIZE_ALL);
         g_free(tmp);
     } else {
         gaym->roomlist_filter = NULL;



From jblebrun at berlios.de  Sun Jul 24 05:25:49 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Sun, 24 Jul 2005 05:25:49 +0200
Subject: [Qrc-svn] r236 - in qrc/trunk: gaym/src gaym-extras
Message-ID: <200507240325.j6O3Pn2s022958@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-24 05:25:47 +0200 (Sun, 24 Jul 2005)
New Revision: 236

Modified:
   qrc/trunk/gaym-extras/chatsort.c
   qrc/trunk/gaym-extras/gaym-extras.c
   qrc/trunk/gaym-extras/roombrowse.c
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/msgs.c
   qrc/trunk/gaym/src/weblogin.c
Log:
*If server too busy to list member rooms, still list configtxt rooms.
*A first attempt at chat icons in the room, using the buddy system. For various reason, this method blows, so it's going to be completely re-hauled to use imgstore. But just in caes, the work is being committed.

gaym.c:
*Created a new signal that signals the reception of a buddy icon.

msgs.c:
*fetch_thumbnail_cb emits the new signal
*if the server is busy, the non-member rooms are still displayed.

gaym-extra.c:
mega thumbnail code!

roombrowse.c, chatsort.c, weblogin.c
formatting changes (ran indent)



Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-24 00:15:50 UTC (rev 235)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-24 03:25:47 UTC (rev 236)
@@ -35,6 +35,7 @@
 #include "version.h"
 #include "request.h"
 #include "privacy.h"
+#include "signals.h"
 
 #include "helpers.h"
 #include "gayminfo.h"
@@ -1511,6 +1512,15 @@
                         "conversation-created", plugin,
                         GAIM_CALLBACK(gaym_get_photo_info), NULL);
 
+    gaim_signal_register(gaim_accounts_get_handle(),
+                         "buddy-icon-fetched",
+                         gaim_marshal_VOID__POINTER_POINTER, NULL, 2,
+                         gaim_value_new(GAIM_TYPE_SUBTYPE,
+                                        GAIM_SUBTYPE_CONNECTION),
+                         gaim_value_new(GAIM_TYPE_SUBTYPE,
+                                        GAIM_SUBTYPE_BUDDY_ICON));
+
+
     gaim_prefs_add_none("/plugins/prpl/gaym");
     gaim_prefs_add_int("/plugins/prpl/gaym/chat_room_instances", 4);
     gaim_prefs_add_bool("/plugins/prpl/gaym/show_join", TRUE);

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-24 00:15:50 UTC (rev 235)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-24 03:25:47 UTC (rev 236)
@@ -88,17 +88,26 @@
 void gaym_fetch_thumbnail_cb(void *user_data, const char *pic_data,
                              size_t len)
 {
-    if (!user_data || !pic_data) {
+    if (!user_data)
         return;
+    struct gaym_fetch_thumbnail_data *d = user_data;
+    if (!pic_data) {
+        gaim_signal_emit(gaim_accounts_get_handle(), "buddy-icon-fetched",
+                         d->gc, NULL, d->who);
+        return;
     }
 
-    struct gaym_fetch_thumbnail_data *d = user_data;
 
     if (GAIM_CONNECTION_IS_VALID(d->gc) && len) {
         gaim_buddy_icons_set_for_user(gaim_connection_get_account(d->gc),
                                       d->who, (void *) pic_data, len);
+        gaim_signal_emit(gaim_accounts_get_handle(), "buddy-icon-fetched",
+                         d->gc, gaim_buddy_icons_find(d->gc->account,
+                                                      d->who));
     } else {
         gaim_debug_error("gaym", "Fetching buddy icon failed.\n");
+        gaim_signal_emit(gaim_accounts_get_handle(), "buddy-icon-fetched",
+                         d->gc, NULL, d->who);
     }
 
     g_free(d->who);
@@ -1235,10 +1244,22 @@
     }
     buf = g_strdup_printf(_("%s"), args[1]);
     gaim_notify_error(gc, _("Server Busy"), _("Server Busy"), buf);
-    if (gaym->roomlist) {
-        gaim_roomlist_cancel_get_list(gaym->roomlist);
+    // if (gaym->roomlist) {
+    // gaim_roomlist_cancel_get_list(gaym->roomlist);
+    // }
+    g_free(buf);
+    /**
+     * Can't get member created rooms right now.
+     * This is our trigger to add the static rooms
+     */
+    build_roomlist_from_config(gaym->roomlist, gaym->confighash,
+                               gaym->roomlist_filter);
+    if (gaym->roomlist_filter) {
+        g_free(gaym->roomlist_filter);
+        gaym->roomlist_filter = NULL;
     }
-    g_free(buf);
+    return;
+
 }
 
 void gaym_msg_richnames_list(struct gaym_conn *gaym, const char *name,

Modified: qrc/trunk/gaym/src/weblogin.c
===================================================================
--- qrc/trunk/gaym/src/weblogin.c	2005-07-24 00:15:50 UTC (rev 235)
+++ qrc/trunk/gaym/src/weblogin.c	2005-07-24 03:25:47 UTC (rev 236)
@@ -62,16 +62,18 @@
 
 } GaimFetchUrlData;
 
-static void gaym_session_destroy(GaimUrlSession* session) {
+static void gaym_session_destroy(GaimUrlSession * session)
+{
     if (session->cookies)
-	g_free(session->cookies);
+        g_free(session->cookies);
     if (session->username)
-	g_free(session->username);
+        g_free(session->username);
     if (session->password)
-	g_free(session->password);
-    gaim_debug_misc("gaym","freeing session: %x\n",session);
+        g_free(session->password);
+    gaim_debug_misc("gaym", "freeing session: %x\n", session);
     g_free(session);
 }
+
 /* gaim_url_decode doesn't change pluses to spaces - edit in place */
 static const char *gaym_url_decode(const char *string)
 {
@@ -89,7 +91,7 @@
 
 static void destroy_fetch_url_data(GaimFetchUrlData * gfud)
 {
-    gaim_debug_misc("gaym","destroy_fetch_url_data called\n");
+    gaim_debug_misc("gaym", "destroy_fetch_url_data called\n");
     if (gfud->webdata != NULL)
         g_free(gfud->webdata);
     if (gfud->url != NULL)
@@ -104,7 +106,7 @@
         g_free(gfud->website.user);
     if (gfud->website.passwd != NULL)
         g_free(gfud->website.passwd);
-   
+
     g_free(gfud);
 }
 
@@ -233,9 +235,9 @@
                     g_strdup_printf("%s; %.*s", session->cookies,
                                     cookie_size, next_token);
             else
-
-	    //FIXME: I think there is a function for resizing the memory
-	    //which is more efficient then a allocation and freeing.
+                // FIXME: I think there is a function for resizing the
+                // memory
+                // which is more efficient then a allocation and freeing.
                 new_cookie =
                     g_strdup_printf("%.*s", cookie_size, next_token);
             if (new_cookie) {
@@ -263,6 +265,7 @@
 // 
 // 
 // 
+// 
 // this
 // structure, as well.
 static void
@@ -297,6 +300,7 @@
                        // 
                        // 
                        // 
+                       // 
                        // (see 
                        // above)
                        (gfud->full ? "" : "/"),
@@ -310,6 +314,7 @@
                        // 
                        // 
                        // 
+                       // 
                        // See 
                        // above
                        (gfud->full ? "" : "/"),
@@ -490,7 +495,7 @@
 {
 
     GaimUrlSession *session = (GaimUrlSession *) data;
-    struct gaym_conn* gaym = session->gaym;
+    struct gaym_conn *gaym = session->gaym;
     // Get hash from text
     if (session && GAIM_CONNECTION_IS_VALID(session->account->gc)) {
         // char *pw_hash;
@@ -503,11 +508,11 @@
 
 
 
-	gaym->server_stats=NULL;
-	gaym->hash_pw=NULL;
-	gaym->server_bioline=NULL;
-	gaym->thumbnail=NULL;
-	
+        gaym->server_stats = NULL;
+        gaym->hash_pw = NULL;
+        gaym->server_bioline = NULL;
+        gaym->thumbnail = NULL;
+
         // First, look for password
         match = "password\" value=\"";
         temp = strstr(text, match);
@@ -553,13 +558,13 @@
                     || (gaym->server_bioline = NULL);
                 g_free(bio);
 
-		//Parse out stats part of bio.
-		temp2 = strchr(result, (char)0x01);
-		if(temp2++) {
-		    gaim_debug_misc("gaym", "Stats: %s\n", temp2);
-		    gaym->server_stats = g_strdup(temp2);
-		}
-	    }
+                // Parse out stats part of bio.
+                temp2 = strchr(result, (char) 0x01);
+                if (temp2++) {
+                    gaim_debug_misc("gaym", "Stats: %s\n", temp2);
+                    gaym->server_stats = g_strdup(temp2);
+                }
+            }
         } else {
             // gaim_connection_error(
             // gaim_account_get_connection(((struct
@@ -573,7 +578,7 @@
         gaim_debug_misc("gaym", "gaym->session: %x\n", session);
     }
 
-    //We don't need the session info anymore.
+    // We don't need the session info anymore.
     gaym_session_destroy(session);
 
 }
@@ -584,8 +589,7 @@
 
     GaimUrlSession *session = (GaimUrlSession *) data;
     gaim_debug_misc("gaym", "Step 4: session: %x\n", session);
-    if (session
-        && GAIM_CONNECTION_IS_VALID(session->account->gc)) {
+    if (session && GAIM_CONNECTION_IS_VALID(session->account->gc)) {
         // The fourth step is to parse a rand=# value out of the message
         // text from
         // The previous step.
@@ -594,8 +598,7 @@
         int nonce;
         char *buf = g_strdup_printf(_("Signon: %s"),
                                     (session->account->username));
-        gaim_connection_update_progress(session->account->gc, buf, 5,
-                                        6);
+        gaim_connection_update_progress(session->account->gc, buf, 5, 6);
         sscanf(text, "?rand=%d", &nonce);
         snprintf(url, 512,
                  "http://www.gay.com/messenger/applet.html?rand=%d",
@@ -607,8 +610,8 @@
     } else {
         gaim_debug_misc("gaym", "Connection was cancelled before step4\n");
         gaim_debug_misc("gaym", "session: %x\n", session);
-	gaym_session_destroy(session);	
-	
+        gaym_session_destroy(session);
+
         // g_free(gaym->session);
     }
 }
@@ -639,8 +642,7 @@
         char *url = "http://www.gay.com/messenger/frameset.html";
         char *buf = g_strdup_printf(_("Signon: %s"),
                                     (session->account->username));
-        gaim_connection_update_progress(session->account->gc, buf, 4,
-                                        6);
+        gaim_connection_update_progress(session->account->gc, buf, 4, 6);
         session->hasFormData = FALSE;
         gaim_session_fetch(url, FALSE, NULL, FALSE, gaym_weblogin_step4,
                            session, session);
@@ -648,7 +650,7 @@
 
         gaim_debug_misc("gaym", "Connection was cancelled before step3\n");
         gaim_debug_misc("gaym", "session: %x\n", session);
-	gaym_session_destroy(session);	
+        gaym_session_destroy(session);
         // g_free(gaym->session);
 
     }
@@ -657,19 +659,17 @@
 gaym_weblogin_step2(gpointer data, const char *text, size_t len)
 {
 
-    
+
     GaimUrlSession *session = (GaimUrlSession *) data;
-    if (session
-        && GAIM_CONNECTION_IS_VALID(session->account->gc)) {
-	gaim_debug_misc("gaym","Step 2: connection is valid.\n");
+    if (session && GAIM_CONNECTION_IS_VALID(session->account->gc)) {
+        gaim_debug_misc("gaym", "Step 2: connection is valid.\n");
         // The second step is to do the actual login.
         // We connect to misc/dologin.html, using cookies set from step 1
         // And add a few more cookie values.
         char url[1024];
         char *buf = g_strdup_printf(_("Signon: %s"),
                                     session->account->username);
-        gaim_connection_update_progress(session->account->gc, buf, 3,
-                                        6);
+        gaim_connection_update_progress(session->account->gc, buf, 3, 6);
 
         snprintf(url, 1024,
                  "http://www.gay.com/misc/dologin.html?__login_haveForm=1&__login_save=1&__login_member=%s&redir=%%2Findex.html&__login_basepage=%%2Fmisc%%2Fdologin.html&__login_password=%s",
@@ -681,7 +681,7 @@
     } else {
         gaim_debug_misc("gaym", "Connection was cancelled before step2\n");
         gaim_debug_misc("gaym", "session: %x\n", session);
-	gaym_session_destroy(session);
+        gaym_session_destroy(session);
         // g_free(gaym->session);
     }
 }
@@ -706,7 +706,7 @@
         session->account = account;
         session->username = g_strdup(account->username);
         session->password = g_strdup(account->password);
-	session->gaym = gaym;
+        session->gaym = gaym;
 
 
         gaim_debug_misc("gaym", "Made session: %x\n", session);
@@ -726,22 +726,22 @@
         } else {
             gaim_debug_misc("gaym", "cancelled before step1\n");
             gaim_debug_misc("gaym", "gaym->sessoin: %x\n", session);
-	    gaym_session_destroy(session);
+            gaym_session_destroy(session);
         }
 
     }
 }
 
 void gaym_try_cached_password(GaimAccount * account,
-                            void (*callback) (GaimAccount * account))
+                              void (*callback) (GaimAccount * account))
 {
 
-    const char* pw;
-    pw=gaim_account_get_string(account, "password", NULL);
-    if (pw==NULL)
+    const char *pw;
+    pw = gaim_account_get_string(account, "password", NULL);
+    if (pw == NULL)
         gaym_get_hash_from_weblogin(account, callback);
-    
 
+
 }
 
 /**

Modified: qrc/trunk/gaym-extras/chatsort.c
===================================================================
--- qrc/trunk/gaym-extras/chatsort.c	2005-07-24 00:15:50 UTC (rev 235)
+++ qrc/trunk/gaym-extras/chatsort.c	2005-07-24 03:25:47 UTC (rev 236)
@@ -17,71 +17,76 @@
 #define CHATSORT_PLUGIN_ID "gtk-chatsort"
 
 
-//A dummy sort function... don't sort at all!
-static gint sort_chat_users(GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer userdata) {
-return 1;
+// A dummy sort function... don't sort at all!
+static gint sort_chat_users(GtkTreeModel * model, GtkTreeIter * a,
+                            GtkTreeIter * b, gpointer userdata)
+{
+    return 1;
 }
 
-//This gets called BEFORE a chatlist is populated... just creates a new type of chat window.
-static void redochatwindow(GaimConversation *c) {
+// This gets called BEFORE a chatlist is populated... just creates a new
+// type of chat window.
+static void redochatwindow(GaimConversation * c)
+{
 
-	GtkTreeModel *oldls;
-	GtkTreeSelection *select;
-	GtkTreeIter iter;
+    GtkTreeModel *oldls;
+    GtkTreeSelection *select;
+    GtkTreeIter iter;
 
-	//Get a handle to the chat pane for the conversation
-	GaimGtkConversation* gtkconv = GAIM_GTK_CONVERSATION(c);
-	GaimGtkChatPane* gtkchat = gtkconv->u.chat;
+    // Get a handle to the chat pane for the conversation
+    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
+    GaimGtkChatPane *gtkchat = gtkconv->u.chat;
 
-	
-	oldls = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
-	select = gtk_tree_view_get_selection(GTK_TREE_VIEW(gtkchat->list));
 
-	//This is a dummy "root" item. If it's not here,
-	//then the first name entered into the list gets "stucK" at the
-	//top. This is a hack.
-	gtk_list_store_append(GTK_LIST_STORE(oldls), &iter);
-	gtk_list_store_set(GTK_LIST_STORE(oldls), &iter, CHAT_USERS_NAME_COLUMN, " ", -1);
-        gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(oldls), CHAT_USERS_NAME_COLUMN, sort_chat_users, NULL, NULL);
-	
+    oldls = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
+    select = gtk_tree_view_get_selection(GTK_TREE_VIEW(gtkchat->list));
+
+    // This is a dummy "root" item. If it's not here,
+    // then the first name entered into the list gets "stucK" at the
+    // top. This is a hack.
+    gtk_list_store_append(GTK_LIST_STORE(oldls), &iter);
+    gtk_list_store_set(GTK_LIST_STORE(oldls), &iter,
+                       CHAT_USERS_NAME_COLUMN, " ", -1);
+    gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(oldls),
+                                    CHAT_USERS_NAME_COLUMN,
+                                    sort_chat_users, NULL, NULL);
+
 }
 
-static gboolean plugin_load(GaimPlugin *plugin)
+static gboolean plugin_load(GaimPlugin * plugin)
 {
-	gaim_signal_connect(gaim_conversations_get_handle(),
-						"chat-joined",
-						plugin, GAIM_CALLBACK(redochatwindow), NULL);
-	
-	return TRUE;
+    gaim_signal_connect(gaim_conversations_get_handle(),
+                        "chat-joined",
+                        plugin, GAIM_CALLBACK(redochatwindow), NULL);
+
+    return TRUE;
 }
 
-static GaimPluginInfo info =
-{
-	GAIM_PLUGIN_MAGIC,
-	GAIM_MAJOR_VERSION,
-	GAIM_MINOR_VERSION,
-	GAIM_PLUGIN_STANDARD,
-	GAIM_GTK_PLUGIN_TYPE,
-	0,
-	NULL,
-	GAIM_PRIORITY_DEFAULT,
-	CHATSORT_PLUGIN_ID,
-	N_("Chatroom Sort options"),
-	VERSION,
-	N_("Changes the sorting options of chatroom lists."),
-	N_("When a new conversation is opened this plugin will insert the last conversation into the current conversation."),
-	"Jason LeBrun <gaim at jasonlebrun.info",
-	GAIM_WEBSITE,
-	plugin_load,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL
+static GaimPluginInfo info = {
+    GAIM_PLUGIN_MAGIC,
+    GAIM_MAJOR_VERSION,
+    GAIM_MINOR_VERSION,
+    GAIM_PLUGIN_STANDARD,
+    GAIM_GTK_PLUGIN_TYPE,
+    0,
+    NULL,
+    GAIM_PRIORITY_DEFAULT,
+    CHATSORT_PLUGIN_ID,
+    N_("Chatroom Sort options"),
+    VERSION,
+    N_("Changes the sorting options of chatroom lists."),
+    N_("When a new conversation is opened this plugin will insert the last conversation into the current conversation."),
+    "Jason LeBrun <gaim at jasonlebrun.info",
+    GAIM_WEBSITE,
+    plugin_load,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL
 };
 
-static void
-init_plugin(GaimPlugin *plugin)
+static void init_plugin(GaimPlugin * plugin)
 {
 }
 

Modified: qrc/trunk/gaym-extras/gaym-extras.c
===================================================================
--- qrc/trunk/gaym-extras/gaym-extras.c	2005-07-24 00:15:50 UTC (rev 235)
+++ qrc/trunk/gaym-extras/gaym-extras.c	2005-07-24 03:25:47 UTC (rev 236)
@@ -10,96 +10,418 @@
 #include "signals.h"
 #include "util.h"
 #include "version.h"
+#include "buddyicon.h"
 
 #include "gtkconv.h"
 #include "gtkimhtml.h"
 #include "gtkplugin.h"
-
 #define CHATSORT_PLUGIN_ID "gtk-chaticon"
 
-GHashTable* icons;
-GHashTable* icon_spots;
-static void clear_icon() {
+GHashTable *icons;
+GHashTable *icon_spots;
+GHashTable *pending_updates;
+GaimConvWindow *hider_window;
 
+typedef struct _GaymChatIcon {
+
+    GaimConversation *conv;
+    GtkWidget *icon_container_parent;
+    GtkWidget *icon_container;
+    GtkWidget *icon;
+    gboolean show_icon;
+    GdkPixbufAnimation *anim;
+    GdkPixbufAnimationIter *iter;
+    gboolean animate;
+    guint32 icon_timer;
+
+} GaymChatIcon;
+
+static void
+get_icon_scale_size(GdkPixbufAnimation * icon, GaimBuddyIconSpec * spec,
+                    int *width, int *height)
+{
+    *width = gdk_pixbuf_animation_get_width(icon);
+    *height = gdk_pixbuf_animation_get_height(icon);
+
+    /* this should eventually get smarter about preserving the aspect
+       ratio when scaling, but gimmie a break, I just woke up */
+    if (spec && spec->scale_rules & GAIM_ICON_SCALE_DISPLAY) {
+        if (*width < spec->min_width)
+            *width = spec->min_width;
+        else if (*width > spec->max_width)
+            *width = spec->max_width;
+
+        if (*height < spec->min_height)
+            *height = spec->min_height;
+        else if (*height > spec->max_height)
+            *height = spec->max_height;
+    }
+
+    /* and now for some arbitrary sanity checks */
+    if (*width > 100)
+        *width = 100;
+    if (*height > 100)
+        *height = 100;
 }
-static void changed_cb(GtkTreeSelection* selection, gpointer data){
 
-	GaimConversation* c = (GaimConversation*)data;
-	GtkTreeIter iter;
-	GtkTreeModel* model;
-	gchar* name;
-	GaimConversation *temp;
-	gtk_tree_selection_get_selected(selection, &model, &iter);
-	gtk_tree_model_get(model,&iter,CHAT_USERS_NAME_COLUMN, &name, -1);
 
-	gaim_debug_misc("chatsort","Click: %s\n",name);
-	gtk_button_set_label(g_hash_table_lookup(icon_spots, c), name);
-	//Look in local icon cache here.
-	//If the icon isn't here, get it from gaym
-	//Update the widget
+void
+gaym_gtkconv_update_buddy_icon(GaimConversation * conv,
+                               GaimBuddyIcon * icon)
+{
+    GaimGtkConversation *gtkconv;
+    // GaimGtkWindow *gtkwin =
+    // GAIM_GTK_WINDOW(gaim_conversation_get_window(conv));
+
+    char filename[256];
+    FILE *file;
+    GError *err = NULL;
+
+    const void *data = NULL;
+    size_t len;
+
+    GdkPixbuf *buf;
+
+    GtkWidget *event;
+    GtkWidget *frame;
+    GdkPixbuf *scale;
+    GdkPixmap *pm;
+    GdkBitmap *bm;
+    int scale_width, scale_height;
+    GtkRequisition requisition;
+
+    GaimAccount *account;
+    GaimPluginProtocolInfo *prpl_info = NULL;
+
+    // GaimButtonStyle button_type;
+
+    gaim_debug_misc("chaticon", "entered update function\n");
+    g_return_if_fail(conv != NULL);
+    g_return_if_fail(GAIM_IS_GTK_CONVERSATION(conv));
+    g_return_if_fail(gaim_conversation_get_type(conv) == GAIM_CONV_CHAT);
+
+    gtkconv = GAIM_GTK_CONVERSATION(conv);
+
+    GaymChatIcon *icon_data = g_hash_table_lookup(icons, conv);
+    gaim_debug_misc("chaticon",
+                    "got icon_data: %x ... icon is %x, show_icon is %i\n",
+                    icon_data, icon, icon_data->show_icon);
+    // Look things up in our hand hash table of icon stuff.
+
+    if (!icon)
+        return;
+    if (!icon_data->show_icon)
+        return;
+
+    account = gaim_conversation_get_account(conv);
+    if (account && account->gc)
+        prpl_info = GAIM_PLUGIN_PROTOCOL_INFO(account->gc->prpl);
+
+    /* Remove the current icon stuff */
+    if (icon_data->icon_container != NULL)
+        gtk_widget_destroy(icon_data->icon_container);
+    icon_data->icon_container = NULL;
+
+    if (icon_data->anim != NULL)
+        g_object_unref(G_OBJECT(icon_data->anim));
+
+    icon_data->anim = NULL;
+
+    gaim_debug_misc("chaticon", "did some unreffing\n");
+    if (icon_data->icon_timer != 0)
+        g_source_remove(icon_data->icon_timer);
+
+    icon_data->icon_timer = 0;
+
+    if (icon_data->iter != NULL)
+        g_object_unref(G_OBJECT(icon_data->iter));
+
+    icon_data->iter = NULL;
+
+    if (!gaim_prefs_get_bool
+        ("/gaim/gtk/conversations/im/show_buddy_icons"))
+        return;
+
+    if (gaim_conversation_get_gc(conv) == NULL)
+        return;
+
+    gaim_debug_misc("chaticon", "did some more unreffing\n");
+    // ///ICON GETTING
+    // icon = gaim_conv_im_get_icon(GAIM_CONV_IM(conv));
+
+    // if (icon == NULL)
+    // return;
+
+    data = gaim_buddy_icon_get_data(icon, &len);
+
+    // ////END ICON GETTING
+
+    /* this is such an evil hack, i don't know why i'm even considering
+       it. we'll do it differently when gdk-pixbuf-loader isn't leaky
+       anymore. */
+    /* gdk-pixbuf-loader was leaky? is it still? */
+
+    gaim_debug_misc("chaticon", "Got icon data\n");
+    g_snprintf(filename, sizeof(filename),
+               "%s" G_DIR_SEPARATOR_S "gaimicon-%s.%d",
+               g_get_tmp_dir(), gaim_buddy_icon_get_username(icon),
+               getpid());
+
+    if (!(file = g_fopen(filename, "wb")))
+        return;
+
+    fwrite(data, 1, len, file);
+    fclose(file);
+    gaim_debug_misc("chaticon", "Wrote temp file\n");
+    icon_data->anim = gdk_pixbuf_animation_new_from_file(filename, &err);
+
+    gaim_debug_misc("chaticon", "Loaded icon from temp file\n");
+    /* make sure we remove the file as soon as possible */
+    g_unlink(filename);
+
+    if (err) {
+        gaim_debug(GAIM_DEBUG_ERROR, "gtkconv",
+                   "Buddy icon error: %s\n", err->message);
+        g_error_free(err);
+    }
+
+    if (!icon_data->anim)
+        return;
+
+    if (gdk_pixbuf_animation_is_static_image(icon_data->anim)) {
+        icon_data->iter = NULL;
+        buf = gdk_pixbuf_animation_get_static_image(icon_data->anim);
+    } else {
+        icon_data->iter = gdk_pixbuf_animation_get_iter(icon_data->anim, NULL); /* LEAK 
+                                                                                 */
+        buf = gdk_pixbuf_animation_iter_get_pixbuf(icon_data->iter);
+        // if (icon_data->animate)
+        // start_anim(NULL, conv);
+    }
+
+    get_icon_scale_size(icon_data->anim,
+                        prpl_info ? &prpl_info->icon_spec : NULL,
+                        &scale_width, &scale_height);
+    scale =
+        gdk_pixbuf_scale_simple(buf,
+                                MAX(gdk_pixbuf_get_width(buf) *
+                                    scale_width /
+                                    gdk_pixbuf_animation_get_width
+                                    (icon_data->anim), 1),
+                                MAX(gdk_pixbuf_get_height(buf) *
+                                    scale_height /
+                                    gdk_pixbuf_animation_get_height
+                                    (icon_data->anim), 1),
+                                GDK_INTERP_NEAREST);
+
+    gdk_pixbuf_render_pixmap_and_mask(scale, &pm, &bm, 100);
+    g_object_unref(G_OBJECT(scale));
+
+
+    icon_data->icon_container = gtk_vbox_new(FALSE, 0);
+
+    frame = gtk_frame_new(NULL);
+    gtk_frame_set_shadow_type(GTK_FRAME(frame),
+                              (bm ? GTK_SHADOW_NONE : GTK_SHADOW_IN));
+    gtk_box_pack_start(GTK_BOX(icon_data->icon_container), frame,
+                       FALSE, FALSE, 0);
+
+    event = gtk_event_box_new();
+    gtk_container_add(GTK_CONTAINER(frame), event);
+    // g_signal_connect(G_OBJECT(event), "button-press-event",
+    // G_CALLBACK(icon_menu), conv);
+    gtk_widget_show(event);
+
+    icon_data->icon = gtk_image_new_from_pixmap(pm, bm);
+    gtk_widget_set_size_request(icon_data->icon, scale_width,
+                                scale_height);
+    gtk_container_add(GTK_CONTAINER(event), icon_data->icon);
+    gtk_widget_show(icon_data->icon);
+
+    g_object_unref(G_OBJECT(pm));
+
+    if (bm)
+        g_object_unref(G_OBJECT(bm));
+
+    // ////OLD CODE, KEEPING FOR REFERENCE UNTIL COMPLETE.
+    // button_type =
+    // gaim_prefs_get_int("/gaim/gtk/conversations/button_type");
+    /* the button seems to get its size before the box, so... */
+    gtk_widget_size_request(gtkconv->send, &requisition);
+    // if (button_type == GAIM_BUTTON_NONE || requisition.height * 1.5 <
+    // scale_height) {
+    gtk_box_pack_start(GTK_BOX(icon_data->icon_container_parent),
+                       icon_data->icon_container, FALSE, FALSE, 0);
+    /* gtk_box_reorder_child(GTK_BOX(gtkconv->lower_hbox), vbox, 0); */
+    // } else {
+    // gtk_box_pack_start(GTK_BOX(gtkconv->bbox),
+    // icon_data->icon_container, FALSE, FALSE, 0);
+    // gtk_box_reorder_child(GTK_BOX(gtkconv->bbox),
+    // icon_data->icon_container, 0);
+    // }
+
+    gtk_widget_show(icon_data->icon_container);
+    gtk_widget_show(frame);
+    // ////////////////////
+    /* The buddy icon code needs badly to be fixed. */
+    buf = gdk_pixbuf_animation_get_static_image(icon_data->anim);
+    // if(conv ==
+    // gaim_conv_window_get_active_conversation(gaim_conversation_get_window(conv)))
+    // gtk_window_set_icon(GTK_WINDOW(gtkwin->window), buf);
 }
-//This gets called BEFORE a chatlist is populated... just creates a new type of chat window.
-static void redochatwindow(GaimConversation *c) {
 
-	GtkTreeModel *oldls;
-	
-	//Get a handle to the chat pane for the conversation
-	GaimGtkConversation* gtkconv = GAIM_GTK_CONVERSATION(c);
-	GaimGtkChatPane* gtkchat = gtkconv->u.chat;
-	GtkTreeSelection* select = gtk_tree_view_get_selection(GTK_TREE_VIEW(gtkchat->list));
-	gtk_tree_selection_set_mode(select, GTK_SELECTION_SINGLE);
 
-	oldls = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));	
-	GtkBox* vbox = GTK_BOX(gtkchat->list->parent->parent);
-	GtkWidget* button = gtk_button_new_with_label("A Button");
-	g_signal_connect(G_OBJECT(select), "changed", G_CALLBACK(changed_cb), c);
+static void changed_cb(GtkTreeSelection * selection, gpointer data)
+{
 
-	gtk_box_pack_end(vbox, GTK_WIDGET(button), FALSE, FALSE, 0);
-	gtk_widget_show(button);
-	g_hash_table_insert(icon_spots, c, button);
-	
+    GaimConversation *c = (GaimConversation *) data;
+    GtkTreeIter iter;
+    GtkTreeModel *model;
+    gchar *name;
 
+    gtk_tree_selection_get_selected(selection, &model, &iter);
+    gtk_tree_model_get(model, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
+
+    gaim_debug_misc("chatsort", "Click: %s\n", name);
+    gtk_button_set_label(g_hash_table_lookup(icon_spots, c), name);
+
+    GaimBuddyIcon *icon =
+        gaim_buddy_icons_find(gaim_conversation_get_account(c), name);
+    if (!icon) {
+
+        // This triggers a conversation window quickly, to trigger an icon 
+        // get.
+        GaimConversation *temp =
+            gaim_conversation_new(GAIM_CONV_IM,
+                                  gaim_conversation_get_account(c), name);
+        gaim_debug_misc("chaticon", "Created temp conv %x\n", temp);
+        // gaim_conversation_destroy(temp);
+        g_hash_table_replace(pending_updates, c, temp);
+    } else {
+        gaym_gtkconv_update_buddy_icon(c, icon);
+    }
 }
 
+// This gets called BEFORE a chatlist is populated... just creates a new
+// type of chat window.
+static void redochatwindow(GaimConversation * c)
+{
 
-static gboolean plugin_load(GaimPlugin *plugin)
+    GtkTreeModel *oldls;
+
+    // Get a handle to the chat pane for the conversation
+    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
+    GaimGtkChatPane *gtkchat = gtkconv->u.chat;
+    GtkTreeSelection *select =
+        gtk_tree_view_get_selection(GTK_TREE_VIEW(gtkchat->list));
+    gtk_tree_selection_set_mode(select, GTK_SELECTION_SINGLE);
+
+    oldls = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
+    GtkBox *vbox = GTK_BOX(gtkchat->list->parent->parent);
+
+    GtkWidget *button = gtk_button_new_with_label("A Button");
+    gtk_box_pack_end(vbox, GTK_WIDGET(button), FALSE, FALSE, 0);
+    gtk_widget_show(button);
+
+
+    g_signal_connect(G_OBJECT(select), "changed", G_CALLBACK(changed_cb),
+                     c);
+
+    GaymChatIcon *icon_data = g_new0(GaymChatIcon, 1);
+
+    icon_data->icon_container_parent = GTK_WIDGET(vbox);
+    icon_data->icon_container = NULL;
+    icon_data->icon = NULL;
+    icon_data->anim = NULL;
+    icon_data->iter = NULL;
+    icon_data->show_icon = TRUE;
+
+    g_hash_table_insert(icon_spots, c, button);
+    g_hash_table_insert(icons, c, icon_data);
+
+}
+
+static gboolean check_for_update(gpointer * conversation,
+                                 const gpointer * temp, gpointer * icon)
 {
-	icons=g_hash_table_new(g_direct_hash, g_direct_equal);
-	icon_spots=g_hash_table_new(g_direct_hash, g_direct_equal);
-	
-	gaim_signal_connect(gaim_conversations_get_handle(), "chat-joined", plugin, GAIM_CALLBACK(redochatwindow), NULL);
-	gaim_signal_connect(gaim_conversations_get_handle(), "chat-buddy-left", plugin, GAIM_CALLBACK(clear_icon), NULL);
 
-	return TRUE;
+    g_return_val_if_fail(conversation != NULL, TRUE);
+    g_return_val_if_fail(temp != NULL, TRUE);
+    g_return_val_if_fail(icon != NULL, TRUE);
+
+    GaimBuddyIcon *bicon = (GaimBuddyIcon *) icon;
+    GaimConversation *c = (GaimConversation *) conversation;
+    GaimConversation *tempconv = (GaimConversation *) temp;
+
+
+    const gchar *name_needing_update =
+        gaim_conversation_get_name(tempconv);
+    gaim_debug_misc("chaticon",
+                    "Conversation: %x, looked for name in %x, found %s\n",
+                    c, tempconv, name_needing_update);
+
+    g_return_val_if_fail(name_needing_update != NULL, FALSE);
+
+    if (!strcmp(gaim_buddy_icon_get_username(bicon), name_needing_update)) {
+        gaym_gtkconv_update_buddy_icon(c, bicon);
+        gaim_buddy_icon_ref(bicon);
+        gaim_conversation_destroy(tempconv);
+        return TRUE;
+    }
+    return TRUE;
 }
 
-static GaimPluginInfo info =
+static void icon_updated(GaimConnection * gc, GaimBuddyIcon * icon)
 {
-	GAIM_PLUGIN_MAGIC,
-	GAIM_MAJOR_VERSION,
-	GAIM_MINOR_VERSION,
-	GAIM_PLUGIN_STANDARD,
-	GAIM_GTK_PLUGIN_TYPE,
-	0,
-	NULL,
-	GAIM_PRIORITY_DEFAULT,
-	CHATSORT_PLUGIN_ID,
-	N_("Chatroom Icons"),
-	VERSION,
-	N_("Shows user thumbnails below the names list in a chatroom."),
-	N_("Shows user thumbnails below the names list in a chatroom."),
-	"Jason LeBrun <gaim at jasonlebrun.info",
-	GAIM_WEBSITE,
-	plugin_load,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL
+
+    g_return_if_fail(icon != NULL);
+    gaim_debug_misc("chaticon", "Icon updated: (%x) %s\n", icon,
+                    gaim_buddy_icon_get_username(icon));
+    g_hash_table_foreach_remove(pending_updates,
+                                (GHRFunc) check_for_update, icon);
+
+}
+static gboolean plugin_load(GaimPlugin * plugin)
+{
+    icons = g_hash_table_new(g_direct_hash, g_direct_equal);
+    icon_spots = g_hash_table_new(g_direct_hash, g_direct_equal);
+    pending_updates = g_hash_table_new(g_direct_hash, g_direct_equal);
+
+    gaim_signal_connect(gaim_conversations_get_handle(), "chat-joined",
+                        plugin, GAIM_CALLBACK(redochatwindow), NULL);
+    gaim_signal_connect(gaim_accounts_get_handle(), "buddy-icon-fetched",
+                        plugin, GAIM_CALLBACK(icon_updated), NULL);
+
+    hider_window = gaim_conv_window_new();
+    // gaim_conv_window_hide(hider_window);
+    return TRUE;
+}
+
+static GaimPluginInfo info = {
+    GAIM_PLUGIN_MAGIC,
+    GAIM_MAJOR_VERSION,
+    GAIM_MINOR_VERSION,
+    GAIM_PLUGIN_STANDARD,
+    GAIM_GTK_PLUGIN_TYPE,
+    0,
+    NULL,
+    GAIM_PRIORITY_DEFAULT,
+    CHATSORT_PLUGIN_ID,
+    N_("Chatroom Icons"),
+    VERSION,
+    N_("Shows user thumbnails below the names list in a chatroom."),
+    N_("Shows user thumbnails below the names list in a chatroom."),
+    "Jason LeBrun <gaim at jasonlebrun.info",
+    GAIM_WEBSITE,
+    plugin_load,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL
 };
 
-static void
-init_plugin(GaimPlugin *plugin)
+static void init_plugin(GaimPlugin * plugin)
 {
 }
 

Modified: qrc/trunk/gaym-extras/roombrowse.c
===================================================================
--- qrc/trunk/gaym-extras/roombrowse.c	2005-07-24 00:15:50 UTC (rev 235)
+++ qrc/trunk/gaym-extras/roombrowse.c	2005-07-24 03:25:47 UTC (rev 236)
@@ -1,5 +1,5 @@
 /* Puts last 4k of log in new conversations a la Everybuddy (and then
- * stolen by Trillian "Pro") */
+   stolen by Trillian "Pro") */
 
 #include "internal.h"
 #include "gtkgaim.h"
@@ -34,20 +34,19 @@
 
 struct RoomBrowseInfo {
 
-	GaimAccount *account;
-	GaimConnection *gc;
+    GaimAccount *account;
+    GaimConnection *gc;
 };
-	
-static GtkWidget *
-setup_roombrowse_pane(GaimConversation *conv)
+
+static GtkWidget *setup_roombrowse_pane(GaimConversation * conv)
 {
-	GaimGtkConversation *gtkconv;
-	GaimGtkChatPane *gtkchat;
-	GaimConnection *gc;
-	GtkWidget *vpaned, *hpaned;
-	GtkWidget *vbox;
+    GaimGtkConversation *gtkconv;
+    GaimGtkChatPane *gtkchat;
+    GaimConnection *gc;
+    GtkWidget *vpaned, *hpaned;
+    GtkWidget *vbox;
 
-	/**
+        /**
 	 * Unused variables:
 	 *
 	 * GaimPluginProtocolInfo *prpl_info = NULL;
@@ -63,392 +62,403 @@
 	 * GList *focus_chain = NULL;
 	 */
 
-	gtkconv = GAIM_GTK_CONVERSATION(conv);
-	gtkchat = gtkconv->u.chat;
-	gc      = gaim_conversation_get_gc(conv);
+    gtkconv = GAIM_GTK_CONVERSATION(conv);
+    gtkchat = gtkconv->u.chat;
+    gc = gaim_conversation_get_gc(conv);
 
-	/* Setup the outer pane. */
-	vpaned = gtk_vpaned_new();
-	gtk_widget_show(vpaned);
-	/* Setup the top part of the pane. */
-	vbox = gtk_vbox_new(FALSE, 6);
-	gtk_paned_pack1(GTK_PANED(vpaned), vbox, TRUE, TRUE);
-	gtk_widget_show(vbox);
+    /* Setup the outer pane. */
+    vpaned = gtk_vpaned_new();
+    gtk_widget_show(vpaned);
+    /* Setup the top part of the pane. */
+    vbox = gtk_vbox_new(FALSE, 6);
+    gtk_paned_pack1(GTK_PANED(vpaned), vbox, TRUE, TRUE);
+    gtk_widget_show(vbox);
 
-	/* Setup the horizontal pane. */
-	hpaned = gtk_hpaned_new();
-	gtk_box_pack_start(GTK_BOX(vbox), hpaned, TRUE, TRUE, 0);
-	gtk_widget_show(hpaned);
+    /* Setup the horizontal pane. */
+    hpaned = gtk_hpaned_new();
+    gtk_box_pack_start(GTK_BOX(vbox), hpaned, TRUE, TRUE, 0);
+    gtk_widget_show(hpaned);
 
-	/* Setup the scrolled window to put gtkimhtml in. */
-	gtkconv->sw = gtk_scrolled_window_new(NULL, NULL);
-	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(gtkconv->sw),
-								   GTK_POLICY_AUTOMATIC, GTK_POLICY_ALWAYS);
-	gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(gtkconv->sw),
-										GTK_SHADOW_IN);
-	gtk_paned_pack1(GTK_PANED(hpaned), gtkconv->sw, TRUE, TRUE);
+    /* Setup the scrolled window to put gtkimhtml in. */
+    gtkconv->sw = gtk_scrolled_window_new(NULL, NULL);
+    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(gtkconv->sw),
+                                   GTK_POLICY_AUTOMATIC,
+                                   GTK_POLICY_ALWAYS);
+    gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(gtkconv->sw),
+                                        GTK_SHADOW_IN);
+    gtk_paned_pack1(GTK_PANED(hpaned), gtkconv->sw, TRUE, TRUE);
 
-	gtk_widget_set_size_request(gtkconv->sw,
-			gaim_prefs_get_int("/gaim/gtk/conversations/chat/default_width"),
-			gaim_prefs_get_int("/gaim/gtk/conversations/chat/default_height"));
+    gtk_widget_set_size_request(gtkconv->sw,
+                                gaim_prefs_get_int
+                                ("/gaim/gtk/conversations/chat/default_width"),
+                                gaim_prefs_get_int
+                                ("/gaim/gtk/conversations/chat/default_height"));
 
-//	g_signal_connect(G_OBJECT(gtkconv->sw), "size-allocate",
-//					 G_CALLBACK(size_allocate_cb), conv);
+    // g_signal_connect(G_OBJECT(gtkconv->sw), "size-allocate",
+    // G_CALLBACK(size_allocate_cb), conv);
 
-	gtk_widget_show(gtkconv->sw);
+    gtk_widget_show(gtkconv->sw);
 
-	return vpaned;
+    return vpaned;
 }
 
-static gint
-close_conv_cb(GtkWidget *w, gpointer d)
+static gint close_conv_cb(GtkWidget * w, gpointer d)
 {
-        GaimConversation *conv = (GaimConversation *)d;
-	
-        gaim_conversation_destroy(conv);
+    GaimConversation *conv = (GaimConversation *) d;
 
-        return TRUE;
+    gaim_conversation_destroy(conv);
+
+    return TRUE;
 }
-GdkPixbuf* get_tab_icon(GaimConversation *conv, gboolean small_icon)
+
+GdkPixbuf *get_tab_icon(GaimConversation * conv, gboolean small_icon)
 {
-        GaimAccount *account = NULL;
-        const char *name = NULL;
-        GdkPixbuf *status = NULL;
+    GaimAccount *account = NULL;
+    const char *name = NULL;
+    GdkPixbuf *status = NULL;
 
-        g_return_val_if_fail( conv != NULL, NULL);
+    g_return_val_if_fail(conv != NULL, NULL);
 
-        account = gaim_conversation_get_account(conv);
-        name = gaim_conversation_get_name(conv);
+    account = gaim_conversation_get_account(conv);
+    name = gaim_conversation_get_name(conv);
 
-        g_return_val_if_fail( account != NULL, NULL);
-        g_return_val_if_fail( name != NULL, NULL);
+    g_return_val_if_fail(account != NULL, NULL);
+    g_return_val_if_fail(name != NULL, NULL);
 
 
-        if (gaim_conversation_get_type(conv) == GAIM_CONV_IM) {
-                GaimBuddy *b = gaim_find_buddy(account, name);
-                if (b != NULL) {
-                        status = gaim_gtk_blist_get_status_icon((GaimBlistNode*)b,
-                                (small_icon ? GAIM_STATUS_ICON_SMALL : GAIM_STATUS_ICON_LARGE));
-                }
+    if (gaim_conversation_get_type(conv) == GAIM_CONV_IM) {
+        GaimBuddy *b = gaim_find_buddy(account, name);
+        if (b != NULL) {
+            status = gaim_gtk_blist_get_status_icon((GaimBlistNode *) b,
+                                                    (small_icon ?
+                                                     GAIM_STATUS_ICON_SMALL
+                                                     :
+                                                     GAIM_STATUS_ICON_LARGE));
         }
+    }
 
-        if (!status) {
-                GdkPixbuf *pixbuf;
-                pixbuf = create_prpl_icon(account);
+    if (!status) {
+        GdkPixbuf *pixbuf;
+        pixbuf = create_prpl_icon(account);
 
-                if (small_icon && pixbuf != NULL)
-                {
-                        status = gdk_pixbuf_scale_simple(pixbuf, 15, 15,
-                                        GDK_INTERP_BILINEAR);
-                        g_object_unref(pixbuf);
-                }
-                else
-                        status = pixbuf;
-        }
- return status;
+        if (small_icon && pixbuf != NULL) {
+            status = gdk_pixbuf_scale_simple(pixbuf, 15, 15,
+                                             GDK_INTERP_BILINEAR);
+            g_object_unref(pixbuf);
+        } else
+            status = pixbuf;
+    }
+    return status;
 }
 
 /**
  * Unused function
  */
 #if 0
-static void
-update_tab_icon(GaimConversation *conv)
+static void update_tab_icon(GaimConversation * conv)
 {
-        GaimGtkConversation *gtkconv;
-        GaimConvWindow *win = gaim_conversation_get_window(conv);
-        GaimAccount *account;
-        const char *name;
-        GdkPixbuf *status = NULL;
+    GaimGtkConversation *gtkconv;
+    GaimConvWindow *win = gaim_conversation_get_window(conv);
+    GaimAccount *account;
+    const char *name;
+    GdkPixbuf *status = NULL;
 
-        g_return_if_fail(conv != NULL);
+    g_return_if_fail(conv != NULL);
 
-        gtkconv = GAIM_GTK_CONVERSATION(conv);
-        name = gaim_conversation_get_name(conv);
-        account = gaim_conversation_get_account(conv);
+    gtkconv = GAIM_GTK_CONVERSATION(conv);
+    name = gaim_conversation_get_name(conv);
+    account = gaim_conversation_get_account(conv);
 
-        status = get_tab_icon(conv, TRUE);
+    status = get_tab_icon(conv, TRUE);
 
-        g_return_if_fail(status != NULL);
+    g_return_if_fail(status != NULL);
 
-        gtk_image_set_from_pixbuf(GTK_IMAGE(gtkconv->icon), status);
-        gtk_image_set_from_pixbuf(GTK_IMAGE(gtkconv->menu_icon), status);
+    gtk_image_set_from_pixbuf(GTK_IMAGE(gtkconv->icon), status);
+    gtk_image_set_from_pixbuf(GTK_IMAGE(gtkconv->menu_icon), status);
 
-        if (status != NULL)
-                g_object_unref(status);
+    if (status != NULL)
+        g_object_unref(status);
 
-        if (gaim_conv_window_get_active_conversation(win) == conv &&
-                gtkconv->u.im->anim == NULL)
-        {
-                status = get_tab_icon(conv, FALSE);
+    if (gaim_conv_window_get_active_conversation(win) == conv &&
+        gtkconv->u.im->anim == NULL) {
+        status = get_tab_icon(conv, FALSE);
 
-                gtk_window_set_icon(GTK_WINDOW(GAIM_GTK_WINDOW(win)->window), status);
+        gtk_window_set_icon(GTK_WINDOW(GAIM_GTK_WINDOW(win)->window),
+                            status);
 
-                if (status != NULL)
-                        g_object_unref(status);
-        }
+        if (status != NULL)
+            g_object_unref(status);
+    }
 }
 #endif
 
 /* Courtesy of Galeon! */
 static void
-tab_close_button_state_changed_cb(GtkWidget *widget, GtkStateType prev_state)
+tab_close_button_state_changed_cb(GtkWidget * widget,
+                                  GtkStateType prev_state)
 {
-        if (GTK_WIDGET_STATE(widget) == GTK_STATE_ACTIVE)
-                gtk_widget_set_state(widget, GTK_STATE_NORMAL);
+    if (GTK_WIDGET_STATE(widget) == GTK_STATE_ACTIVE)
+        gtk_widget_set_state(widget, GTK_STATE_NORMAL);
 }
 
 static void
-roombrowse_gtk_add_conversation(GaimConvWindow *win, GaimConversation *conv)
+roombrowse_gtk_add_conversation(GaimConvWindow * win,
+                                GaimConversation * conv)
 {
-	GaimGtkWindow *gtkwin;
-	GaimGtkConversation *gtkconv, *focus_gtkconv;
-	GaimConversation *focus_conv;
-	GtkWidget *pane = NULL;
-	GtkWidget *tab_cont;
-	GtkWidget *tabby, *menu_tabby;
-	GtkWidget *close_image;
-	gboolean new_ui;
-	GaimConversationType conv_type;
-	const char *name;
+    GaimGtkWindow *gtkwin;
+    GaimGtkConversation *gtkconv, *focus_gtkconv;
+    GaimConversation *focus_conv;
+    GtkWidget *pane = NULL;
+    GtkWidget *tab_cont;
+    GtkWidget *tabby, *menu_tabby;
+    GtkWidget *close_image;
+    gboolean new_ui;
+    GaimConversationType conv_type;
+    const char *name;
 
-	name      = gaim_conversation_get_name(conv);
-	conv_type = gaim_conversation_get_type(conv);
-	gtkwin    = GAIM_GTK_WINDOW(win);
+    name = gaim_conversation_get_name(conv);
+    conv_type = gaim_conversation_get_type(conv);
+    gtkwin = GAIM_GTK_WINDOW(win);
 
-	if (conv->ui_data != NULL) {
-		gtkconv = (GaimGtkConversation *)conv->ui_data;
+    if (conv->ui_data != NULL) {
+        gtkconv = (GaimGtkConversation *) conv->ui_data;
 
-		tab_cont = gtkconv->tab_cont;
+        tab_cont = gtkconv->tab_cont;
 
-		new_ui = FALSE;
-	}
-	else {
-		gtkconv = g_malloc0(sizeof(GaimGtkConversation));
-		conv->ui_data = gtkconv;
+        new_ui = FALSE;
+    } else {
+        gtkconv = g_malloc0(sizeof(GaimGtkConversation));
+        conv->ui_data = gtkconv;
 
-		/* Setup some initial variables. */
-		gtkconv->sg       = gtk_size_group_new(GTK_SIZE_GROUP_BOTH);
-		gtkconv->tooltips = gtk_tooltips_new();
+        /* Setup some initial variables. */
+        gtkconv->sg = gtk_size_group_new(GTK_SIZE_GROUP_BOTH);
+        gtkconv->tooltips = gtk_tooltips_new();
 
-	gaim_debug_misc("roombrowse","setting up pane\n");	
-		pane = setup_roombrowse_pane(conv);
-		
-	gaim_debug_misc("roombrowse","set up pane\n");	
+        gaim_debug_misc("roombrowse", "setting up pane\n");
+        pane = setup_roombrowse_pane(conv);
 
-		if (pane == NULL) {
-			g_free(gtkconv);
-			conv->ui_data = NULL;
+        gaim_debug_misc("roombrowse", "set up pane\n");
 
-			return;
-		}
+        if (pane == NULL) {
+            g_free(gtkconv);
+            conv->ui_data = NULL;
 
-		
-		
-		/* Setup the container for the tab. */
-		gtkconv->tab_cont = tab_cont = gtk_vbox_new(FALSE, 6);
-		gtk_container_set_border_width(GTK_CONTAINER(tab_cont), 6);
-		gtk_container_add(GTK_CONTAINER(tab_cont), pane);
-		gtk_widget_show(pane);
+            return;
+        }
 
-		new_ui = TRUE;
 
-		gtkconv->make_sound = FALSE;
-		gtkconv->show_formatting_toolbar = FALSE;
-		gtkconv->show_timestamps = FALSE;
-		
-		g_signal_connect_swapped(G_OBJECT(pane), "focus",
-					 G_CALLBACK(gtk_widget_grab_focus),
-					 gtkconv->entry);
-	}
 
-	gaim_debug_misc("roombrowse","Setting up tabs\n");
-	gtkconv->tabby = tabby = gtk_hbox_new(FALSE, 6);
-        gtkconv->menu_tabby = menu_tabby = gtk_hbox_new(FALSE, 6);
-	gtkconv->entry = gtk_imhtml_new(NULL, NULL);
-		gtkconv->toolbar = gtk_imhtmltoolbar_new();
+        /* Setup the container for the tab. */
+        gtkconv->tab_cont = tab_cont = gtk_vbox_new(FALSE, 6);
+        gtk_container_set_border_width(GTK_CONTAINER(tab_cont), 6);
+        gtk_container_add(GTK_CONTAINER(tab_cont), pane);
+        gtk_widget_show(pane);
 
-	gaim_debug_misc("roombrowse","Setting up close button\n");
-	/* Close button. */
-	gtkconv->close = gtk_button_new();
-	gtk_widget_set_size_request(GTK_WIDGET(gtkconv->close), 16, 16);
-	gtk_button_set_relief(GTK_BUTTON(gtkconv->close), GTK_RELIEF_NONE);
-	close_image = gtk_image_new_from_stock(GTK_STOCK_CLOSE, GTK_ICON_SIZE_MENU);
-	gtk_widget_show(close_image);
-	gtk_container_add(GTK_CONTAINER(gtkconv->close), close_image);
-	gtk_tooltips_set_tip(gtkconv->tooltips, gtkconv->close,
-			     _("Close conversation"), NULL);
+        new_ui = TRUE;
 
-	g_signal_connect(G_OBJECT(gtkconv->close), "clicked",
-		 G_CALLBACK(close_conv_cb), conv);
+        gtkconv->make_sound = FALSE;
+        gtkconv->show_formatting_toolbar = FALSE;
+        gtkconv->show_timestamps = FALSE;
 
-	/*
-	* I love Galeon. They have a fix for that stupid annoying visible
-	* border bug. I love you guys! -- ChipX86
-	*/
-	g_signal_connect(G_OBJECT(gtkconv->close), "state_changed",
-			 G_CALLBACK(tab_close_button_state_changed_cb), NULL);
+        g_signal_connect_swapped(G_OBJECT(pane), "focus",
+                                 G_CALLBACK(gtk_widget_grab_focus),
+                                 gtkconv->entry);
+    }
 
-	/* Status icon. */
-	gtkconv->icon = gtk_image_new();
-	gtkconv->menu_icon = gtk_image_new();
-//	update_tab_icon(conv);
+    gaim_debug_misc("roombrowse", "Setting up tabs\n");
+    gtkconv->tabby = tabby = gtk_hbox_new(FALSE, 6);
+    gtkconv->menu_tabby = menu_tabby = gtk_hbox_new(FALSE, 6);
+    gtkconv->entry = gtk_imhtml_new(NULL, NULL);
+    gtkconv->toolbar = gtk_imhtmltoolbar_new();
 
-	/* Tab label. */
-	gtkconv->tab_label = gtk_label_new(gaim_conversation_get_title(conv));
-	gtkconv->menu_label = gtk_label_new(gaim_conversation_get_title(conv));
+    gaim_debug_misc("roombrowse", "Setting up close button\n");
+    /* Close button. */
+    gtkconv->close = gtk_button_new();
+    gtk_widget_set_size_request(GTK_WIDGET(gtkconv->close), 16, 16);
+    gtk_button_set_relief(GTK_BUTTON(gtkconv->close), GTK_RELIEF_NONE);
+    close_image =
+        gtk_image_new_from_stock(GTK_STOCK_CLOSE, GTK_ICON_SIZE_MENU);
+    gtk_widget_show(close_image);
+    gtk_container_add(GTK_CONTAINER(gtkconv->close), close_image);
+    gtk_tooltips_set_tip(gtkconv->tooltips, gtkconv->close,
+                         _("Close conversation"), NULL);
+
+    g_signal_connect(G_OBJECT(gtkconv->close), "clicked",
+                     G_CALLBACK(close_conv_cb), conv);
+
+    /* 
+     * I love Galeon. They have a fix for that stupid annoying visible
+     * border bug. I love you guys! -- ChipX86
+     */
+    g_signal_connect(G_OBJECT(gtkconv->close), "state_changed",
+                     G_CALLBACK(tab_close_button_state_changed_cb), NULL);
+
+    /* Status icon. */
+    gtkconv->icon = gtk_image_new();
+    gtkconv->menu_icon = gtk_image_new();
+    // update_tab_icon(conv);
+
+    /* Tab label. */
+    gtkconv->tab_label = gtk_label_new(gaim_conversation_get_title(conv));
+    gtkconv->menu_label = gtk_label_new(gaim_conversation_get_title(conv));
 #if 0
-	gtk_misc_set_alignment(GTK_MISC(gtkconv->tab_label), 0.00, 0.5);
-	gtk_misc_set_padding(GTK_MISC(gtkconv->tab_label), 4, 0);
+    gtk_misc_set_alignment(GTK_MISC(gtkconv->tab_label), 0.00, 0.5);
+    gtk_misc_set_padding(GTK_MISC(gtkconv->tab_label), 4, 0);
 #endif
 
-	gaim_debug_misc("roombrowse","Packing\n");
-	/* Pack it all together. */
-	gtk_box_pack_start(GTK_BOX(tabby), gtkconv->icon, FALSE, FALSE, 0);
-	gtk_box_pack_start(GTK_BOX(menu_tabby), gtkconv->menu_icon,
-			   FALSE, FALSE, 0);
+    gaim_debug_misc("roombrowse", "Packing\n");
+    /* Pack it all together. */
+    gtk_box_pack_start(GTK_BOX(tabby), gtkconv->icon, FALSE, FALSE, 0);
+    gtk_box_pack_start(GTK_BOX(menu_tabby), gtkconv->menu_icon,
+                       FALSE, FALSE, 0);
 
-	gtk_widget_show_all(gtkconv->icon);
-	gtk_widget_show_all(gtkconv->menu_icon);
+    gtk_widget_show_all(gtkconv->icon);
+    gtk_widget_show_all(gtkconv->menu_icon);
 
-	gtk_box_pack_start(GTK_BOX(tabby), gtkconv->tab_label, TRUE, TRUE, 0);
-	gtk_box_pack_start(GTK_BOX(menu_tabby), gtkconv->menu_label, TRUE, TRUE, 0);
-	gtk_widget_show(gtkconv->tab_label);
-	gtk_widget_show(gtkconv->menu_label);
-	gtk_misc_set_alignment(GTK_MISC(gtkconv->menu_label), 0, 0);
+    gtk_box_pack_start(GTK_BOX(tabby), gtkconv->tab_label, TRUE, TRUE, 0);
+    gtk_box_pack_start(GTK_BOX(menu_tabby), gtkconv->menu_label, TRUE,
+                       TRUE, 0);
+    gtk_widget_show(gtkconv->tab_label);
+    gtk_widget_show(gtkconv->menu_label);
+    gtk_misc_set_alignment(GTK_MISC(gtkconv->menu_label), 0, 0);
 
-	gtk_box_pack_start(GTK_BOX(tabby), gtkconv->close, FALSE, FALSE, 0);
-	if (gaim_prefs_get_bool("/gaim/gtk/conversations/close_on_tabs"))
-		gtk_widget_show(gtkconv->close);
+    gtk_box_pack_start(GTK_BOX(tabby), gtkconv->close, FALSE, FALSE, 0);
+    if (gaim_prefs_get_bool("/gaim/gtk/conversations/close_on_tabs"))
+        gtk_widget_show(gtkconv->close);
 
-	gtk_widget_show(tabby);
-	gtk_widget_show(menu_tabby);
+    gtk_widget_show(tabby);
+    gtk_widget_show(menu_tabby);
 
-	if (gaim_conversation_get_type(conv) == GAIM_CONV_IM)
-		gaim_gtkconv_update_buddy_icon(conv);
+    if (gaim_conversation_get_type(conv) == GAIM_CONV_IM)
+        gaim_gtkconv_update_buddy_icon(conv);
 
-	gaim_debug_misc("roombrowse","Adding to notebook\n");
-	gaim_debug_misc("roombrowse","gtkwin->notebook=%x\n",gtkwin->notebook);
-	gaim_debug_misc("roombrowse","gtkwin=%x\n",gtkwin);
-	gaim_debug_misc("roombrowse","tabby=%x\n",tabby);
-	gaim_debug_misc("roombrowse","menu_tabby=%x\n",menu_tabby);
-	gaim_debug_misc("roombrowse","tab_cont=%x\n",tab_cont);
+    gaim_debug_misc("roombrowse", "Adding to notebook\n");
+    gaim_debug_misc("roombrowse", "gtkwin->notebook=%x\n",
+                    gtkwin->notebook);
+    gaim_debug_misc("roombrowse", "gtkwin=%x\n", gtkwin);
+    gaim_debug_misc("roombrowse", "tabby=%x\n", tabby);
+    gaim_debug_misc("roombrowse", "menu_tabby=%x\n", menu_tabby);
+    gaim_debug_misc("roombrowse", "tab_cont=%x\n", tab_cont);
 
-	/* Add this pane to the conversation's notebook. */
-	int n=	gtk_notebook_get_n_pages(GTK_NOTEBOOK(gtkwin->notebook));
-	gaim_debug_misc("roombrowse:","Notebook has %d pages\n",n);
-	gtk_notebook_append_page_menu(GTK_NOTEBOOK(gtkwin->notebook), tab_cont, tabby, menu_tabby);
-	gaim_debug_misc("roombrowse","Got through append_page_menu\n");
-	gtk_widget_show(tab_cont);
-	
-	if (gaim_conv_window_get_conversation_count(win) == 1) {
-		/* Er, bug in notebooks? Switch to the page manually. */
-		gtk_notebook_set_current_page(GTK_NOTEBOOK(gtkwin->notebook), 0);
+    /* Add this pane to the conversation's notebook. */
+    int n = gtk_notebook_get_n_pages(GTK_NOTEBOOK(gtkwin->notebook));
+    gaim_debug_misc("roombrowse:", "Notebook has %d pages\n", n);
+    gtk_notebook_append_page_menu(GTK_NOTEBOOK(gtkwin->notebook), tab_cont,
+                                  tabby, menu_tabby);
+    gaim_debug_misc("roombrowse", "Got through append_page_menu\n");
+    gtk_widget_show(tab_cont);
 
-		gtk_notebook_set_show_tabs(GTK_NOTEBOOK(gtkwin->notebook),
-					   gaim_prefs_get_bool("/gaim/gtk/conversations/tabs"));
-	}
-	else
-		gtk_notebook_set_show_tabs(GTK_NOTEBOOK(gtkwin->notebook), TRUE);
-	gaim_debug_misc("roombrowse","FOcus stuff\n");
-	focus_conv = g_list_nth_data(gaim_conv_window_get_conversations(win),
-				     gtk_notebook_get_current_page(GTK_NOTEBOOK(gtkwin->notebook)));
-	focus_gtkconv = GAIM_GTK_CONVERSATION(focus_conv);
-	gtk_widget_grab_focus(focus_gtkconv->entry);
+    if (gaim_conv_window_get_conversation_count(win) == 1) {
+        /* Er, bug in notebooks? Switch to the page manually. */
+        gtk_notebook_set_current_page(GTK_NOTEBOOK(gtkwin->notebook), 0);
 
-	if (!new_ui)
-		g_object_unref(gtkconv->tab_cont);
+        gtk_notebook_set_show_tabs(GTK_NOTEBOOK(gtkwin->notebook),
+                                   gaim_prefs_get_bool
+                                   ("/gaim/gtk/conversations/tabs"));
+    } else
+        gtk_notebook_set_show_tabs(GTK_NOTEBOOK(gtkwin->notebook), TRUE);
+    gaim_debug_misc("roombrowse", "FOcus stuff\n");
+    focus_conv = g_list_nth_data(gaim_conv_window_get_conversations(win),
+                                 gtk_notebook_get_current_page(GTK_NOTEBOOK
+                                                               (gtkwin->
+                                                                notebook)));
+    focus_gtkconv = GAIM_GTK_CONVERSATION(focus_conv);
+    gtk_widget_grab_focus(focus_gtkconv->entry);
+
+    if (!new_ui)
+        g_object_unref(gtkconv->tab_cont);
 }
 
 
-static void roombrowse_menu_cb(GaimBlistNode* node, gpointer data) {
-	GaimConvWindow *win=gaim_get_first_window_with_type(GAIM_CONV_MISC);
-	GaimConversation *conv=g_new0(GaimConversation, 1);
+static void roombrowse_menu_cb(GaimBlistNode * node, gpointer data)
+{
+    GaimConvWindow *win = gaim_get_first_window_with_type(GAIM_CONV_MISC);
+    GaimConversation *conv = g_new0(GaimConversation, 1);
 
-	GaimAccount* account=((GaimChat*)node)->account;
-	if(!win)
-		win=gaim_conv_window_new();
-	GaimChat* chat = ((GaimChat*)node);
-	char *room= g_strdup(g_hash_table_lookup(chat->components,"name"));
+    GaimAccount *account = ((GaimChat *) node)->account;
+    if (!win)
+        win = gaim_conv_window_new();
+    GaimChat *chat = ((GaimChat *) node);
+    char *room = g_strdup(g_hash_table_lookup(chat->components, "name"));
 
-	
-	gaim_debug_misc("roombrowser","In cb with node=%x, account=%x\n",node,account);
-	conv=gaim_conversation_new(GAIM_CONV_MISC, account, room);
-	
-	gaim_conversation_set_logging(conv, FALSE);
-		
-	roombrowse_gtk_add_conversation(conv->window, conv);
-	gaim_conv_window_show(conv->window);
 
-	g_free(room);
-	
+    gaim_debug_misc("roombrowser", "In cb with node=%x, account=%x\n",
+                    node, account);
+    conv = gaim_conversation_new(GAIM_CONV_MISC, account, room);
+
+    gaim_conversation_set_logging(conv, FALSE);
+
+    roombrowse_gtk_add_conversation(conv->window, conv);
+    gaim_conv_window_show(conv->window);
+
+    g_free(room);
+
 }
-static void roombrowse_menu_create(GaimBlistNode *node, GList **menu)
+static void roombrowse_menu_create(GaimBlistNode * node, GList ** menu)
 {
-  
-	char *label,*room;	
-  
-	struct gaym_conn *gaym;
-	GaimChat *chat=(GaimChat*)node;
-  
-	gaim_debug_misc("roombrowse","In callback\n");
-	if(node->type != GAIM_BLIST_CHAT_NODE)
-		return;
-  
-	gaym=chat->account->gc->proto_data;
-  
-	room=g_strdup(g_hash_table_lookup(chat->components,"name"));
-	gaim_debug_misc("roombrowse","Room name: %s\n",room);
-	if(!room)
-		return;
-  
-    
-		label = g_strdup_printf("Lurk in %s",room);
-		GaimBlistNodeAction* act=gaim_blist_node_action_new(label,
-				roombrowse_menu_cb,
-				chat->account);
-  
-		*menu=g_list_append(*menu,act);
-    //g_free(label);
+
+    char *label, *room;
+
+    struct gaym_conn *gaym;
+    GaimChat *chat = (GaimChat *) node;
+
+    gaim_debug_misc("roombrowse", "In callback\n");
+    if (node->type != GAIM_BLIST_CHAT_NODE)
+        return;
+
+    gaym = chat->account->gc->proto_data;
+
+    room = g_strdup(g_hash_table_lookup(chat->components, "name"));
+    gaim_debug_misc("roombrowse", "Room name: %s\n", room);
+    if (!room)
+        return;
+
+
+    label = g_strdup_printf("Lurk in %s", room);
+    GaimBlistNodeAction *act = gaim_blist_node_action_new(label,
+                                                          roombrowse_menu_cb,
+                                                          chat->account);
+
+    *menu = g_list_append(*menu, act);
+    // g_free(label);
 }
-static gboolean plugin_load(GaimPlugin *plugin)
+static gboolean plugin_load(GaimPlugin * plugin)
 {
-	gaim_signal_connect(gaim_blist_get_handle(),
-						"blist-node-extended-menu",
-						plugin, GAIM_CALLBACK(roombrowse_menu_create), NULL);
+    gaim_signal_connect(gaim_blist_get_handle(),
+                        "blist-node-extended-menu",
+                        plugin, GAIM_CALLBACK(roombrowse_menu_create),
+                        NULL);
 
-	
-	gaim_debug_misc("roombrowse","Callback registered!\n");	
-	return TRUE;
+
+    gaim_debug_misc("roombrowse", "Callback registered!\n");
+    return TRUE;
 }
 
-static GaimPluginInfo info =
-{
-	GAIM_PLUGIN_MAGIC,
-	GAIM_MAJOR_VERSION,
-	GAIM_MINOR_VERSION,
-	GAIM_PLUGIN_STANDARD,
-	GAIM_GTK_PLUGIN_TYPE,
-	0,
-	NULL,
-	GAIM_PRIORITY_DEFAULT,
-	CHATSORT_PLUGIN_ID,
-	N_("Gay.Com Room Browser"),
-	VERSION,
-	N_("Browse rooms in gay.com"),
-	N_("Adds a right-click item to context menu."),
-	"Jason LeBrun <gaim at jasonlebrun.info",
-	GAIM_WEBSITE,
-	plugin_load,
-	NULL,
-	NULL,
-	NULL,
-	NULL,
-	NULL
+static GaimPluginInfo info = {
+    GAIM_PLUGIN_MAGIC,
+    GAIM_MAJOR_VERSION,
+    GAIM_MINOR_VERSION,
+    GAIM_PLUGIN_STANDARD,
+    GAIM_GTK_PLUGIN_TYPE,
+    0,
+    NULL,
+    GAIM_PRIORITY_DEFAULT,
+    CHATSORT_PLUGIN_ID,
+    N_("Gay.Com Room Browser"),
+    VERSION,
+    N_("Browse rooms in gay.com"),
+    N_("Adds a right-click item to context menu."),
+    "Jason LeBrun <gaim at jasonlebrun.info",
+    GAIM_WEBSITE,
+    plugin_load,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL
 };
 
-static void
-init_plugin(GaimPlugin *plugin)
+static void init_plugin(GaimPlugin * plugin)
 {
 }
 



From jblebrun at berlios.de  Sun Jul 24 10:18:08 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Sun, 24 Jul 2005 10:18:08 +0200
Subject: [Qrc-svn] r237 - in qrc/trunk: gaym/src gaym-extras
Message-ID: <200507240818.j6O8I8d8014691@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-24 10:18:06 +0200 (Sun, 24 Jul 2005)
New Revision: 237

Modified:
   qrc/trunk/gaym-extras/gaym-extras.c
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gaym.h
   qrc/trunk/gaym/src/gayminfo.c
   qrc/trunk/gaym/src/gayminfo.h
   qrc/trunk/gaym/src/msgs.c
   qrc/trunk/gaym/src/weblogin.c
Log:
AWESOME CHATROOM ICON SUPPORT NOW!

*Complete redone chat-icon system, does not use buddy icons or imgstores.

*gaym now maintains information about people in a hash table as they join the channel. The hash table is cleaned up as they leave, or if you part from the channel. The same people in different rooms are handled using reference counting.

*Added a gaym API call to allow querying of the channel member info



gaym-extras.c:
Complete overhaul.

gaym.h:
Added the GaymChannelMember struct, and channel_members hash table.

gaym.c, gayminfo.c, 
*Added code to clean up hash table on channel parts
*Added function to free a GaymChannelMember struct
*Added various functions for maintaining the channel_members hash

gayminfo.h:
*Minor additions to the fetch_thumbnail_data struct to make it useful in the gui plugin.

msgs.c:
*Joins and parts affect the channel_member struct.





Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-24 03:25:47 UTC (rev 236)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-24 08:18:06 UTC (rev 237)
@@ -63,6 +63,7 @@
 static guint gaym_nick_hash(const char *nick);
 static gboolean gaym_nick_equal(const char *nick1, const char *nick2);
 static void gaym_buddy_free(struct gaym_buddy *ib);
+static void gaym_channel_member_free(GaymChannelMember * cm);
 
 static void gaym_buddy_append(char *name, struct gaym_buddy *ib,
                               BListWhois * blist_whois);
@@ -514,6 +515,12 @@
         g_hash_table_new_full((GHashFunc) gaym_nick_hash,
                               (GEqualFunc) gaym_nick_equal, NULL,
                               (GDestroyNotify) gaym_buddy_free);
+
+    gaym->channel_members =
+        g_hash_table_new_full((GHashFunc) gaym_nick_hash,
+                              (GEqualFunc) gaym_nick_equal, NULL,
+                              (GDestroyNotify) gaym_channel_member_free);
+
     gaym->cmds = g_hash_table_new(g_str_hash, g_str_equal);
     gaym_cmd_table_build(gaym);
     gaym->msgs = g_hash_table_new(g_str_hash, g_str_equal);
@@ -827,6 +834,58 @@
      */
 }
 
+GaymChannelMember *gaym_get_channel_member_reference(struct gaym_conn
+                                                     *gaym,
+                                                     const gchar * name)
+{
+
+    GaymChannelMember *channel_member =
+        (GaymChannelMember *) g_hash_table_lookup(gaym->channel_members,
+                                                  name);
+
+    if (!channel_member) {
+        channel_member = g_new0(struct channel_member, 1);
+        channel_member->ref_count = 1;
+        g_hash_table_insert(gaym->channel_members, g_strdup(name),
+                            channel_member);
+        return g_hash_table_lookup(gaym->channel_members, name);
+    } else {
+        (channel_member->ref_count)++;
+        return channel_member;
+    }
+
+}
+
+gboolean gaym_unreference_channel_member(struct gaym_conn * gaym,
+                                         gchar * name)
+{
+
+    GaymChannelMember *channel_member;
+    channel_member =
+        (GaymChannelMember *) g_hash_table_lookup(gaym->channel_members,
+                                                  name);
+    if (!channel_member)
+        return FALSE;
+    else {
+
+        if (channel_member->ref_count <= 0)
+            gaim_debug_error("gaym",
+                             "****Reference counting error with channel members struct.\n");
+
+        channel_member->ref_count--;
+
+        if (channel_member->ref_count == 0)
+            return g_hash_table_remove(gaym->channel_members, name);
+        return FALSE;
+    }
+}
+
+GaymChannelMember *gaym_get_channel_member_info(struct gaym_conn * gaym,
+                                                gchar * name)
+{
+    return g_hash_table_lookup(gaym->channel_members, name);
+}
+
 static void gaym_add_buddy(GaimConnection * gc, GaimBuddy * buddy,
                            GaimGroup * group)
 {
@@ -1105,6 +1164,17 @@
     return (gaim_utf8_strcasecmp(nick1, nick2) == 0);
 }
 
+static void gaym_channel_member_free(GaymChannelMember * cm)
+{
+    g_free(cm->name);
+    g_free(cm->bio);
+    g_free(cm->thumbnail);
+    g_free(cm->sex);
+    g_free(cm->age);
+    g_free(cm->location);
+    g_free(cm);
+}
+
 static void gaym_buddy_free(struct gaym_buddy *ib)
 {
     g_free(ib->name);
@@ -1271,7 +1341,7 @@
     0,                          /* options */
     NULL,                       /* user_splits */
     NULL,                       /* protocol_options */
-    {"jpg", 55, 75, 55, 75},    /* icon_spec */
+    {"jpg", 57, 77, 57, 77},    /* icon_spec */
     gaym_blist_icon,            /* list_icon */
     gaym_blist_emblems,         /* list_emblems */
     gaym_status_text,           /* status_text */
@@ -1328,6 +1398,28 @@
     gaym_dccsend_send_file      /* send_file */
 };
 
+void deref_one_user(gpointer * user, gpointer * data)
+{
+
+    struct gaym_conn *gaym = (struct gaym_conn *) data;
+    GaimConvChatBuddy *cb = (GaimConvChatBuddy *) user;
+    gaim_debug_misc("gaym", "Removing %s in %x from list\n",
+                    (char *) cb->name, cb);
+
+    gaim_debug_misc("    ", "Succes was: %i\n",
+                    gaym_unreference_channel_member(gaym, cb->name));
+
+}
+static void gaym_clean_channel_members(GaimConversation * conv)
+{
+    GaimConvChat *chat = gaim_conversation_get_chat_data(conv);
+    GaimConnection *gc = gaim_conversation_get_gc(conv);
+    struct gaym_conn *gaym = gc->proto_data;
+    GList *users = gaim_conv_chat_get_users(chat);
+    gaim_debug_misc("gaym", "got userlist %x length %i\n", users,
+                    g_list_length(users));
+    g_list_foreach(users, (GFunc) deref_one_user, gaym);
+}
 static void gaym_get_photo_info(GaimConversation * conv)
 {
     char *buf;
@@ -1512,15 +1604,13 @@
                         "conversation-created", plugin,
                         GAIM_CALLBACK(gaym_get_photo_info), NULL);
 
-    gaim_signal_register(gaim_accounts_get_handle(),
-                         "buddy-icon-fetched",
-                         gaim_marshal_VOID__POINTER_POINTER, NULL, 2,
-                         gaim_value_new(GAIM_TYPE_SUBTYPE,
-                                        GAIM_SUBTYPE_CONNECTION),
-                         gaim_value_new(GAIM_TYPE_SUBTYPE,
-                                        GAIM_SUBTYPE_BUDDY_ICON));
 
+    gaim_signal_connect(gaim_conversations_get_handle(),
+                        "chat-left", plugin,
+                        GAIM_CALLBACK(gaym_clean_channel_members), NULL);
 
+
+
     gaim_prefs_add_none("/plugins/prpl/gaym");
     gaim_prefs_add_int("/plugins/prpl/gaym/chat_room_instances", 4);
     gaim_prefs_add_bool("/plugins/prpl/gaym/show_join", TRUE);
@@ -1548,6 +1638,8 @@
 
 GAIM_INIT_PLUGIN(gaym, _init_plugin, info);
 
+
+
 /**
  * vim:tabstop=4:shiftwidth=4:expandtab:
  */

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-24 03:25:47 UTC (rev 236)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-24 08:18:06 UTC (rev 237)
@@ -63,7 +63,9 @@
     char *server;
     int fd;
     guint timer;
-    GHashTable *buddies;
+    GHashTable *buddies;        /* hash table of struct gaym_buddy */
+    GHashTable *channel_members;        /* hash table of
+                                           GaymChannelMembers */
 
     char *inbuf;
     int inbuflen;
@@ -123,6 +125,24 @@
     char *location;             /* location string */
 };
 
+typedef struct channel_member {
+    char *name;                 /* gaym formatted nick */
+    char *bio;                  /* bio string */
+    char *thumbnail;            /* thumbnail string */
+    char *sex;                  /* sex string */
+    char *age;                  /* age string */
+    char *location;             /* location string */
+    gint ref_count;             /* reference count for mem mngmnt */
+} GaymChannelMember;
+
+gboolean gaym_unreference_channel_member(struct gaym_conn *gaym,
+                                         gchar * name);
+GaymChannelMember *gaym_get_channel_member_info(struct gaym_conn *gaym,
+                                                gchar * name);
+
+GaymChannelMember *gaym_get_channel_member_reference(struct gaym_conn
+                                                     *gaym,
+                                                     const char *name);
 typedef int (*IRCCmdCallback) (struct gaym_conn * gaym, const char *cmd,
                                const char *target, const char **args);
 

Modified: qrc/trunk/gaym/src/gayminfo.c
===================================================================
--- qrc/trunk/gaym/src/gayminfo.c	2005-07-24 03:25:47 UTC (rev 236)
+++ qrc/trunk/gaym/src/gayminfo.c	2005-07-24 08:18:06 UTC (rev 237)
@@ -24,6 +24,7 @@
 
 #include "gayminfo.h"
 #include "util.h"
+#include "debug.h"
 
 char *gaym_thumbnail_strdup(const char *info)
 {
@@ -79,6 +80,37 @@
     }
 }
 
+
+void gaym_update_channel_member(struct gaym_conn *gaym, const char *nick,
+                                const char *info)
+{
+    GaymChannelMember *cm = gaym_get_channel_member_reference(gaym, nick);
+    if (!cm) {
+        gaim_debug_error("gaym",
+                         "ERROR: A member has joined a channel, but we were unable to add the member to the internal management structure. Report a bug.");
+        return;
+    } else {
+        gchar *stats = gaym_stats_strdup(info);
+        if (stats) {
+            gchar **s = g_strsplit(stats, "|", 3);
+            if (s[0] && strlen(g_strstrip(s[0])) > 0) {
+                cm->sex = g_ascii_strup(s[0], -1);
+            }
+            if (s[1] && strlen(g_strstrip(s[1])) > 0) {
+                cm->age = g_strdup(s[1]);
+            }
+            if (s[2] && strlen(g_strstrip(s[2])) > 0) {
+                cm->location = g_strdup(s[2]);
+            }
+            g_strfreev(s);
+            g_free(stats);
+        }
+        cm->name = g_strdup(nick);
+        cm->bio = gaym_bio_strdup(info);
+        cm->thumbnail = gaym_thumbnail_strdup(info);
+
+    }
+}
 void gaym_buddy_status(struct gaym_conn *gaym, char *name,
                        gboolean online, char *info)
 {

Modified: qrc/trunk/gaym/src/gayminfo.h
===================================================================
--- qrc/trunk/gaym/src/gayminfo.h	2005-07-24 03:25:47 UTC (rev 236)
+++ qrc/trunk/gaym/src/gayminfo.h	2005-07-24 08:18:06 UTC (rev 237)
@@ -37,6 +37,8 @@
     char *who;
     char *bio;
     char *stats;
+    const char *pic_data;
+    gint pic_data_len;
 };
 void gaym_fetch_thumbnail_cb(void *user_data, const char *pic_data,
                              size_t len);
@@ -85,6 +87,9 @@
 void gaym_buddy_status(struct gaym_conn *gaym, char *name,
                        gboolean online, char *info);
 
+
+void gaym_update_channel_member(struct gaym_conn *gaym, const char *nick,
+                                const char *info);
 #endif                          /* _GAIM_GAYM_GAYMINFO_H_ */
 
 /**

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-24 03:25:47 UTC (rev 236)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-24 08:18:06 UTC (rev 237)
@@ -101,13 +101,8 @@
     if (GAIM_CONNECTION_IS_VALID(d->gc) && len) {
         gaim_buddy_icons_set_for_user(gaim_connection_get_account(d->gc),
                                       d->who, (void *) pic_data, len);
-        gaim_signal_emit(gaim_accounts_get_handle(), "buddy-icon-fetched",
-                         d->gc, gaim_buddy_icons_find(d->gc->account,
-                                                      d->who));
     } else {
         gaim_debug_error("gaym", "Fetching buddy icon failed.\n");
-        gaim_signal_emit(gaim_accounts_get_handle(), "buddy-icon-fetched",
-                         d->gc, NULL, d->who);
     }
 
     g_free(d->who);
@@ -758,6 +753,7 @@
     }
     ops->chat_update_user((convo), nick);
 
+    gaym_update_channel_member(gaym, nick, args[1]);
     g_free(bio_markedup);
     g_free(nick);
 }
@@ -924,6 +920,9 @@
                                          (gaim_conv_chat_get_users
                                           (GAIM_CONV_CHAT(convo)), cb));
                 gaim_conv_chat_cb_destroy(cb);
+                if (!gaym_unreference_channel_member(gaym, nick))
+                    gaim_debug_error("gaym",
+                                     "channel_members reference counting bug.\n");
             }
         }
     }
@@ -1315,6 +1314,7 @@
         gaim_conv_chat_ignore(GAIM_CONV_CHAT(convo), nick);
     }
     ops->chat_update_user((convo), nick);
+    gaym_update_channel_member(gaym, nick, extra);
 }
 
 /**

Modified: qrc/trunk/gaym/src/weblogin.c
===================================================================
--- qrc/trunk/gaym/src/weblogin.c	2005-07-24 03:25:47 UTC (rev 236)
+++ qrc/trunk/gaym/src/weblogin.c	2005-07-24 08:18:06 UTC (rev 237)
@@ -266,6 +266,7 @@
 // 
 // 
 // 
+// 
 // this
 // structure, as well.
 static void
@@ -301,6 +302,7 @@
                        // 
                        // 
                        // 
+                       // 
                        // (see 
                        // above)
                        (gfud->full ? "" : "/"),
@@ -315,6 +317,7 @@
                        // 
                        // 
                        // 
+                       // 
                        // See 
                        // above
                        (gfud->full ? "" : "/"),

Modified: qrc/trunk/gaym-extras/gaym-extras.c
===================================================================
--- qrc/trunk/gaym-extras/gaym-extras.c	2005-07-24 03:25:47 UTC (rev 236)
+++ qrc/trunk/gaym-extras/gaym-extras.c	2005-07-24 08:18:06 UTC (rev 237)
@@ -15,6 +15,10 @@
 #include "gtkconv.h"
 #include "gtkimhtml.h"
 #include "gtkplugin.h"
+
+#include "../gaym/src/gaym.h"
+#include "../gaym/src/gayminfo.h"
+
 #define CHATSORT_PLUGIN_ID "gtk-chaticon"
 
 GHashTable *icons;
@@ -27,7 +31,9 @@
     GaimConversation *conv;
     GtkWidget *icon_container_parent;
     GtkWidget *icon_container;
+    GtkWidget *frame;
     GtkWidget *icon;
+    GtkWidget *event;
     gboolean show_icon;
     GdkPixbufAnimation *anim;
     GdkPixbufAnimationIter *iter;
@@ -36,66 +42,29 @@
 
 } GaymChatIcon;
 
-static void
-get_icon_scale_size(GdkPixbufAnimation * icon, GaimBuddyIconSpec * spec,
-                    int *width, int *height)
-{
-    *width = gdk_pixbuf_animation_get_width(icon);
-    *height = gdk_pixbuf_animation_get_height(icon);
 
-    /* this should eventually get smarter about preserving the aspect
-       ratio when scaling, but gimmie a break, I just woke up */
-    if (spec && spec->scale_rules & GAIM_ICON_SCALE_DISPLAY) {
-        if (*width < spec->min_width)
-            *width = spec->min_width;
-        else if (*width > spec->max_width)
-            *width = spec->max_width;
 
-        if (*height < spec->min_height)
-            *height = spec->min_height;
-        else if (*height > spec->max_height)
-            *height = spec->max_height;
-    }
-
-    /* and now for some arbitrary sanity checks */
-    if (*width > 100)
-        *width = 100;
-    if (*height > 100)
-        *height = 100;
-}
-
-
 void
-gaym_gtkconv_update_buddy_icon(GaimConversation * conv,
-                               GaimBuddyIcon * icon)
+gaym_gtkconv_update_thumbnail(GaimConversation * conv,
+                              struct gaym_fetch_thumbnail_data
+                              *thumbnail_data)
 {
     GaimGtkConversation *gtkconv;
-    // GaimGtkWindow *gtkwin =
-    // GAIM_GTK_WINDOW(gaim_conversation_get_window(conv));
 
     char filename[256];
     FILE *file;
     GError *err = NULL;
 
-    const void *data = NULL;
     size_t len;
 
     GdkPixbuf *buf;
 
-    GtkWidget *event;
-    GtkWidget *frame;
-    GdkPixbuf *scale;
     GdkPixmap *pm;
     GdkBitmap *bm;
-    int scale_width, scale_height;
-    GtkRequisition requisition;
 
     GaimAccount *account;
     GaimPluginProtocolInfo *prpl_info = NULL;
 
-    // GaimButtonStyle button_type;
-
-    gaim_debug_misc("chaticon", "entered update function\n");
     g_return_if_fail(conv != NULL);
     g_return_if_fail(GAIM_IS_GTK_CONVERSATION(conv));
     g_return_if_fail(gaim_conversation_get_type(conv) == GAIM_CONV_CHAT);
@@ -103,31 +72,25 @@
     gtkconv = GAIM_GTK_CONVERSATION(conv);
 
     GaymChatIcon *icon_data = g_hash_table_lookup(icons, conv);
-    gaim_debug_misc("chaticon",
-                    "got icon_data: %x ... icon is %x, show_icon is %i\n",
-                    icon_data, icon, icon_data->show_icon);
-    // Look things up in our hand hash table of icon stuff.
 
-    if (!icon)
+    if (!thumbnail_data)
         return;
     if (!icon_data->show_icon)
         return;
 
+    const char *data = thumbnail_data->pic_data;
+    len = thumbnail_data->pic_data_len;
+
     account = gaim_conversation_get_account(conv);
     if (account && account->gc)
         prpl_info = GAIM_PLUGIN_PROTOCOL_INFO(account->gc->prpl);
 
-    /* Remove the current icon stuff */
-    if (icon_data->icon_container != NULL)
-        gtk_widget_destroy(icon_data->icon_container);
-    icon_data->icon_container = NULL;
 
     if (icon_data->anim != NULL)
         g_object_unref(G_OBJECT(icon_data->anim));
 
     icon_data->anim = NULL;
 
-    gaim_debug_misc("chaticon", "did some unreffing\n");
     if (icon_data->icon_timer != 0)
         g_source_remove(icon_data->icon_timer);
 
@@ -145,37 +108,23 @@
     if (gaim_conversation_get_gc(conv) == NULL)
         return;
 
-    gaim_debug_misc("chaticon", "did some more unreffing\n");
-    // ///ICON GETTING
-    // icon = gaim_conv_im_get_icon(GAIM_CONV_IM(conv));
 
-    // if (icon == NULL)
-    // return;
-
-    data = gaim_buddy_icon_get_data(icon, &len);
-
-    // ////END ICON GETTING
-
     /* this is such an evil hack, i don't know why i'm even considering
        it. we'll do it differently when gdk-pixbuf-loader isn't leaky
        anymore. */
     /* gdk-pixbuf-loader was leaky? is it still? */
 
-    gaim_debug_misc("chaticon", "Got icon data\n");
     g_snprintf(filename, sizeof(filename),
                "%s" G_DIR_SEPARATOR_S "gaimicon-%s.%d",
-               g_get_tmp_dir(), gaim_buddy_icon_get_username(icon),
-               getpid());
+               g_get_tmp_dir(), thumbnail_data->who, getpid());
 
     if (!(file = g_fopen(filename, "wb")))
         return;
 
     fwrite(data, 1, len, file);
     fclose(file);
-    gaim_debug_misc("chaticon", "Wrote temp file\n");
     icon_data->anim = gdk_pixbuf_animation_new_from_file(filename, &err);
 
-    gaim_debug_misc("chaticon", "Loaded icon from temp file\n");
     /* make sure we remove the file as soon as possible */
     g_unlink(filename);
 
@@ -185,6 +134,8 @@
         g_error_free(err);
     }
 
+
+
     if (!icon_data->anim)
         return;
 
@@ -195,47 +146,20 @@
         icon_data->iter = gdk_pixbuf_animation_get_iter(icon_data->anim, NULL); /* LEAK 
                                                                                  */
         buf = gdk_pixbuf_animation_iter_get_pixbuf(icon_data->iter);
-        // if (icon_data->animate)
-        // start_anim(NULL, conv);
     }
 
-    get_icon_scale_size(icon_data->anim,
-                        prpl_info ? &prpl_info->icon_spec : NULL,
-                        &scale_width, &scale_height);
-    scale =
-        gdk_pixbuf_scale_simple(buf,
-                                MAX(gdk_pixbuf_get_width(buf) *
-                                    scale_width /
-                                    gdk_pixbuf_animation_get_width
-                                    (icon_data->anim), 1),
-                                MAX(gdk_pixbuf_get_height(buf) *
-                                    scale_height /
-                                    gdk_pixbuf_animation_get_height
-                                    (icon_data->anim), 1),
-                                GDK_INTERP_NEAREST);
 
-    gdk_pixbuf_render_pixmap_and_mask(scale, &pm, &bm, 100);
-    g_object_unref(G_OBJECT(scale));
+    gdk_pixbuf_render_pixmap_and_mask(buf, &pm, &bm, 100);
+    // g_object_unref(G_OBJECT(buf));
 
 
-    icon_data->icon_container = gtk_vbox_new(FALSE, 0);
-
-    frame = gtk_frame_new(NULL);
-    gtk_frame_set_shadow_type(GTK_FRAME(frame),
-                              (bm ? GTK_SHADOW_NONE : GTK_SHADOW_IN));
-    gtk_box_pack_start(GTK_BOX(icon_data->icon_container), frame,
-                       FALSE, FALSE, 0);
-
-    event = gtk_event_box_new();
-    gtk_container_add(GTK_CONTAINER(frame), event);
-    // g_signal_connect(G_OBJECT(event), "button-press-event",
+    icon_data->event = gtk_event_box_new();
+    gtk_container_add(GTK_CONTAINER(icon_data->frame), icon_data->event);
+    // g_signal_connect(G_OBJECT(icon_data->event), "button-press-event",
     // G_CALLBACK(icon_menu), conv);
-    gtk_widget_show(event);
-
+    gtk_widget_show(icon_data->event);
     icon_data->icon = gtk_image_new_from_pixmap(pm, bm);
-    gtk_widget_set_size_request(icon_data->icon, scale_width,
-                                scale_height);
-    gtk_container_add(GTK_CONTAINER(event), icon_data->icon);
+    gtk_container_add(GTK_CONTAINER(icon_data->event), icon_data->icon);
     gtk_widget_show(icon_data->icon);
 
     g_object_unref(G_OBJECT(pm));
@@ -243,38 +167,66 @@
     if (bm)
         g_object_unref(G_OBJECT(bm));
 
-    // ////OLD CODE, KEEPING FOR REFERENCE UNTIL COMPLETE.
-    // button_type =
-    // gaim_prefs_get_int("/gaim/gtk/conversations/button_type");
-    /* the button seems to get its size before the box, so... */
-    gtk_widget_size_request(gtkconv->send, &requisition);
-    // if (button_type == GAIM_BUTTON_NONE || requisition.height * 1.5 <
-    // scale_height) {
-    gtk_box_pack_start(GTK_BOX(icon_data->icon_container_parent),
-                       icon_data->icon_container, FALSE, FALSE, 0);
-    /* gtk_box_reorder_child(GTK_BOX(gtkconv->lower_hbox), vbox, 0); */
-    // } else {
-    // gtk_box_pack_start(GTK_BOX(gtkconv->bbox),
-    // icon_data->icon_container, FALSE, FALSE, 0);
-    // gtk_box_reorder_child(GTK_BOX(gtkconv->bbox),
-    // icon_data->icon_container, 0);
-    // }
-
-    gtk_widget_show(icon_data->icon_container);
-    gtk_widget_show(frame);
-    // ////////////////////
-    /* The buddy icon code needs badly to be fixed. */
     buf = gdk_pixbuf_animation_get_static_image(icon_data->anim);
-    // if(conv ==
-    // gaim_conv_window_get_active_conversation(gaim_conversation_get_window(conv)))
-    // gtk_window_set_icon(GTK_WINDOW(gtkwin->window), buf);
+
 }
+static gboolean check_for_update(gpointer * conversation,
+                                 const gpointer * name, gpointer * data)
+{
 
+    g_return_val_if_fail(conversation != NULL, TRUE);
+    g_return_val_if_fail(name != NULL, TRUE);
+    g_return_val_if_fail(data != NULL, TRUE);
 
-static void changed_cb(GtkTreeSelection * selection, gpointer data)
+    gaim_debug_misc("chaticon", "check for update: %x\n", conversation);
+    GaimConversation *c = (GaimConversation *) conversation;
+    char *name_needing_update = (char *) name;
+
+    struct gaym_fetch_thumbnail_data *d =
+        (struct gaym_fetch_thumbnail_data *) data;
+
+    gaim_debug_misc("chaticon",
+                    "Conversation: %x, name %s\n", c, name_needing_update);
+
+    g_return_val_if_fail(name_needing_update != NULL, FALSE);
+
+    if (!strcmp(d->who, name_needing_update)) {
+        gaym_gtkconv_update_thumbnail(c, d);
+        return TRUE;
+    }
+    return TRUE;
+}
+
+void fetch_thumbnail_cb(void *user_data, const char *pic_data, size_t len)
 {
+    if (!user_data)
+        return;
+    struct gaym_fetch_thumbnail_data *d = user_data;
+    if (!pic_data) {
+        return;
+    }
+    gaim_debug_misc("gaym", "got pic data: %s\n", pic_data);
+    if (len && !g_strrstr_len(pic_data, len, "Server Error")) {
+        d->pic_data = pic_data;
+        d->pic_data_len = len;
+    } else {
+        d->pic_data = 0;
+        d->pic_data_len = 0;
+        gaim_debug_error("gaym", "Fetching thumbnail failed.\n");
+    }
+    g_hash_table_foreach_remove(pending_updates,
+                                (GHRFunc) check_for_update, d);
+    g_free(d->who);
+    g_free(d);
+}
 
-    GaimConversation *c = (GaimConversation *) data;
+
+static void changed_cb(GtkTreeSelection * selection, gpointer conv)
+{
+
+    GaimConversation *c = (GaimConversation *) conv;
+    GaymChannelMember *cm;
+    struct gaym_conn *gaym = c->account->gc->proto_data;
     GtkTreeIter iter;
     GtkTreeModel *model;
     gchar *name;
@@ -285,33 +237,47 @@
     gaim_debug_misc("chatsort", "Click: %s\n", name);
     gtk_button_set_label(g_hash_table_lookup(icon_spots, c), name);
 
-    GaimBuddyIcon *icon =
-        gaim_buddy_icons_find(gaim_conversation_get_account(c), name);
-    if (!icon) {
 
-        // This triggers a conversation window quickly, to trigger an icon 
-        // get.
-        GaimConversation *temp =
-            gaim_conversation_new(GAIM_CONV_IM,
-                                  gaim_conversation_get_account(c), name);
-        gaim_debug_misc("chaticon", "Created temp conv %x\n", temp);
-        // gaim_conversation_destroy(temp);
-        g_hash_table_replace(pending_updates, c, temp);
-    } else {
-        gaym_gtkconv_update_buddy_icon(c, icon);
-    }
+    /* Remove the current icon stuff */
+    GaymChatIcon *icon_data = g_hash_table_lookup(icons, c);
+    if (icon_data->event != NULL)
+        gtk_widget_destroy(icon_data->event);
+    icon_data->event = NULL;
+
+    // Get thumbnail URL.
+    cm = gaym_get_channel_member_info(gaym, name);
+    gaim_debug_misc("chaticon", "got thumbnail url %s for %s\n",
+                    cm->thumbnail, name);
+
+    // Fetch thumbnail.
+
+    struct gaym_fetch_thumbnail_data *data;
+    char *hashurl = g_hash_table_lookup(gaym->confighash,
+                                        "mini-profile-panel.thumbnail-prefix");
+    g_return_if_fail(hashurl != NULL);
+    data = g_new0(struct gaym_fetch_thumbnail_data, 1);
+    data->gc = gaim_account_get_connection(gaym->account);
+    data->who = g_strdup(name);
+    char *url = g_strdup_printf("%s%s", hashurl, cm->thumbnail);
+    gaim_url_fetch(url, FALSE, "Mozilla/4.0", FALSE,
+                   fetch_thumbnail_cb, data);
+
+    // Add entry to hash table for tracking.
+    g_hash_table_replace(pending_updates, c, name);
+
 }
 
-// This gets called BEFORE a chatlist is populated... just creates a new
-// type of chat window.
 static void redochatwindow(GaimConversation * c)
 {
 
     GtkTreeModel *oldls;
 
-    // Get a handle to the chat pane for the conversation
     GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
     GaimGtkChatPane *gtkchat = gtkconv->u.chat;
+    GaimPluginProtocolInfo *prpl_info = NULL;
+    GaimAccount *account = gaim_conversation_get_account(c);
+    if (account && account->gc)
+        prpl_info = GAIM_PLUGIN_PROTOCOL_INFO(account->gc->prpl);
     GtkTreeSelection *select =
         gtk_tree_view_get_selection(GTK_TREE_VIEW(gtkchat->list));
     gtk_tree_selection_set_mode(select, GTK_SELECTION_SINGLE);
@@ -319,6 +285,8 @@
     oldls = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
     GtkBox *vbox = GTK_BOX(gtkchat->list->parent->parent);
 
+    GtkBox *hbox = GTK_BOX(gtkconv->lower_hbox);
+
     GtkWidget *button = gtk_button_new_with_label("A Button");
     gtk_box_pack_end(vbox, GTK_WIDGET(button), FALSE, FALSE, 0);
     gtk_widget_show(button);
@@ -329,58 +297,43 @@
 
     GaymChatIcon *icon_data = g_new0(GaymChatIcon, 1);
 
-    icon_data->icon_container_parent = GTK_WIDGET(vbox);
+    icon_data->icon_container_parent = GTK_WIDGET(hbox);
     icon_data->icon_container = NULL;
     icon_data->icon = NULL;
     icon_data->anim = NULL;
     icon_data->iter = NULL;
     icon_data->show_icon = TRUE;
 
-    g_hash_table_insert(icon_spots, c, button);
-    g_hash_table_insert(icons, c, icon_data);
+    icon_data->icon_container = gtk_vbox_new(FALSE, 0);
+    gtk_widget_set_size_request(GTK_WIDGET(icon_data->icon_container),
+                                prpl_info->icon_spec.max_width,
+                                prpl_info->icon_spec.max_height);
 
-}
 
-static gboolean check_for_update(gpointer * conversation,
-                                 const gpointer * temp, gpointer * icon)
-{
+    icon_data->frame = gtk_frame_new(NULL);
+    gtk_frame_set_shadow_type(GTK_FRAME(icon_data->frame),
+                              (GTK_SHADOW_IN));
+    gtk_box_pack_start(GTK_BOX(icon_data->icon_container),
+                       icon_data->frame, FALSE, FALSE, 0);
+    gtk_widget_show(icon_data->icon_container);
+    gtk_widget_show(icon_data->frame);
+    gtk_box_pack_end(GTK_BOX(icon_data->icon_container_parent),
+                     icon_data->icon_container, FALSE, FALSE, 0);
+    gtk_widget_set_size_request(GTK_WIDGET(icon_data->frame),
+                                prpl_info->icon_spec.max_width,
+                                prpl_info->icon_spec.max_height);
+    gaim_debug_misc("chaticon", "made container\n");
 
-    g_return_val_if_fail(conversation != NULL, TRUE);
-    g_return_val_if_fail(temp != NULL, TRUE);
-    g_return_val_if_fail(icon != NULL, TRUE);
+    icon_data->event = gtk_event_box_new();
+    gtk_container_add(GTK_CONTAINER(icon_data->frame), icon_data->event);
+    // g_signal_connect(G_OBJECT(icon_data->event), "button-press-event",
+    // G_CALLBACK(icon_menu), conv);
+    gtk_widget_show(icon_data->event);
+    g_hash_table_insert(icon_spots, c, button);
+    g_hash_table_insert(icons, c, icon_data);
 
-    GaimBuddyIcon *bicon = (GaimBuddyIcon *) icon;
-    GaimConversation *c = (GaimConversation *) conversation;
-    GaimConversation *tempconv = (GaimConversation *) temp;
-
-
-    const gchar *name_needing_update =
-        gaim_conversation_get_name(tempconv);
-    gaim_debug_misc("chaticon",
-                    "Conversation: %x, looked for name in %x, found %s\n",
-                    c, tempconv, name_needing_update);
-
-    g_return_val_if_fail(name_needing_update != NULL, FALSE);
-
-    if (!strcmp(gaim_buddy_icon_get_username(bicon), name_needing_update)) {
-        gaym_gtkconv_update_buddy_icon(c, bicon);
-        gaim_buddy_icon_ref(bicon);
-        gaim_conversation_destroy(tempconv);
-        return TRUE;
-    }
-    return TRUE;
 }
 
-static void icon_updated(GaimConnection * gc, GaimBuddyIcon * icon)
-{
-
-    g_return_if_fail(icon != NULL);
-    gaim_debug_misc("chaticon", "Icon updated: (%x) %s\n", icon,
-                    gaim_buddy_icon_get_username(icon));
-    g_hash_table_foreach_remove(pending_updates,
-                                (GHRFunc) check_for_update, icon);
-
-}
 static gboolean plugin_load(GaimPlugin * plugin)
 {
     icons = g_hash_table_new(g_direct_hash, g_direct_equal);
@@ -389,11 +342,7 @@
 
     gaim_signal_connect(gaim_conversations_get_handle(), "chat-joined",
                         plugin, GAIM_CALLBACK(redochatwindow), NULL);
-    gaim_signal_connect(gaim_accounts_get_handle(), "buddy-icon-fetched",
-                        plugin, GAIM_CALLBACK(icon_updated), NULL);
 
-    hider_window = gaim_conv_window_new();
-    // gaim_conv_window_hide(hider_window);
     return TRUE;
 }
 
@@ -407,10 +356,10 @@
     NULL,
     GAIM_PRIORITY_DEFAULT,
     CHATSORT_PLUGIN_ID,
-    N_("Chatroom Icons"),
+    N_("Gaym Extras"),
     VERSION,
-    N_("Shows user thumbnails below the names list in a chatroom."),
-    N_("Shows user thumbnails below the names list in a chatroom."),
+    N_("GUI-related additions for the gaym protocol plugin."),
+    N_("Allow modifications of namelist sorting order in "),
     "Jason LeBrun <gaim at jasonlebrun.info",
     GAIM_WEBSITE,
     plugin_load,



From jblebrun at berlios.de  Sun Jul 24 10:53:11 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Sun, 24 Jul 2005 10:53:11 +0200
Subject: [Qrc-svn] r238 - qrc/trunk/gaym-extras
Message-ID: <200507240853.j6O8rBf3016851@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-24 10:53:02 +0200 (Sun, 24 Jul 2005)
New Revision: 238

Modified:
   qrc/trunk/gaym-extras/gaym-extras.c
Log:
Hey, why not show the bio, too. 

OK, it's not in a beautiful place... but I can't figure out how to get it somewhere better.



Modified: qrc/trunk/gaym-extras/gaym-extras.c
===================================================================
--- qrc/trunk/gaym-extras/gaym-extras.c	2005-07-24 08:18:06 UTC (rev 237)
+++ qrc/trunk/gaym-extras/gaym-extras.c	2005-07-24 08:53:02 UTC (rev 238)
@@ -22,9 +22,7 @@
 #define CHATSORT_PLUGIN_ID "gtk-chaticon"
 
 GHashTable *icons;
-GHashTable *icon_spots;
 GHashTable *pending_updates;
-GaimConvWindow *hider_window;
 
 typedef struct _GaymChatIcon {
 
@@ -39,15 +37,14 @@
     GdkPixbufAnimationIter *iter;
     gboolean animate;
     guint32 icon_timer;
+    GtkWidget *bio_area;
 
 } GaymChatIcon;
 
 
 
-void
-gaym_gtkconv_update_thumbnail(GaimConversation * conv,
-                              struct gaym_fetch_thumbnail_data
-                              *thumbnail_data)
+void gaym_gtkconv_update_thumbnail(GaimConversation * conv, struct gaym_fetch_thumbnail_data
+                                   *thumbnail_data)
 {
     GaimGtkConversation *gtkconv;
 
@@ -234,10 +231,6 @@
     gtk_tree_selection_get_selected(selection, &model, &iter);
     gtk_tree_model_get(model, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
 
-    gaim_debug_misc("chatsort", "Click: %s\n", name);
-    gtk_button_set_label(g_hash_table_lookup(icon_spots, c), name);
-
-
     /* Remove the current icon stuff */
     GaymChatIcon *icon_data = g_hash_table_lookup(icons, c);
     if (icon_data->event != NULL)
@@ -249,6 +242,7 @@
     gaim_debug_misc("chaticon", "got thumbnail url %s for %s\n",
                     cm->thumbnail, name);
 
+    gtk_label_set_text(GTK_LABEL(icon_data->bio_area), cm->bio);
     // Fetch thumbnail.
 
     struct gaym_fetch_thumbnail_data *data;
@@ -283,15 +277,10 @@
     gtk_tree_selection_set_mode(select, GTK_SELECTION_SINGLE);
 
     oldls = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
-    GtkBox *vbox = GTK_BOX(gtkchat->list->parent->parent);
 
     GtkBox *hbox = GTK_BOX(gtkconv->lower_hbox);
+    GtkBox *vbox_big = GTK_BOX(gtkconv->lower_hbox->parent);
 
-    GtkWidget *button = gtk_button_new_with_label("A Button");
-    gtk_box_pack_end(vbox, GTK_WIDGET(button), FALSE, FALSE, 0);
-    gtk_widget_show(button);
-
-
     g_signal_connect(G_OBJECT(select), "changed", G_CALLBACK(changed_cb),
                      c);
 
@@ -329,7 +318,11 @@
     // g_signal_connect(G_OBJECT(icon_data->event), "button-press-event",
     // G_CALLBACK(icon_menu), conv);
     gtk_widget_show(icon_data->event);
-    g_hash_table_insert(icon_spots, c, button);
+
+    icon_data->bio_area = gtk_label_new(_(""));
+    gtk_box_pack_start(vbox_big, icon_data->bio_area, FALSE, FALSE, 0);
+    gtk_widget_show(icon_data->bio_area);
+
     g_hash_table_insert(icons, c, icon_data);
 
 }
@@ -337,7 +330,6 @@
 static gboolean plugin_load(GaimPlugin * plugin)
 {
     icons = g_hash_table_new(g_direct_hash, g_direct_equal);
-    icon_spots = g_hash_table_new(g_direct_hash, g_direct_equal);
     pending_updates = g_hash_table_new(g_direct_hash, g_direct_equal);
 
     gaim_signal_connect(gaim_conversations_get_handle(), "chat-joined",



From jblebrun at berlios.de  Sun Jul 24 21:36:08 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Sun, 24 Jul 2005 21:36:08 +0200
Subject: [Qrc-svn] r239 - in qrc/trunk: gaym/src gaym-extras
Message-ID: <200507241936.j6OJa8dC013004@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-24 21:36:03 +0200 (Sun, 24 Jul 2005)
New Revision: 239

Modified:
   qrc/trunk/gaym-extras/gaym-extras.c
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gayminfo.c
   qrc/trunk/gaym/src/msgs.c
   qrc/trunk/gaym/src/weblogin.c
Log:
PLEASE BEAT THE HELL OUT OF THIS! 

*Various bug/crash fixes
*channel_members struct also maintains info for open pvt ims
*Added bio display to pvt windows
*Probably need to change the name of channel_member, channel_members, since it includes pvt ims too.

gaym-extras.c:
*Add stat info to bio display
*Add bio display in pvt ims

gayminfo.c:
*ran indent

msgs.c:
*New signal gets emitted in gaym_msg_whois
*gaym_msg_whois updates the channel_members entry

gaym.c:
*Add signal to notify of info updates.
*Debug messages to keep track of channel_member reference counting
*Added hooks to store pvt im conversation user info in channel_members, too.








Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-24 08:53:02 UTC (rev 238)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-24 19:36:03 UTC (rev 239)
@@ -848,8 +848,13 @@
         channel_member->ref_count = 1;
         g_hash_table_insert(gaym->channel_members, g_strdup(name),
                             channel_member);
+        gaim_debug_misc("gaym", "Creating channel_members entry for %s\n",
+                        name);
         return g_hash_table_lookup(gaym->channel_members, name);
     } else {
+        gaim_debug_misc("gaym",
+                        "Adding reference to channel_members entry for %s\n",
+                        name);
         (channel_member->ref_count)++;
         return channel_member;
     }
@@ -874,8 +879,11 @@
 
         channel_member->ref_count--;
 
-        if (channel_member->ref_count == 0)
+        if (channel_member->ref_count == 0) {
+            gaim_debug_misc("gaym", "Removing %s from channel_members\n",
+                            name);
             return g_hash_table_remove(gaym->channel_members, name);
+        }
         return FALSE;
     }
 }
@@ -1412,13 +1420,23 @@
 }
 static void gaym_clean_channel_members(GaimConversation * conv)
 {
-    GaimConvChat *chat = gaim_conversation_get_chat_data(conv);
-    GaimConnection *gc = gaim_conversation_get_gc(conv);
-    struct gaym_conn *gaym = gc->proto_data;
-    GList *users = gaim_conv_chat_get_users(chat);
-    gaim_debug_misc("gaym", "got userlist %x length %i\n", users,
-                    g_list_length(users));
-    g_list_foreach(users, (GFunc) deref_one_user, gaym);
+
+    g_return_if_fail(conv != NULL);
+
+    if (conv->type == GAIM_CONV_CHAT) {
+        GaimConvChat *chat = gaim_conversation_get_chat_data(conv);
+        GaimConnection *gc = gaim_conversation_get_gc(conv);
+        struct gaym_conn *gaym = gc->proto_data;
+        GList *users = gaim_conv_chat_get_users(chat);
+        gaim_debug_misc("gaym", "got userlist %x length %i\n", users,
+                        g_list_length(users));
+        g_list_foreach(users, (GFunc) deref_one_user, gaym);
+    } else if (conv->type == GAIM_CONV_IM) {
+        gaim_debug_misc("gaym", "removing reference to %s\n", conv->name);
+        GaimConnection *gc = gaim_conversation_get_gc(conv);
+        struct gaym_conn *gaym = gc->proto_data;
+        gaym_unreference_channel_member(gaym, conv->name);
+    }
 }
 static void gaym_get_photo_info(GaimConversation * conv)
 {
@@ -1436,7 +1454,6 @@
         struct gaym_conn *gaym;
 
         GaimConnection *gc = gaim_conversation_get_gc(conv);
-
         gaym = (struct gaym_conn *) gc->proto_data;
 
         if (!gaym) {
@@ -1465,8 +1482,11 @@
         gaim_debug_misc("gaym", "Conversation triggered command: %s\n",
                         buf);
         gaym_send(gaym, buf);
+        gaym_get_channel_member_reference(gaym, name);
         g_free(name);
         g_free(buf);
+        // Opens a reference in channel_members.
+
     }
 }
 
@@ -1606,11 +1626,17 @@
 
 
     gaim_signal_connect(gaim_conversations_get_handle(),
-                        "chat-left", plugin,
+                        "deleting-conversation", plugin,
                         GAIM_CALLBACK(gaym_clean_channel_members), NULL);
 
+    gaim_signal_register(gaim_accounts_get_handle(),
+                         "info-updated",
+                         gaim_marshal_VOID__POINTER_POINTER, NULL, 3,
+                         gaim_value_new(GAIM_TYPE_SUBTYPE,
+                                        GAIM_SUBTYPE_ACCOUNT),
+                         gaim_value_new(GAIM_TYPE_POINTER,
+                                        GAIM_TYPE_CHAR));
 
-
     gaim_prefs_add_none("/plugins/prpl/gaym");
     gaim_prefs_add_int("/plugins/prpl/gaym/chat_room_instances", 4);
     gaim_prefs_add_bool("/plugins/prpl/gaym/show_join", TRUE);

Modified: qrc/trunk/gaym/src/gayminfo.c
===================================================================
--- qrc/trunk/gaym/src/gayminfo.c	2005-07-24 08:53:02 UTC (rev 238)
+++ qrc/trunk/gaym/src/gayminfo.c	2005-07-24 19:36:03 UTC (rev 239)
@@ -87,7 +87,7 @@
     GaymChannelMember *cm = gaym_get_channel_member_reference(gaym, nick);
     if (!cm) {
         gaim_debug_error("gaym",
-                         "ERROR: A member has joined a channel, but we were unable to add the member to the internal management structure. Report a bug.");
+                         "ERROR: A member has joined a channel, or a conversation was opened, but we were unable to add the member to the internal management structure. Report a bug.");
         return;
     } else {
         gchar *stats = gaym_stats_strdup(info);

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-24 08:53:02 UTC (rev 238)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-24 19:36:03 UTC (rev 239)
@@ -277,16 +277,24 @@
 
     struct gaym_fetch_thumbnail_data *data;
 
+    // Update, but then release the reference. It was already opened
+    // during conversation-created.
+    gaym_update_channel_member(gaym, args[1], args[5]);
+    gaym_unreference_channel_member(gaym, args[1]);
+    gaim_signal_emit(gaim_accounts_get_handle(), "info-updated",
+                     gaym->account, args[1]);
+
     if (g_hash_table_lookup(gaym->info_window_needed, normalized)) {
-        g_hash_table_remove(gaym->info_window_needed, normalized);
-        char *hashurl = g_hash_table_lookup(gaym->confighash,
-                                            "ohm.profile-url");
-        g_return_if_fail(hashurl != NULL);
+
         data = g_new0(struct gaym_fetch_thumbnail_data, 1);
         data->gc = gaim_account_get_connection(gaym->account);
         data->who = g_strdup(args[1]);
         data->bio = gaym_bio_strdup(args[5]);
         data->stats = gaym_stats_strdup(args[5]);
+        g_hash_table_remove(gaym->info_window_needed, normalized);
+        char *hashurl = g_hash_table_lookup(gaym->confighash,
+                                            "ohm.profile-url");
+        g_return_if_fail(hashurl != NULL);
 
         char *infourl = g_strdup_printf("%s?pw=%s&name=%s", hashurl,
                                         gaym->hash_pw, args[1]);
@@ -710,6 +718,7 @@
 
     gaym_buddy_status(gaym, nick, TRUE, args[1]);
 
+
     gboolean gaym_botfilter_permit =
         gaym_botfilter_check(gc, nick, bio, FALSE);
 

Modified: qrc/trunk/gaym/src/weblogin.c
===================================================================
--- qrc/trunk/gaym/src/weblogin.c	2005-07-24 08:53:02 UTC (rev 238)
+++ qrc/trunk/gaym/src/weblogin.c	2005-07-24 19:36:03 UTC (rev 239)
@@ -267,6 +267,7 @@
 // 
 // 
 // 
+// 
 // this
 // structure, as well.
 static void
@@ -303,6 +304,7 @@
                        // 
                        // 
                        // 
+                       // 
                        // (see 
                        // above)
                        (gfud->full ? "" : "/"),
@@ -318,6 +320,7 @@
                        // 
                        // 
                        // 
+                       // 
                        // See 
                        // above
                        (gfud->full ? "" : "/"),

Modified: qrc/trunk/gaym-extras/gaym-extras.c
===================================================================
--- qrc/trunk/gaym-extras/gaym-extras.c	2005-07-24 08:53:02 UTC (rev 238)
+++ qrc/trunk/gaym-extras/gaym-extras.c	2005-07-24 19:36:03 UTC (rev 239)
@@ -23,6 +23,7 @@
 
 GHashTable *icons;
 GHashTable *pending_updates;
+GHashTable *im_window_bios;
 
 typedef struct _GaymChatIcon {
 
@@ -221,6 +222,9 @@
 static void changed_cb(GtkTreeSelection * selection, gpointer conv)
 {
 
+    g_return_if_fail(selection != NULL);
+    g_return_if_fail(conv != NULL);
+
     GaimConversation *c = (GaimConversation *) conv;
     GaymChannelMember *cm;
     struct gaym_conn *gaym = c->account->gc->proto_data;
@@ -228,7 +232,9 @@
     GtkTreeModel *model;
     gchar *name;
 
-    gtk_tree_selection_get_selected(selection, &model, &iter);
+    if (!gtk_tree_selection_get_selected(selection, &model, &iter))
+        return;
+
     gtk_tree_model_get(model, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
 
     /* Remove the current icon stuff */
@@ -242,7 +248,18 @@
     gaim_debug_misc("chaticon", "got thumbnail url %s for %s\n",
                     cm->thumbnail, name);
 
-    gtk_label_set_text(GTK_LABEL(icon_data->bio_area), cm->bio);
+    char *buf;
+    buf = g_strdup_printf(" ");
+    if (cm->age)
+        buf = g_strdup_printf("Age: %s", cm->age);
+    if (cm->location)
+        buf = g_strdup_printf("%s Location: %s", buf, cm->location);
+    if (cm->bio)
+        buf = g_strdup_printf("%s\nBio: %s", buf, cm->bio);
+
+    gtk_label_set_text(GTK_LABEL(icon_data->bio_area), buf);
+    gtk_label_set_line_wrap(GTK_LABEL(icon_data->bio_area), TRUE);
+    g_free(buf);
     // Fetch thumbnail.
 
     struct gaym_fetch_thumbnail_data *data;
@@ -261,6 +278,60 @@
 
 }
 
+static void clean_im_bio(GaimConversation * c)
+{
+
+    g_return_if_fail(c->type == GAIM_CONV_IM);
+    g_hash_table_remove(im_window_bios, c->name);
+
+}
+
+static void update_im_bio(GaimAccount * account, gchar * name)
+{
+    gaim_debug_misc("chaticon", "update bio area: %s\n", name);
+    g_return_if_fail(name != NULL);
+    g_return_if_fail(account != NULL);
+
+    GaimConversation *c =
+        gaim_find_conversation_with_account(name, account);
+
+    g_return_if_fail(c != NULL);
+
+    gaim_debug_misc("chaticon", "got conversation\n");
+    g_return_if_fail(c->type == GAIM_CONV_IM);
+
+    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
+    struct gaym_conn *gaym = account->gc->proto_data;
+    GaymChannelMember *cm = gaym_get_channel_member_info(gaym, c->name);
+
+    g_return_if_fail(cm != NULL);
+
+    gaim_debug_misc("chaticon", "got cm\n");
+    GtkBox *vbox_big = GTK_BOX(gtkconv->lower_hbox->parent);
+
+    GtkWidget *bio_area = g_hash_table_lookup(im_window_bios, c->name);
+    if (!bio_area) {
+        bio_area = gtk_label_new(_(" "));
+        g_hash_table_insert(im_window_bios, c, bio_area);
+        gtk_box_pack_start(vbox_big, bio_area, TRUE, TRUE, 0);
+        gtk_widget_show(bio_area);
+    }
+    gaim_debug_misc("chaticon", "Populating bio area with cm %x\n", cm);
+    char *buf;
+    buf = g_strdup_printf(" ");
+    if (cm->age)
+        buf = g_strdup_printf("Age: %s", cm->age);
+    if (cm->location)
+        buf = g_strdup_printf("%s Location: %s", buf, cm->location);
+    if (cm->bio)
+        buf = g_strdup_printf("%s\nBio: %s", buf, cm->bio);
+
+    gtk_label_set_text(GTK_LABEL(bio_area), buf);
+    gtk_label_set_line_wrap(GTK_LABEL(bio_area), TRUE);
+    g_free(buf);
+
+}
+
 static void redochatwindow(GaimConversation * c)
 {
 
@@ -320,7 +391,7 @@
     gtk_widget_show(icon_data->event);
 
     icon_data->bio_area = gtk_label_new(_(""));
-    gtk_box_pack_start(vbox_big, icon_data->bio_area, FALSE, FALSE, 0);
+    gtk_box_pack_start(vbox_big, icon_data->bio_area, TRUE, TRUE, 0);
     gtk_widget_show(icon_data->bio_area);
 
     g_hash_table_insert(icons, c, icon_data);
@@ -331,9 +402,17 @@
 {
     icons = g_hash_table_new(g_direct_hash, g_direct_equal);
     pending_updates = g_hash_table_new(g_direct_hash, g_direct_equal);
+    im_window_bios =
+        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL,
+                              (GDestroyNotify) gtk_widget_destroy);
 
     gaim_signal_connect(gaim_conversations_get_handle(), "chat-joined",
                         plugin, GAIM_CALLBACK(redochatwindow), NULL);
+    gaim_signal_connect(gaim_accounts_get_handle(), "info-updated",
+                        plugin, GAIM_CALLBACK(update_im_bio), NULL);
+    gaim_signal_connect(gaim_conversations_get_handle(),
+                        "deleting-conversation", plugin,
+                        GAIM_CALLBACK(clean_im_bio), NULL);
 
     return TRUE;
 }



From jblebrun at berlios.de  Mon Jul 25 06:12:51 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Mon, 25 Jul 2005 06:12:51 +0200
Subject: [Qrc-svn] r240 - qrc/trunk/gaym-extras
Message-ID: <200507250412.j6P4CpOG023378@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-25 06:11:03 +0200 (Mon, 25 Jul 2005)
New Revision: 240

Modified:
   qrc/trunk/gaym-extras/gaym-extras.c
Log:
HELP, I CAN'T STOP CODING!!!!!!!!

Bio/stats display in chat rooms moved to tooltip.
Yay for massive code copying. Thank you gtkblist.c!!!!




Modified: qrc/trunk/gaym-extras/gaym-extras.c
===================================================================
--- qrc/trunk/gaym-extras/gaym-extras.c	2005-07-24 19:36:03 UTC (rev 239)
+++ qrc/trunk/gaym-extras/gaym-extras.c	2005-07-25 04:11:03 UTC (rev 240)
@@ -24,6 +24,9 @@
 GHashTable *icons;
 GHashTable *pending_updates;
 GHashTable *im_window_bios;
+GHashTable *popup_rects;
+GHashTable *popup_timeouts;
+GHashTable *popups;
 
 typedef struct _GaymChatIcon {
 
@@ -176,15 +179,12 @@
     g_return_val_if_fail(name != NULL, TRUE);
     g_return_val_if_fail(data != NULL, TRUE);
 
-    gaim_debug_misc("chaticon", "check for update: %x\n", conversation);
     GaimConversation *c = (GaimConversation *) conversation;
     char *name_needing_update = (char *) name;
 
     struct gaym_fetch_thumbnail_data *d =
         (struct gaym_fetch_thumbnail_data *) data;
 
-    gaim_debug_misc("chaticon",
-                    "Conversation: %x, name %s\n", c, name_needing_update);
 
     g_return_val_if_fail(name_needing_update != NULL, FALSE);
 
@@ -203,14 +203,12 @@
     if (!pic_data) {
         return;
     }
-    gaim_debug_misc("gaym", "got pic data: %s\n", pic_data);
     if (len && !g_strrstr_len(pic_data, len, "Server Error")) {
         d->pic_data = pic_data;
         d->pic_data_len = len;
     } else {
         d->pic_data = 0;
         d->pic_data_len = 0;
-        gaim_debug_error("gaym", "Fetching thumbnail failed.\n");
     }
     g_hash_table_foreach_remove(pending_updates,
                                 (GHRFunc) check_for_update, d);
@@ -245,21 +243,8 @@
 
     // Get thumbnail URL.
     cm = gaym_get_channel_member_info(gaym, name);
-    gaim_debug_misc("chaticon", "got thumbnail url %s for %s\n",
-                    cm->thumbnail, name);
 
-    char *buf;
-    buf = g_strdup_printf(" ");
-    if (cm->age)
-        buf = g_strdup_printf("Age: %s", cm->age);
-    if (cm->location)
-        buf = g_strdup_printf("%s Location: %s", buf, cm->location);
-    if (cm->bio)
-        buf = g_strdup_printf("%s\nBio: %s", buf, cm->bio);
 
-    gtk_label_set_text(GTK_LABEL(icon_data->bio_area), buf);
-    gtk_label_set_line_wrap(GTK_LABEL(icon_data->bio_area), TRUE);
-    g_free(buf);
     // Fetch thumbnail.
 
     struct gaym_fetch_thumbnail_data *data;
@@ -288,7 +273,6 @@
 
 static void update_im_bio(GaimAccount * account, gchar * name)
 {
-    gaim_debug_misc("chaticon", "update bio area: %s\n", name);
     g_return_if_fail(name != NULL);
     g_return_if_fail(account != NULL);
 
@@ -297,7 +281,6 @@
 
     g_return_if_fail(c != NULL);
 
-    gaim_debug_misc("chaticon", "got conversation\n");
     g_return_if_fail(c->type == GAIM_CONV_IM);
 
     GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
@@ -306,7 +289,6 @@
 
     g_return_if_fail(cm != NULL);
 
-    gaim_debug_misc("chaticon", "got cm\n");
     GtkBox *vbox_big = GTK_BOX(gtkconv->lower_hbox->parent);
 
     GtkWidget *bio_area = g_hash_table_lookup(im_window_bios, c->name);
@@ -316,22 +298,277 @@
         gtk_box_pack_start(vbox_big, bio_area, TRUE, TRUE, 0);
         gtk_widget_show(bio_area);
     }
-    gaim_debug_misc("chaticon", "Populating bio area with cm %x\n", cm);
+    
     char *buf;
-    buf = g_strdup_printf(" ");
-    if (cm->age)
-        buf = g_strdup_printf("Age: %s", cm->age);
-    if (cm->location)
-        buf = g_strdup_printf("%s Location: %s", buf, cm->location);
-    if (cm->bio)
-        buf = g_strdup_printf("%s\nBio: %s", buf, cm->bio);
+    buf =
+	    g_strconcat(1		? "Age: "		: "",
+			cm->age		? cm->age		: "?",
+			1		? "\nLocation: "	: "",
+			cm->location	? cm->location		: "?",
+			cm->bio		? "\nInfo: "		: "",
+			cm->bio		? cm->bio		: "");
 
     gtk_label_set_text(GTK_LABEL(bio_area), buf);
     gtk_label_set_line_wrap(GTK_LABEL(bio_area), TRUE);
     g_free(buf);
 
 }
+static void namelist_leave_cb (GtkWidget *tv, GdkEventCrossing *e, gpointer n)
+{
+	guint *timeout =g_hash_table_lookup(popup_timeouts, tv);
+	g_hash_table_remove(popups, tv);
+	
+	if (*timeout) {
+		g_source_remove(*timeout);
+		*timeout = 0;
+	}
+}
 
+static void namelist_paint_tip(GtkWidget *tipwindow, GdkEventExpose *event, gchar* tooltiptext)
+{
+	GtkStyle *style;
+	
+	//GdkPixbuf *pixbuf = gaim_gtk_blist_get_status_icon(node, GAIM_STATUS_ICON_LARGE);
+	PangoLayout *layout;
+
+	//gchar* tooltiptext=data;
+	layout = gtk_widget_create_pango_layout (tipwindow, NULL);
+	pango_layout_set_markup(layout, tooltiptext, strlen(tooltiptext));
+	pango_layout_set_wrap(layout, PANGO_WRAP_WORD);
+	pango_layout_set_width(layout, 300000);
+	style = tipwindow->style;
+
+	gtk_paint_flat_box(style, tipwindow->window, GTK_STATE_NORMAL, GTK_SHADOW_OUT,
+					   NULL, tipwindow, "tooltip", 0, 0, -1, -1);
+
+#if GTK_CHECK_VERSION(2,2,0)
+	//gdk_draw_pixbuf(GDK_DRAWABLE(tipwindow->window), NULL, pixbuf,
+	//		0, 0, 4, 4, -1 , -1, GDK_RGB_DITHER_NONE, 0, 0);
+#else
+	//gdk_pixbuf_render_to_drawable(pixbuf, GDK_DRAWABLE(tipwindow->window), NULL, 0, 0, 4, 4, -1, -1, GDK_RGB_DITHER_NONE, 0, 0);
+#endif
+
+	gtk_paint_layout (style, tipwindow->window, GTK_STATE_NORMAL, TRUE,
+			  NULL, tipwindow, "tooltip", 38, 4, layout);
+
+	//g_object_unref (pixbuf);
+	g_object_unref (layout);
+    
+	return;
+}
+
+struct timeout_cb_data {
+    GtkWidget *tv;
+    struct gaym_conn* gaym;
+};
+
+static gboolean namelist_tooltip_timeout(struct timeout_cb_data* data)
+{
+	GtkTreePath *path;
+	GtkTreeIter iter;
+	GtkTreeModel *model;
+	gchar* name;
+	int scr_w, scr_h, w, h, x, y;
+#if GTK_CHECK_VERSION(2,2,0)
+	int mon_num;
+	GdkScreen *screen = NULL;
+#endif
+	PangoLayout *layout;
+	gboolean tooltip_top = FALSE;
+	char *tooltiptext = NULL;
+	GdkRectangle mon_size;
+	GdkRectangle *rect;
+	guint* timeout;
+	GtkWidget *tipwindow;
+	GtkWidget *tv=data->tv;
+	struct gaym_conn* gaym=data->gaym;
+	g_free(data);
+	rect=g_hash_table_lookup(popup_rects, tv);
+	timeout=(guint*)g_hash_table_lookup(popup_timeouts, tv);
+	if (!gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(tv), rect->x, rect->y, &path, NULL, NULL, NULL))
+		return FALSE;
+	model=gtk_tree_view_get_model(GTK_TREE_VIEW(tv));
+	gtk_tree_model_get_iter(model, &iter, path);
+	gtk_tree_model_get(model, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
+
+
+
+	while (gtk_events_pending())
+		gtk_main_iteration();
+
+	/* we check to see if we're still supposed to be moving, now that gtk events have
+	 * happened, and the mouse might not still be in the buddy list */
+	if(!(*timeout)) {
+		gtk_tree_path_free(path);
+		return FALSE;
+	}
+/*
+	gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, &gtkblist->contact_rect);
+	gdk_drawable_get_size(GDK_DRAWABLE(tv->window), &(gtkblist->contact_rect.width), NULL);
+	gtk_tree_path_down (path);
+	while (gtk_tree_model_get_iter(GTK_TREE_MODEL(gtkblist->treemodel), &i, path)) {
+		GdkRectangle rect;
+		gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, &rect);
+		gtkblist->contact_rect.height += rect.height;
+		gtk_tree_path_next(path);
+
+	}
+*/
+
+	gtk_tree_path_free(path);
+
+	GaymChannelMember*cm=gaym_get_channel_member_info(gaym, name);
+
+	
+	if(!cm->age && !cm->location && !cm->bio)
+	    tooltiptext = g_strdup_printf("No info");   
+	else {
+	    tooltiptext =
+	    g_strconcat(1		? "<b>Age: </b>"	: "",
+			cm->age		? cm->age		: "?",
+			1   		? "\n<b>Location: </b>"	: "",
+			cm->location	? cm->location		: "?",
+			cm->bio		? "\n<b>Info: </b> : "	: "",
+			cm->bio		? cm->bio		: "");
+	}
+	if(!tooltiptext)
+		return FALSE;
+
+		
+	tipwindow = g_hash_table_lookup(popups, tv);
+	if(tipwindow)
+		g_hash_table_remove(popups, tv);
+	    
+	tipwindow = gtk_window_new(GTK_WINDOW_POPUP);
+	g_hash_table_insert(popups, tv, tipwindow);
+	
+	gtk_widget_set_app_paintable(tipwindow, TRUE);
+	gtk_window_set_resizable(GTK_WINDOW(tipwindow), FALSE);
+	gtk_widget_set_name(tipwindow, "gtk-tooltips");
+	g_signal_connect(G_OBJECT(tipwindow), "expose_event",
+			G_CALLBACK(namelist_paint_tip), tooltiptext);
+	gtk_widget_ensure_style (tipwindow);
+
+	layout = gtk_widget_create_pango_layout (tipwindow, NULL);
+	pango_layout_set_wrap(layout, PANGO_WRAP_WORD);
+	pango_layout_set_width(layout, 300000);
+	pango_layout_set_markup(layout, tooltiptext, strlen(tooltiptext));
+	pango_layout_get_size (layout, &w, &h);
+
+#if GTK_CHECK_VERSION(2,2,0)
+	gdk_display_get_pointer(gdk_display_get_default(), &screen, &x, &y, NULL);
+	mon_num = gdk_screen_get_monitor_at_point(screen, x, y);
+	gdk_screen_get_monitor_geometry(screen, mon_num, &mon_size);
+
+	scr_w = mon_size.width + mon_size.x;
+	scr_h = mon_size.height + mon_size.y;
+#else
+	scr_w = gdk_screen_width();
+	scr_h = gdk_screen_height();
+	gdk_window_get_pointer(NULL, &x, &y, NULL);
+	mon_size.x = 0;
+	mon_size.y = 0;
+#endif
+
+
+	w = PANGO_PIXELS(w) + 8;
+	h = PANGO_PIXELS(h) + 8;
+
+	/* 38 is the size of a large status icon plus 4 pixels padding on each side.
+	 *  I should #define this or something */
+	w = w + 38;
+	h = MAX(h, 38);
+
+#if GTK_CHECK_VERSION(2,2,0)
+	if( w > mon_size.width )
+	  w = mon_size.width - 10;
+
+	if( h > mon_size.height )
+	  h = mon_size.height - 10;
+#endif
+
+	//Find the conversation window here....
+	//if (GTK_WIDGET_NO_WINDOW(window))
+	//	y+=window->allocation.y;
+
+	x -= ((w >> 1) + 4);
+
+	if ((y + h + 4) > scr_h || tooltip_top)
+		y = y - h - 5;
+	else
+		y = y + 6;
+
+	if (y < mon_size.y)
+		y = mon_size.y;
+
+	if (y != mon_size.y) {
+		if ((x + w) > scr_w)
+			x -= (x + w + 5) - scr_w;
+		else if (x < mon_size.x)
+			x = mon_size.x;
+	} else {
+		x -= (w / 2 + 10);
+		if (x < mon_size.x)
+			x = mon_size.x;
+	}
+
+	g_object_unref (layout);
+	//g_free(tooltiptext);
+	gtk_widget_set_size_request(tipwindow, w, h);
+	gtk_window_move(GTK_WINDOW(tipwindow), x, y);
+	gtk_widget_show(tipwindow);
+
+	return FALSE;
+}
+
+
+static gboolean namelist_motion_cb (GtkWidget *tv, GdkEventMotion *event, gpointer gaym)
+{	
+	GtkTreeModel *ls=NULL;
+	GtkTreePath *path=NULL;
+	GtkTreeIter iter;
+	char* name;
+	static int count=0;
+	gboolean tf;
+	GdkRectangle *rect;
+	guint* timeout;
+	count++;
+	guint delay;	
+	rect = g_hash_table_lookup(popup_rects, tv);
+	g_return_val_if_fail(rect != NULL, FALSE);
+
+	
+	timeout=g_hash_table_lookup(popup_timeouts, tv);
+	
+	delay = gaim_prefs_get_int("/gaim/gtk/blist/tooltip_delay");
+
+	if (delay == 0)
+		return FALSE;
+
+	if (*timeout) {
+		if ((event->y > rect->y) && ((event->y - rect->height) < rect->y))
+			return FALSE;
+		/* We've left the cell.  Remove the timeout and create a new one below */
+		g_hash_table_remove(popups, tv);
+		g_source_remove(*timeout);
+	}
+
+   	gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(tv), event->x, event->y, &path, NULL, NULL, NULL);
+	g_return_val_if_fail(path != NULL, FALSE);
+	struct timeout_cb_data* timeout_data = g_new0(struct timeout_cb_data, 1);
+	timeout_data->tv=tv;
+	timeout_data->gaym=gaym;
+	*timeout = g_timeout_add(delay, (GSourceFunc)namelist_tooltip_timeout, timeout_data);
+
+	gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, rect);
+
+	ls = gtk_tree_view_get_model(GTK_TREE_VIEW(tv));
+	tf=gtk_tree_model_get_iter(ls, &iter, path);
+	gtk_tree_model_get(ls, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
+	gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, rect);
+	
+	return TRUE;
+}    
 static void redochatwindow(GaimConversation * c)
 {
 
@@ -350,11 +587,14 @@
     oldls = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
 
     GtkBox *hbox = GTK_BOX(gtkconv->lower_hbox);
-    GtkBox *vbox_big = GTK_BOX(gtkconv->lower_hbox->parent);
+    //GtkBox *vbox_big = GTK_BOX(gtkconv->lower_hbox->parent);
 
     g_signal_connect(G_OBJECT(select), "changed", G_CALLBACK(changed_cb),
                      c);
+    g_signal_connect(G_OBJECT(gtkchat->list), "motion-notify-event", G_CALLBACK(namelist_motion_cb), account->gc->proto_data);
+    g_signal_connect(G_OBJECT(gtkchat->list), "leave-notify-event", G_CALLBACK(namelist_leave_cb), NULL);
 
+
     GaymChatIcon *icon_data = g_new0(GaymChatIcon, 1);
 
     icon_data->icon_container_parent = GTK_WIDGET(hbox);
@@ -382,20 +622,20 @@
     gtk_widget_set_size_request(GTK_WIDGET(icon_data->frame),
                                 prpl_info->icon_spec.max_width,
                                 prpl_info->icon_spec.max_height);
-    gaim_debug_misc("chaticon", "made container\n");
 
     icon_data->event = gtk_event_box_new();
     gtk_container_add(GTK_CONTAINER(icon_data->frame), icon_data->event);
     // g_signal_connect(G_OBJECT(icon_data->event), "button-press-event",
     // G_CALLBACK(icon_menu), conv);
     gtk_widget_show(icon_data->event);
-
+/*
     icon_data->bio_area = gtk_label_new(_(""));
     gtk_box_pack_start(vbox_big, icon_data->bio_area, TRUE, TRUE, 0);
     gtk_widget_show(icon_data->bio_area);
-
+*/
     g_hash_table_insert(icons, c, icon_data);
-
+    g_hash_table_insert(popup_rects, gtkchat->list, g_new0(GdkRectangle, 1));
+    g_hash_table_insert(popup_timeouts, gtkchat->list, g_new0(guint, 1));
 }
 
 static gboolean plugin_load(GaimPlugin * plugin)
@@ -405,7 +645,14 @@
     im_window_bios =
         g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL,
                               (GDestroyNotify) gtk_widget_destroy);
+    popup_rects =
+	g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
 
+    popup_timeouts =
+	g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
+
+    popups =
+	g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, (GDestroyNotify) gtk_widget_destroy);
     gaim_signal_connect(gaim_conversations_get_handle(), "chat-joined",
                         plugin, GAIM_CALLBACK(redochatwindow), NULL);
     gaim_signal_connect(gaim_accounts_get_handle(), "info-updated",



From jblebrun at berlios.de  Mon Jul 25 06:57:09 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Mon, 25 Jul 2005 06:57:09 +0200
Subject: [Qrc-svn] r241 - in qrc/trunk: gaym/src gaym-extras
Message-ID: <200507250457.j6P4v91M013374@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-25 06:56:43 +0200 (Mon, 25 Jul 2005)
New Revision: 241

Modified:
   qrc/trunk/gaym-extras/gaym-extras.c
   qrc/trunk/gaym/src/weblogin.c
Log:
Now there is a button to change the sort order. Just for you, Evan!
Note that I also fixed the stupid "sort upper before lower" behavior.
If anyone actually found that useful, I'll make another sort state.

Can someone make informative icons for the button? 

Right now 

A = Alpha
E = Entry
P = Picture type




Modified: qrc/trunk/gaym/src/weblogin.c
===================================================================
--- qrc/trunk/gaym/src/weblogin.c	2005-07-25 04:11:03 UTC (rev 240)
+++ qrc/trunk/gaym/src/weblogin.c	2005-07-25 04:56:43 UTC (rev 241)
@@ -268,6 +268,7 @@
 // 
 // 
 // 
+// 
 // this
 // structure, as well.
 static void
@@ -305,6 +306,7 @@
                        // 
                        // 
                        // 
+                       // 
                        // (see 
                        // above)
                        (gfud->full ? "" : "/"),
@@ -321,6 +323,7 @@
                        // 
                        // 
                        // 
+                       // 
                        // See 
                        // above
                        (gfud->full ? "" : "/"),

Modified: qrc/trunk/gaym-extras/gaym-extras.c
===================================================================
--- qrc/trunk/gaym-extras/gaym-extras.c	2005-07-25 04:11:03 UTC (rev 240)
+++ qrc/trunk/gaym-extras/gaym-extras.c	2005-07-25 04:56:43 UTC (rev 241)
@@ -45,8 +45,143 @@
 
 } GaymChatIcon;
 
+typedef enum {
+    SORT_ALPHA,
+    SORT_ENTRY,
+    SORT_CATEGORY,
+} GaymSortOrder;
 
+static gint
+sort_chat_users_by_entry(GtkTreeModel * model, GtkTreeIter * a,
+                         GtkTreeIter * b, gpointer userdata)
+{
+    GaimConvChatBuddyFlags f1 = 0, f2 = 0;
+    char *user1 = NULL, *user2 = NULL;
+    gint ret = 0;
 
+    gtk_tree_model_get(model, a, CHAT_USERS_NAME_COLUMN, &user1,
+                       CHAT_USERS_FLAGS_COLUMN, &f1, -1);
+    gtk_tree_model_get(model, b, CHAT_USERS_NAME_COLUMN, &user2,
+                       CHAT_USERS_FLAGS_COLUMN, &f2, -1);
+
+    if (user1 == NULL || user2 == NULL) {
+        if (!(user1 == NULL && user2 == NULL))
+            ret = (user1 == NULL) ? -1 : 1;
+    } else if (f1 != f2) {
+        /* sort more important users first */
+        ret = (f1 > f2) ? -1 : 1;
+    } else {
+        ret = g_utf8_collate(user1, user2);
+    }
+
+    g_free(user1);
+    g_free(user2);
+    return ret;
+}
+
+static gint
+sort_chat_users_by_alpha(GtkTreeModel * model, GtkTreeIter * a,
+                         GtkTreeIter * b, gpointer userdata)
+{
+    char *user1 = NULL, *user2 = NULL, *luser1 = NULL, *luser2 = NULL;
+    gint ret = 0;
+
+    gtk_tree_model_get(model, a, CHAT_USERS_NAME_COLUMN, &user1, -1);
+    gtk_tree_model_get(model, b, CHAT_USERS_NAME_COLUMN, &user2, -1);
+
+    luser1 = g_utf8_strdown(user1, -1);
+    luser2 = g_utf8_strdown(user2, -1);
+    if (luser1 == NULL || luser2 == NULL) {
+        if (!(luser1 == NULL && luser2 == NULL))
+            ret = (luser1 == NULL) ? -1 : 1;
+    } else {
+        ret = g_utf8_collate(luser1, luser2);
+    }
+
+    g_free(user1);
+    g_free(user2);
+    g_free(luser1);
+    g_free(luser2);
+    return ret;
+}
+
+
+static gint
+sort_chat_users_by_category(GtkTreeModel * model, GtkTreeIter * a,
+                            GtkTreeIter * b, gpointer userdata)
+{
+    GaimConvChatBuddyFlags f1 = 0, f2 = 0;
+    gint flag_mask = 0x000F;
+    char *user1 = NULL, *user2 = NULL, *luser1 = NULL, *luser2 = NULL;
+    gint ret = 0;
+
+    gtk_tree_model_get(model, a, CHAT_USERS_NAME_COLUMN, &user1,
+                       CHAT_USERS_FLAGS_COLUMN, &f1, -1);
+    gtk_tree_model_get(model, b, CHAT_USERS_NAME_COLUMN, &user2,
+                       CHAT_USERS_FLAGS_COLUMN, &f2, -1);
+
+    f1 = f1 & flag_mask;
+    f2 = f2 & flag_mask;
+
+    luser1 = g_utf8_strdown(user1, -1);
+    luser2 = g_utf8_strdown(user2, -1);
+    if (luser1 == NULL || luser2 == NULL) {
+        if (!(luser1 == NULL && luser2 == NULL))
+            ret = (luser1 == NULL) ? -1 : 1;
+    } else if (f1 != f2) {
+        /* sort more important lusers first */
+        ret = (f1 > f2) ? -1 : 1;
+    } else {
+        ret = g_utf8_collate(luser1, luser2);
+    }
+
+    g_free(user1);
+    g_free(user2);
+    g_free(luser1);
+    g_free(luser2);
+    return ret;
+}
+
+
+
+static void change_sort_order(GtkWidget * button, void *data)
+{
+
+    static GaymSortOrder order = SORT_ENTRY;
+
+
+    GtkTreeView *list = (GtkTreeView *) data;
+    GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(list));
+    gaim_debug_misc("chatsort", "list: %x, data: %x, model: %x\n", list,
+                    data, model);
+    if (order == SORT_ALPHA) {
+        order = SORT_CATEGORY;
+        gaim_debug_misc("chatsort", "Change to entry order");
+        gtk_button_set_label(GTK_BUTTON(button), "E");
+        gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model),
+                                        CHAT_USERS_NAME_COLUMN,
+                                        sort_chat_users_by_category, NULL,
+                                        NULL);
+    } else if (order == SORT_CATEGORY) {
+        order = SORT_ENTRY;
+        gaim_debug_misc("chatsort", "Change to category order");
+        gtk_button_set_label(GTK_BUTTON(button), "P");
+        gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model),
+                                        CHAT_USERS_NAME_COLUMN,
+                                        sort_chat_users_by_entry, NULL,
+                                        NULL);
+    } else {
+        order = SORT_ALPHA;
+        gaim_debug_misc("chatsort", "Change to alpha order");
+        gtk_button_set_label(GTK_BUTTON(button), "A");
+        gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model),
+                                        CHAT_USERS_NAME_COLUMN,
+                                        sort_chat_users_by_alpha, NULL,
+                                        NULL);
+    }
+
+}
+
 void gaym_gtkconv_update_thumbnail(GaimConversation * conv, struct gaym_fetch_thumbnail_data
                                    *thumbnail_data)
 {
@@ -298,277 +433,291 @@
         gtk_box_pack_start(vbox_big, bio_area, TRUE, TRUE, 0);
         gtk_widget_show(bio_area);
     }
-    
+
     char *buf;
     buf =
-	    g_strconcat(1		? "Age: "		: "",
-			cm->age		? cm->age		: "?",
-			1		? "\nLocation: "	: "",
-			cm->location	? cm->location		: "?",
-			cm->bio		? "\nInfo: "		: "",
-			cm->bio		? cm->bio		: "");
+        g_strconcat(1 ? "Age: " : "",
+                    cm->age ? cm->age : "?",
+                    1 ? "\nLocation: " : "",
+                    cm->location ? cm->location : "?",
+                    cm->bio ? "\nInfo: " : "", cm->bio ? cm->bio : "");
 
     gtk_label_set_text(GTK_LABEL(bio_area), buf);
     gtk_label_set_line_wrap(GTK_LABEL(bio_area), TRUE);
     g_free(buf);
 
 }
-static void namelist_leave_cb (GtkWidget *tv, GdkEventCrossing *e, gpointer n)
+static void namelist_leave_cb(GtkWidget * tv, GdkEventCrossing * e,
+                              gpointer n)
 {
-	guint *timeout =g_hash_table_lookup(popup_timeouts, tv);
-	g_hash_table_remove(popups, tv);
-	
-	if (*timeout) {
-		g_source_remove(*timeout);
-		*timeout = 0;
-	}
+    guint *timeout = g_hash_table_lookup(popup_timeouts, tv);
+    g_hash_table_remove(popups, tv);
+
+    if (*timeout) {
+        g_source_remove(*timeout);
+        *timeout = 0;
+    }
 }
 
-static void namelist_paint_tip(GtkWidget *tipwindow, GdkEventExpose *event, gchar* tooltiptext)
+static void namelist_paint_tip(GtkWidget * tipwindow,
+                               GdkEventExpose * event, gchar * tooltiptext)
 {
-	GtkStyle *style;
-	
-	//GdkPixbuf *pixbuf = gaim_gtk_blist_get_status_icon(node, GAIM_STATUS_ICON_LARGE);
-	PangoLayout *layout;
+    GtkStyle *style;
 
-	//gchar* tooltiptext=data;
-	layout = gtk_widget_create_pango_layout (tipwindow, NULL);
-	pango_layout_set_markup(layout, tooltiptext, strlen(tooltiptext));
-	pango_layout_set_wrap(layout, PANGO_WRAP_WORD);
-	pango_layout_set_width(layout, 300000);
-	style = tipwindow->style;
+    // GdkPixbuf *pixbuf = gaim_gtk_blist_get_status_icon(node,
+    // GAIM_STATUS_ICON_LARGE);
+    PangoLayout *layout;
 
-	gtk_paint_flat_box(style, tipwindow->window, GTK_STATE_NORMAL, GTK_SHADOW_OUT,
-					   NULL, tipwindow, "tooltip", 0, 0, -1, -1);
+    // gchar* tooltiptext=data;
+    layout = gtk_widget_create_pango_layout(tipwindow, NULL);
+    pango_layout_set_markup(layout, tooltiptext, strlen(tooltiptext));
+    pango_layout_set_wrap(layout, PANGO_WRAP_WORD);
+    pango_layout_set_width(layout, 300000);
+    style = tipwindow->style;
 
+    gtk_paint_flat_box(style, tipwindow->window, GTK_STATE_NORMAL,
+                       GTK_SHADOW_OUT, NULL, tipwindow, "tooltip", 0, 0,
+                       -1, -1);
+
 #if GTK_CHECK_VERSION(2,2,0)
-	//gdk_draw_pixbuf(GDK_DRAWABLE(tipwindow->window), NULL, pixbuf,
-	//		0, 0, 4, 4, -1 , -1, GDK_RGB_DITHER_NONE, 0, 0);
+    // gdk_draw_pixbuf(GDK_DRAWABLE(tipwindow->window), NULL, pixbuf,
+    // 0, 0, 4, 4, -1 , -1, GDK_RGB_DITHER_NONE, 0, 0);
 #else
-	//gdk_pixbuf_render_to_drawable(pixbuf, GDK_DRAWABLE(tipwindow->window), NULL, 0, 0, 4, 4, -1, -1, GDK_RGB_DITHER_NONE, 0, 0);
+    // gdk_pixbuf_render_to_drawable(pixbuf,
+    // GDK_DRAWABLE(tipwindow->window), NULL, 0, 0, 4, 4, -1, -1,
+    // GDK_RGB_DITHER_NONE, 0, 0);
 #endif
 
-	gtk_paint_layout (style, tipwindow->window, GTK_STATE_NORMAL, TRUE,
-			  NULL, tipwindow, "tooltip", 38, 4, layout);
+    gtk_paint_layout(style, tipwindow->window, GTK_STATE_NORMAL, TRUE,
+                     NULL, tipwindow, "tooltip", 38, 4, layout);
 
-	//g_object_unref (pixbuf);
-	g_object_unref (layout);
-    
-	return;
+    // g_object_unref (pixbuf);
+    g_object_unref(layout);
+
+    return;
 }
 
 struct timeout_cb_data {
     GtkWidget *tv;
-    struct gaym_conn* gaym;
+    struct gaym_conn *gaym;
 };
 
-static gboolean namelist_tooltip_timeout(struct timeout_cb_data* data)
+static gboolean namelist_tooltip_timeout(struct timeout_cb_data *data)
 {
-	GtkTreePath *path;
-	GtkTreeIter iter;
-	GtkTreeModel *model;
-	gchar* name;
-	int scr_w, scr_h, w, h, x, y;
+    GtkTreePath *path;
+    GtkTreeIter iter;
+    GtkTreeModel *model;
+    gchar *name;
+    int scr_w, scr_h, w, h, x, y;
 #if GTK_CHECK_VERSION(2,2,0)
-	int mon_num;
-	GdkScreen *screen = NULL;
+    int mon_num;
+    GdkScreen *screen = NULL;
 #endif
-	PangoLayout *layout;
-	gboolean tooltip_top = FALSE;
-	char *tooltiptext = NULL;
-	GdkRectangle mon_size;
-	GdkRectangle *rect;
-	guint* timeout;
-	GtkWidget *tipwindow;
-	GtkWidget *tv=data->tv;
-	struct gaym_conn* gaym=data->gaym;
-	g_free(data);
-	rect=g_hash_table_lookup(popup_rects, tv);
-	timeout=(guint*)g_hash_table_lookup(popup_timeouts, tv);
-	if (!gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(tv), rect->x, rect->y, &path, NULL, NULL, NULL))
-		return FALSE;
-	model=gtk_tree_view_get_model(GTK_TREE_VIEW(tv));
-	gtk_tree_model_get_iter(model, &iter, path);
-	gtk_tree_model_get(model, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
+    PangoLayout *layout;
+    gboolean tooltip_top = FALSE;
+    char *tooltiptext = NULL;
+    GdkRectangle mon_size;
+    GdkRectangle *rect;
+    guint *timeout;
+    GtkWidget *tipwindow;
+    GtkWidget *tv = data->tv;
+    struct gaym_conn *gaym = data->gaym;
+    g_free(data);
+    rect = g_hash_table_lookup(popup_rects, tv);
+    timeout = (guint *) g_hash_table_lookup(popup_timeouts, tv);
+    if (!gtk_tree_view_get_path_at_pos
+        (GTK_TREE_VIEW(tv), rect->x, rect->y, &path, NULL, NULL, NULL))
+        return FALSE;
+    model = gtk_tree_view_get_model(GTK_TREE_VIEW(tv));
+    gtk_tree_model_get_iter(model, &iter, path);
+    gtk_tree_model_get(model, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
 
 
 
-	while (gtk_events_pending())
-		gtk_main_iteration();
+    while (gtk_events_pending())
+        gtk_main_iteration();
 
-	/* we check to see if we're still supposed to be moving, now that gtk events have
-	 * happened, and the mouse might not still be in the buddy list */
-	if(!(*timeout)) {
-		gtk_tree_path_free(path);
-		return FALSE;
-	}
-/*
-	gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, &gtkblist->contact_rect);
-	gdk_drawable_get_size(GDK_DRAWABLE(tv->window), &(gtkblist->contact_rect.width), NULL);
-	gtk_tree_path_down (path);
-	while (gtk_tree_model_get_iter(GTK_TREE_MODEL(gtkblist->treemodel), &i, path)) {
-		GdkRectangle rect;
-		gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, &rect);
-		gtkblist->contact_rect.height += rect.height;
-		gtk_tree_path_next(path);
+    /* we check to see if we're still supposed to be moving, now that gtk
+       events have happened, and the mouse might not still be in the buddy 
+       list */
+    if (!(*timeout)) {
+        gtk_tree_path_free(path);
+        return FALSE;
+    }
+    /* 
+       gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL,
+       &gtkblist->contact_rect);
+       gdk_drawable_get_size(GDK_DRAWABLE(tv->window),
+       &(gtkblist->contact_rect.width), NULL); gtk_tree_path_down (path);
+       while (gtk_tree_model_get_iter(GTK_TREE_MODEL(gtkblist->treemodel), 
+       &i, path)) { GdkRectangle rect;
+       gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, &rect);
+       gtkblist->contact_rect.height += rect.height;
+       gtk_tree_path_next(path);
 
-	}
-*/
+       } */
 
-	gtk_tree_path_free(path);
+    gtk_tree_path_free(path);
 
-	GaymChannelMember*cm=gaym_get_channel_member_info(gaym, name);
+    GaymChannelMember *cm = gaym_get_channel_member_info(gaym, name);
 
-	
-	if(!cm->age && !cm->location && !cm->bio)
-	    tooltiptext = g_strdup_printf("No info");   
-	else {
-	    tooltiptext =
-	    g_strconcat(1		? "<b>Age: </b>"	: "",
-			cm->age		? cm->age		: "?",
-			1   		? "\n<b>Location: </b>"	: "",
-			cm->location	? cm->location		: "?",
-			cm->bio		? "\n<b>Info: </b> : "	: "",
-			cm->bio		? cm->bio		: "");
-	}
-	if(!tooltiptext)
-		return FALSE;
 
-		
-	tipwindow = g_hash_table_lookup(popups, tv);
-	if(tipwindow)
-		g_hash_table_remove(popups, tv);
-	    
-	tipwindow = gtk_window_new(GTK_WINDOW_POPUP);
-	g_hash_table_insert(popups, tv, tipwindow);
-	
-	gtk_widget_set_app_paintable(tipwindow, TRUE);
-	gtk_window_set_resizable(GTK_WINDOW(tipwindow), FALSE);
-	gtk_widget_set_name(tipwindow, "gtk-tooltips");
-	g_signal_connect(G_OBJECT(tipwindow), "expose_event",
-			G_CALLBACK(namelist_paint_tip), tooltiptext);
-	gtk_widget_ensure_style (tipwindow);
+    if (!cm->age && !cm->location && !cm->bio)
+        tooltiptext = g_strdup_printf("No info");
+    else {
+        tooltiptext =
+            g_strconcat(1 ? "<b>Age: </b>" : "",
+                        cm->age ? cm->age : "?",
+                        1 ? "\n<b>Location: </b>" : "",
+                        cm->location ? cm->location : "?",
+                        cm->bio ? "\n<b>Info: </b> : " : "",
+                        cm->bio ? cm->bio : "");
+    }
+    if (!tooltiptext)
+        return FALSE;
 
-	layout = gtk_widget_create_pango_layout (tipwindow, NULL);
-	pango_layout_set_wrap(layout, PANGO_WRAP_WORD);
-	pango_layout_set_width(layout, 300000);
-	pango_layout_set_markup(layout, tooltiptext, strlen(tooltiptext));
-	pango_layout_get_size (layout, &w, &h);
 
+    tipwindow = g_hash_table_lookup(popups, tv);
+    if (tipwindow)
+        g_hash_table_remove(popups, tv);
+
+    tipwindow = gtk_window_new(GTK_WINDOW_POPUP);
+    g_hash_table_insert(popups, tv, tipwindow);
+
+    gtk_widget_set_app_paintable(tipwindow, TRUE);
+    gtk_window_set_resizable(GTK_WINDOW(tipwindow), FALSE);
+    gtk_widget_set_name(tipwindow, "gtk-tooltips");
+    g_signal_connect(G_OBJECT(tipwindow), "expose_event",
+                     G_CALLBACK(namelist_paint_tip), tooltiptext);
+    gtk_widget_ensure_style(tipwindow);
+
+    layout = gtk_widget_create_pango_layout(tipwindow, NULL);
+    pango_layout_set_wrap(layout, PANGO_WRAP_WORD);
+    pango_layout_set_width(layout, 300000);
+    pango_layout_set_markup(layout, tooltiptext, strlen(tooltiptext));
+    pango_layout_get_size(layout, &w, &h);
+
 #if GTK_CHECK_VERSION(2,2,0)
-	gdk_display_get_pointer(gdk_display_get_default(), &screen, &x, &y, NULL);
-	mon_num = gdk_screen_get_monitor_at_point(screen, x, y);
-	gdk_screen_get_monitor_geometry(screen, mon_num, &mon_size);
+    gdk_display_get_pointer(gdk_display_get_default(), &screen, &x, &y,
+                            NULL);
+    mon_num = gdk_screen_get_monitor_at_point(screen, x, y);
+    gdk_screen_get_monitor_geometry(screen, mon_num, &mon_size);
 
-	scr_w = mon_size.width + mon_size.x;
-	scr_h = mon_size.height + mon_size.y;
+    scr_w = mon_size.width + mon_size.x;
+    scr_h = mon_size.height + mon_size.y;
 #else
-	scr_w = gdk_screen_width();
-	scr_h = gdk_screen_height();
-	gdk_window_get_pointer(NULL, &x, &y, NULL);
-	mon_size.x = 0;
-	mon_size.y = 0;
+    scr_w = gdk_screen_width();
+    scr_h = gdk_screen_height();
+    gdk_window_get_pointer(NULL, &x, &y, NULL);
+    mon_size.x = 0;
+    mon_size.y = 0;
 #endif
 
 
-	w = PANGO_PIXELS(w) + 8;
-	h = PANGO_PIXELS(h) + 8;
+    w = PANGO_PIXELS(w) + 8;
+    h = PANGO_PIXELS(h) + 8;
 
-	/* 38 is the size of a large status icon plus 4 pixels padding on each side.
-	 *  I should #define this or something */
-	w = w + 38;
-	h = MAX(h, 38);
+    /* 38 is the size of a large status icon plus 4 pixels padding on each 
+       side.  I should #define this or something */
+    w = w + 38;
+    h = MAX(h, 38);
 
 #if GTK_CHECK_VERSION(2,2,0)
-	if( w > mon_size.width )
-	  w = mon_size.width - 10;
+    if (w > mon_size.width)
+        w = mon_size.width - 10;
 
-	if( h > mon_size.height )
-	  h = mon_size.height - 10;
+    if (h > mon_size.height)
+        h = mon_size.height - 10;
 #endif
 
-	//Find the conversation window here....
-	//if (GTK_WIDGET_NO_WINDOW(window))
-	//	y+=window->allocation.y;
+    // Find the conversation window here....
+    // if (GTK_WIDGET_NO_WINDOW(window))
+    // y+=window->allocation.y;
 
-	x -= ((w >> 1) + 4);
+    x -= ((w >> 1) + 4);
 
-	if ((y + h + 4) > scr_h || tooltip_top)
-		y = y - h - 5;
-	else
-		y = y + 6;
+    if ((y + h + 4) > scr_h || tooltip_top)
+        y = y - h - 5;
+    else
+        y = y + 6;
 
-	if (y < mon_size.y)
-		y = mon_size.y;
+    if (y < mon_size.y)
+        y = mon_size.y;
 
-	if (y != mon_size.y) {
-		if ((x + w) > scr_w)
-			x -= (x + w + 5) - scr_w;
-		else if (x < mon_size.x)
-			x = mon_size.x;
-	} else {
-		x -= (w / 2 + 10);
-		if (x < mon_size.x)
-			x = mon_size.x;
-	}
+    if (y != mon_size.y) {
+        if ((x + w) > scr_w)
+            x -= (x + w + 5) - scr_w;
+        else if (x < mon_size.x)
+            x = mon_size.x;
+    } else {
+        x -= (w / 2 + 10);
+        if (x < mon_size.x)
+            x = mon_size.x;
+    }
 
-	g_object_unref (layout);
-	//g_free(tooltiptext);
-	gtk_widget_set_size_request(tipwindow, w, h);
-	gtk_window_move(GTK_WINDOW(tipwindow), x, y);
-	gtk_widget_show(tipwindow);
+    g_object_unref(layout);
+    // g_free(tooltiptext);
+    gtk_widget_set_size_request(tipwindow, w, h);
+    gtk_window_move(GTK_WINDOW(tipwindow), x, y);
+    gtk_widget_show(tipwindow);
 
-	return FALSE;
+    return FALSE;
 }
 
 
-static gboolean namelist_motion_cb (GtkWidget *tv, GdkEventMotion *event, gpointer gaym)
-{	
-	GtkTreeModel *ls=NULL;
-	GtkTreePath *path=NULL;
-	GtkTreeIter iter;
-	char* name;
-	static int count=0;
-	gboolean tf;
-	GdkRectangle *rect;
-	guint* timeout;
-	count++;
-	guint delay;	
-	rect = g_hash_table_lookup(popup_rects, tv);
-	g_return_val_if_fail(rect != NULL, FALSE);
+static gboolean namelist_motion_cb(GtkWidget * tv, GdkEventMotion * event,
+                                   gpointer gaym)
+{
+    GtkTreeModel *ls = NULL;
+    GtkTreePath *path = NULL;
+    GtkTreeIter iter;
+    char *name;
+    static int count = 0;
+    gboolean tf;
+    GdkRectangle *rect;
+    guint *timeout;
+    count++;
+    guint delay;
+    rect = g_hash_table_lookup(popup_rects, tv);
+    g_return_val_if_fail(rect != NULL, FALSE);
 
-	
-	timeout=g_hash_table_lookup(popup_timeouts, tv);
-	
-	delay = gaim_prefs_get_int("/gaim/gtk/blist/tooltip_delay");
 
-	if (delay == 0)
-		return FALSE;
+    timeout = g_hash_table_lookup(popup_timeouts, tv);
 
-	if (*timeout) {
-		if ((event->y > rect->y) && ((event->y - rect->height) < rect->y))
-			return FALSE;
-		/* We've left the cell.  Remove the timeout and create a new one below */
-		g_hash_table_remove(popups, tv);
-		g_source_remove(*timeout);
-	}
+    delay = gaim_prefs_get_int("/gaim/gtk/blist/tooltip_delay");
 
-   	gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(tv), event->x, event->y, &path, NULL, NULL, NULL);
-	g_return_val_if_fail(path != NULL, FALSE);
-	struct timeout_cb_data* timeout_data = g_new0(struct timeout_cb_data, 1);
-	timeout_data->tv=tv;
-	timeout_data->gaym=gaym;
-	*timeout = g_timeout_add(delay, (GSourceFunc)namelist_tooltip_timeout, timeout_data);
+    if (delay == 0)
+        return FALSE;
 
-	gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, rect);
+    if (*timeout) {
+        if ((event->y > rect->y) && ((event->y - rect->height) < rect->y))
+            return FALSE;
+        /* We've left the cell.  Remove the timeout and create a new one
+           below */
+        g_hash_table_remove(popups, tv);
+        g_source_remove(*timeout);
+    }
 
-	ls = gtk_tree_view_get_model(GTK_TREE_VIEW(tv));
-	tf=gtk_tree_model_get_iter(ls, &iter, path);
-	gtk_tree_model_get(ls, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
-	gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, rect);
-	
-	return TRUE;
-}    
+    gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(tv), event->x, event->y,
+                                  &path, NULL, NULL, NULL);
+    g_return_val_if_fail(path != NULL, FALSE);
+    struct timeout_cb_data *timeout_data =
+        g_new0(struct timeout_cb_data, 1);
+    timeout_data->tv = tv;
+    timeout_data->gaym = gaym;
+    *timeout =
+        g_timeout_add(delay, (GSourceFunc) namelist_tooltip_timeout,
+                      timeout_data);
+
+    gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, rect);
+
+    ls = gtk_tree_view_get_model(GTK_TREE_VIEW(tv));
+    tf = gtk_tree_model_get_iter(ls, &iter, path);
+    gtk_tree_model_get(ls, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
+    gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, rect);
+
+    return TRUE;
+}
 static void redochatwindow(GaimConversation * c)
 {
 
@@ -587,12 +736,15 @@
     oldls = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
 
     GtkBox *hbox = GTK_BOX(gtkconv->lower_hbox);
-    //GtkBox *vbox_big = GTK_BOX(gtkconv->lower_hbox->parent);
+    // GtkBox *vbox_big = GTK_BOX(gtkconv->lower_hbox->parent);
 
     g_signal_connect(G_OBJECT(select), "changed", G_CALLBACK(changed_cb),
                      c);
-    g_signal_connect(G_OBJECT(gtkchat->list), "motion-notify-event", G_CALLBACK(namelist_motion_cb), account->gc->proto_data);
-    g_signal_connect(G_OBJECT(gtkchat->list), "leave-notify-event", G_CALLBACK(namelist_leave_cb), NULL);
+    g_signal_connect(G_OBJECT(gtkchat->list), "motion-notify-event",
+                     G_CALLBACK(namelist_motion_cb),
+                     account->gc->proto_data);
+    g_signal_connect(G_OBJECT(gtkchat->list), "leave-notify-event",
+                     G_CALLBACK(namelist_leave_cb), NULL);
 
 
     GaymChatIcon *icon_data = g_new0(GaymChatIcon, 1);
@@ -628,14 +780,25 @@
     // g_signal_connect(G_OBJECT(icon_data->event), "button-press-event",
     // G_CALLBACK(icon_menu), conv);
     gtk_widget_show(icon_data->event);
-/*
-    icon_data->bio_area = gtk_label_new(_(""));
-    gtk_box_pack_start(vbox_big, icon_data->bio_area, TRUE, TRUE, 0);
-    gtk_widget_show(icon_data->bio_area);
-*/
+    /* 
+       icon_data->bio_area = gtk_label_new(_(""));
+       gtk_box_pack_start(vbox_big, icon_data->bio_area, TRUE, TRUE, 0);
+       gtk_widget_show(icon_data->bio_area); */
     g_hash_table_insert(icons, c, icon_data);
-    g_hash_table_insert(popup_rects, gtkchat->list, g_new0(GdkRectangle, 1));
+    g_hash_table_insert(popup_rects, gtkchat->list,
+                        g_new0(GdkRectangle, 1));
     g_hash_table_insert(popup_timeouts, gtkchat->list, g_new0(guint, 1));
+
+    GtkBox *iconbox = (GtkBox *) gtkconv->info->parent;
+    GtkWidget *button = gtk_button_new_with_label("E");
+    gtk_button_set_relief(GTK_BUTTON(button), GTK_RELIEF_NONE);
+    gtk_box_pack_end(iconbox, button, FALSE, FALSE, 0);
+    gtk_widget_show(button);
+    g_signal_connect(G_OBJECT(button), "clicked",
+                     G_CALLBACK(change_sort_order), gtkchat->list);
+    gaim_debug_misc("chatsort", "Connected signal with data %x\n",
+                    gtkchat->list);
+
 }
 
 static gboolean plugin_load(GaimPlugin * plugin)
@@ -646,17 +809,18 @@
         g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL,
                               (GDestroyNotify) gtk_widget_destroy);
     popup_rects =
-	g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
+        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
 
     popup_timeouts =
-	g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
+        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
 
     popups =
-	g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, (GDestroyNotify) gtk_widget_destroy);
+        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL,
+                              (GDestroyNotify) gtk_widget_destroy);
     gaim_signal_connect(gaim_conversations_get_handle(), "chat-joined",
                         plugin, GAIM_CALLBACK(redochatwindow), NULL);
-    gaim_signal_connect(gaim_accounts_get_handle(), "info-updated",
-                        plugin, GAIM_CALLBACK(update_im_bio), NULL);
+    gaim_signal_connect(gaim_accounts_get_handle(), "info-updated", plugin,
+                        GAIM_CALLBACK(update_im_bio), NULL);
     gaim_signal_connect(gaim_conversations_get_handle(),
                         "deleting-conversation", plugin,
                         GAIM_CALLBACK(clean_im_bio), NULL);



From jblebrun at berlios.de  Mon Jul 25 07:04:11 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Mon, 25 Jul 2005 07:04:11 +0200
Subject: [Qrc-svn] r242 - qrc/trunk/gaym-extras
Message-ID: <200507250504.j6P54BLF019308@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-25 07:03:53 +0200 (Mon, 25 Jul 2005)
New Revision: 242

Modified:
   qrc/trunk/gaym-extras/gaym-extras.c
Log:
Replaced scaling code. 
Can someone verify that it does the right thing?



Modified: qrc/trunk/gaym-extras/gaym-extras.c
===================================================================
--- qrc/trunk/gaym-extras/gaym-extras.c	2005-07-25 04:56:43 UTC (rev 241)
+++ qrc/trunk/gaym-extras/gaym-extras.c	2005-07-25 05:03:53 UTC (rev 242)
@@ -181,7 +181,33 @@
     }
 
 }
+static void
+get_icon_scale_size(GdkPixbufAnimation *icon, GaimBuddyIconSpec *spec, int *width, int *height)
+{
+	*width = gdk_pixbuf_animation_get_width(icon);
+	*height = gdk_pixbuf_animation_get_height(icon);
 
+	/* this should eventually get smarter about preserving the aspect
+	 * ratio when scaling, but gimmie a break, I just woke up */
+	if(spec && spec->scale_rules & GAIM_ICON_SCALE_DISPLAY) {
+		if(*width < spec->min_width)
+			*width = spec->min_width;
+		else if(*width > spec->max_width)
+			*width = spec->max_width;
+
+		if(*height < spec->min_height)
+			*height = spec->min_height;
+		else if(*height  > spec->max_height)
+			*height = spec->max_height;
+	}
+
+	/* and now for some arbitrary sanity checks */
+	if(*width > 100)
+		*width = 100;
+	if(*height > 100)
+		*height = 100;
+}
+
 void gaym_gtkconv_update_thumbnail(GaimConversation * conv, struct gaym_fetch_thumbnail_data
                                    *thumbnail_data)
 {
@@ -194,10 +220,12 @@
     size_t len;
 
     GdkPixbuf *buf;
-
+    GdkPixbuf *scale;
     GdkPixmap *pm;
     GdkBitmap *bm;
+    int scale_width, scale_height;
 
+
     GaimAccount *account;
     GaimPluginProtocolInfo *prpl_info = NULL;
 
@@ -284,9 +312,17 @@
         buf = gdk_pixbuf_animation_iter_get_pixbuf(icon_data->iter);
     }
 
+	get_icon_scale_size(icon_data->anim, prpl_info ? &prpl_info->icon_spec :
+			NULL, &scale_width, &scale_height);
+	scale = gdk_pixbuf_scale_simple(buf,
+				MAX(gdk_pixbuf_get_width(buf) * scale_width /
+				    gdk_pixbuf_animation_get_width(icon_data->anim), 1),
+				MAX(gdk_pixbuf_get_height(buf) * scale_height /
+				    gdk_pixbuf_animation_get_height(icon_data->anim), 1),
+				GDK_INTERP_NEAREST);
 
-    gdk_pixbuf_render_pixmap_and_mask(buf, &pm, &bm, 100);
-    // g_object_unref(G_OBJECT(buf));
+    gdk_pixbuf_render_pixmap_and_mask(scale, &pm, &bm, 100);
+    g_object_unref(G_OBJECT(scale));
 
 
     icon_data->event = gtk_event_box_new();
@@ -303,7 +339,6 @@
     if (bm)
         g_object_unref(G_OBJECT(bm));
 
-    buf = gdk_pixbuf_animation_get_static_image(icon_data->anim);
 
 }
 static gboolean check_for_update(gpointer * conversation,



From jblebrun at berlios.de  Mon Jul 25 07:05:56 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Mon, 25 Jul 2005 07:05:56 +0200
Subject: [Qrc-svn] r243 - qrc/trunk/gaym/src
Message-ID: <200507250505.j6P55uMK020336@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-25 07:05:54 +0200 (Mon, 25 Jul 2005)
New Revision: 243

Modified:
   qrc/trunk/gaym/src/gaym.c
Log:
Added a couple null pointer checks.



Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-25 05:03:53 UTC (rev 242)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-25 05:05:54 UTC (rev 243)
@@ -1426,6 +1426,7 @@
     if (conv->type == GAIM_CONV_CHAT) {
         GaimConvChat *chat = gaim_conversation_get_chat_data(conv);
         GaimConnection *gc = gaim_conversation_get_gc(conv);
+	g_return_if_fail(gc != NULL);
         struct gaym_conn *gaym = gc->proto_data;
         GList *users = gaim_conv_chat_get_users(chat);
         gaim_debug_misc("gaym", "got userlist %x length %i\n", users,
@@ -1434,7 +1435,9 @@
     } else if (conv->type == GAIM_CONV_IM) {
         gaim_debug_misc("gaym", "removing reference to %s\n", conv->name);
         GaimConnection *gc = gaim_conversation_get_gc(conv);
+	g_return_if_fail(gc != NULL);
         struct gaym_conn *gaym = gc->proto_data;
+
         gaym_unreference_channel_member(gaym, conv->name);
     }
 }



From deckrider at berlios.de  Mon Jul 25 14:57:33 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Mon, 25 Jul 2005 14:57:33 +0200
Subject: [Qrc-svn] r244 - qrc/trunk/gaym/src
Message-ID: <200507251257.j6PCvXiK014559@sheep.berlios.de>

Author: deckrider
Date: 2005-07-25 14:57:32 +0200 (Mon, 25 Jul 2005)
New Revision: 244

Modified:
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/helpers.c
   qrc/trunk/gaym/src/helpers.h
Log:
Moved formatting of tooltip text to helpers.[ch] so that it can be
consistently used from throughout qrc.


Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-25 05:05:54 UTC (rev 243)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-25 12:57:32 UTC (rev 244)
@@ -242,42 +242,7 @@
         return NULL;
     }
 
-    char *escaped;
-    GString *tooltip = g_string_new("");
-
-    if (ib->sex) {
-        escaped = g_markup_escape_text(ib->sex, strlen(ib->sex));
-        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"), _("Sex"),
-                               escaped);
-        g_free(escaped);
-    }
-
-    if (ib->age) {
-        escaped = g_markup_escape_text(ib->age, strlen(ib->age));
-        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"), _("Age"),
-                               escaped);
-        g_free(escaped);
-    }
-
-    if (ib->location) {
-        escaped = g_markup_escape_text(ib->location, strlen(ib->location));
-        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"),
-                               _("Location"), escaped);
-        g_free(escaped);
-    }
-
-    if (ib->bio) {
-        escaped = g_markup_escape_text(ib->bio, strlen(ib->bio));
-        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"), _("Bio"),
-                               escaped);
-        g_free(escaped);
-    }
-
-    if (tooltip->len == 0) {
-        return g_string_free(tooltip, TRUE);
-    }
-
-    return g_string_free(tooltip, FALSE);
+    return build_tooltip_text(ib);
 }
 
 static GList *gaym_away_states(GaimConnection * gc)
@@ -1426,7 +1391,7 @@
     if (conv->type == GAIM_CONV_CHAT) {
         GaimConvChat *chat = gaim_conversation_get_chat_data(conv);
         GaimConnection *gc = gaim_conversation_get_gc(conv);
-	g_return_if_fail(gc != NULL);
+        g_return_if_fail(gc != NULL);
         struct gaym_conn *gaym = gc->proto_data;
         GList *users = gaim_conv_chat_get_users(chat);
         gaim_debug_misc("gaym", "got userlist %x length %i\n", users,
@@ -1435,7 +1400,7 @@
     } else if (conv->type == GAIM_CONV_IM) {
         gaim_debug_misc("gaym", "removing reference to %s\n", conv->name);
         GaimConnection *gc = gaim_conversation_get_gc(conv);
-	g_return_if_fail(gc != NULL);
+        g_return_if_fail(gc != NULL);
         struct gaym_conn *gaym = gc->proto_data;
 
         gaym_unreference_channel_member(gaym, conv->name);

Modified: qrc/trunk/gaym/src/helpers.c
===================================================================
--- qrc/trunk/gaym/src/helpers.c	2005-07-25 05:05:54 UTC (rev 243)
+++ qrc/trunk/gaym/src/helpers.c	2005-07-25 12:57:32 UTC (rev 244)
@@ -444,6 +444,47 @@
     return flags;
 }
 
+char *build_tooltip_text(struct gaym_buddy *ib)
+{
+    char *escaped;
+    GString *tooltip = g_string_new("");
+
+    g_return_val_if_fail(ib != NULL, NULL);
+
+    if (ib->sex) {
+        escaped = g_markup_escape_text(ib->sex, strlen(ib->sex));
+        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"), _("Sex"),
+                               escaped);
+        g_free(escaped);
+    }
+
+    if (ib->age) {
+        escaped = g_markup_escape_text(ib->age, strlen(ib->age));
+        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"), _("Age"),
+                               escaped);
+        g_free(escaped);
+    }
+    if (ib->location) {
+        escaped = g_markup_escape_text(ib->location, strlen(ib->location));
+        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"),
+                               _("Location"), escaped);
+        g_free(escaped);
+    }
+
+    if (ib->bio) {
+        escaped = g_markup_escape_text(ib->bio, strlen(ib->bio));
+        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"), _("Bio"),
+                               escaped);
+        g_free(escaped);
+    }
+
+    if (tooltip->len == 0) {
+        return g_string_free(tooltip, TRUE);
+    }
+
+    return g_string_free(tooltip, FALSE);
+}
+
 GaimConvChatBuddyFlags include_chat_entry_order(GaimConvChatBuddyFlags
                                                 flags, gint entry)
 {

Modified: qrc/trunk/gaym/src/helpers.h
===================================================================
--- qrc/trunk/gaym/src/helpers.h	2005-07-25 05:05:54 UTC (rev 243)
+++ qrc/trunk/gaym/src/helpers.h	2005-07-25 12:57:32 UTC (rev 244)
@@ -28,6 +28,8 @@
 
 #include "roomlist.h"
 
+#include "gaym.h"
+
 char *return_string_between(const char *startbit, const char *endbit,
                             const char *source);
 
@@ -157,6 +159,15 @@
  */
 GaimConvChatBuddyFlags chat_pecking_order(const char *extra);
 
+/**
+ * Format and return the tooltip text for a buddy/user
+ *
+ * @param ib The stuct containing the information about the buddy
+ *
+ * @return   The correctly formatted tooltip text
+ */
+char *build_tooltip_text(struct gaym_buddy *ib);
+
 GaimConvChatBuddyFlags include_chat_entry_order(GaimConvChatBuddyFlags
                                                 flags, gint entry);
 #endif                          /* _GAIM_GAYM_HELPERS_H_ */



From deckrider at berlios.de  Mon Jul 25 15:31:52 2005
From: deckrider at berlios.de (David Everly at BerliOS)
Date: Mon, 25 Jul 2005 15:31:52 +0200
Subject: [Qrc-svn] r245 - in qrc/trunk: gaym/src gaym-extras
Message-ID: <200507251331.j6PDVqlN018227@sheep.berlios.de>

Author: deckrider
Date: 2005-07-25 15:31:45 +0200 (Mon, 25 Jul 2005)
New Revision: 245

Modified:
   qrc/trunk/gaym-extras/gaym-extras.c
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gaym.h
   qrc/trunk/gaym/src/gayminfo.c
Log:
Make tooltip consistent with buddy list (still needs icon and user name).


Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-25 12:57:32 UTC (rev 244)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-25 13:31:45 UTC (rev 245)
@@ -63,7 +63,7 @@
 static guint gaym_nick_hash(const char *nick);
 static gboolean gaym_nick_equal(const char *nick1, const char *nick2);
 static void gaym_buddy_free(struct gaym_buddy *ib);
-static void gaym_channel_member_free(GaymChannelMember * cm);
+static void gaym_channel_member_free(GaymBuddy * cm);
 
 static void gaym_buddy_append(char *name, struct gaym_buddy *ib,
                               BListWhois * blist_whois);
@@ -799,17 +799,16 @@
      */
 }
 
-GaymChannelMember *gaym_get_channel_member_reference(struct gaym_conn
-                                                     *gaym,
-                                                     const gchar * name)
+GaymBuddy *gaym_get_channel_member_reference(struct gaym_conn
+                                             *gaym, const gchar * name)
 {
 
-    GaymChannelMember *channel_member =
-        (GaymChannelMember *) g_hash_table_lookup(gaym->channel_members,
-                                                  name);
+    GaymBuddy *channel_member =
+        (GaymBuddy *) g_hash_table_lookup(gaym->channel_members,
+                                          name);
 
     if (!channel_member) {
-        channel_member = g_new0(struct channel_member, 1);
+        GaymBuddy *channel_member = g_new0(GaymBuddy, 1);
         channel_member->ref_count = 1;
         g_hash_table_insert(gaym->channel_members, g_strdup(name),
                             channel_member);
@@ -830,10 +829,9 @@
                                          gchar * name)
 {
 
-    GaymChannelMember *channel_member;
+    GaymBuddy *channel_member;
     channel_member =
-        (GaymChannelMember *) g_hash_table_lookup(gaym->channel_members,
-                                                  name);
+        (GaymBuddy *) g_hash_table_lookup(gaym->channel_members, name);
     if (!channel_member)
         return FALSE;
     else {
@@ -853,8 +851,8 @@
     }
 }
 
-GaymChannelMember *gaym_get_channel_member_info(struct gaym_conn * gaym,
-                                                gchar * name)
+GaymBuddy *gaym_get_channel_member_info(struct gaym_conn * gaym,
+                                        gchar * name)
 {
     return g_hash_table_lookup(gaym->channel_members, name);
 }
@@ -1137,7 +1135,7 @@
     return (gaim_utf8_strcasecmp(nick1, nick2) == 0);
 }
 
-static void gaym_channel_member_free(GaymChannelMember * cm)
+static void gaym_channel_member_free(GaymBuddy * cm)
 {
     g_free(cm->name);
     g_free(cm->bio);

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-25 12:57:32 UTC (rev 244)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-25 13:31:45 UTC (rev 245)
@@ -64,8 +64,8 @@
     int fd;
     guint timer;
     GHashTable *buddies;        /* hash table of struct gaym_buddy */
-    GHashTable *channel_members;        /* hash table of
-                                           GaymChannelMembers */
+    GHashTable *channel_members;        /* hash table of struct gaym_buddy 
+                                         */
 
     char *inbuf;
     int inbuflen;
@@ -113,11 +113,12 @@
 
 } GaimUrlSession;
 
-
+typedef struct gaym_buddy GaymBuddy;
 struct gaym_buddy {
     char *name;                 /* gaym formatted nick */
     gboolean done;              /* has been checked */
     gboolean online;            /* is online */
+    gint ref_count;             /* reference count for mem mngmnt */
     char *bio;                  /* bio string */
     char *thumbnail;            /* thumbnail string */
     char *sex;                  /* sex string */
@@ -125,24 +126,13 @@
     char *location;             /* location string */
 };
 
-typedef struct channel_member {
-    char *name;                 /* gaym formatted nick */
-    char *bio;                  /* bio string */
-    char *thumbnail;            /* thumbnail string */
-    char *sex;                  /* sex string */
-    char *age;                  /* age string */
-    char *location;             /* location string */
-    gint ref_count;             /* reference count for mem mngmnt */
-} GaymChannelMember;
-
 gboolean gaym_unreference_channel_member(struct gaym_conn *gaym,
                                          gchar * name);
-GaymChannelMember *gaym_get_channel_member_info(struct gaym_conn *gaym,
-                                                gchar * name);
+GaymBuddy *gaym_get_channel_member_info(struct gaym_conn *gaym,
+                                        gchar * name);
 
-GaymChannelMember *gaym_get_channel_member_reference(struct gaym_conn
-                                                     *gaym,
-                                                     const char *name);
+GaymBuddy *gaym_get_channel_member_reference(struct gaym_conn
+                                             *gaym, const char *name);
 typedef int (*IRCCmdCallback) (struct gaym_conn * gaym, const char *cmd,
                                const char *target, const char **args);
 

Modified: qrc/trunk/gaym/src/gayminfo.c
===================================================================
--- qrc/trunk/gaym/src/gayminfo.c	2005-07-25 12:57:32 UTC (rev 244)
+++ qrc/trunk/gaym/src/gayminfo.c	2005-07-25 13:31:45 UTC (rev 245)
@@ -84,7 +84,7 @@
 void gaym_update_channel_member(struct gaym_conn *gaym, const char *nick,
                                 const char *info)
 {
-    GaymChannelMember *cm = gaym_get_channel_member_reference(gaym, nick);
+    GaymBuddy *cm = gaym_get_channel_member_reference(gaym, nick);
     if (!cm) {
         gaim_debug_error("gaym",
                          "ERROR: A member has joined a channel, or a conversation was opened, but we were unable to add the member to the internal management structure. Report a bug.");

Modified: qrc/trunk/gaym-extras/gaym-extras.c
===================================================================
--- qrc/trunk/gaym-extras/gaym-extras.c	2005-07-25 12:57:32 UTC (rev 244)
+++ qrc/trunk/gaym-extras/gaym-extras.c	2005-07-25 13:31:45 UTC (rev 245)
@@ -18,6 +18,7 @@
 
 #include "../gaym/src/gaym.h"
 #include "../gaym/src/gayminfo.h"
+#include "../gaym/src/helpers.h"
 
 #define CHATSORT_PLUGIN_ID "gtk-chaticon"
 
@@ -182,30 +183,31 @@
 
 }
 static void
-get_icon_scale_size(GdkPixbufAnimation *icon, GaimBuddyIconSpec *spec, int *width, int *height)
+get_icon_scale_size(GdkPixbufAnimation * icon, GaimBuddyIconSpec * spec,
+                    int *width, int *height)
 {
-	*width = gdk_pixbuf_animation_get_width(icon);
-	*height = gdk_pixbuf_animation_get_height(icon);
+    *width = gdk_pixbuf_animation_get_width(icon);
+    *height = gdk_pixbuf_animation_get_height(icon);
 
-	/* this should eventually get smarter about preserving the aspect
-	 * ratio when scaling, but gimmie a break, I just woke up */
-	if(spec && spec->scale_rules & GAIM_ICON_SCALE_DISPLAY) {
-		if(*width < spec->min_width)
-			*width = spec->min_width;
-		else if(*width > spec->max_width)
-			*width = spec->max_width;
+    /* this should eventually get smarter about preserving the aspect
+       ratio when scaling, but gimmie a break, I just woke up */
+    if (spec && spec->scale_rules & GAIM_ICON_SCALE_DISPLAY) {
+        if (*width < spec->min_width)
+            *width = spec->min_width;
+        else if (*width > spec->max_width)
+            *width = spec->max_width;
 
-		if(*height < spec->min_height)
-			*height = spec->min_height;
-		else if(*height  > spec->max_height)
-			*height = spec->max_height;
-	}
+        if (*height < spec->min_height)
+            *height = spec->min_height;
+        else if (*height > spec->max_height)
+            *height = spec->max_height;
+    }
 
-	/* and now for some arbitrary sanity checks */
-	if(*width > 100)
-		*width = 100;
-	if(*height > 100)
-		*height = 100;
+    /* and now for some arbitrary sanity checks */
+    if (*width > 100)
+        *width = 100;
+    if (*height > 100)
+        *height = 100;
 }
 
 void gaym_gtkconv_update_thumbnail(GaimConversation * conv, struct gaym_fetch_thumbnail_data
@@ -312,14 +314,20 @@
         buf = gdk_pixbuf_animation_iter_get_pixbuf(icon_data->iter);
     }
 
-	get_icon_scale_size(icon_data->anim, prpl_info ? &prpl_info->icon_spec :
-			NULL, &scale_width, &scale_height);
-	scale = gdk_pixbuf_scale_simple(buf,
-				MAX(gdk_pixbuf_get_width(buf) * scale_width /
-				    gdk_pixbuf_animation_get_width(icon_data->anim), 1),
-				MAX(gdk_pixbuf_get_height(buf) * scale_height /
-				    gdk_pixbuf_animation_get_height(icon_data->anim), 1),
-				GDK_INTERP_NEAREST);
+    get_icon_scale_size(icon_data->anim,
+                        prpl_info ? &prpl_info->icon_spec : NULL,
+                        &scale_width, &scale_height);
+    scale =
+        gdk_pixbuf_scale_simple(buf,
+                                MAX(gdk_pixbuf_get_width(buf) *
+                                    scale_width /
+                                    gdk_pixbuf_animation_get_width
+                                    (icon_data->anim), 1),
+                                MAX(gdk_pixbuf_get_height(buf) *
+                                    scale_height /
+                                    gdk_pixbuf_animation_get_height
+                                    (icon_data->anim), 1),
+                                GDK_INTERP_NEAREST);
 
     gdk_pixbuf_render_pixmap_and_mask(scale, &pm, &bm, 100);
     g_object_unref(G_OBJECT(scale));
@@ -394,7 +402,7 @@
     g_return_if_fail(conv != NULL);
 
     GaimConversation *c = (GaimConversation *) conv;
-    GaymChannelMember *cm;
+    GaymBuddy *cm;
     struct gaym_conn *gaym = c->account->gc->proto_data;
     GtkTreeIter iter;
     GtkTreeModel *model;
@@ -455,7 +463,7 @@
 
     GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
     struct gaym_conn *gaym = account->gc->proto_data;
-    GaymChannelMember *cm = gaym_get_channel_member_info(gaym, c->name);
+    GaymBuddy *cm = gaym_get_channel_member_info(gaym, c->name);
 
     g_return_if_fail(cm != NULL);
 
@@ -594,24 +602,12 @@
 
     gtk_tree_path_free(path);
 
-    GaymChannelMember *cm = gaym_get_channel_member_info(gaym, name);
+    GaymBuddy *cm = gaym_get_channel_member_info(gaym, name);
 
+    tooltiptext = build_tooltip_text(cm);
 
-    if (!cm->age && !cm->location && !cm->bio)
-        tooltiptext = g_strdup_printf("No info");
-    else {
-        tooltiptext =
-            g_strconcat(1 ? "<b>Age: </b>" : "",
-                        cm->age ? cm->age : "?",
-                        1 ? "\n<b>Location: </b>" : "",
-                        cm->location ? cm->location : "?",
-                        cm->bio ? "\n<b>Info: </b> : " : "",
-                        cm->bio ? cm->bio : "");
-    }
-    if (!tooltiptext)
-        return FALSE;
+    g_return_val_if_fail(tooltiptext != NULL, FALSE);
 
-
     tipwindow = g_hash_table_lookup(popups, tv);
     if (tipwindow)
         g_hash_table_remove(popups, tv);



From jblebrun at berlios.de  Tue Jul 26 10:02:27 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Tue, 26 Jul 2005 10:02:27 +0200
Subject: [Qrc-svn] r246 - in qrc/trunk: gaym/src gaym-extras
Message-ID: <200507260802.j6Q82RHT009832@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-26 10:02:20 +0200 (Tue, 26 Jul 2005)
New Revision: 246

Modified:
   qrc/trunk/gaym-extras/gaym-extras.c
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gaym.h
   qrc/trunk/gaym/src/gayminfo.h
   qrc/trunk/gaym/src/gaympriv.c
   qrc/trunk/gaym/src/helpers.c
   qrc/trunk/gaym/src/msgs.c
   qrc/trunk/gaym/src/parse.c
   qrc/trunk/gaym/src/weblogin.c
Log:
*IM (pvt) window bio display is now a tooltip on the tab
*Removed dependencies to two of the gaym headers in gaym-extra
*Renamed hash_pw/pw_hash variables to chat_key
*tooltiptext function gets rid of initial newline, and generates "No info" for profiles with no info.
*buddy info lookup function returns info from channel members if nothing exists in buddy struct.
*removed step2 of login: unnecessary
*added some comments to try_cached_chat_key function in weblogin
*added a msg handler for quit messages (will be needed for new login process)
*removed unnecessary fields from struct fetch_thumbnail_data
*Made typedef for cmd and msg function types. that mess was ugly (gaym.h)



The bio/tooltip code still needs work. No guarantees. 
I might've messed up something with login too. I think info is not being set anymore.



Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-25 13:31:45 UTC (rev 245)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-26 08:02:20 UTC (rev 246)
@@ -238,6 +238,9 @@
     struct gaym_buddy *ib =
         g_hash_table_lookup(gaym->buddies, buddy->name);
 
+    if (!ib)
+        ib = g_hash_table_lookup(gaym->channel_members, buddy->name);
+
     if (!ib) {
         return NULL;
     }
@@ -418,7 +421,7 @@
     return defaults;
 }
 
-static void gaym_login_with_hash(GaimAccount * account)
+static void gaym_login_with_chat_key(GaimAccount * account)
 {
     GaimConnection *gc;
     struct gaym_conn *gaym;
@@ -517,11 +520,12 @@
 
     /**
      * Making a change to try cached password first.
-     * gaym_try_cached_password(account, gaym_login_with_hash);
+     * gaym_try_cached_password(account, gaym_login_with_chat_key);
      */
-    gaym_get_hash_from_weblogin(account, gaym_login_with_hash);
+    gaym_get_chat_key_from_weblogin(account, gaym_login_with_chat_key);
 }
 
+
 static void gaym_get_configtxt_cb(gpointer proto_data,
                                   const gchar * config_text, size_t len)
 {
@@ -537,7 +541,6 @@
 
     return;
 }
-
 static void gaym_login_cb(gpointer data, gint source,
                           GaimInputCondition cond)
 {
@@ -551,6 +554,10 @@
     char *login_name;
 
     if (GAIM_CONNECTION_IS_VALID(gc)) {
+
+        gc->inpa =
+            gaim_input_add(source, GAIM_INPUT_READ, gaym_input_cb, gc);
+
         GList *connections = gaim_connections_get_all();
 
         if (source < 0) {
@@ -564,11 +571,11 @@
         }
 
         gaym->fd = source;
-        gaim_debug_misc("gaym", "In login_cb with pw_hash=%s\n",
-                        gaym->hash_pw);
-        if (gaym->hash_pw) {
+        gaim_debug_misc("gaym", "In login_cb with chat_key=%s\n",
+                        gaym->chat_key);
+        if (gaym->chat_key) {
 
-            buf = gaym_format(gaym, "vv", "PASS", gaym->hash_pw);
+            buf = gaym_format(gaym, "vv", "PASS", gaym->chat_key);
             if (gaym_send(gaym, buf) < 0) {
                 gaim_connection_error(gc, "Error sending password");
                 return;
@@ -622,10 +629,9 @@
 
         const char *server = gaim_account_get_string(gc->account, "server",
                                                      IRC_DEFAULT_SERVER);
-
         char *url =
             g_strdup_printf
-            ("http://%s/messenger/config.txt?%s", server, gaym->hash_pw);
+            ("http://%s/messenger/config.txt?%s", server, gaym->chat_key);
 
         char *user_agent = "Mozilla/4.0";
 
@@ -635,8 +641,7 @@
 
         g_free(url);
 
-        gc->inpa =
-            gaim_input_add(gaym->fd, GAIM_INPUT_READ, gaym_input_cb, gc);
+
     }
 }
 static void gaym_close(GaimConnection * gc)
@@ -662,8 +667,8 @@
     if (gaym->thumbnail)
         g_free(gaym->thumbnail);
 
-    if (gaym->hash_pw)
-        g_free(gaym->hash_pw);
+    if (gaym->chat_key)
+        g_free(gaym->chat_key);
 
     if (gaym->server_bioline)
         g_free(gaym->server_bioline);
@@ -852,7 +857,7 @@
 }
 
 GaymBuddy *gaym_get_channel_member_info(struct gaym_conn * gaym,
-                                        gchar * name)
+                                        const gchar * name)
 {
     return g_hash_table_lookup(gaym->channel_members, name);
 }
@@ -1400,7 +1405,6 @@
         GaimConnection *gc = gaim_conversation_get_gc(conv);
         g_return_if_fail(gc != NULL);
         struct gaym_conn *gaym = gc->proto_data;
-
         gaym_unreference_channel_member(gaym, conv->name);
     }
 }

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-25 13:31:45 UTC (rev 245)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-26 08:02:20 UTC (rev 246)
@@ -72,7 +72,7 @@
     int inbufused;
 
     char *thumbnail;
-    char *hash_pw;
+    char *chat_key;
     char *server_bioline;
     char *server_stats;
     char *roomlist_filter;
@@ -129,7 +129,7 @@
 gboolean gaym_unreference_channel_member(struct gaym_conn *gaym,
                                          gchar * name);
 GaymBuddy *gaym_get_channel_member_info(struct gaym_conn *gaym,
-                                        gchar * name);
+                                        const gchar * name);
 
 GaymBuddy *gaym_get_channel_member_reference(struct gaym_conn
                                              *gaym, const char *name);
@@ -149,151 +149,91 @@
                       const char *to, const char *msg, int notice);
 char *gaym_format(struct gaym_conn *gaym, const char *format, ...);
 
-void gaym_msg_default(struct gaym_conn *gaym, const char *name,
-                      const char *from, char **args);
-void gaym_msg_away(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args);
-void gaym_msg_badmode(struct gaym_conn *gaym, const char *name,
-                      const char *from, char **args);
-void gaym_msg_banned(struct gaym_conn *gaym, const char *name,
-                     const char *from, char **args);
-void gaym_msg_chanmode(struct gaym_conn *gaym, const char *name,
-                       const char *from, char **args);
-void gaym_msg_endwhois(struct gaym_conn *gaym, const char *name,
-                       const char *from, char **args);
-void gaym_msg_endmotd(struct gaym_conn *gaym, const char *name,
-                      const char *from, char **args);
-void gaym_msg_invite(struct gaym_conn *gaym, const char *name,
-                     const char *from, char **args);
-void gaym_msg_inviteonly(struct gaym_conn *gaym, const char *name,
-                         const char *from, char **args);
-void gaym_msg_who(struct gaym_conn *gaym, const char *name,
-                  const char *from, char **args);
-void gaym_msg_chanfull(struct gaym_conn *gaym, const char *name,
-                       const char *from, char **args);
-void gaym_msg_join(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args);
-void gaym_msg_kick(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args);
-void gaym_msg_list(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args);
-void gaym_msg_mode(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args);
-void gaym_msg_motd(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args);
-void gaym_msg_names(struct gaym_conn *gaym, const char *name,
-                    const char *from, char **args);
-void gaym_msg_nick(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args);
-void gaym_msg_nickused(struct gaym_conn *gaym, const char *name,
-                       const char *from, char **args);
-void gaym_msg_nochan(struct gaym_conn *gaym, const char *name,
-                     const char *from, char **args);
-void gaym_msg_nonick_chan(struct gaym_conn *gaym, const char *name,
-                          const char *from, char **args);
-void gaym_msg_nonick(struct gaym_conn *gaym, const char *name,
-                     const char *from, char **args);
-void gaym_msg_no_such_nick(struct gaym_conn *gaym, const char *name,
-                           const char *from, char **args);
-void gaym_msg_nochangenick(struct gaym_conn *gaym, const char *name,
-                           const char *from, char **args);
-void gaym_msg_nosend(struct gaym_conn *gaym, const char *name,
-                     const char *from, char **args);
-void gaym_msg_notice(struct gaym_conn *gaym, const char *name,
-                     const char *from, char **args);
-void gaym_msg_notinchan(struct gaym_conn *gaym, const char *name,
-                        const char *from, char **args);
-void gaym_msg_notop(struct gaym_conn *gaym, const char *name,
-                    const char *from, char **args);
-void gaym_msg_part(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args);
-void gaym_msg_ping(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args);
-void gaym_msg_pong(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args);
-void gaym_msg_privmsg(struct gaym_conn *gaym, const char *name,
-                      const char *from, char **args);
-void gaym_msg_regonly(struct gaym_conn *gaym, const char *name,
-                      const char *from, char **args);
-void gaym_msg_quit(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args);
-void gaym_msg_topic(struct gaym_conn *gaym, const char *name,
-                    const char *from, char **args);
-void gaym_msg_trace(struct gaym_conn *gaym, const char *name,
-                    const char *from, char **args);
-void gaym_msg_unknown(struct gaym_conn *gaym, const char *name,
-                      const char *from, char **args);
-void gaym_msg_wallops(struct gaym_conn *gaym, const char *name,
-                      const char *from, char **args);
-void gaym_msg_whois(struct gaym_conn *gaym, const char *name,
-                    const char *from, char **args);
+typedef void (msg_handler) (struct gaym_conn * gaym, const char *name,
+                            const char *from, char **args);
+msg_handler gaym_msg_away;
+msg_handler gaym_msg_default;
+msg_handler gaym_msg_away;
+msg_handler gaym_msg_badmode;
+msg_handler gaym_msg_banned;
+msg_handler gaym_msg_chanmode;
+msg_handler gaym_msg_endwhois;
+msg_handler gaym_msg_endmotd;
+msg_handler gaym_msg_invite;
+msg_handler gaym_msg_inviteonly;
+msg_handler gaym_msg_who;
+msg_handler gaym_msg_chanfull;
+msg_handler gaym_msg_join;
+msg_handler gaym_msg_kick;
+msg_handler gaym_msg_list;
+msg_handler gaym_msg_login_failed;
+msg_handler gaym_msg_mode;
+msg_handler gaym_msg_motd;
+msg_handler gaym_msg_names;
+msg_handler gaym_msg_nick;
+msg_handler gaym_msg_nickused;
+msg_handler gaym_msg_nochan;
+msg_handler gaym_msg_nonick_chan;
+msg_handler gaym_msg_nonick;
+msg_handler gaym_msg_no_such_nick;
+msg_handler gaym_msg_nochangenick;
+msg_handler gaym_msg_nosend;
+msg_handler gaym_msg_notice;
+msg_handler gaym_msg_notinchan;
+msg_handler gaym_msg_notop;
+msg_handler gaym_msg_part;
+msg_handler gaym_msg_ping;
+msg_handler gaym_msg_pong;
+msg_handler gaym_msg_privmsg;
+msg_handler gaym_msg_regonly;
+msg_handler gaym_msg_quit;
+msg_handler gaym_msg_topic;
+msg_handler gaym_msg_trace;
+msg_handler gaym_msg_unknown;
+msg_handler gaym_msg_wallops;
+msg_handler gaym_msg_whois;
+msg_handler gaym_msg_richnames_list;
+msg_handler gaym_msg_create_pay_only;
+msg_handler gaym_msg_pay_channel;
+msg_handler gaym_msg_toomany_channels;
+msg_handler gaym_msg_list_busy;
 
 
-void gaym_msg_richnames_list(struct gaym_conn *gaym, const char *name,
-                             const char *from, char **args);
-void gaym_msg_create_pay_only(struct gaym_conn *gaym, const char *name,
-                              const char *from, char **args);
-void gaym_msg_pay_channel(struct gaym_conn *gaym, const char *name,
-                          const char *from, char **args);
-void gaym_msg_toomany_channels(struct gaym_conn *gaym, const char *name,
-                               const char *from, char **args);
-void gaym_msg_list_busy(struct gaym_conn *gaym, const char *name,
-                        const char *from, char **args);
+void gaym_cmd_table_build(struct gaym_conn *gaym);
 
+typedef int (cmd_handler) (struct gaym_conn * gaym, const char *cmd,
+                           const char *target, const char **args);
 
-void gaym_cmd_table_build(struct gaym_conn *gaym);
+cmd_handler gaym_cmd_default;
+cmd_handler gaym_cmd_away;
+cmd_handler gaym_cmd_ctcp_action;
+cmd_handler gaym_cmd_invite;
+cmd_handler gaym_cmd_join;
+cmd_handler gaym_cmd_kick;
+cmd_handler gaym_cmd_list;
+cmd_handler gaym_cmd_mode;
+cmd_handler gaym_cmd_names;
+cmd_handler gaym_cmd_nick;
+cmd_handler gaym_cmd_op;
+cmd_handler gaym_cmd_privmsg;
+cmd_handler gaym_cmd_part;
+cmd_handler gaym_cmd_ping;
+cmd_handler gaym_cmd_quit;
+cmd_handler gaym_cmd_quote;
+cmd_handler gaym_cmd_query;
+cmd_handler gaym_cmd_remove;
+cmd_handler gaym_cmd_topic;
+cmd_handler gaym_cmd_trace;
+cmd_handler gaym_cmd_wallops;
+cmd_handler gaym_cmd_whois;
 
-int gaym_cmd_default(struct gaym_conn *gaym, const char *cmd,
-                     const char *target, const char **args);
-int gaym_cmd_away(struct gaym_conn *gaym, const char *cmd,
-                  const char *target, const char **args);
-int gaym_cmd_ctcp_action(struct gaym_conn *gaym, const char *cmd,
-                         const char *target, const char **args);
-int gaym_cmd_invite(struct gaym_conn *gaym, const char *cmd,
-                    const char *target, const char **args);
-int gaym_cmd_join(struct gaym_conn *gaym, const char *cmd,
-                  const char *target, const char **args);
-int gaym_cmd_kick(struct gaym_conn *gaym, const char *cmd,
-                  const char *target, const char **args);
-int gaym_cmd_list(struct gaym_conn *gaym, const char *cmd,
-                  const char *target, const char **args);
-int gaym_cmd_mode(struct gaym_conn *gaym, const char *cmd,
-                  const char *target, const char **args);
-int gaym_cmd_names(struct gaym_conn *gaym, const char *cmd,
-                   const char *target, const char **args);
-int gaym_cmd_nick(struct gaym_conn *gaym, const char *cmd,
-                  const char *target, const char **args);
-int gaym_cmd_op(struct gaym_conn *gaym, const char *cmd,
-                const char *target, const char **args);
-int gaym_cmd_privmsg(struct gaym_conn *gaym, const char *cmd,
-                     const char *target, const char **args);
-int gaym_cmd_part(struct gaym_conn *gaym, const char *cmd,
-                  const char *target, const char **args);
-int gaym_cmd_ping(struct gaym_conn *gaym, const char *cmd,
-                  const char *target, const char **args);
-int gaym_cmd_quit(struct gaym_conn *gaym, const char *cmd,
-                  const char *target, const char **args);
-int gaym_cmd_quote(struct gaym_conn *gaym, const char *cmd,
-                   const char *target, const char **args);
-int gaym_cmd_query(struct gaym_conn *gaym, const char *cmd,
-                   const char *target, const char **args);
-int gaym_cmd_remove(struct gaym_conn *gaym, const char *cmd,
-                    const char *target, const char **args);
-int gaym_cmd_topic(struct gaym_conn *gaym, const char *cmd,
-                   const char *target, const char **args);
-int gaym_cmd_trace(struct gaym_conn *gaym, const char *cmd,
-                   const char *target, const char **args);
-int gaym_cmd_wallops(struct gaym_conn *gaym, const char *cmd,
-                     const char *target, const char **args);
-int gaym_cmd_whois(struct gaym_conn *gaym, const char *cmd,
-                   const char *target, const char **args);
 
 void gaym_dccsend_send_file(GaimConnection * gc, const char *who,
                             const char *file);
 void gaym_dccsend_recv(struct gaym_conn *gaym, const char *from,
                        const char *msg);
-void gaym_get_hash_from_weblogin(GaimAccount * account,
-                                 void (*callback) (GaimAccount *));
+void gaym_get_chat_key_from_weblogin(GaimAccount * account,
+                                     void (*callback) (GaimAccount *));
 
 void gaim_session_fetch(const char *url, gboolean full,
                         const char *user_agent, gboolean http11,

Modified: qrc/trunk/gaym/src/gayminfo.h
===================================================================
--- qrc/trunk/gaym/src/gayminfo.h	2005-07-25 13:31:45 UTC (rev 245)
+++ qrc/trunk/gaym/src/gayminfo.h	2005-07-26 08:02:20 UTC (rev 246)
@@ -37,8 +37,8 @@
     char *who;
     char *bio;
     char *stats;
-    const char *pic_data;
-    gint pic_data_len;
+    // const char *pic_data;
+    // gint pic_data_len;
 };
 void gaym_fetch_thumbnail_cb(void *user_data, const char *pic_data,
                              size_t len);

Modified: qrc/trunk/gaym/src/gaympriv.c
===================================================================
--- qrc/trunk/gaym/src/gaympriv.c	2005-07-25 13:31:45 UTC (rev 245)
+++ qrc/trunk/gaym/src/gaympriv.c	2005-07-26 08:02:20 UTC (rev 246)
@@ -204,7 +204,7 @@
 
     char *url =
         g_strdup_printf("%s?name=%s&key=%s&list=ignore&op=%s", hashurl,
-                        name, gaym->hash_pw, action);
+                        name, gaym->chat_key, action);
 
     char *user_agent = "Mozilla/4.0";
 

Modified: qrc/trunk/gaym/src/helpers.c
===================================================================
--- qrc/trunk/gaym/src/helpers.c	2005-07-25 13:31:45 UTC (rev 245)
+++ qrc/trunk/gaym/src/helpers.c	2005-07-26 08:02:20 UTC (rev 246)
@@ -479,9 +479,11 @@
     }
 
     if (tooltip->len == 0) {
-        return g_string_free(tooltip, TRUE);
+        g_string_append_printf(tooltip, _(" No info."));
     }
 
+    g_string_erase(tooltip, 0, 1);
+
     return g_string_free(tooltip, FALSE);
 }
 

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-25 13:31:45 UTC (rev 245)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-26 08:02:20 UTC (rev 246)
@@ -297,7 +297,7 @@
         g_return_if_fail(hashurl != NULL);
 
         char *infourl = g_strdup_printf("%s?pw=%s&name=%s", hashurl,
-                                        gaym->hash_pw, args[1]);
+                                        gaym->chat_key, args[1]);
         if (infourl) {
             gaim_url_fetch(infourl, FALSE,
                            "Mozilla/4.0 (compatible; MSIE 5.0)", FALSE,
@@ -308,6 +308,26 @@
     g_free(normalized);
 }
 
+void gaym_msg_login_failed(struct gaym_conn *gaym, const char *name,
+                           const char *from, char **args)
+{
+
+
+
+    gaym_cmd_quit(gaym, "quit", NULL, NULL);
+
+    // if (gc->inpa)
+    // gaim_input_remove(gc->inpa);
+
+    // g_free(gaym->inbuf);
+    // gaim_debug_misc("gaym", "Login failed. closing fd %i\n", gaym->fd);
+    // close(gaym->fd);
+    // gaim_debug_misc("gaym", "Get chatkey from weblogin\n");
+    // gaym_get_hash_from_weblogin(gaym->account,
+    // gaym_login_with_chat_key);
+
+}
+
 void gaym_msg_list(struct gaym_conn *gaym, const char *name,
                    const char *from, char **args)
 {
@@ -504,15 +524,19 @@
 /**
  * Change this to WELCOME
  */
+
 void gaym_msg_endmotd(struct gaym_conn *gaym, const char *name,
                       const char *from, char **args)
 {
     GaimConnection *gc;
 
+    gaim_debug_misc("gaym", "Got motd\n");
+
     gc = gaim_account_get_connection(gaym->account);
-    if (!gc)
+    if (!gc) {
+        gaim_debug_misc("gaym", "!gc ???\n");
         return;
-
+    }
     gaim_connection_set_state(gc, GAIM_CONNECTED);
     serv_finish_login(gc);
 

Modified: qrc/trunk/gaym/src/parse.c
===================================================================
--- qrc/trunk/gaym/src/parse.c	2005-07-25 13:31:45 UTC (rev 245)
+++ qrc/trunk/gaym/src/parse.c	2005-07-26 08:02:20 UTC (rev 246)
@@ -94,6 +94,8 @@
     {
     "471", "nc:", gaym_msg_chanfull},   /* Channel Full */
     {
+    "668", "n:", gaym_msg_login_failed},        /* Invalid Authentication */
+    {
     "690", "ncnt:", gaym_msg_richnames_list},   /* Gay.com's RPL for names 
                                                    list */
     {

Modified: qrc/trunk/gaym/src/weblogin.c
===================================================================
--- qrc/trunk/gaym/src/weblogin.c	2005-07-25 13:31:45 UTC (rev 245)
+++ qrc/trunk/gaym/src/weblogin.c	2005-07-26 08:02:20 UTC (rev 246)
@@ -269,6 +269,7 @@
 // 
 // 
 // 
+// 
 // this
 // structure, as well.
 static void
@@ -307,6 +308,7 @@
                        // 
                        // 
                        // 
+                       // 
                        // (see 
                        // above)
                        (gfud->full ? "" : "/"),
@@ -324,6 +326,7 @@
                        // 
                        // 
                        // 
+                       // 
                        // See 
                        // above
                        (gfud->full ? "" : "/"),
@@ -507,7 +510,7 @@
     struct gaym_conn *gaym = session->gaym;
     // Get hash from text
     if (session && GAIM_CONNECTION_IS_VALID(session->account->gc)) {
-        // char *pw_hash;
+        // char *chat_key;
         char *bio;
         char *thumbnail;
         char *temp = NULL;
@@ -518,7 +521,7 @@
 
 
         gaym->server_stats = NULL;
-        gaym->hash_pw = NULL;
+        gaym->chat_key = NULL;
         gaym->server_bioline = NULL;
         gaym->thumbnail = NULL;
 
@@ -531,7 +534,7 @@
         }
         if (!
             (temp && temp2 && temp != temp2
-             && (gaym->hash_pw =
+             && (gaym->chat_key =
                  g_strndup(temp, (temp2 - temp) * sizeof(char))))) {
             gaim_connection_error((session->account->gc),
                                   _
@@ -540,8 +543,8 @@
         }
 
         gaim_debug_misc("weblogin",
-                        "Got hash, temp=%x, temp2=%x, gaym->hash_pw=%x\n",
-                        temp, temp2, gaym->hash_pw);
+                        "Got hash, temp=%x, temp2=%x, gaym->chat_key=%x\n",
+                        temp, temp2, gaym->chat_key);
         // Next, loook for bio
         match = "param name=\"bio\" value=\"";
         temp = strstr(text, match);
@@ -695,8 +698,8 @@
     }
 }
 void
-gaym_get_hash_from_weblogin(GaimAccount * account,
-                            void (*callback) (GaimAccount * account))
+gaym_get_chat_key_from_weblogin(GaimAccount * account,
+                                void (*callback) (GaimAccount * account))
 {
 
     struct gaym_conn *gaym = account->gc->proto_data;
@@ -723,15 +726,22 @@
             (((GaimUrlSession *) session)->account->gc)) {
             // The first step is to establish the initial sesion
             // We connect to index.html, and get a few cookie values.
-            char *url = "http://www.gay.com/index.html";
-            char *buf = g_strdup_printf(_("Signon: %s"),
-                                        ((GaimUrlSession *) session)->
-                                        account->username);
-            gaim_connection_update_progress(((GaimUrlSession *) session)->
-                                            account->gc, buf, 2, 6);
-            ((GaimUrlSession *) session)->hasFormData = FALSE;
+            char *url =
+                g_strdup_printf
+                ("http://www.gay.com/misc/dologin.html?__login_haveForm=1&__login_save=1&__login_member=%s&redir=%%2Findex.html&__login_basepage=%%2Fmisc%%2Fdologin.html&__login_password=%s",
+                 session->username, session->password);
+
+            session->hasFormData = TRUE;
             gaim_session_fetch(url, FALSE, NULL, FALSE,
-                               gaym_weblogin_step2, session, session);
+                               gaym_weblogin_step3, session, session);
+
+            /* char *url = "http://www.gay.com/index.html"; char *buf =
+               g_strdup_printf(_("Signon: %s"), ((GaimUrlSession *)
+               session)-> account->username);
+               gaim_connection_update_progress(((GaimUrlSession *)
+               session)-> account->gc, buf, 2, 6); session->hasFormData =
+               FALSE; gaim_session_fetch(url, FALSE, NULL, FALSE,
+               gaym_weblogin_step3, session, session); */
         } else {
             gaim_debug_misc("gaym", "cancelled before step1\n");
             gaim_debug_misc("gaym", "gaym->sessoin: %x\n", session);
@@ -746,11 +756,29 @@
 {
 
     const char *pw;
-    pw = gaim_account_get_string(account, "password", NULL);
-    if (pw == NULL)
-        gaym_get_hash_from_weblogin(account, callback);
+    pw = gaim_account_get_string(account, "chat_key", NULL);
+    if (pw == NULL) {
+        gaym_get_chat_key_from_weblogin(account, callback);
+        return;
+    }
+    // All in one shot:
+    // 1. Login to the irc server <--- blocks serv_login
+    // 2. grab the applet <--- blocks serv_login
+    // 3. spamlist update <--- does not block serv_login
+    // 4. get config.txt <--- does not block serv_login
+    // 
+    // Note: if the chat key happens to be invalid, 2 and 4 will fail.
 
+    // 1
+    // callback(gaym->account);
 
+    // 2
+
+    // 3
+
+
+    // 4
+
 }
 
 /**

Modified: qrc/trunk/gaym-extras/gaym-extras.c
===================================================================
--- qrc/trunk/gaym-extras/gaym-extras.c	2005-07-25 13:31:45 UTC (rev 245)
+++ qrc/trunk/gaym-extras/gaym-extras.c	2005-07-26 08:02:20 UTC (rev 246)
@@ -11,24 +11,32 @@
 #include "util.h"
 #include "version.h"
 #include "buddyicon.h"
+#include "prpl.h"
 
 #include "gtkconv.h"
 #include "gtkimhtml.h"
 #include "gtkplugin.h"
 
 #include "../gaym/src/gaym.h"
-#include "../gaym/src/gayminfo.h"
-#include "../gaym/src/helpers.h"
-
+struct fetch_thumbnail_data {
+    char *who;
+    const char *pic_data;
+    gint pic_data_len;
+};
 #define CHATSORT_PLUGIN_ID "gtk-chaticon"
 
+
 GHashTable *icons;
 GHashTable *pending_updates;
 GHashTable *im_window_bios;
+
+// Consider combining into one popup hash...
 GHashTable *popup_rects;
 GHashTable *popup_timeouts;
 GHashTable *popups;
 
+// Additional UI info for a conversation.
+// We may be able to clean this up, some.
 typedef struct _GaymChatIcon {
 
     GaimConversation *conv;
@@ -84,25 +92,21 @@
 sort_chat_users_by_alpha(GtkTreeModel * model, GtkTreeIter * a,
                          GtkTreeIter * b, gpointer userdata)
 {
-    char *user1 = NULL, *user2 = NULL, *luser1 = NULL, *luser2 = NULL;
+    char *user1 = NULL, *user2 = NULL;
     gint ret = 0;
 
     gtk_tree_model_get(model, a, CHAT_USERS_NAME_COLUMN, &user1, -1);
     gtk_tree_model_get(model, b, CHAT_USERS_NAME_COLUMN, &user2, -1);
 
-    luser1 = g_utf8_strdown(user1, -1);
-    luser2 = g_utf8_strdown(user2, -1);
-    if (luser1 == NULL || luser2 == NULL) {
-        if (!(luser1 == NULL && luser2 == NULL))
-            ret = (luser1 == NULL) ? -1 : 1;
+    if (user1 == NULL || user2 == NULL) {
+        if (!(user1 == NULL && user2 == NULL))
+            ret = (user1 == NULL) ? -1 : 1;
     } else {
-        ret = g_utf8_collate(luser1, luser2);
+        ret = g_utf8_collate(user1, user2);
     }
 
     g_free(user1);
     g_free(user2);
-    g_free(luser1);
-    g_free(luser2);
     return ret;
 }
 
@@ -113,7 +117,7 @@
 {
     GaimConvChatBuddyFlags f1 = 0, f2 = 0;
     gint flag_mask = 0x000F;
-    char *user1 = NULL, *user2 = NULL, *luser1 = NULL, *luser2 = NULL;
+    char *user1 = NULL, *user2 = NULL;
     gint ret = 0;
 
     gtk_tree_model_get(model, a, CHAT_USERS_NAME_COLUMN, &user1,
@@ -124,22 +128,18 @@
     f1 = f1 & flag_mask;
     f2 = f2 & flag_mask;
 
-    luser1 = g_utf8_strdown(user1, -1);
-    luser2 = g_utf8_strdown(user2, -1);
-    if (luser1 == NULL || luser2 == NULL) {
-        if (!(luser1 == NULL && luser2 == NULL))
-            ret = (luser1 == NULL) ? -1 : 1;
+    if (user1 == NULL || user2 == NULL) {
+        if (!(user1 == NULL && user2 == NULL))
+            ret = (user1 == NULL) ? -1 : 1;
     } else if (f1 != f2) {
-        /* sort more important lusers first */
+        /* sort more important users first */
         ret = (f1 > f2) ? -1 : 1;
     } else {
-        ret = g_utf8_collate(luser1, luser2);
+        ret = g_utf8_collate(user1, user2);
     }
 
     g_free(user1);
     g_free(user2);
-    g_free(luser1);
-    g_free(luser2);
     return ret;
 }
 
@@ -210,7 +210,7 @@
         *height = 100;
 }
 
-void gaym_gtkconv_update_thumbnail(GaimConversation * conv, struct gaym_fetch_thumbnail_data
+void gaym_gtkconv_update_thumbnail(GaimConversation * conv, struct fetch_thumbnail_data
                                    *thumbnail_data)
 {
     GaimGtkConversation *gtkconv;
@@ -230,7 +230,6 @@
 
     GaimAccount *account;
     GaimPluginProtocolInfo *prpl_info = NULL;
-
     g_return_if_fail(conv != NULL);
     g_return_if_fail(GAIM_IS_GTK_CONVERSATION(conv));
     g_return_if_fail(gaim_conversation_get_type(conv) == GAIM_CONV_CHAT);
@@ -360,8 +359,7 @@
     GaimConversation *c = (GaimConversation *) conversation;
     char *name_needing_update = (char *) name;
 
-    struct gaym_fetch_thumbnail_data *d =
-        (struct gaym_fetch_thumbnail_data *) data;
+    struct fetch_thumbnail_data *d = (struct fetch_thumbnail_data *) data;
 
 
     g_return_val_if_fail(name_needing_update != NULL, FALSE);
@@ -377,7 +375,7 @@
 {
     if (!user_data)
         return;
-    struct gaym_fetch_thumbnail_data *d = user_data;
+    struct fetch_thumbnail_data *d = user_data;
     if (!pic_data) {
         return;
     }
@@ -404,6 +402,7 @@
     GaimConversation *c = (GaimConversation *) conv;
     GaymBuddy *cm;
     struct gaym_conn *gaym = c->account->gc->proto_data;
+
     GtkTreeIter iter;
     GtkTreeModel *model;
     gchar *name;
@@ -421,16 +420,15 @@
 
     // Get thumbnail URL.
     cm = gaym_get_channel_member_info(gaym, name);
+    // thumbnail = ui_info->get_user_thumbnail_url(gaym, name);
 
-
     // Fetch thumbnail.
 
-    struct gaym_fetch_thumbnail_data *data;
+    struct fetch_thumbnail_data *data;
     char *hashurl = g_hash_table_lookup(gaym->confighash,
                                         "mini-profile-panel.thumbnail-prefix");
     g_return_if_fail(hashurl != NULL);
-    data = g_new0(struct gaym_fetch_thumbnail_data, 1);
-    data->gc = gaim_account_get_connection(gaym->account);
+    data = g_new0(struct fetch_thumbnail_data, 1);
     data->who = g_strdup(name);
     char *url = g_strdup_printf("%s%s", hashurl, cm->thumbnail);
     gaim_url_fetch(url, FALSE, "Mozilla/4.0", FALSE,
@@ -441,11 +439,19 @@
 
 }
 
-static void clean_im_bio(GaimConversation * c)
+static void clean_popup_stuff(GaimConversation * c)
 {
 
-    g_return_if_fail(c->type == GAIM_CONV_IM);
-    g_hash_table_remove(im_window_bios, c->name);
+    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
+    if (c->type == GAIM_CONV_IM) {
+        g_hash_table_remove(popup_timeouts, gtkconv->tab_label);
+        g_hash_table_remove(popups, gtkconv->tab_label);
+    } else if (c->type == GAIM_CONV_CHAT) {
+        GaimGtkChatPane *gtkchat = gtkconv->u.chat;
+        g_hash_table_remove(popup_timeouts, gtkchat->list);
+        g_hash_table_remove(popup_rects, gtkchat->list);
+        g_hash_table_remove(popups, gtkchat->list);
+    }
 
 }
 
@@ -458,37 +464,30 @@
         gaim_find_conversation_with_account(name, account);
 
     g_return_if_fail(c != NULL);
-
     g_return_if_fail(c->type == GAIM_CONV_IM);
 
     GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-    struct gaym_conn *gaym = account->gc->proto_data;
-    GaymBuddy *cm = gaym_get_channel_member_info(gaym, c->name);
+    // struct gaym_conn *gaym = account->gc->proto_data;
 
-    g_return_if_fail(cm != NULL);
-
     GtkBox *vbox_big = GTK_BOX(gtkconv->lower_hbox->parent);
 
     GtkWidget *bio_area = g_hash_table_lookup(im_window_bios, c->name);
     if (!bio_area) {
-        bio_area = gtk_label_new(_(" "));
+        bio_area = gtk_label_new(_("Temporarily disabled."));
         g_hash_table_insert(im_window_bios, c, bio_area);
         gtk_box_pack_start(vbox_big, bio_area, TRUE, TRUE, 0);
-        gtk_widget_show(bio_area);
+        // gtk_widget_show(bio_area);
     }
 
-    char *buf;
-    buf =
-        g_strconcat(1 ? "Age: " : "",
-                    cm->age ? cm->age : "?",
-                    1 ? "\nLocation: " : "",
-                    cm->location ? cm->location : "?",
-                    cm->bio ? "\nInfo: " : "", cm->bio ? cm->bio : "");
+    /* char* age = ui_info->get_user_age(gaym, name); char* location =
+       ui_info->get_user_location(gaym, name); char* bio =
+       ui_info->get_user_bio(gaym, name); char *buf; buf = g_strconcat(1 ? 
+       "Age: " : "", cm->age ? cm->age : "?", 1 ? "\nLocation: " : "",
+       cm->location ? cm->location : "?", cm->bio ? "\nInfo: " : "",
+       cm->bio ? cm->bio : "");
 
-    gtk_label_set_text(GTK_LABEL(bio_area), buf);
-    gtk_label_set_line_wrap(GTK_LABEL(bio_area), TRUE);
-    g_free(buf);
-
+       gtk_label_set_text(GTK_LABEL(bio_area), buf);
+       gtk_label_set_line_wrap(GTK_LABEL(bio_area), TRUE); g_free(buf); */
 }
 static void namelist_leave_cb(GtkWidget * tv, GdkEventCrossing * e,
                               gpointer n)
@@ -540,17 +539,20 @@
     return;
 }
 
+typedef enum {
+    TOOLTIP_CHAT,
+    TOOLTIP_IM,
+} GaymTooltipType;
+
 struct timeout_cb_data {
+    GaymTooltipType type;
     GtkWidget *tv;
     struct gaym_conn *gaym;
 };
 
-static gboolean namelist_tooltip_timeout(struct timeout_cb_data *data)
+static gboolean tooltip_timeout(struct timeout_cb_data *data)
 {
-    GtkTreePath *path;
-    GtkTreeIter iter;
-    GtkTreeModel *model;
-    gchar *name;
+    const gchar *name;
     int scr_w, scr_h, w, h, x, y;
 #if GTK_CHECK_VERSION(2,2,0)
     int mon_num;
@@ -560,23 +562,17 @@
     gboolean tooltip_top = FALSE;
     char *tooltiptext = NULL;
     GdkRectangle mon_size;
-    GdkRectangle *rect;
     guint *timeout;
     GtkWidget *tipwindow;
     GtkWidget *tv = data->tv;
+    GaymTooltipType type = data->type;
     struct gaym_conn *gaym = data->gaym;
-    g_free(data);
-    rect = g_hash_table_lookup(popup_rects, tv);
+    GaimPluginProtocolInfo *prpl_info =
+        GAIM_PLUGIN_PROTOCOL_INFO(gaim_find_prpl
+                                  (gaim_account_get_protocol_id
+                                   (gaym->account)));
+
     timeout = (guint *) g_hash_table_lookup(popup_timeouts, tv);
-    if (!gtk_tree_view_get_path_at_pos
-        (GTK_TREE_VIEW(tv), rect->x, rect->y, &path, NULL, NULL, NULL))
-        return FALSE;
-    model = gtk_tree_view_get_model(GTK_TREE_VIEW(tv));
-    gtk_tree_model_get_iter(model, &iter, path);
-    gtk_tree_model_get(model, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
-
-
-
     while (gtk_events_pending())
         gtk_main_iteration();
 
@@ -584,28 +580,49 @@
        events have happened, and the mouse might not still be in the buddy 
        list */
     if (!(*timeout)) {
-        gtk_tree_path_free(path);
         return FALSE;
     }
-    /* 
-       gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL,
-       &gtkblist->contact_rect);
-       gdk_drawable_get_size(GDK_DRAWABLE(tv->window),
-       &(gtkblist->contact_rect.width), NULL); gtk_tree_path_down (path);
-       while (gtk_tree_model_get_iter(GTK_TREE_MODEL(gtkblist->treemodel), 
-       &i, path)) { GdkRectangle rect;
-       gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, &rect);
-       gtkblist->contact_rect.height += rect.height;
-       gtk_tree_path_next(path);
 
-       } */
+    if (type == TOOLTIP_CHAT) {
+        GtkTreePath *path;
+        GtkTreeIter iter;
+        GtkTreeModel *model;
+        GdkRectangle *rect;
 
-    gtk_tree_path_free(path);
+        rect = g_hash_table_lookup(popup_rects, tv);
+        if (!gtk_tree_view_get_path_at_pos
+            (GTK_TREE_VIEW(tv), rect->x, rect->y, &path, NULL, NULL, NULL))
+            return FALSE;
+        model = gtk_tree_view_get_model(GTK_TREE_VIEW(tv));
+        gtk_tree_model_get_iter(model, &iter, path);
+        gtk_tree_model_get(model, &iter, CHAT_USERS_NAME_COLUMN, &name,
+                           -1);
+        gtk_tree_path_free(path);
+    } else if (type == TOOLTIP_IM) {
+        name = gtk_label_get_text(GTK_LABEL(tv));
+    } else
+        return FALSE;
 
+
     GaymBuddy *cm = gaym_get_channel_member_info(gaym, name);
+    if (!cm) {
+        guint *timeout = g_hash_table_lookup(popup_timeouts, tv);
+        if (timeout) {
+            int delay =
+                gaim_prefs_get_int("/gaim/gtk/blist/tooltip_delay");
+            g_timeout_add(delay, (GSourceFunc) tooltip_timeout, data);
+        }
+        return FALSE;
+    }
+    g_free(data);
 
-    tooltiptext = build_tooltip_text(cm);
 
+    GaimBuddy *gb = g_new0(GaimBuddy, 1);
+    gb->name = cm->name;
+    gb->account = gaym->account;
+
+    tooltiptext = prpl_info->tooltip_text(gb);
+    g_free(gb);
     g_return_val_if_fail(tooltiptext != NULL, FALSE);
 
     tipwindow = g_hash_table_lookup(popups, tv);
@@ -736,9 +753,9 @@
         g_new0(struct timeout_cb_data, 1);
     timeout_data->tv = tv;
     timeout_data->gaym = gaym;
+    timeout_data->type = TOOLTIP_CHAT;
     *timeout =
-        g_timeout_add(delay, (GSourceFunc) namelist_tooltip_timeout,
-                      timeout_data);
+        g_timeout_add(delay, (GSourceFunc) tooltip_timeout, timeout_data);
 
     gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, rect);
 
@@ -749,9 +766,107 @@
 
     return TRUE;
 }
+
+static void tab_leave_cb(GtkWidget * event, GdkEventCrossing * e,
+                         gpointer n)
+{
+    GtkWidget *tab = gtk_bin_get_child(GTK_BIN(event));
+    gaim_debug_misc("im_bio", "tab exit\n");
+    guint *timeout = g_hash_table_lookup(popup_timeouts, tab);
+    g_hash_table_remove(popups, tab);
+
+
+    if (timeout && *timeout) {
+        g_source_remove(*timeout);
+        *timeout = 0;
+    }
+}
+
+
+static gboolean tab_entry_cb(GtkWidget * event,
+                             GdkEventCrossing * crossing, gpointer conv)
+{
+
+    guint *timeout;
+    guint delay;
+    gaim_debug_misc("im_bio", "tab entry\n");
+    GaimConversation *c = (GaimConversation *) conv;
+    struct gaym_conn *gaym = c->account->gc->proto_data;
+
+    GtkWidget *tab = gtk_bin_get_child(GTK_BIN(event));
+    timeout = g_hash_table_lookup(popup_timeouts, tab);
+
+    delay = gaim_prefs_get_int("/gaim/gtk/blist/tooltip_delay");
+
+    if (delay == 0)
+        return FALSE;
+
+    if (timeout && *timeout)
+        return FALSE;
+
+    // g_hash_table_remove(popups, tab);
+    // g_source_remove(*timeout);
+
+
+
+    struct timeout_cb_data *timeout_data =
+        g_new0(struct timeout_cb_data, 1);
+    timeout_data->tv = tab;
+    timeout_data->gaym = gaym;
+    timeout_data->type = TOOLTIP_IM;
+    *timeout =
+        g_timeout_add(delay, (GSourceFunc) tooltip_timeout, timeout_data);
+
+    return TRUE;
+}
+static void redo_im_window(GaimConversation * c)
+{
+
+    if (c && c->type == GAIM_CONV_IM) {
+        GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
+        GtkWidget *event = gtk_event_box_new();
+
+        gaim_debug_misc("im_bio", "remove tab_label\n");
+        gtk_widget_ref(gtkconv->tab_label);
+        gtk_container_remove(GTK_CONTAINER(gtkconv->tabby),
+                             GTK_WIDGET(gtkconv->tab_label));
+        // gtk_container_remove(GTK_CONTAINER(gtkconv->tabby),
+        // gtkconv->icon);
+        // gtk_container_remove(GTK_CONTAINER(gtkconv->tabby),
+        // gtkconv->close);
+        gtk_widget_add_events(event,
+                              GDK_ENTER_NOTIFY_MASK |
+                              GDK_LEAVE_NOTIFY_MASK);
+        g_signal_connect(G_OBJECT(event), "enter-notify-event",
+                         G_CALLBACK(tab_entry_cb), c);
+
+        g_signal_connect(G_OBJECT(event),
+                         "leave-notify-event",
+                         G_CALLBACK(tab_leave_cb), c);
+        gaim_debug_misc("im_bio", "put event in tabby\n");
+        gtk_box_pack_start(GTK_BOX(gtkconv->tabby), GTK_WIDGET(event),
+                           TRUE, TRUE, 0);
+        gaim_debug_misc("im_bio", "show event\n");
+        gtk_widget_show(GTK_WIDGET(event));
+        gaim_debug_misc("im_bio", "put label in event\n");
+        gtk_container_add(GTK_CONTAINER(event),
+                          GTK_WIDGET(gtkconv->tab_label));
+        gtk_widget_unref(gtkconv->tab_label);
+        gaim_debug_misc("im_bio", "show label\n");
+        gtk_widget_show(GTK_WIDGET(gtkconv->tab_label));
+
+        // gaim_debug_misc("im_bio","Tried to add events: tab_label text
+        // is %s\n",gtk_label_get_text(GTK_LABEL(gtkconv->tab_label)));
+        g_hash_table_insert(popup_timeouts, gtkconv->tab_label,
+                            g_new0(guint, 1));
+    }
+
+}
+
 static void redochatwindow(GaimConversation * c)
 {
 
+
     GtkTreeModel *oldls;
 
     GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
@@ -850,11 +965,14 @@
                               (GDestroyNotify) gtk_widget_destroy);
     gaim_signal_connect(gaim_conversations_get_handle(), "chat-joined",
                         plugin, GAIM_CALLBACK(redochatwindow), NULL);
+    gaim_signal_connect(gaim_conversations_get_handle(),
+                        "conversation-created", plugin,
+                        GAIM_CALLBACK(redo_im_window), NULL);
     gaim_signal_connect(gaim_accounts_get_handle(), "info-updated", plugin,
                         GAIM_CALLBACK(update_im_bio), NULL);
     gaim_signal_connect(gaim_conversations_get_handle(),
                         "deleting-conversation", plugin,
-                        GAIM_CALLBACK(clean_im_bio), NULL);
+                        GAIM_CALLBACK(clean_popup_stuff), NULL);
 
     return TRUE;
 }



From jblebrun at berlios.de  Tue Jul 26 10:10:32 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Tue, 26 Jul 2005 10:10:32 +0200
Subject: [Qrc-svn] r247 - qrc/trunk/gaym/src
Message-ID: <200507260810.j6Q8AWbC011387@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-26 10:10:10 +0200 (Tue, 26 Jul 2005)
New Revision: 247

Modified:
   qrc/trunk/gaym/src/gaym.c
Log:
nick_hash was crashing for null names. 



Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-26 08:02:20 UTC (rev 246)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-26 08:10:10 UTC (rev 247)
@@ -1125,9 +1125,11 @@
 
 static guint gaym_nick_hash(const char *nick)
 {
-    char *lc;
+    char *lc=NULL;
     guint bucket;
-
+    
+    if(!nick)
+	return NULL;
     lc = g_utf8_strdown(nick, -1);
     bucket = g_str_hash(lc);
     g_free(lc);



From jblebrun at berlios.de  Wed Jul 27 09:48:21 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Wed, 27 Jul 2005 09:48:21 +0200
Subject: [Qrc-svn] r248 - in qrc/trunk: . gaym/src gaym-extras
Message-ID: <200507270748.j6R7mLED002822@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-27 09:47:36 +0200 (Wed, 27 Jul 2005)
New Revision: 248

Added:
   qrc/trunk/gaym-extras/bio-popups.c
   qrc/trunk/gaym-extras/chaticon.c
   qrc/trunk/gaym-extras/gaym-extras.h
Modified:
   qrc/trunk/configure.ac
   qrc/trunk/gaym-extras/Makefile.am
   qrc/trunk/gaym-extras/chatsort.c
   qrc/trunk/gaym-extras/gaym-extras.c
   qrc/trunk/gaym-extras/roombrowse.c
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gaym.h
Log:
WORK IN PROGRESS COMMIT. THESE FEATURES ARE NOT COMPLETE
*File-Caching of images locally to avoid http requests
*Icons in tooltip popups
*Restructuring of gaym-extras files to be neater

Question for everyone: Should we get rid of Icon in corner completely, in chat windows?

Things to be done before next release:
*Fix hammering
*Finish thumbnail-caching system
*Perfect popup layout
*Clean up icon rendering code (uses a lot of crap for animated icons)
*Use info-updated signal to signal popup repaints
*Verify a windows build



Modified: qrc/trunk/configure.ac
===================================================================
--- qrc/trunk/configure.ac	2005-07-26 08:10:10 UTC (rev 247)
+++ qrc/trunk/configure.ac	2005-07-27 07:47:36 UTC (rev 248)
@@ -34,6 +34,8 @@
 fi
 
 # Build preferences
+
+
 AC_ARG_ENABLE([bot-challenger],
 	[AS_HELP_STRING(--enable-bot-challenger,build the bot-challenger plugin @<:@default=yes@:>@)],,
 	[enable_bot_challenger="yes"])
@@ -51,7 +53,7 @@
 AM_CONDITIONAL([COND_GAYM_EXTRAS], [test "$enable_gaym_extras" = "yes"])
 
 if test "$enable_bot_challenger" != "yes" ; then
-	enable_bot_challener="no"
+	enable_bot_challenger="no"
 fi
 
 if test "$enable_gaym" != "yes" ; then
@@ -72,12 +74,17 @@
 		]
 	)
 fi
+AC_ARG_WITH([gaim-prefix],
+	[AS_HELP_STRING(--with-gaim-prefix,specify the prefix where gaim is found)],
+	PKG_CONFIG_PATH=$withval/lib/pkgconfig,[])
+export PKG_CONFIG_PATH
 PKG_CHECK_MODULES([GAIM], [$REQUIRED_GAIM],
 	[
 	AC_SUBST(GAIM_CFLAGS)
 	AC_SUBST(GAIM_LIBS)
 	]
 )
+
 AC_ARG_VAR([GAIM_DATADIR], [datadir of GAIM, overriding pkg-config])dnl
 AC_ARG_VAR([GAIM_LIBDIR], [libdir of GAIM, overriding pkg-config])dnl
 AC_CACHE_CHECK([for GAIM][_DATADIR], [pkg_cv_][GAIM][_DATADIR],

Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-26 08:10:10 UTC (rev 247)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-27 07:47:36 UTC (rev 248)
@@ -236,10 +236,10 @@
     }
 
     struct gaym_buddy *ib =
-        g_hash_table_lookup(gaym->buddies, buddy->name);
+        g_hash_table_lookup(gaym->channel_members, buddy->name);
 
     if (!ib)
-        ib = g_hash_table_lookup(gaym->channel_members, buddy->name);
+        ib = g_hash_table_lookup(gaym->buddies, buddy->name);
 
     if (!ib) {
         return NULL;
@@ -555,8 +555,6 @@
 
     if (GAIM_CONNECTION_IS_VALID(gc)) {
 
-        gc->inpa =
-            gaim_input_add(source, GAIM_INPUT_READ, gaym_input_cb, gc);
 
         GList *connections = gaim_connections_get_all();
 
@@ -640,6 +638,8 @@
                        gaym_get_configtxt_cb, gaym);
 
         g_free(url);
+        gc->inpa =
+            gaim_input_add(gaym->fd, GAIM_INPUT_READ, gaym_input_cb, gc);
 
 
     }
@@ -856,12 +856,6 @@
     }
 }
 
-GaymBuddy *gaym_get_channel_member_info(struct gaym_conn * gaym,
-                                        const gchar * name)
-{
-    return g_hash_table_lookup(gaym->channel_members, name);
-}
-
 static void gaym_add_buddy(GaimConnection * gc, GaimBuddy * buddy,
                            GaimGroup * group)
 {
@@ -1129,7 +1123,7 @@
     guint bucket;
     
     if(!nick)
-	return NULL;
+	return 0;
     lc = g_utf8_strdown(nick, -1);
     bucket = g_str_hash(lc);
     g_free(lc);
@@ -1366,7 +1360,7 @@
     NULL,                       /* normalize */
     NULL,                       /* set_buddy_icon */
     NULL,                       /* remove_group */
-    NULL,                       /* get_cb_real_name */
+    NULL,		       /* get_cb_real_name */
     NULL,                       /* set_chat_topic */
     gaym_find_blist_chat,       /* find_blist_chat */
     gaym_roomlist_get_list,     /* roomlist_get_list */
@@ -1562,7 +1556,7 @@
     NULL,                                                 /**< unload         */
     NULL,                                                 /**< destroy        */
 
-    NULL,                                                 /**< ui_info        */
+    gaym_get_channel_member_reference,                    /**< ui_info        */
     &prpl_info,                                           /**< extra_info     */
     &prefs_info,
     gaym_actions

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-26 08:10:10 UTC (rev 247)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-27 07:47:36 UTC (rev 248)
@@ -54,8 +54,8 @@
 
 enum { IRC_USEROPT_SERVER, IRC_USEROPT_PORT, IRC_USEROPT_CHARSET };
 enum gaym_state { IRC_STATE_NEW, IRC_STATE_ESTABLISHED };
+enum info_string {INFO_AGE, INFO_LOCATION, INFO_BIO, INFO_URL};
 
-
 struct gaym_conn {
     GaimAccount *account;
     GHashTable *msgs;

Modified: qrc/trunk/gaym-extras/Makefile.am
===================================================================
--- qrc/trunk/gaym-extras/Makefile.am	2005-07-26 08:10:10 UTC (rev 247)
+++ qrc/trunk/gaym-extras/Makefile.am	2005-07-27 07:47:36 UTC (rev 248)
@@ -2,7 +2,7 @@
 	$(GAIM_LIBDIR)/gaim
 
 GAYMSOURCES = \
-	gaym-extras.c
+	gaym-extras.c chatsort.c bio-popups.c chaticon.c gaym-extras.h
 
 AM_CFLAGS = \
 	$(st)
@@ -23,3 +23,4 @@
 	$(DEBUG_CFLAGS) \
 	$(GTK_CFLAGS) \
 	$(GAIM_CFLAGS)
+	

Added: qrc/trunk/gaym-extras/bio-popups.c
===================================================================
--- qrc/trunk/gaym-extras/bio-popups.c	2005-07-26 08:10:10 UTC (rev 247)
+++ qrc/trunk/gaym-extras/bio-popups.c	2005-07-27 07:47:36 UTC (rev 248)
@@ -0,0 +1,400 @@
+#include "gaym-extras.h"
+// Consider combining into one popup hash...
+GHashTable *popup_rects;
+GHashTable *popup_timeouts;
+GHashTable *popups;
+void clean_popup_stuff(GaimConversation * c)
+{
+
+    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
+    if (c->type == GAIM_CONV_IM) {
+        g_hash_table_remove(popup_timeouts, gtkconv->tab_label);
+        g_hash_table_remove(popups, gtkconv->tab_label);
+    } else if (c->type == GAIM_CONV_CHAT) {
+        GaimGtkChatPane *gtkchat = gtkconv->u.chat;
+        g_hash_table_remove(popup_timeouts, gtkchat->list);
+        g_hash_table_remove(popup_rects, gtkchat->list);
+        g_hash_table_remove(popups, gtkchat->list);
+    }
+
+}
+
+static void namelist_leave_cb(GtkWidget * tv, GdkEventCrossing * e, gpointer n)
+{
+    //This prevent clicks from demloishing popups.
+    if(e->mode != GDK_CROSSING_NORMAL)
+	return;
+    
+    guint *timeout = g_hash_table_lookup(popup_timeouts, tv);
+    g_hash_table_remove(popups, tv);
+
+    if (*timeout) {
+        g_source_remove(*timeout);
+        *timeout = 0;
+    }
+}
+
+static void namelist_paint_tip(GtkWidget * tipwindow, GdkEventExpose * event, gpointer data)
+{
+    char* tooltiptext=((struct paint_data*)data)->tooltiptext;
+    const char* name=((struct paint_data*)data)->name;
+    GtkStyle *style;
+    char* filename=g_strdup_printf("%s.jpg",name);
+    char* path = g_build_filename(gaim_user_dir(), "icons", "gaym", filename, NULL);
+    gaim_debug_misc("popups","trying to load image %s\n",path);
+    GError* err=NULL;
+    GdkPixbuf* pixbuf = gdk_pixbuf_new_from_file(path, &err);	
+    if(err)
+    {
+	gaim_debug_error("popups","Pixbuf error: %s\n",err->message);
+	g_error_free(err);
+    }
+    g_free(filename);
+    g_free(path);
+
+    // GAIM_STATUS_ICON_LARGE);
+    PangoLayout *layout;
+
+    layout = gtk_widget_create_pango_layout(tipwindow, NULL);
+    pango_layout_set_markup(layout, tooltiptext, strlen(tooltiptext));
+    pango_layout_set_wrap(layout, PANGO_WRAP_WORD);
+    pango_layout_set_width(layout, 300000);
+    style = tipwindow->style;
+
+    gtk_paint_flat_box(style, tipwindow->window, GTK_STATE_NORMAL,
+                       GTK_SHADOW_OUT, NULL, tipwindow, "tooltip", 0, 0,
+                       -1, -1);
+
+#if GTK_CHECK_VERSION(2,2,0)
+     gdk_draw_pixbuf(GDK_DRAWABLE(tipwindow->window), NULL, pixbuf,
+     0, 0, 4, 4, -1, -1, GDK_RGB_DITHER_NONE, 0, 0);
+#else
+     gdk_pixbuf_render_to_drawable(pixbuf,
+     GDK_DRAWABLE(tipwindow->window), NULL, 0, 0, 4, 4, -1, -1,
+     GDK_RGB_DITHER_NONE, 0, 0);
+#endif
+
+    gtk_paint_layout(style, tipwindow->window, GTK_STATE_NORMAL, TRUE,
+                     NULL, tipwindow, "tooltip", 57, 4, layout);
+
+    g_object_unref (pixbuf);
+    g_object_unref(layout);
+    g_free(tooltiptext);
+    g_free(data);
+
+    return;
+}
+
+static gboolean tooltip_timeout(struct timeout_cb_data *data)
+{
+    const gchar *name;
+    int scr_w, scr_h, w, h, x, y;
+#if GTK_CHECK_VERSION(2,2,0)
+    int mon_num;
+    GdkScreen *screen = NULL;
+#endif
+    PangoLayout *layout;
+    gboolean tooltip_top = FALSE;
+    char *tooltiptext = NULL;
+    GdkRectangle mon_size;
+    guint *timeout;
+    GtkWidget *tipwindow;
+    GtkWidget *tv = data->tv;
+    
+    GaymTooltipType type = data->type;
+    struct gaym_conn *gaym = data->gaym;
+    g_free(data);
+    GaimPluginProtocolInfo *prpl_info =
+        GAIM_PLUGIN_PROTOCOL_INFO(gaim_find_prpl (gaim_account_get_protocol_id (gaym->account)));
+
+    timeout = (guint *) g_hash_table_lookup(popup_timeouts, tv);
+    /* we check to see if we're still supposed to be moving, now that gtk
+       events have happened, and the mouse might not still be in the buddy 
+       list */
+    while (gtk_events_pending())
+        gtk_main_iteration();
+    if (!(*timeout)) {
+        return FALSE;
+    }
+
+    if (type == TOOLTIP_CHAT) {
+        GtkTreePath *path;
+        GtkTreeIter iter;
+        GtkTreeModel *model;
+        GdkRectangle *rect;
+
+        rect = g_hash_table_lookup(popup_rects, tv);
+        if (!gtk_tree_view_get_path_at_pos
+            (GTK_TREE_VIEW(tv), rect->x, rect->y, &path, NULL, NULL, NULL))
+            return FALSE;
+        model = gtk_tree_view_get_model(GTK_TREE_VIEW(tv));
+        gtk_tree_model_get_iter(model, &iter, path);
+        gtk_tree_model_get(model, &iter, CHAT_USERS_NAME_COLUMN, &name,
+                           -1);
+        gtk_tree_path_free(path);
+    } else if (type == TOOLTIP_IM) {
+        name = gtk_label_get_text(GTK_LABEL(tv));
+    } else
+        return FALSE;
+
+
+    GaimBuddy *gb = g_new0(GaimBuddy, 1);
+    gb->name = g_strdup(name);
+    gb->account = gaym->account;
+    tooltiptext = prpl_info->tooltip_text(gb);
+    g_free(gb->name);
+    g_free(gb);
+    if (!tooltiptext) {
+        guint *timeout = g_hash_table_lookup(popup_timeouts, tv);
+        if (timeout) {
+            int delay =
+                gaim_prefs_get_int("/gaim/gtk/blist/tooltip_delay");
+            g_timeout_add(delay, (GSourceFunc) tooltip_timeout, data);
+        }
+        return FALSE;
+    }
+
+
+    g_return_val_if_fail(tooltiptext != NULL, FALSE);
+
+    tipwindow = g_hash_table_lookup(popups, tv);
+    if (tipwindow)
+    {
+        g_hash_table_remove(popups, tv);
+    }
+    tipwindow = gtk_window_new(GTK_WINDOW_POPUP);
+    g_hash_table_insert(popups, tv, tipwindow);
+
+    gtk_widget_set_app_paintable(tipwindow, TRUE);
+    gtk_window_set_resizable(GTK_WINDOW(tipwindow), FALSE);
+    gtk_widget_set_name(tipwindow, "gtk-tooltips");
+    
+    struct paint_data* pdata=g_new0(struct paint_data,1);
+    pdata->tooltiptext=tooltiptext;
+    pdata->name=name;
+    g_signal_connect(G_OBJECT(tipwindow), "expose_event",
+                     G_CALLBACK(namelist_paint_tip), pdata);
+    gtk_widget_ensure_style(tipwindow);
+    layout = gtk_widget_create_pango_layout(tipwindow, NULL);
+    pango_layout_set_wrap(layout, PANGO_WRAP_WORD);
+    pango_layout_set_width(layout, 300000);
+    pango_layout_set_markup(layout, tooltiptext, strlen(tooltiptext));
+    pango_layout_get_size(layout, &w, &h);
+
+#if GTK_CHECK_VERSION(2,2,0)
+    gdk_display_get_pointer(gdk_display_get_default(), &screen, &x, &y,
+                            NULL);
+    mon_num = gdk_screen_get_monitor_at_point(screen, x, y);
+    gdk_screen_get_monitor_geometry(screen, mon_num, &mon_size);
+
+    scr_w = mon_size.width + mon_size.x;
+    scr_h = mon_size.height + mon_size.y;
+#else
+    scr_w = gdk_screen_width();
+    scr_h = gdk_screen_height();
+    gdk_window_get_pointer(NULL, &x, &y, NULL);
+    mon_size.x = 0;
+    mon_size.y = 0;
+#endif
+
+
+    w = PANGO_PIXELS(w) + 8;
+    h = PANGO_PIXELS(h) + 8;
+
+    /* 57 is the size of a large status icon plus 4 pixels padding on each 
+       side.  I should #define this or something */
+    w = w + 57;
+    h = MAX(h, 57);
+
+#if GTK_CHECK_VERSION(2,2,0)
+    if (w > mon_size.width)
+        w = mon_size.width - 10;
+
+    if (h > mon_size.height)
+        h = mon_size.height - 10;
+#endif
+
+    // Find the conversation window here....
+    // if (GTK_WIDGET_NO_WINDOW(window))
+    // y+=window->allocation.y;
+
+    x -= ((w >> 1) + 4);
+
+    if ((y + h + 4) > scr_h || tooltip_top)
+        y = y - h - 5;
+    else
+        y = y + 6;
+
+    if (y < mon_size.y)
+        y = mon_size.y;
+
+    if (y != mon_size.y) {
+        if ((x + w) > scr_w)
+            x -= (x + w + 5) - scr_w;
+        else if (x < mon_size.x)
+            x = mon_size.x;
+    } else {
+        x -= (w / 2 + 10);
+        if (x < mon_size.x)
+            x = mon_size.x;
+    }
+
+    g_object_unref(layout);
+    gtk_widget_set_size_request(tipwindow, w, h);
+    gtk_window_move(GTK_WINDOW(tipwindow), x, y);
+    gtk_widget_show(tipwindow);
+
+    return FALSE;
+}
+
+
+static gboolean namelist_motion_cb(GtkWidget * tv, GdkEventMotion * event, gpointer gaym)
+{
+    GtkTreeModel *ls = NULL;
+    GtkTreePath *path = NULL;
+    GtkTreeIter iter;
+    char *name;
+    static int count = 0;
+    gboolean tf;
+    GdkRectangle *rect;
+    guint *timeout;
+    count++;
+    guint delay;
+    rect = g_hash_table_lookup(popup_rects, tv);
+    g_return_val_if_fail(rect != NULL, FALSE);
+
+    timeout = g_hash_table_lookup(popup_timeouts, tv);
+
+    delay = gaim_prefs_get_int("/gaim/gtk/blist/tooltip_delay");
+
+    if (delay == 0)
+        return FALSE;
+
+    if (*timeout) {
+        if ((event->y > rect->y) && ((event->y - rect->height) < rect->y))
+            return FALSE;
+        /* We've left the cell.  Remove the timeout and create a new one
+           below */
+	
+        g_hash_table_remove(popups, tv);
+        g_source_remove(*timeout);
+    }
+
+    gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(tv), event->x, event->y,
+                                  &path, NULL, NULL, NULL);
+    if(G_UNLIKELY(path == NULL))
+	return FALSE;
+    struct timeout_cb_data *timeout_data =
+        g_new0(struct timeout_cb_data, 1);
+    timeout_data->tv = tv;
+    timeout_data->gaym = gaym;
+    timeout_data->type = TOOLTIP_CHAT;
+    *timeout =
+        g_timeout_add(delay, (GSourceFunc) tooltip_timeout, timeout_data);
+
+    gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, rect);
+
+    ls = gtk_tree_view_get_model(GTK_TREE_VIEW(tv));
+    tf = gtk_tree_model_get_iter(ls, &iter, path);
+    gtk_tree_model_get(ls, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
+    gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, rect);
+
+    return TRUE;
+}
+
+static void tab_leave_cb(GtkWidget * event, GdkEventCrossing * e, gpointer n)
+{
+    //Prevent clicks from demolishing popup.
+    if(e->mode != GDK_CROSSING_NORMAL)
+	return;
+    GtkWidget *tab = gtk_bin_get_child(GTK_BIN(event));
+    guint *timeout = g_hash_table_lookup(popup_timeouts, tab);
+    g_hash_table_remove(popups, tab);
+
+
+    if (timeout && *timeout) {
+        g_source_remove(*timeout);
+        *timeout = 0;
+    }
+}
+
+
+static gboolean tab_entry_cb(GtkWidget * event, GdkEventCrossing * crossing, gpointer conv)
+{
+
+    guint *timeout;
+    guint delay;
+    GaimConversation *c = (GaimConversation *) conv;
+    struct gaym_conn *gaym = gaim_conversation_get_gc(c)->proto_data;
+
+    GtkWidget *tab = gtk_bin_get_child(GTK_BIN(event));
+    timeout = g_hash_table_lookup(popup_timeouts, tab);
+
+    delay = gaim_prefs_get_int("/gaim/gtk/blist/tooltip_delay");
+
+    if (delay == 0)
+        return FALSE;
+
+    if (timeout && *timeout)
+        return FALSE;
+
+    // g_hash_table_remove(popups, tab);
+    // g_source_remove(*timeout);
+
+
+
+    struct timeout_cb_data *timeout_data =
+        g_new0(struct timeout_cb_data, 1);
+    timeout_data->tv = tab;
+    timeout_data->gaym = gaym;
+    timeout_data->type = TOOLTIP_IM;
+    *timeout =
+        g_timeout_add(delay, (GSourceFunc) tooltip_timeout, timeout_data);
+
+    return TRUE;
+}
+
+void add_chat_popup_stuff(GaimConversation* c) {
+    
+    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
+    GaimGtkChatPane *gtkchat = gtkconv->u.chat;
+    GaimConnection *gc = gaim_conversation_get_gc(c);
+    
+    g_signal_connect(G_OBJECT(gtkchat->list), "motion-notify-event",
+                     G_CALLBACK(namelist_motion_cb),
+                     gc->proto_data);
+    g_signal_connect(G_OBJECT(gtkchat->list), "leave-notify-event",
+                     G_CALLBACK(namelist_leave_cb), NULL);
+
+
+    g_hash_table_insert(popup_rects, gtkchat->list,
+                        g_new0(GdkRectangle, 1));
+    g_hash_table_insert(popup_timeouts, gtkchat->list, g_new0(guint, 1));
+
+
+}
+void add_im_popup_stuff(GaimConversation* c) {
+	GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
+        GtkWidget *event = gtk_event_box_new();
+        gtk_widget_ref(gtkconv->tab_label);
+        gtk_container_remove(GTK_CONTAINER(gtkconv->tabby), GTK_WIDGET(gtkconv->tab_label));
+        gtk_widget_add_events(event, GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK);
+        g_signal_connect(G_OBJECT(event), "enter-notify-event", G_CALLBACK(tab_entry_cb), c);
+        g_signal_connect(G_OBJECT(event), "leave-notify-event", G_CALLBACK(tab_leave_cb), c);
+        gtk_box_pack_start(GTK_BOX(gtkconv->tabby), GTK_WIDGET(event), TRUE, TRUE, 0);
+        gtk_widget_show(GTK_WIDGET(event));
+        gtk_container_add(GTK_CONTAINER(event), GTK_WIDGET(gtkconv->tab_label));
+        gtk_widget_unref(gtkconv->tab_label);
+        gtk_widget_show(GTK_WIDGET(gtkconv->tab_label));
+        g_hash_table_insert(popup_timeouts, gtkconv->tab_label, g_new0(guint, 1));
+}
+
+void init_popups(){
+    popup_rects = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
+
+    popup_timeouts = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
+
+    popups = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, (GDestroyNotify) gtk_widget_destroy);
+}
+
+

Added: qrc/trunk/gaym-extras/chaticon.c
===================================================================
--- qrc/trunk/gaym-extras/chaticon.c	2005-07-26 08:10:10 UTC (rev 247)
+++ qrc/trunk/gaym-extras/chaticon.c	2005-07-27 07:47:36 UTC (rev 248)
@@ -0,0 +1,371 @@
+#include "gaym-extras.h"
+GHashTable *icons;
+GHashTable *pending_updates;
+static void
+get_icon_scale_size(GdkPixbufAnimation * icon, GaimBuddyIconSpec * spec,
+                    int *width, int *height)
+{
+    *width = gdk_pixbuf_animation_get_width(icon);
+    *height = gdk_pixbuf_animation_get_height(icon);
+
+    /* this should eventually get smarter about preserving the aspect
+       ratio when scaling, but gimmie a break, I just woke up */
+    if (spec && spec->scale_rules & GAIM_ICON_SCALE_DISPLAY) {
+        if (*width < spec->min_width)
+            *width = spec->min_width;
+        else if (*width > spec->max_width)
+            *width = spec->max_width;
+
+        if (*height < spec->min_height)
+            *height = spec->min_height;
+        else if (*height > spec->max_height)
+            *height = spec->max_height;
+    }
+
+    /* and now for some arbitrary sanity checks */
+    if (*width > 100)
+        *width = 100;
+    if (*height > 100)
+        *height = 100;
+}
+
+void gaym_gtkconv_update_thumbnail(GaimConversation * conv, struct fetch_thumbnail_data
+                                   *thumbnail_data)
+{
+    GaimGtkConversation *gtkconv;
+
+    char filename[256];
+    FILE *file;
+    GError *err = NULL;
+
+    size_t len;
+
+    GdkPixbuf *buf;
+    GdkPixbuf *scale;
+    GdkPixmap *pm;
+    GdkBitmap *bm;
+    int scale_width, scale_height;
+
+
+    GaimAccount *account;
+    GaimPluginProtocolInfo *prpl_info = NULL;
+    g_return_if_fail(conv != NULL);
+    g_return_if_fail(GAIM_IS_GTK_CONVERSATION(conv));
+    g_return_if_fail(gaim_conversation_get_type(conv) == GAIM_CONV_CHAT);
+
+    gtkconv = GAIM_GTK_CONVERSATION(conv);
+
+    GaymChatIcon *icon_data = g_hash_table_lookup(icons, conv);
+
+    if (!thumbnail_data)
+        return;
+    if (!icon_data->show_icon)
+        return;
+
+    const char *data = thumbnail_data->pic_data;
+    len = thumbnail_data->pic_data_len;
+
+    account = gaim_conversation_get_account(conv);
+    if (account && account->gc)
+        prpl_info = GAIM_PLUGIN_PROTOCOL_INFO(account->gc->prpl);
+
+
+    if (icon_data->anim != NULL)
+        g_object_unref(G_OBJECT(icon_data->anim));
+
+    icon_data->anim = NULL;
+
+    if (icon_data->icon_timer != 0)
+        g_source_remove(icon_data->icon_timer);
+
+    icon_data->icon_timer = 0;
+
+    if (icon_data->iter != NULL)
+        g_object_unref(G_OBJECT(icon_data->iter));
+
+    icon_data->iter = NULL;
+
+    if (!gaim_prefs_get_bool
+        ("/gaim/gtk/conversations/im/show_buddy_icons"))
+        return;
+
+    if (gaim_conversation_get_gc(conv) == NULL)
+        return;
+
+
+    /* this is such an evil hack, i don't know why i'm even considering
+       it. we'll do it differently when gdk-pixbuf-loader isn't leaky
+       anymore. */
+    /* gdk-pixbuf-loader was leaky? is it still? */
+
+    g_snprintf(filename, sizeof(filename),
+               "%s" G_DIR_SEPARATOR_S "gaimicon-%s.%d",
+               g_get_tmp_dir(), thumbnail_data->who, getpid());
+
+    if (!(file = g_fopen(filename, "wb")))
+        return;
+
+    fwrite(data, 1, len, file);
+    fclose(file);
+    icon_data->anim = gdk_pixbuf_animation_new_from_file(filename, &err);
+
+    /* make sure we remove the file as soon as possible */
+    g_unlink(filename);
+
+    if (err) {
+        gaim_debug(GAIM_DEBUG_ERROR, "gtkconv",
+                   "Buddy icon error: %s\n", err->message);
+        g_error_free(err);
+    }
+
+
+
+    if (!icon_data->anim)
+        return;
+
+    if (gdk_pixbuf_animation_is_static_image(icon_data->anim)) {
+        icon_data->iter = NULL;
+        buf = gdk_pixbuf_animation_get_static_image(icon_data->anim);
+    } else {
+        icon_data->iter = gdk_pixbuf_animation_get_iter(icon_data->anim, NULL); /* LEAK 
+                                                                                 */
+        buf = gdk_pixbuf_animation_iter_get_pixbuf(icon_data->iter);
+    }
+
+    get_icon_scale_size(icon_data->anim,
+                        prpl_info ? &prpl_info->icon_spec : NULL,
+                        &scale_width, &scale_height);
+    scale =
+        gdk_pixbuf_scale_simple(buf,
+                                MAX(gdk_pixbuf_get_width(buf) *
+                                    scale_width /
+                                    gdk_pixbuf_animation_get_width
+                                    (icon_data->anim), 1),
+                                MAX(gdk_pixbuf_get_height(buf) *
+                                    scale_height /
+                                    gdk_pixbuf_animation_get_height
+                                    (icon_data->anim), 1),
+                                GDK_INTERP_NEAREST);
+
+    gdk_pixbuf_render_pixmap_and_mask(scale, &pm, &bm, 100);
+    g_object_unref(G_OBJECT(scale));
+
+
+    icon_data->event = gtk_event_box_new();
+    gtk_container_add(GTK_CONTAINER(icon_data->frame), icon_data->event);
+    gtk_widget_set_size_request(GTK_WIDGET(icon_data->frame), scale_width, scale_height);
+
+    // g_signal_connect(G_OBJECT(icon_data->event), "button-press-event",
+    // G_CALLBACK(icon_menu), conv);
+    gtk_widget_show(icon_data->event);
+    icon_data->icon = gtk_image_new_from_pixmap(pm, bm);
+    gtk_container_add(GTK_CONTAINER(icon_data->event), icon_data->icon);
+    gtk_widget_show(icon_data->icon);
+
+    g_object_unref(G_OBJECT(pm));
+
+    if (bm)
+        g_object_unref(G_OBJECT(bm));
+
+
+}
+
+static gboolean check_for_update(gpointer * conversation,
+                                 const gpointer * name, gpointer * data)
+{
+    g_return_val_if_fail(conversation != NULL, TRUE);
+    g_return_val_if_fail(name != NULL, TRUE);
+    g_return_val_if_fail(data != NULL, TRUE);
+
+    GaimConversation *c = (GaimConversation *) conversation;
+    char *name_needing_update = (char *) name;
+
+    struct fetch_thumbnail_data *d = (struct fetch_thumbnail_data *) data;
+
+    gaim_debug_misc("chaticon","Check for update: %x %s %s %i\n",c,name,d->who, d->pic_data_len);
+    g_return_val_if_fail(name_needing_update != NULL, FALSE);
+
+    if (!strcmp(d->who, name_needing_update)) {
+        gaym_gtkconv_update_thumbnail(c, d);
+        return TRUE;
+    }
+    return TRUE;
+}
+
+void fetch_thumbnail_cb(void *user_data, const char *pic_data, size_t len)
+{
+    if (!user_data)
+        return;
+    struct fetch_thumbnail_data *d = user_data;
+    if (!pic_data) {
+        return;
+    }
+    if (len && !g_strrstr_len(pic_data, len, "Server Error")) {
+	char* dir;	
+	if ((!d->from_file) && (dir = g_build_filename(gaim_user_dir(), "icons", "gaym", NULL) != NULL)) {
+	    d->pic_data = pic_data;
+	    d->pic_data_len = len;
+	    gaim_build_dir(dir, S_IRUSR | S_IWUSR | S_IXUSR);
+	    char* filename = g_strdup_printf("%s.jpg",d->who);
+	    char* path = g_build_filename(dir, filename, NULL);
+	    FILE* file;
+	    if ((file = g_fopen(path, "wb")))
+	    {
+		fwrite(pic_data, 1, len, file);
+	        fclose(file);
+	    }
+	    else
+	    {
+		gaim_debug_misc("chaticon","Couldn't write file\n");
+	    }
+	    g_free(filename);
+	    g_free(path);
+	    g_free(dir);
+	}
+    } else {
+        d->pic_data = 0;
+        d->pic_data_len = 0;
+    }
+     
+    g_hash_table_foreach_remove(pending_updates,
+                                (GHRFunc) check_for_update, d);
+    g_free(d);
+}
+
+
+static void changed_cb(GtkTreeSelection * selection, gpointer conv)
+{
+
+    g_return_if_fail(selection != NULL);
+    g_return_if_fail(conv != NULL);
+
+    GaimConversation *c = (GaimConversation *) conv;
+    GaymBuddy *cm;
+    struct gaym_conn *gaym = c->account->gc->proto_data;
+
+    GtkTreeIter iter;
+    GtkTreeModel *model;
+    gchar *name;
+
+    if (!gtk_tree_selection_get_selected(selection, &model, &iter))
+        return;
+
+    gtk_tree_model_get(model, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
+
+    /* Remove the current icon stuff */
+    GaymChatIcon *icon_data = g_hash_table_lookup(icons, c);
+    if (icon_data->event != NULL)
+        gtk_widget_destroy(icon_data->event);
+    icon_data->event = NULL;
+    
+    
+    char* dir = g_build_filename(gaim_user_dir(), "icons", "gaym", NULL);
+    char* filename = g_strdup_printf("%s.jpg",name);
+    char* path=NULL;
+    FILE* file;
+    struct stat st;
+    struct fetch_thumbnail_data *data=g_new0(struct fetch_thumbnail_data,1);
+    
+    if ((dir != NULL) && (filename != NULL) && (path = g_build_filename(dir, filename, NULL)));
+    {
+	if (!g_stat(path, &st) && (file = g_fopen(path, "rb")))
+	{
+	    data->pic_data = g_malloc(st.st_size);
+	    data->who=name;
+	    data->pic_data_len = st.st_size;
+	    data->from_file = TRUE;
+	    fread(data->pic_data, 1, st.st_size, file);
+	    fclose(file);
+	}
+	g_free(dir);
+	g_free(filename);
+	g_free(path);
+	g_hash_table_replace(pending_updates, c, name);
+	fetch_thumbnail_cb(data, data->pic_data, data->pic_data_len);
+	return;
+    }
+    // Get GaymBuddy struct for the thumbnail URL.
+    cm = g_hash_table_lookup(gaym->channel_members, name);
+    if(!cm)
+	return;
+
+    
+    // Fetch thumbnail.
+
+    char *hashurl = g_hash_table_lookup(gaym->confighash,
+                                        "mini-profile-panel.thumbnail-prefix");
+   
+    data = g_new0(struct fetch_thumbnail_data, 1);
+    data->who = name;
+    data->from_file = FALSE;
+    char *url = g_strdup_printf("%s%s", hashurl, cm->thumbnail);
+    gaim_url_fetch(url, FALSE, "Mozilla/4.0", FALSE,
+                   fetch_thumbnail_cb, data);
+
+    // Add entry to hash table for tracking.
+    g_hash_table_replace(pending_updates, c, name);
+
+}
+void add_chat_icon_stuff(GaimConversation *c) {
+    
+    GtkTreeModel *ls;
+    
+    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
+    GaimGtkChatPane *gtkchat = gtkconv->u.chat;
+    GaimPluginProtocolInfo *prpl_info = NULL;
+    GaimAccount *account = gaim_conversation_get_account(c);
+    GaymChatIcon *icon_data = g_new0(GaymChatIcon, 1);
+
+    if (account && account->gc)
+        prpl_info = GAIM_PLUGIN_PROTOCOL_INFO(account->gc->prpl);
+    GtkTreeSelection *select =
+        gtk_tree_view_get_selection(GTK_TREE_VIEW(gtkchat->list));
+    
+    gtk_tree_selection_set_mode(select, GTK_SELECTION_SINGLE);
+
+    ls = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
+
+    GtkBox *hbox = GTK_BOX(gtkconv->lower_hbox);
+
+    g_signal_connect(G_OBJECT(select), "changed", G_CALLBACK(changed_cb),
+                     c);
+
+    icon_data->icon_container_parent = GTK_WIDGET(hbox);
+    icon_data->icon_container = NULL;
+    icon_data->icon = NULL;
+    icon_data->anim = NULL;
+    icon_data->iter = NULL;
+    icon_data->show_icon = TRUE;
+    icon_data->icon_container = gtk_vbox_new(FALSE, 0);
+    
+    gtk_widget_set_size_request(GTK_WIDGET(icon_data->icon_container),
+                                prpl_info->icon_spec.max_width,
+                                prpl_info->icon_spec.max_height);
+
+
+    icon_data->frame = gtk_frame_new(NULL);
+    gtk_frame_set_shadow_type(GTK_FRAME(icon_data->frame),
+                              (GTK_SHADOW_IN));
+    gtk_box_pack_start(GTK_BOX(icon_data->icon_container),
+                       icon_data->frame, FALSE, FALSE, 0);
+    gtk_widget_show(icon_data->icon_container);
+    gtk_widget_show(icon_data->frame);
+    gtk_box_pack_end(GTK_BOX(icon_data->icon_container_parent),
+                     icon_data->icon_container, FALSE, FALSE, 0);
+    
+    icon_data->event = gtk_event_box_new();
+    gtk_container_add(GTK_CONTAINER(icon_data->frame), icon_data->event);
+
+    // Maybe add menu functionality later.
+    // g_signal_connect(G_OBJECT(icon_data->event), "button-press-event",
+    // G_CALLBACK(icon_menu), conv);
+    gtk_widget_show(icon_data->event);
+    g_hash_table_insert(icons, c, icon_data);
+
+
+}
+void init_chat_icons() {
+
+    icons = g_hash_table_new(g_direct_hash, g_direct_equal);
+    pending_updates = g_hash_table_new(g_direct_hash, g_direct_equal);
+}

Modified: qrc/trunk/gaym-extras/chatsort.c
===================================================================
--- qrc/trunk/gaym-extras/chatsort.c	2005-07-26 08:10:10 UTC (rev 247)
+++ qrc/trunk/gaym-extras/chatsort.c	2005-07-27 07:47:36 UTC (rev 248)
@@ -1,93 +1,141 @@
-/* Attempt to sort chat users by entry order, instead of alpha */
-#include "internal.h"
-#include "gtkgaim.h"
+#include "gaym-extras.h"
 
-#include "conversation.h"
-#include "debug.h"
-#include "log.h"
-#include "prefs.h"
-#include "signals.h"
-#include "util.h"
-#include "version.h"
+static gint
+sort_chat_users_by_entry(GtkTreeModel * model, GtkTreeIter * a,
+                         GtkTreeIter * b, gpointer userdata)
+{
+    GaimConvChatBuddyFlags f1 = 0, f2 = 0;
+    char *user1 = NULL, *user2 = NULL;
+    gint ret = 0;
 
-#include "gtkconv.h"
-#include "gtkimhtml.h"
-#include "gtkplugin.h"
+    gtk_tree_model_get(model, a, CHAT_USERS_NAME_COLUMN, &user1,
+                       CHAT_USERS_FLAGS_COLUMN, &f1, -1);
+    gtk_tree_model_get(model, b, CHAT_USERS_NAME_COLUMN, &user2,
+                       CHAT_USERS_FLAGS_COLUMN, &f2, -1);
 
-#define CHATSORT_PLUGIN_ID "gtk-chatsort"
+    if (user1 == NULL || user2 == NULL) {
+        if (!(user1 == NULL && user2 == NULL))
+            ret = (user1 == NULL) ? -1 : 1;
+    } else if (f1 != f2) {
+        /* sort more important users first */
+        ret = (f1 > f2) ? -1 : 1;
+    } else {
+        ret = g_utf8_collate(user1, user2);
+    }
 
+    g_free(user1);
+    g_free(user2);
+    return ret;
+}
 
-// A dummy sort function... don't sort at all!
-static gint sort_chat_users(GtkTreeModel * model, GtkTreeIter * a,
-                            GtkTreeIter * b, gpointer userdata)
+static gint
+sort_chat_users_by_alpha(GtkTreeModel * model, GtkTreeIter * a,
+                         GtkTreeIter * b, gpointer userdata)
 {
-    return 1;
+    char *user1 = NULL, *user2 = NULL;
+    gint ret = 0;
+
+    gtk_tree_model_get(model, a, CHAT_USERS_NAME_COLUMN, &user1, -1);
+    gtk_tree_model_get(model, b, CHAT_USERS_NAME_COLUMN, &user2, -1);
+
+    if (user1 == NULL || user2 == NULL) {
+        if (!(user1 == NULL && user2 == NULL))
+            ret = (user1 == NULL) ? -1 : 1;
+    } else {
+        ret = g_utf8_collate(user1, user2);
+    }
+
+    g_free(user1);
+    g_free(user2);
+    return ret;
 }
 
-// This gets called BEFORE a chatlist is populated... just creates a new
-// type of chat window.
-static void redochatwindow(GaimConversation * c)
+
+static gint
+sort_chat_users_by_category(GtkTreeModel * model, GtkTreeIter * a,
+                            GtkTreeIter * b, gpointer userdata)
 {
+    GaimConvChatBuddyFlags f1 = 0, f2 = 0;
+    gint flag_mask = 0x000F;
+    char *user1 = NULL, *user2 = NULL;
+    gint ret = 0;
 
-    GtkTreeModel *oldls;
-    GtkTreeSelection *select;
-    GtkTreeIter iter;
+    gtk_tree_model_get(model, a, CHAT_USERS_NAME_COLUMN, &user1,
+                       CHAT_USERS_FLAGS_COLUMN, &f1, -1);
+    gtk_tree_model_get(model, b, CHAT_USERS_NAME_COLUMN, &user2,
+                       CHAT_USERS_FLAGS_COLUMN, &f2, -1);
 
-    // Get a handle to the chat pane for the conversation
-    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-    GaimGtkChatPane *gtkchat = gtkconv->u.chat;
+    f1 = f1 & flag_mask;
+    f2 = f2 & flag_mask;
 
+    if (user1 == NULL || user2 == NULL) {
+        if (!(user1 == NULL && user2 == NULL))
+            ret = (user1 == NULL) ? -1 : 1;
+    } else if (f1 != f2) {
+        /* sort more important users first */
+        ret = (f1 > f2) ? -1 : 1;
+    } else {
+        ret = g_utf8_collate(user1, user2);
+    }
 
-    oldls = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
-    select = gtk_tree_view_get_selection(GTK_TREE_VIEW(gtkchat->list));
+    g_free(user1);
+    g_free(user2);
+    return ret;
+}
 
-    // This is a dummy "root" item. If it's not here,
-    // then the first name entered into the list gets "stucK" at the
-    // top. This is a hack.
-    gtk_list_store_append(GTK_LIST_STORE(oldls), &iter);
-    gtk_list_store_set(GTK_LIST_STORE(oldls), &iter,
-                       CHAT_USERS_NAME_COLUMN, " ", -1);
-    gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(oldls),
-                                    CHAT_USERS_NAME_COLUMN,
-                                    sort_chat_users, NULL, NULL);
 
-}
 
-static gboolean plugin_load(GaimPlugin * plugin)
+void change_sort_order(GtkWidget * button, void *data)
 {
-    gaim_signal_connect(gaim_conversations_get_handle(),
-                        "chat-joined",
-                        plugin, GAIM_CALLBACK(redochatwindow), NULL);
 
-    return TRUE;
+    static GaymSortOrder order = SORT_ENTRY;
+
+
+    GtkTreeView *list = (GtkTreeView *) data;
+    GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(list));
+    gaim_debug_misc("chatsort", "list: %x, data: %x, model: %x\n", list,
+                    data, model);
+    if (order == SORT_ALPHA) {
+        order = SORT_CATEGORY;
+        gaim_debug_misc("chatsort", "Change to entry order");
+        gtk_button_set_label(GTK_BUTTON(button), "E");
+        gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model),
+                                        CHAT_USERS_NAME_COLUMN,
+                                        sort_chat_users_by_category, NULL,
+                                        NULL);
+    } else if (order == SORT_CATEGORY) {
+        order = SORT_ENTRY;
+        gaim_debug_misc("chatsort", "Change to category order");
+        gtk_button_set_label(GTK_BUTTON(button), "P");
+        gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model),
+                                        CHAT_USERS_NAME_COLUMN,
+                                        sort_chat_users_by_entry, NULL,
+                                        NULL);
+    } else {
+        order = SORT_ALPHA;
+        gaim_debug_misc("chatsort", "Change to alpha order");
+        gtk_button_set_label(GTK_BUTTON(button), "A");
+        gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model),
+                                        CHAT_USERS_NAME_COLUMN,
+                                        sort_chat_users_by_alpha, NULL,
+                                        NULL);
+    }
+
 }
+void add_chat_sort_functions(GaimConversation* c) {
+     
+    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
+    GaimGtkChatPane *gtkchat = gtkconv->u.chat;
+    
+    GtkBox *iconbox = (GtkBox *) gtkconv->info->parent;
+    GtkWidget *button = gtk_button_new_with_label("E");
+    gtk_button_set_relief(GTK_BUTTON(button), GTK_RELIEF_NONE);
+    gtk_box_pack_end(iconbox, button, FALSE, FALSE, 0);
+    gtk_widget_show(button);
+    g_signal_connect(G_OBJECT(button), "clicked",
+                     G_CALLBACK(change_sort_order), gtkchat->list);
+    gaim_debug_misc("chatsort", "Connected signal with data %x\n",
+                    gtkchat->list);
 
-static GaimPluginInfo info = {
-    GAIM_PLUGIN_MAGIC,
-    GAIM_MAJOR_VERSION,
-    GAIM_MINOR_VERSION,
-    GAIM_PLUGIN_STANDARD,
-    GAIM_GTK_PLUGIN_TYPE,
-    0,
-    NULL,
-    GAIM_PRIORITY_DEFAULT,
-    CHATSORT_PLUGIN_ID,
-    N_("Chatroom Sort options"),
-    VERSION,
-    N_("Changes the sorting options of chatroom lists."),
-    N_("When a new conversation is opened this plugin will insert the last conversation into the current conversation."),
-    "Jason LeBrun <gaim at jasonlebrun.info",
-    GAIM_WEBSITE,
-    plugin_load,
-    NULL,
-    NULL,
-    NULL,
-    NULL,
-    NULL
-};
 
-static void init_plugin(GaimPlugin * plugin)
-{
 }
-
-GAIM_INIT_PLUGIN(history, init_plugin, info)

Modified: qrc/trunk/gaym-extras/gaym-extras.c
===================================================================
--- qrc/trunk/gaym-extras/gaym-extras.c	2005-07-26 08:10:10 UTC (rev 247)
+++ qrc/trunk/gaym-extras/gaym-extras.c	2005-07-27 07:47:36 UTC (rev 248)
@@ -1,975 +1,47 @@
 /* Show icons in chat room windows */
 
-#include "internal.h"
-#include "gtkgaim.h"
 
-#include "conversation.h"
-#include "debug.h"
-#include "log.h"
-#include "prefs.h"
-#include "signals.h"
-#include "util.h"
-#include "version.h"
-#include "buddyicon.h"
-#include "prpl.h"
+#include "gaym-extras.h"
 
-#include "gtkconv.h"
-#include "gtkimhtml.h"
-#include "gtkplugin.h"
 
-#include "../gaym/src/gaym.h"
-struct fetch_thumbnail_data {
-    char *who;
-    const char *pic_data;
-    gint pic_data_len;
-};
-#define CHATSORT_PLUGIN_ID "gtk-chaticon"
+#define GAYM_EXTRAS_PLUGIN_ID "gtk-gaym-extras"
 
 
-GHashTable *icons;
-GHashTable *pending_updates;
-GHashTable *im_window_bios;
 
-// Consider combining into one popup hash...
-GHashTable *popup_rects;
-GHashTable *popup_timeouts;
-GHashTable *popups;
-
-// Additional UI info for a conversation.
-// We may be able to clean this up, some.
-typedef struct _GaymChatIcon {
-
-    GaimConversation *conv;
-    GtkWidget *icon_container_parent;
-    GtkWidget *icon_container;
-    GtkWidget *frame;
-    GtkWidget *icon;
-    GtkWidget *event;
-    gboolean show_icon;
-    GdkPixbufAnimation *anim;
-    GdkPixbufAnimationIter *iter;
-    gboolean animate;
-    guint32 icon_timer;
-    GtkWidget *bio_area;
-
-} GaymChatIcon;
-
-typedef enum {
-    SORT_ALPHA,
-    SORT_ENTRY,
-    SORT_CATEGORY,
-} GaymSortOrder;
-
-static gint
-sort_chat_users_by_entry(GtkTreeModel * model, GtkTreeIter * a,
-                         GtkTreeIter * b, gpointer userdata)
+//Adds motion handlers to IM tab labels.
+static void redo_im_window(GaimConversation * c)
 {
-    GaimConvChatBuddyFlags f1 = 0, f2 = 0;
-    char *user1 = NULL, *user2 = NULL;
-    gint ret = 0;
-
-    gtk_tree_model_get(model, a, CHAT_USERS_NAME_COLUMN, &user1,
-                       CHAT_USERS_FLAGS_COLUMN, &f1, -1);
-    gtk_tree_model_get(model, b, CHAT_USERS_NAME_COLUMN, &user2,
-                       CHAT_USERS_FLAGS_COLUMN, &f2, -1);
-
-    if (user1 == NULL || user2 == NULL) {
-        if (!(user1 == NULL && user2 == NULL))
-            ret = (user1 == NULL) ? -1 : 1;
-    } else if (f1 != f2) {
-        /* sort more important users first */
-        ret = (f1 > f2) ? -1 : 1;
-    } else {
-        ret = g_utf8_collate(user1, user2);
-    }
-
-    g_free(user1);
-    g_free(user2);
-    return ret;
+    if (c && c->type == GAIM_CONV_IM) 
+	add_im_popup_stuff(c);
 }
 
-static gint
-sort_chat_users_by_alpha(GtkTreeModel * model, GtkTreeIter * a,
-                         GtkTreeIter * b, gpointer userdata)
-{
-    char *user1 = NULL, *user2 = NULL;
-    gint ret = 0;
 
-    gtk_tree_model_get(model, a, CHAT_USERS_NAME_COLUMN, &user1, -1);
-    gtk_tree_model_get(model, b, CHAT_USERS_NAME_COLUMN, &user2, -1);
-
-    if (user1 == NULL || user2 == NULL) {
-        if (!(user1 == NULL && user2 == NULL))
-            ret = (user1 == NULL) ? -1 : 1;
-    } else {
-        ret = g_utf8_collate(user1, user2);
-    }
-
-    g_free(user1);
-    g_free(user2);
-    return ret;
+static void update_info_cb(GaimAccount* account, char* name) {
+    gaim_debug_misc("gaym-extras","info update\n");
 }
 
-
-static gint
-sort_chat_users_by_category(GtkTreeModel * model, GtkTreeIter * a,
-                            GtkTreeIter * b, gpointer userdata)
-{
-    GaimConvChatBuddyFlags f1 = 0, f2 = 0;
-    gint flag_mask = 0x000F;
-    char *user1 = NULL, *user2 = NULL;
-    gint ret = 0;
-
-    gtk_tree_model_get(model, a, CHAT_USERS_NAME_COLUMN, &user1,
-                       CHAT_USERS_FLAGS_COLUMN, &f1, -1);
-    gtk_tree_model_get(model, b, CHAT_USERS_NAME_COLUMN, &user2,
-                       CHAT_USERS_FLAGS_COLUMN, &f2, -1);
-
-    f1 = f1 & flag_mask;
-    f2 = f2 & flag_mask;
-
-    if (user1 == NULL || user2 == NULL) {
-        if (!(user1 == NULL && user2 == NULL))
-            ret = (user1 == NULL) ? -1 : 1;
-    } else if (f1 != f2) {
-        /* sort more important users first */
-        ret = (f1 > f2) ? -1 : 1;
-    } else {
-        ret = g_utf8_collate(user1, user2);
-    }
-
-    g_free(user1);
-    g_free(user2);
-    return ret;
-}
-
-
-
-static void change_sort_order(GtkWidget * button, void *data)
-{
-
-    static GaymSortOrder order = SORT_ENTRY;
-
-
-    GtkTreeView *list = (GtkTreeView *) data;
-    GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(list));
-    gaim_debug_misc("chatsort", "list: %x, data: %x, model: %x\n", list,
-                    data, model);
-    if (order == SORT_ALPHA) {
-        order = SORT_CATEGORY;
-        gaim_debug_misc("chatsort", "Change to entry order");
-        gtk_button_set_label(GTK_BUTTON(button), "E");
-        gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model),
-                                        CHAT_USERS_NAME_COLUMN,
-                                        sort_chat_users_by_category, NULL,
-                                        NULL);
-    } else if (order == SORT_CATEGORY) {
-        order = SORT_ENTRY;
-        gaim_debug_misc("chatsort", "Change to category order");
-        gtk_button_set_label(GTK_BUTTON(button), "P");
-        gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model),
-                                        CHAT_USERS_NAME_COLUMN,
-                                        sort_chat_users_by_entry, NULL,
-                                        NULL);
-    } else {
-        order = SORT_ALPHA;
-        gaim_debug_misc("chatsort", "Change to alpha order");
-        gtk_button_set_label(GTK_BUTTON(button), "A");
-        gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model),
-                                        CHAT_USERS_NAME_COLUMN,
-                                        sort_chat_users_by_alpha, NULL,
-                                        NULL);
-    }
-
-}
-static void
-get_icon_scale_size(GdkPixbufAnimation * icon, GaimBuddyIconSpec * spec,
-                    int *width, int *height)
-{
-    *width = gdk_pixbuf_animation_get_width(icon);
-    *height = gdk_pixbuf_animation_get_height(icon);
-
-    /* this should eventually get smarter about preserving the aspect
-       ratio when scaling, but gimmie a break, I just woke up */
-    if (spec && spec->scale_rules & GAIM_ICON_SCALE_DISPLAY) {
-        if (*width < spec->min_width)
-            *width = spec->min_width;
-        else if (*width > spec->max_width)
-            *width = spec->max_width;
-
-        if (*height < spec->min_height)
-            *height = spec->min_height;
-        else if (*height > spec->max_height)
-            *height = spec->max_height;
-    }
-
-    /* and now for some arbitrary sanity checks */
-    if (*width > 100)
-        *width = 100;
-    if (*height > 100)
-        *height = 100;
-}
-
-void gaym_gtkconv_update_thumbnail(GaimConversation * conv, struct fetch_thumbnail_data
-                                   *thumbnail_data)
-{
-    GaimGtkConversation *gtkconv;
-
-    char filename[256];
-    FILE *file;
-    GError *err = NULL;
-
-    size_t len;
-
-    GdkPixbuf *buf;
-    GdkPixbuf *scale;
-    GdkPixmap *pm;
-    GdkBitmap *bm;
-    int scale_width, scale_height;
-
-
-    GaimAccount *account;
-    GaimPluginProtocolInfo *prpl_info = NULL;
-    g_return_if_fail(conv != NULL);
-    g_return_if_fail(GAIM_IS_GTK_CONVERSATION(conv));
-    g_return_if_fail(gaim_conversation_get_type(conv) == GAIM_CONV_CHAT);
-
-    gtkconv = GAIM_GTK_CONVERSATION(conv);
-
-    GaymChatIcon *icon_data = g_hash_table_lookup(icons, conv);
-
-    if (!thumbnail_data)
-        return;
-    if (!icon_data->show_icon)
-        return;
-
-    const char *data = thumbnail_data->pic_data;
-    len = thumbnail_data->pic_data_len;
-
-    account = gaim_conversation_get_account(conv);
-    if (account && account->gc)
-        prpl_info = GAIM_PLUGIN_PROTOCOL_INFO(account->gc->prpl);
-
-
-    if (icon_data->anim != NULL)
-        g_object_unref(G_OBJECT(icon_data->anim));
-
-    icon_data->anim = NULL;
-
-    if (icon_data->icon_timer != 0)
-        g_source_remove(icon_data->icon_timer);
-
-    icon_data->icon_timer = 0;
-
-    if (icon_data->iter != NULL)
-        g_object_unref(G_OBJECT(icon_data->iter));
-
-    icon_data->iter = NULL;
-
-    if (!gaim_prefs_get_bool
-        ("/gaim/gtk/conversations/im/show_buddy_icons"))
-        return;
-
-    if (gaim_conversation_get_gc(conv) == NULL)
-        return;
-
-
-    /* this is such an evil hack, i don't know why i'm even considering
-       it. we'll do it differently when gdk-pixbuf-loader isn't leaky
-       anymore. */
-    /* gdk-pixbuf-loader was leaky? is it still? */
-
-    g_snprintf(filename, sizeof(filename),
-               "%s" G_DIR_SEPARATOR_S "gaimicon-%s.%d",
-               g_get_tmp_dir(), thumbnail_data->who, getpid());
-
-    if (!(file = g_fopen(filename, "wb")))
-        return;
-
-    fwrite(data, 1, len, file);
-    fclose(file);
-    icon_data->anim = gdk_pixbuf_animation_new_from_file(filename, &err);
-
-    /* make sure we remove the file as soon as possible */
-    g_unlink(filename);
-
-    if (err) {
-        gaim_debug(GAIM_DEBUG_ERROR, "gtkconv",
-                   "Buddy icon error: %s\n", err->message);
-        g_error_free(err);
-    }
-
-
-
-    if (!icon_data->anim)
-        return;
-
-    if (gdk_pixbuf_animation_is_static_image(icon_data->anim)) {
-        icon_data->iter = NULL;
-        buf = gdk_pixbuf_animation_get_static_image(icon_data->anim);
-    } else {
-        icon_data->iter = gdk_pixbuf_animation_get_iter(icon_data->anim, NULL); /* LEAK 
-                                                                                 */
-        buf = gdk_pixbuf_animation_iter_get_pixbuf(icon_data->iter);
-    }
-
-    get_icon_scale_size(icon_data->anim,
-                        prpl_info ? &prpl_info->icon_spec : NULL,
-                        &scale_width, &scale_height);
-    scale =
-        gdk_pixbuf_scale_simple(buf,
-                                MAX(gdk_pixbuf_get_width(buf) *
-                                    scale_width /
-                                    gdk_pixbuf_animation_get_width
-                                    (icon_data->anim), 1),
-                                MAX(gdk_pixbuf_get_height(buf) *
-                                    scale_height /
-                                    gdk_pixbuf_animation_get_height
-                                    (icon_data->anim), 1),
-                                GDK_INTERP_NEAREST);
-
-    gdk_pixbuf_render_pixmap_and_mask(scale, &pm, &bm, 100);
-    g_object_unref(G_OBJECT(scale));
-
-
-    icon_data->event = gtk_event_box_new();
-    gtk_container_add(GTK_CONTAINER(icon_data->frame), icon_data->event);
-    // g_signal_connect(G_OBJECT(icon_data->event), "button-press-event",
-    // G_CALLBACK(icon_menu), conv);
-    gtk_widget_show(icon_data->event);
-    icon_data->icon = gtk_image_new_from_pixmap(pm, bm);
-    gtk_container_add(GTK_CONTAINER(icon_data->event), icon_data->icon);
-    gtk_widget_show(icon_data->icon);
-
-    g_object_unref(G_OBJECT(pm));
-
-    if (bm)
-        g_object_unref(G_OBJECT(bm));
-
-
-}
-static gboolean check_for_update(gpointer * conversation,
-                                 const gpointer * name, gpointer * data)
-{
-
-    g_return_val_if_fail(conversation != NULL, TRUE);
-    g_return_val_if_fail(name != NULL, TRUE);
-    g_return_val_if_fail(data != NULL, TRUE);
-
-    GaimConversation *c = (GaimConversation *) conversation;
-    char *name_needing_update = (char *) name;
-
-    struct fetch_thumbnail_data *d = (struct fetch_thumbnail_data *) data;
-
-
-    g_return_val_if_fail(name_needing_update != NULL, FALSE);
-
-    if (!strcmp(d->who, name_needing_update)) {
-        gaym_gtkconv_update_thumbnail(c, d);
-        return TRUE;
-    }
-    return TRUE;
-}
-
-void fetch_thumbnail_cb(void *user_data, const char *pic_data, size_t len)
-{
-    if (!user_data)
-        return;
-    struct fetch_thumbnail_data *d = user_data;
-    if (!pic_data) {
-        return;
-    }
-    if (len && !g_strrstr_len(pic_data, len, "Server Error")) {
-        d->pic_data = pic_data;
-        d->pic_data_len = len;
-    } else {
-        d->pic_data = 0;
-        d->pic_data_len = 0;
-    }
-    g_hash_table_foreach_remove(pending_updates,
-                                (GHRFunc) check_for_update, d);
-    g_free(d->who);
-    g_free(d);
-}
-
-
-static void changed_cb(GtkTreeSelection * selection, gpointer conv)
-{
-
-    g_return_if_fail(selection != NULL);
-    g_return_if_fail(conv != NULL);
-
-    GaimConversation *c = (GaimConversation *) conv;
-    GaymBuddy *cm;
-    struct gaym_conn *gaym = c->account->gc->proto_data;
-
-    GtkTreeIter iter;
-    GtkTreeModel *model;
-    gchar *name;
-
-    if (!gtk_tree_selection_get_selected(selection, &model, &iter))
-        return;
-
-    gtk_tree_model_get(model, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
-
-    /* Remove the current icon stuff */
-    GaymChatIcon *icon_data = g_hash_table_lookup(icons, c);
-    if (icon_data->event != NULL)
-        gtk_widget_destroy(icon_data->event);
-    icon_data->event = NULL;
-
-    // Get thumbnail URL.
-    cm = gaym_get_channel_member_info(gaym, name);
-    // thumbnail = ui_info->get_user_thumbnail_url(gaym, name);
-
-    // Fetch thumbnail.
-
-    struct fetch_thumbnail_data *data;
-    char *hashurl = g_hash_table_lookup(gaym->confighash,
-                                        "mini-profile-panel.thumbnail-prefix");
-    g_return_if_fail(hashurl != NULL);
-    data = g_new0(struct fetch_thumbnail_data, 1);
-    data->who = g_strdup(name);
-    char *url = g_strdup_printf("%s%s", hashurl, cm->thumbnail);
-    gaim_url_fetch(url, FALSE, "Mozilla/4.0", FALSE,
-                   fetch_thumbnail_cb, data);
-
-    // Add entry to hash table for tracking.
-    g_hash_table_replace(pending_updates, c, name);
-
-}
-
-static void clean_popup_stuff(GaimConversation * c)
-{
-
-    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-    if (c->type == GAIM_CONV_IM) {
-        g_hash_table_remove(popup_timeouts, gtkconv->tab_label);
-        g_hash_table_remove(popups, gtkconv->tab_label);
-    } else if (c->type == GAIM_CONV_CHAT) {
-        GaimGtkChatPane *gtkchat = gtkconv->u.chat;
-        g_hash_table_remove(popup_timeouts, gtkchat->list);
-        g_hash_table_remove(popup_rects, gtkchat->list);
-        g_hash_table_remove(popups, gtkchat->list);
-    }
-
-}
-
-static void update_im_bio(GaimAccount * account, gchar * name)
-{
-    g_return_if_fail(name != NULL);
-    g_return_if_fail(account != NULL);
-
-    GaimConversation *c =
-        gaim_find_conversation_with_account(name, account);
-
-    g_return_if_fail(c != NULL);
-    g_return_if_fail(c->type == GAIM_CONV_IM);
-
-    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-    // struct gaym_conn *gaym = account->gc->proto_data;
-
-    GtkBox *vbox_big = GTK_BOX(gtkconv->lower_hbox->parent);
-
-    GtkWidget *bio_area = g_hash_table_lookup(im_window_bios, c->name);
-    if (!bio_area) {
-        bio_area = gtk_label_new(_("Temporarily disabled."));
-        g_hash_table_insert(im_window_bios, c, bio_area);
-        gtk_box_pack_start(vbox_big, bio_area, TRUE, TRUE, 0);
-        // gtk_widget_show(bio_area);
-    }
-
-    /* char* age = ui_info->get_user_age(gaym, name); char* location =
-       ui_info->get_user_location(gaym, name); char* bio =
-       ui_info->get_user_bio(gaym, name); char *buf; buf = g_strconcat(1 ? 
-       "Age: " : "", cm->age ? cm->age : "?", 1 ? "\nLocation: " : "",
-       cm->location ? cm->location : "?", cm->bio ? "\nInfo: " : "",
-       cm->bio ? cm->bio : "");
-
-       gtk_label_set_text(GTK_LABEL(bio_area), buf);
-       gtk_label_set_line_wrap(GTK_LABEL(bio_area), TRUE); g_free(buf); */
-}
-static void namelist_leave_cb(GtkWidget * tv, GdkEventCrossing * e,
-                              gpointer n)
-{
-    guint *timeout = g_hash_table_lookup(popup_timeouts, tv);
-    g_hash_table_remove(popups, tv);
-
-    if (*timeout) {
-        g_source_remove(*timeout);
-        *timeout = 0;
-    }
-}
-
-static void namelist_paint_tip(GtkWidget * tipwindow,
-                               GdkEventExpose * event, gchar * tooltiptext)
-{
-    GtkStyle *style;
-
-    // GdkPixbuf *pixbuf = gaim_gtk_blist_get_status_icon(node,
-    // GAIM_STATUS_ICON_LARGE);
-    PangoLayout *layout;
-
-    // gchar* tooltiptext=data;
-    layout = gtk_widget_create_pango_layout(tipwindow, NULL);
-    pango_layout_set_markup(layout, tooltiptext, strlen(tooltiptext));
-    pango_layout_set_wrap(layout, PANGO_WRAP_WORD);
-    pango_layout_set_width(layout, 300000);
-    style = tipwindow->style;
-
-    gtk_paint_flat_box(style, tipwindow->window, GTK_STATE_NORMAL,
-                       GTK_SHADOW_OUT, NULL, tipwindow, "tooltip", 0, 0,
-                       -1, -1);
-
-#if GTK_CHECK_VERSION(2,2,0)
-    // gdk_draw_pixbuf(GDK_DRAWABLE(tipwindow->window), NULL, pixbuf,
-    // 0, 0, 4, 4, -1 , -1, GDK_RGB_DITHER_NONE, 0, 0);
-#else
-    // gdk_pixbuf_render_to_drawable(pixbuf,
-    // GDK_DRAWABLE(tipwindow->window), NULL, 0, 0, 4, 4, -1, -1,
-    // GDK_RGB_DITHER_NONE, 0, 0);
-#endif
-
-    gtk_paint_layout(style, tipwindow->window, GTK_STATE_NORMAL, TRUE,
-                     NULL, tipwindow, "tooltip", 38, 4, layout);
-
-    // g_object_unref (pixbuf);
-    g_object_unref(layout);
-
-    return;
-}
-
-typedef enum {
-    TOOLTIP_CHAT,
-    TOOLTIP_IM,
-} GaymTooltipType;
-
-struct timeout_cb_data {
-    GaymTooltipType type;
-    GtkWidget *tv;
-    struct gaym_conn *gaym;
-};
-
-static gboolean tooltip_timeout(struct timeout_cb_data *data)
-{
-    const gchar *name;
-    int scr_w, scr_h, w, h, x, y;
-#if GTK_CHECK_VERSION(2,2,0)
-    int mon_num;
-    GdkScreen *screen = NULL;
-#endif
-    PangoLayout *layout;
-    gboolean tooltip_top = FALSE;
-    char *tooltiptext = NULL;
-    GdkRectangle mon_size;
-    guint *timeout;
-    GtkWidget *tipwindow;
-    GtkWidget *tv = data->tv;
-    GaymTooltipType type = data->type;
-    struct gaym_conn *gaym = data->gaym;
-    GaimPluginProtocolInfo *prpl_info =
-        GAIM_PLUGIN_PROTOCOL_INFO(gaim_find_prpl
-                                  (gaim_account_get_protocol_id
-                                   (gaym->account)));
-
-    timeout = (guint *) g_hash_table_lookup(popup_timeouts, tv);
-    while (gtk_events_pending())
-        gtk_main_iteration();
-
-    /* we check to see if we're still supposed to be moving, now that gtk
-       events have happened, and the mouse might not still be in the buddy 
-       list */
-    if (!(*timeout)) {
-        return FALSE;
-    }
-
-    if (type == TOOLTIP_CHAT) {
-        GtkTreePath *path;
-        GtkTreeIter iter;
-        GtkTreeModel *model;
-        GdkRectangle *rect;
-
-        rect = g_hash_table_lookup(popup_rects, tv);
-        if (!gtk_tree_view_get_path_at_pos
-            (GTK_TREE_VIEW(tv), rect->x, rect->y, &path, NULL, NULL, NULL))
-            return FALSE;
-        model = gtk_tree_view_get_model(GTK_TREE_VIEW(tv));
-        gtk_tree_model_get_iter(model, &iter, path);
-        gtk_tree_model_get(model, &iter, CHAT_USERS_NAME_COLUMN, &name,
-                           -1);
-        gtk_tree_path_free(path);
-    } else if (type == TOOLTIP_IM) {
-        name = gtk_label_get_text(GTK_LABEL(tv));
-    } else
-        return FALSE;
-
-
-    GaymBuddy *cm = gaym_get_channel_member_info(gaym, name);
-    if (!cm) {
-        guint *timeout = g_hash_table_lookup(popup_timeouts, tv);
-        if (timeout) {
-            int delay =
-                gaim_prefs_get_int("/gaim/gtk/blist/tooltip_delay");
-            g_timeout_add(delay, (GSourceFunc) tooltip_timeout, data);
-        }
-        return FALSE;
-    }
-    g_free(data);
-
-
-    GaimBuddy *gb = g_new0(GaimBuddy, 1);
-    gb->name = cm->name;
-    gb->account = gaym->account;
-
-    tooltiptext = prpl_info->tooltip_text(gb);
-    g_free(gb);
-    g_return_val_if_fail(tooltiptext != NULL, FALSE);
-
-    tipwindow = g_hash_table_lookup(popups, tv);
-    if (tipwindow)
-        g_hash_table_remove(popups, tv);
-
-    tipwindow = gtk_window_new(GTK_WINDOW_POPUP);
-    g_hash_table_insert(popups, tv, tipwindow);
-
-    gtk_widget_set_app_paintable(tipwindow, TRUE);
-    gtk_window_set_resizable(GTK_WINDOW(tipwindow), FALSE);
-    gtk_widget_set_name(tipwindow, "gtk-tooltips");
-    g_signal_connect(G_OBJECT(tipwindow), "expose_event",
-                     G_CALLBACK(namelist_paint_tip), tooltiptext);
-    gtk_widget_ensure_style(tipwindow);
-
-    layout = gtk_widget_create_pango_layout(tipwindow, NULL);
-    pango_layout_set_wrap(layout, PANGO_WRAP_WORD);
-    pango_layout_set_width(layout, 300000);
-    pango_layout_set_markup(layout, tooltiptext, strlen(tooltiptext));
-    pango_layout_get_size(layout, &w, &h);
-
-#if GTK_CHECK_VERSION(2,2,0)
-    gdk_display_get_pointer(gdk_display_get_default(), &screen, &x, &y,
-                            NULL);
-    mon_num = gdk_screen_get_monitor_at_point(screen, x, y);
-    gdk_screen_get_monitor_geometry(screen, mon_num, &mon_size);
-
-    scr_w = mon_size.width + mon_size.x;
-    scr_h = mon_size.height + mon_size.y;
-#else
-    scr_w = gdk_screen_width();
-    scr_h = gdk_screen_height();
-    gdk_window_get_pointer(NULL, &x, &y, NULL);
-    mon_size.x = 0;
-    mon_size.y = 0;
-#endif
-
-
-    w = PANGO_PIXELS(w) + 8;
-    h = PANGO_PIXELS(h) + 8;
-
-    /* 38 is the size of a large status icon plus 4 pixels padding on each 
-       side.  I should #define this or something */
-    w = w + 38;
-    h = MAX(h, 38);
-
-#if GTK_CHECK_VERSION(2,2,0)
-    if (w > mon_size.width)
-        w = mon_size.width - 10;
-
-    if (h > mon_size.height)
-        h = mon_size.height - 10;
-#endif
-
-    // Find the conversation window here....
-    // if (GTK_WIDGET_NO_WINDOW(window))
-    // y+=window->allocation.y;
-
-    x -= ((w >> 1) + 4);
-
-    if ((y + h + 4) > scr_h || tooltip_top)
-        y = y - h - 5;
-    else
-        y = y + 6;
-
-    if (y < mon_size.y)
-        y = mon_size.y;
-
-    if (y != mon_size.y) {
-        if ((x + w) > scr_w)
-            x -= (x + w + 5) - scr_w;
-        else if (x < mon_size.x)
-            x = mon_size.x;
-    } else {
-        x -= (w / 2 + 10);
-        if (x < mon_size.x)
-            x = mon_size.x;
-    }
-
-    g_object_unref(layout);
-    // g_free(tooltiptext);
-    gtk_widget_set_size_request(tipwindow, w, h);
-    gtk_window_move(GTK_WINDOW(tipwindow), x, y);
-    gtk_widget_show(tipwindow);
-
-    return FALSE;
-}
-
-
-static gboolean namelist_motion_cb(GtkWidget * tv, GdkEventMotion * event,
-                                   gpointer gaym)
-{
-    GtkTreeModel *ls = NULL;
-    GtkTreePath *path = NULL;
-    GtkTreeIter iter;
-    char *name;
-    static int count = 0;
-    gboolean tf;
-    GdkRectangle *rect;
-    guint *timeout;
-    count++;
-    guint delay;
-    rect = g_hash_table_lookup(popup_rects, tv);
-    g_return_val_if_fail(rect != NULL, FALSE);
-
-
-    timeout = g_hash_table_lookup(popup_timeouts, tv);
-
-    delay = gaim_prefs_get_int("/gaim/gtk/blist/tooltip_delay");
-
-    if (delay == 0)
-        return FALSE;
-
-    if (*timeout) {
-        if ((event->y > rect->y) && ((event->y - rect->height) < rect->y))
-            return FALSE;
-        /* We've left the cell.  Remove the timeout and create a new one
-           below */
-        g_hash_table_remove(popups, tv);
-        g_source_remove(*timeout);
-    }
-
-    gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(tv), event->x, event->y,
-                                  &path, NULL, NULL, NULL);
-    g_return_val_if_fail(path != NULL, FALSE);
-    struct timeout_cb_data *timeout_data =
-        g_new0(struct timeout_cb_data, 1);
-    timeout_data->tv = tv;
-    timeout_data->gaym = gaym;
-    timeout_data->type = TOOLTIP_CHAT;
-    *timeout =
-        g_timeout_add(delay, (GSourceFunc) tooltip_timeout, timeout_data);
-
-    gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, rect);
-
-    ls = gtk_tree_view_get_model(GTK_TREE_VIEW(tv));
-    tf = gtk_tree_model_get_iter(ls, &iter, path);
-    gtk_tree_model_get(ls, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
-    gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, rect);
-
-    return TRUE;
-}
-
-static void tab_leave_cb(GtkWidget * event, GdkEventCrossing * e,
-                         gpointer n)
-{
-    GtkWidget *tab = gtk_bin_get_child(GTK_BIN(event));
-    gaim_debug_misc("im_bio", "tab exit\n");
-    guint *timeout = g_hash_table_lookup(popup_timeouts, tab);
-    g_hash_table_remove(popups, tab);
-
-
-    if (timeout && *timeout) {
-        g_source_remove(*timeout);
-        *timeout = 0;
-    }
-}
-
-
-static gboolean tab_entry_cb(GtkWidget * event,
-                             GdkEventCrossing * crossing, gpointer conv)
-{
-
-    guint *timeout;
-    guint delay;
-    gaim_debug_misc("im_bio", "tab entry\n");
-    GaimConversation *c = (GaimConversation *) conv;
-    struct gaym_conn *gaym = c->account->gc->proto_data;
-
-    GtkWidget *tab = gtk_bin_get_child(GTK_BIN(event));
-    timeout = g_hash_table_lookup(popup_timeouts, tab);
-
-    delay = gaim_prefs_get_int("/gaim/gtk/blist/tooltip_delay");
-
-    if (delay == 0)
-        return FALSE;
-
-    if (timeout && *timeout)
-        return FALSE;
-
-    // g_hash_table_remove(popups, tab);
-    // g_source_remove(*timeout);
-
-
-
-    struct timeout_cb_data *timeout_data =
-        g_new0(struct timeout_cb_data, 1);
-    timeout_data->tv = tab;
-    timeout_data->gaym = gaym;
-    timeout_data->type = TOOLTIP_IM;
-    *timeout =
-        g_timeout_add(delay, (GSourceFunc) tooltip_timeout, timeout_data);
-
-    return TRUE;
-}
-static void redo_im_window(GaimConversation * c)
-{
-
-    if (c && c->type == GAIM_CONV_IM) {
-        GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-        GtkWidget *event = gtk_event_box_new();
-
-        gaim_debug_misc("im_bio", "remove tab_label\n");
-        gtk_widget_ref(gtkconv->tab_label);
-        gtk_container_remove(GTK_CONTAINER(gtkconv->tabby),
-                             GTK_WIDGET(gtkconv->tab_label));
-        // gtk_container_remove(GTK_CONTAINER(gtkconv->tabby),
-        // gtkconv->icon);
-        // gtk_container_remove(GTK_CONTAINER(gtkconv->tabby),
-        // gtkconv->close);
-        gtk_widget_add_events(event,
-                              GDK_ENTER_NOTIFY_MASK |
-                              GDK_LEAVE_NOTIFY_MASK);
-        g_signal_connect(G_OBJECT(event), "enter-notify-event",
-                         G_CALLBACK(tab_entry_cb), c);
-
-        g_signal_connect(G_OBJECT(event),
-                         "leave-notify-event",
-                         G_CALLBACK(tab_leave_cb), c);
-        gaim_debug_misc("im_bio", "put event in tabby\n");
-        gtk_box_pack_start(GTK_BOX(gtkconv->tabby), GTK_WIDGET(event),
-                           TRUE, TRUE, 0);
-        gaim_debug_misc("im_bio", "show event\n");
-        gtk_widget_show(GTK_WIDGET(event));
-        gaim_debug_misc("im_bio", "put label in event\n");
-        gtk_container_add(GTK_CONTAINER(event),
-                          GTK_WIDGET(gtkconv->tab_label));
-        gtk_widget_unref(gtkconv->tab_label);
-        gaim_debug_misc("im_bio", "show label\n");
-        gtk_widget_show(GTK_WIDGET(gtkconv->tab_label));
-
-        // gaim_debug_misc("im_bio","Tried to add events: tab_label text
-        // is %s\n",gtk_label_get_text(GTK_LABEL(gtkconv->tab_label)));
-        g_hash_table_insert(popup_timeouts, gtkconv->tab_label,
-                            g_new0(guint, 1));
-    }
-
-}
-
 static void redochatwindow(GaimConversation * c)
 {
-
-
-    GtkTreeModel *oldls;
-
-    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-    GaimGtkChatPane *gtkchat = gtkconv->u.chat;
-    GaimPluginProtocolInfo *prpl_info = NULL;
-    GaimAccount *account = gaim_conversation_get_account(c);
-    if (account && account->gc)
-        prpl_info = GAIM_PLUGIN_PROTOCOL_INFO(account->gc->prpl);
-    GtkTreeSelection *select =
-        gtk_tree_view_get_selection(GTK_TREE_VIEW(gtkchat->list));
-    gtk_tree_selection_set_mode(select, GTK_SELECTION_SINGLE);
-
-    oldls = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
-
-    GtkBox *hbox = GTK_BOX(gtkconv->lower_hbox);
-    // GtkBox *vbox_big = GTK_BOX(gtkconv->lower_hbox->parent);
-
-    g_signal_connect(G_OBJECT(select), "changed", G_CALLBACK(changed_cb),
-                     c);
-    g_signal_connect(G_OBJECT(gtkchat->list), "motion-notify-event",
-                     G_CALLBACK(namelist_motion_cb),
-                     account->gc->proto_data);
-    g_signal_connect(G_OBJECT(gtkchat->list), "leave-notify-event",
-                     G_CALLBACK(namelist_leave_cb), NULL);
-
-
-    GaymChatIcon *icon_data = g_new0(GaymChatIcon, 1);
-
-    icon_data->icon_container_parent = GTK_WIDGET(hbox);
-    icon_data->icon_container = NULL;
-    icon_data->icon = NULL;
-    icon_data->anim = NULL;
-    icon_data->iter = NULL;
-    icon_data->show_icon = TRUE;
-
-    icon_data->icon_container = gtk_vbox_new(FALSE, 0);
-    gtk_widget_set_size_request(GTK_WIDGET(icon_data->icon_container),
-                                prpl_info->icon_spec.max_width,
-                                prpl_info->icon_spec.max_height);
-
-
-    icon_data->frame = gtk_frame_new(NULL);
-    gtk_frame_set_shadow_type(GTK_FRAME(icon_data->frame),
-                              (GTK_SHADOW_IN));
-    gtk_box_pack_start(GTK_BOX(icon_data->icon_container),
-                       icon_data->frame, FALSE, FALSE, 0);
-    gtk_widget_show(icon_data->icon_container);
-    gtk_widget_show(icon_data->frame);
-    gtk_box_pack_end(GTK_BOX(icon_data->icon_container_parent),
-                     icon_data->icon_container, FALSE, FALSE, 0);
-    gtk_widget_set_size_request(GTK_WIDGET(icon_data->frame),
-                                prpl_info->icon_spec.max_width,
-                                prpl_info->icon_spec.max_height);
-
-    icon_data->event = gtk_event_box_new();
-    gtk_container_add(GTK_CONTAINER(icon_data->frame), icon_data->event);
-    // g_signal_connect(G_OBJECT(icon_data->event), "button-press-event",
-    // G_CALLBACK(icon_menu), conv);
-    gtk_widget_show(icon_data->event);
-    /* 
-       icon_data->bio_area = gtk_label_new(_(""));
-       gtk_box_pack_start(vbox_big, icon_data->bio_area, TRUE, TRUE, 0);
-       gtk_widget_show(icon_data->bio_area); */
-    g_hash_table_insert(icons, c, icon_data);
-    g_hash_table_insert(popup_rects, gtkchat->list,
-                        g_new0(GdkRectangle, 1));
-    g_hash_table_insert(popup_timeouts, gtkchat->list, g_new0(guint, 1));
-
-    GtkBox *iconbox = (GtkBox *) gtkconv->info->parent;
-    GtkWidget *button = gtk_button_new_with_label("E");
-    gtk_button_set_relief(GTK_BUTTON(button), GTK_RELIEF_NONE);
-    gtk_box_pack_end(iconbox, button, FALSE, FALSE, 0);
-    gtk_widget_show(button);
-    g_signal_connect(G_OBJECT(button), "clicked",
-                     G_CALLBACK(change_sort_order), gtkchat->list);
-    gaim_debug_misc("chatsort", "Connected signal with data %x\n",
-                    gtkchat->list);
-
+    add_chat_sort_functions(c);
+    add_chat_popup_stuff(c);
+    add_chat_icon_stuff(c);
 }
 
 static gboolean plugin_load(GaimPlugin * plugin)
 {
-    icons = g_hash_table_new(g_direct_hash, g_direct_equal);
-    pending_updates = g_hash_table_new(g_direct_hash, g_direct_equal);
-    im_window_bios =
-        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL,
-                              (GDestroyNotify) gtk_widget_destroy);
-    popup_rects =
-        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
-
-    popup_timeouts =
-        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
-
-    popups =
-        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL,
-                              (GDestroyNotify) gtk_widget_destroy);
+    init_chat_icons();
+    init_popups();
+    
     gaim_signal_connect(gaim_conversations_get_handle(), "chat-joined",
                         plugin, GAIM_CALLBACK(redochatwindow), NULL);
+    
     gaim_signal_connect(gaim_conversations_get_handle(),
                         "conversation-created", plugin,
                         GAIM_CALLBACK(redo_im_window), NULL);
+    
     gaim_signal_connect(gaim_accounts_get_handle(), "info-updated", plugin,
-                        GAIM_CALLBACK(update_im_bio), NULL);
+                        GAIM_CALLBACK(update_info_cb), NULL);
+    
     gaim_signal_connect(gaim_conversations_get_handle(),
                         "deleting-conversation", plugin,
                         GAIM_CALLBACK(clean_popup_stuff), NULL);
@@ -986,12 +58,12 @@
     0,
     NULL,
     GAIM_PRIORITY_DEFAULT,
-    CHATSORT_PLUGIN_ID,
+    GAYM_EXTRAS_PLUGIN_ID,
     N_("Gaym Extras"),
     VERSION,
     N_("GUI-related additions for the gaym protocol plugin."),
-    N_("Allow modifications of namelist sorting order in "),
-    "Jason LeBrun <gaim at jasonlebrun.info",
+    N_("Current functionality provided by this plugin:\n1. Allows namelist sort order in rooms to be changed.\n2. Shows thumbnails for currently selected user in rooms.\n3. Popup displays bio when you hover over a name in the namelist.\n4. Popup shows bio when you hover over an IM tab."),
+    "Jason LeBrun gaym at jasonlebrun.info",
     GAIM_WEBSITE,
     plugin_load,
     NULL,

Added: qrc/trunk/gaym-extras/gaym-extras.h
===================================================================
--- qrc/trunk/gaym-extras/gaym-extras.h	2005-07-26 08:10:10 UTC (rev 247)
+++ qrc/trunk/gaym-extras/gaym-extras.h	2005-07-27 07:47:36 UTC (rev 248)
@@ -0,0 +1,72 @@
+#include "internal.h"
+#include "gtkgaim.h"
+
+#include "conversation.h"
+#include "debug.h"
+#include "prefs.h"
+#include "signals.h"
+#include "util.h"
+#include "version.h"
+#include "buddyicon.h"
+#include "prpl.h"
+
+#include "gtkconv.h"
+#include "gtkplugin.h"
+
+#include "../gaym/src/gaym.h"
+struct fetch_thumbnail_data {
+    const char *who;
+    char *pic_data;
+    gint pic_data_len;
+    gboolean from_file;
+};
+
+struct paint_data {
+    char *tooltiptext;
+    const char *name;
+};
+// Additional UI info for a conversation.
+// We may be able to clean this up, some.
+typedef struct _GaymChatIcon {
+
+    GaimConversation *conv;
+    GtkWidget *icon_container_parent;
+    GtkWidget *icon_container;
+    GtkWidget *frame;
+    GtkWidget *icon;
+    GtkWidget *event;
+    gboolean show_icon;
+    GdkPixbufAnimation *anim;
+    GdkPixbufAnimationIter *iter;
+    gboolean animate;
+    guint32 icon_timer;
+    GtkWidget *bio_area;
+
+} GaymChatIcon;
+
+typedef enum {
+    SORT_ALPHA,
+    SORT_ENTRY,
+    SORT_CATEGORY,
+} GaymSortOrder;
+
+typedef enum {
+    TOOLTIP_CHAT,
+    TOOLTIP_IM,
+} GaymTooltipType;
+
+struct timeout_cb_data {
+    GaymTooltipType type;
+    GtkWidget *tv;
+    struct gaym_conn *gaym;
+};
+
+
+
+void clean_popup_stuff(GaimConversation * c);
+void add_chat_icon_stuff(GaimConversation *c);
+void add_chat_popup_stuff(GaimConversation *c);
+void add_chat_sort_functions(GaimConversation *c);
+void add_im_popup_stuff(GaimConversation* c);
+void init_chat_icons();
+void init_popups();

Modified: qrc/trunk/gaym-extras/roombrowse.c
===================================================================
--- qrc/trunk/gaym-extras/roombrowse.c	2005-07-26 08:10:10 UTC (rev 247)
+++ qrc/trunk/gaym-extras/roombrowse.c	2005-07-27 07:47:36 UTC (rev 248)
@@ -422,7 +422,7 @@
     *menu = g_list_append(*menu, act);
     // g_free(label);
 }
-static gboolean plugin_load(GaimPlugin * plugin)
+static gboolean roombrowse_load(GaimPlugin * plugin)
 {
     gaim_signal_connect(gaim_blist_get_handle(),
                         "blist-node-extended-menu",
@@ -434,32 +434,4 @@
     return TRUE;
 }
 
-static GaimPluginInfo info = {
-    GAIM_PLUGIN_MAGIC,
-    GAIM_MAJOR_VERSION,
-    GAIM_MINOR_VERSION,
-    GAIM_PLUGIN_STANDARD,
-    GAIM_GTK_PLUGIN_TYPE,
-    0,
-    NULL,
-    GAIM_PRIORITY_DEFAULT,
-    CHATSORT_PLUGIN_ID,
-    N_("Gay.Com Room Browser"),
-    VERSION,
-    N_("Browse rooms in gay.com"),
-    N_("Adds a right-click item to context menu."),
-    "Jason LeBrun <gaim at jasonlebrun.info",
-    GAIM_WEBSITE,
-    plugin_load,
-    NULL,
-    NULL,
-    NULL,
-    NULL,
-    NULL
-};
 
-static void init_plugin(GaimPlugin * plugin)
-{
-}
-
-GAIM_INIT_PLUGIN(history, init_plugin, info)



From jblebrun at berlios.de  Thu Jul 28 16:31:23 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Thu, 28 Jul 2005 16:31:23 +0200
Subject: [Qrc-svn] r249 - in qrc/trunk: gaym/src gaym-extras
Message-ID: <200507281431.j6SEVNUW020160@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-28 16:31:20 +0200 (Thu, 28 Jul 2005)
New Revision: 249

Modified:
   qrc/trunk/gaym-extras/bio-popups.c
   qrc/trunk/gaym-extras/chaticon.c
   qrc/trunk/gaym-extras/chatsort.c
   qrc/trunk/gaym-extras/gaym-extras.c
   qrc/trunk/gaym-extras/roombrowse.c
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gaym.h
   qrc/trunk/gaym/src/weblogin.c
Log:
*Lots of bugfixes!
*Chat icons in popups, if they've been cached in a file already.
*Fixed cookie code so gay.com lets us login again.
*Applied indent to everything


We need a new numbering system. How about this is release 0.9?
Still on the table before a release:
*Fix hammer code.
*Finish thumbnail caching system (it's never cleaned at ALL, once you get an icon, that's what you'll see forever).
*Have popups trigger thumbnail fetches
*Have popups update when thumbnails arrive
*Windows build? Anyone want to test this? It builds... need some dll guinea pigs. See README.mingw for details.

Longer term goals (release 1.0
*Completely redone info window
*Floating info window
*Caching of things like your thumbnail and config.txt, so we can login super fast.
*Roombrowser (see who is in a room without entering... super /names)




Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-27 07:47:36 UTC (rev 248)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-28 14:31:20 UTC (rev 249)
@@ -1119,11 +1119,11 @@
 
 static guint gaym_nick_hash(const char *nick)
 {
-    char *lc=NULL;
+    char *lc = NULL;
     guint bucket;
-    
-    if(!nick)
-	return 0;
+
+    if (!nick)
+        return 0;
     lc = g_utf8_strdown(nick, -1);
     bucket = g_str_hash(lc);
     g_free(lc);
@@ -1360,7 +1360,7 @@
     NULL,                       /* normalize */
     NULL,                       /* set_buddy_icon */
     NULL,                       /* remove_group */
-    NULL,		       /* get_cb_real_name */
+    NULL,                       /* get_cb_real_name */
     NULL,                       /* set_chat_topic */
     gaym_find_blist_chat,       /* find_blist_chat */
     gaym_roomlist_get_list,     /* roomlist_get_list */

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-27 07:47:36 UTC (rev 248)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-28 14:31:20 UTC (rev 249)
@@ -54,7 +54,7 @@
 
 enum { IRC_USEROPT_SERVER, IRC_USEROPT_PORT, IRC_USEROPT_CHARSET };
 enum gaym_state { IRC_STATE_NEW, IRC_STATE_ESTABLISHED };
-enum info_string {INFO_AGE, INFO_LOCATION, INFO_BIO, INFO_URL};
+enum info_string { INFO_AGE, INFO_LOCATION, INFO_BIO, INFO_URL };
 
 struct gaym_conn {
     GaimAccount *account;
@@ -103,7 +103,8 @@
 
 typedef struct {
 
-    char *cookies;
+    gchar *cookies;
+    GHashTable *cookie_table;
     void (*session_cb) (GaimAccount *);
     GaimAccount *account;
     char *username;

Modified: qrc/trunk/gaym/src/weblogin.c
===================================================================
--- qrc/trunk/gaym/src/weblogin.c	2005-07-27 07:47:36 UTC (rev 248)
+++ qrc/trunk/gaym/src/weblogin.c	2005-07-28 14:31:20 UTC (rev 249)
@@ -30,6 +30,7 @@
 
 #include "gaym.h"
 
+#include "helpers.h"
 
 typedef struct {
     void (*callback) (void *, const char *, size_t);
@@ -197,81 +198,48 @@
 
 // This looks for Set-cookie: fields in headers, and adds those cookies
 // To the session struct.
+static void add_cookie(gpointer key, gpointer value, gpointer data)
+{
+    g_return_if_fail(key != NULL);
+    g_return_if_fail(value != NULL);
+    g_return_if_fail(data != NULL);
+    GaimUrlSession *session = (GaimUrlSession *) data;
+    gchar *cookies = session->cookies;
+    session->cookies =
+        g_strconcat(cookies ? cookies : "", key, "=", value, "; ", NULL);
+    g_free(cookies);
 
-// TODO If a cookie value is re-set, then it will be duplicated, since
-// Set-Cookie
-// field is just appended to already existing cookies. This is not an
-// issue for
-// the current gay.com implementation, but this should be changed, so that
-// receiving a duplicate cookie *updates* the existing value.
-// JBL 10-16-2004
+}
 static void parse_cookies(const char *webdata, GaimUrlSession * session,
                           size_t len)
 {
-
-
-    char *haystack = g_malloc0(len * sizeof(char));
-    size_t cookie_size;
-    strncpy(haystack, webdata, len);
-    char *next_token = haystack;
-    char *end_token;
-    char *new_cookie;
-
-    const char *match = "Set-cookie: ";
-    while ((next_token = strstr(next_token, match))) {
-
-        next_token += strlen(match);    // We don't want the "Set-cookie:
-        // " part!
-        end_token = strstr(next_token, "\r\n");
-
-        if (!end_token)
-            continue;
-        else {
-
-            cookie_size = end_token - next_token;
-
-            if (session->cookies)
-                new_cookie =
-                    g_strdup_printf("%s; %.*s", session->cookies,
-                                    cookie_size, next_token);
-            else
-                // FIXME: I think there is a function for resizing the
-                // memory
-                // which is more efficient then a allocation and freeing.
-                new_cookie =
-                    g_strdup_printf("%.*s", cookie_size, next_token);
-            if (new_cookie) {
-                g_free(session->cookies);       // g_strdup makes
-                // allocates memory, so
-                // get rid of the old
-                // stuff.
-                session->cookies = new_cookie;
-            }
-
-
-
+    gchar **cookies = g_strsplit(webdata, "\n", -1);
+    gchar **cookie_parts;
+    char *cookie;
+    int index = 0;
+    while (cookies[index]) {
+        cookie =
+            return_string_between("Set-cookie: ", "; ", cookies[index]);
+        if (cookie) {
+            cookie_parts = g_strsplit(cookie, "=", 2);
+            if (cookie_parts[0] && cookie_parts[1])
+                g_hash_table_replace(session->cookie_table,
+                                     cookie_parts[0], cookie_parts[1]);
         }
-
+        g_free(cookie);
+        index++;
     }
+    g_strfreev(cookies);
+    g_hash_table_foreach(session->cookie_table, (GHFunc) add_cookie,
+                         session);
+
 }
 
 
-// This is a modified version of gaim's url_fetched_cb function. It has
-// been
-// modified to pass cookies during requests. The cookies are set in
-// user_data,
-// cast as a GaimUrlSession item. Any cookies in the response are added to 
-// 
-// 
-// 
-// 
-// 
-// 
-// 
-// 
-// 
-// this
-// structure, as well.
+/* This is a modified version of gaim's url_fetched_cb function. It has
+   been modified to pass cookies during requests. The cookies are set in
+   user_data, cast as a GaimUrlSession item. Any cookies in the response
+   are added to this structure, as well. */
 static void
 session_fetched_cb(gpointer url_data, gint sock, GaimInputCondition cond)
 {
@@ -299,36 +267,17 @@
                transfer encoding. Gaim doesn't know how to handle
                "chunked", so should always send the Host header
                regardless, to get around some observed problems */
-            g_snprintf(buf, sizeof(buf), "GET %s%s HTTP/%s\r\n" "User-Agent: %s\r\n" "Host: %s\r\n" "Cookie: %s\r\n",   // (1) 
-                                                                                                                        // 
-                       // 
-                       // 
-                       // 
-                       // 
-                       // 
-                       // 
-                       // 
-                       // 
-                       // (see 
-                       // above)
+            g_snprintf(buf, sizeof(buf),
+                       "GET %s%s HTTP/%s\r\n" "User-Agent: %s\r\n"
+                       "Host: %s\r\n" "Cookie: %s\r\n",
                        (gfud->full ? "" : "/"),
                        (gfud->full ? gfud->url : gfud->website.page),
-                       (gfud->http11 ? "1.1" : "1.0"),
-                       gfud->user_agent, gfud->website.address,
-                       gfud->session->cookies);
+                       (gfud->http11 ? "1.1" : "1.0"), gfud->user_agent,
+                       gfud->website.address, gfud->session->cookies);
         } else {
-            g_snprintf(buf, sizeof(buf), "GET %s%s HTTP/%s\r\n" "Host: %s\r\n" "Accept-Encoding: identity\r\n" "Cookie: %s\r\n",        // (1) 
-                                                                                                                                        // 
-                       // 
-                       // 
-                       // 
-                       // 
-                       // 
-                       // 
-                       // 
-                       // 
-                       // See 
-                       // above
+            g_snprintf(buf, sizeof(buf),
+                       "GET %s%s HTTP/%s\r\n" "Host: %s\r\n"
+                       "Accept-Encoding: identity\r\n" "Cookie: %s\r\n",
                        (gfud->full ? "" : "/"),
                        (gfud->full ? gfud->url : gfud->website.page),
                        (gfud->http11 ? "1.1" : "1.0"),
@@ -383,15 +332,9 @@
                                     gfud->len, gfud->len, gfud->webdata);
 
                     // JBL 10-16-2004: Put cookies into session
-                    gaim_debug(GAIM_DEBUG_MISC, "gaym",
-                               "Parsing cookies...");
 
                     parse_cookies(gfud->webdata, gfud->session, gfud->len);
-                    gaim_debug(GAIM_DEBUG_MISC, "gaym",
-                               "Found cookies: %s\n",
-                               (gfud->session->cookies));
-                    gaim_debug_misc("gaim_url_fetch",
-                                    "Parsing of cookies successful\n");
+
                     /* See if we can find a redirect. */
                     if (parse_redirect
                         (gfud->webdata, gfud->len, sock, gfud))
@@ -451,9 +394,6 @@
         gfud->webdata = g_realloc(gfud->webdata, gfud->len + 1);
         gfud->webdata[gfud->len] = 0;
 
-        /* gaim_debug_misc("gaim_url_fetch", "Received: '%s'\n",
-           gfud->webdata); */
-
         gaim_input_remove(gfud->inpa);
         close(sock);
         gfud->callback(gfud->user_data, gfud->webdata, gfud->len);
@@ -510,7 +450,6 @@
     struct gaym_conn *gaym = session->gaym;
     // Get hash from text
     if (session && GAIM_CONNECTION_IS_VALID(session->account->gc)) {
-        // char *chat_key;
         char *bio;
         char *thumbnail;
         char *temp = NULL;
@@ -581,7 +520,7 @@
             // gaim_connection_error(
             // gaim_account_get_connection(((struct
             // gaym_conn*)((GaimUrlSession*)session)->account),
-            // _("Problem parsing password from web. Report a bug."));
+            // _("Problem parsing password from web. Report a bug.")));
         }
         session->session_cb(gaym->account);
 
@@ -610,7 +549,7 @@
         int nonce;
         char *buf = g_strdup_printf(_("Signon: %s"),
                                     (session->account->username));
-        gaim_connection_update_progress(session->account->gc, buf, 5, 6);
+        gaim_connection_update_progress(session->account->gc, buf, 3, 6);
         sscanf(text, "?rand=%d", &nonce);
         snprintf(url, 512,
                  "http://www.gay.com/messenger/applet.html?rand=%d",
@@ -628,75 +567,6 @@
     }
 }
 
-
-static void
-gaym_weblogin_step3(gpointer data, const char *text, size_t len)
-{
-
-
-
-
-    GaimUrlSession *session = (GaimUrlSession *) data;
-
-    gaim_debug_misc("gaym", "Step 3: session: %x\n", session);
-    if (session && GAIM_CONNECTION_IS_VALID(session->account->gc)) {
-        if (!strstr(session->cookies, "MEMBERX")) {
-            gaim_connection_error((session->account->gc),
-                                  _
-                                  ("Problem during login. Are you sure your password is correct?"));
-            return;
-        }
-        // The third step is to get a nonce needed for getting the applet.
-        // We connect to messenger/frameset.html, using previously set
-        // cookie values.
-        // From the returned body, we will need to parse out the rand
-        // values.
-        char *url = "http://www.gay.com/messenger/frameset.html";
-        char *buf = g_strdup_printf(_("Signon: %s"),
-                                    (session->account->username));
-        gaim_connection_update_progress(session->account->gc, buf, 4, 6);
-        session->hasFormData = FALSE;
-        gaim_session_fetch(url, FALSE, NULL, FALSE, gaym_weblogin_step4,
-                           session, session);
-    } else {
-
-        gaim_debug_misc("gaym", "Connection was cancelled before step3\n");
-        gaim_debug_misc("gaym", "session: %x\n", session);
-        gaym_session_destroy(session);
-        // g_free(gaym->session);
-
-    }
-}
-static void
-gaym_weblogin_step2(gpointer data, const char *text, size_t len)
-{
-
-
-    GaimUrlSession *session = (GaimUrlSession *) data;
-    if (session && GAIM_CONNECTION_IS_VALID(session->account->gc)) {
-        gaim_debug_misc("gaym", "Step 2: connection is valid.\n");
-        // The second step is to do the actual login.
-        // We connect to misc/dologin.html, using cookies set from step 1
-        // And add a few more cookie values.
-        char url[1024];
-        char *buf = g_strdup_printf(_("Signon: %s"),
-                                    session->account->username);
-        gaim_connection_update_progress(session->account->gc, buf, 3, 6);
-
-        snprintf(url, 1024,
-                 "http://www.gay.com/misc/dologin.html?__login_haveForm=1&__login_save=1&__login_member=%s&redir=%%2Findex.html&__login_basepage=%%2Fmisc%%2Fdologin.html&__login_password=%s",
-                 session->username, session->password);
-
-        session->hasFormData = TRUE;
-        gaim_session_fetch(url, FALSE, NULL, FALSE, gaym_weblogin_step3,
-                           session, session);
-    } else {
-        gaim_debug_misc("gaym", "Connection was cancelled before step2\n");
-        gaim_debug_misc("gaym", "session: %x\n", session);
-        gaym_session_destroy(session);
-        // g_free(gaym->session);
-    }
-}
 void
 gaym_get_chat_key_from_weblogin(GaimAccount * account,
                                 void (*callback) (GaimAccount * account))
@@ -705,13 +575,6 @@
     struct gaym_conn *gaym = account->gc->proto_data;
     if (GAIM_CONNECTION_IS_VALID(account->gc)) {
 
-        // FIXME: By passing struct gaym_conn around through the 
-        // callbacks, instead of a GaimAccount struct, we will
-        // lose the information needed to free this session if 
-        // conncetion is cancelled. This needs to be modified
-        // to make sure that the GaimUrlSession *session memory
-        // is not leaked!
-
         GaimUrlSession *session = g_new0(GaimUrlSession, 1);
         session->session_cb = callback;
         session->cookies = NULL;
@@ -719,8 +582,9 @@
         session->username = g_strdup(account->username);
         session->password = g_strdup(account->password);
         session->gaym = gaym;
+        session->cookie_table =
+            g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
 
-
         gaim_debug_misc("gaym", "Made session: %x\n", session);
         if (GAIM_CONNECTION_IS_VALID
             (((GaimUrlSession *) session)->account->gc)) {
@@ -733,15 +597,7 @@
 
             session->hasFormData = TRUE;
             gaim_session_fetch(url, FALSE, NULL, FALSE,
-                               gaym_weblogin_step3, session, session);
-
-            /* char *url = "http://www.gay.com/index.html"; char *buf =
-               g_strdup_printf(_("Signon: %s"), ((GaimUrlSession *)
-               session)-> account->username);
-               gaim_connection_update_progress(((GaimUrlSession *)
-               session)-> account->gc, buf, 2, 6); session->hasFormData =
-               FALSE; gaim_session_fetch(url, FALSE, NULL, FALSE,
-               gaym_weblogin_step3, session, session); */
+                               gaym_weblogin_step4, session, session);
         } else {
             gaim_debug_misc("gaym", "cancelled before step1\n");
             gaim_debug_misc("gaym", "gaym->sessoin: %x\n", session);

Modified: qrc/trunk/gaym-extras/bio-popups.c
===================================================================
--- qrc/trunk/gaym-extras/bio-popups.c	2005-07-27 07:47:36 UTC (rev 248)
+++ qrc/trunk/gaym-extras/bio-popups.c	2005-07-28 14:31:20 UTC (rev 249)
@@ -19,12 +19,13 @@
 
 }
 
-static void namelist_leave_cb(GtkWidget * tv, GdkEventCrossing * e, gpointer n)
+static void namelist_leave_cb(GtkWidget * tv, GdkEventCrossing * e,
+                              gpointer n)
 {
-    //This prevent clicks from demloishing popups.
-    if(e->mode != GDK_CROSSING_NORMAL)
-	return;
-    
+    // This prevent clicks from demloishing popups.
+    if (e->mode != GDK_CROSSING_NORMAL)
+        return;
+
     guint *timeout = g_hash_table_lookup(popup_timeouts, tv);
     g_hash_table_remove(popups, tv);
 
@@ -34,20 +35,21 @@
     }
 }
 
-static void namelist_paint_tip(GtkWidget * tipwindow, GdkEventExpose * event, gpointer data)
+static void namelist_paint_tip(GtkWidget * tipwindow,
+                               GdkEventExpose * event, gpointer data)
 {
-    char* tooltiptext=((struct paint_data*)data)->tooltiptext;
-    const char* name=((struct paint_data*)data)->name;
+    char *tooltiptext = ((struct paint_data *) data)->tooltiptext;
+    const char *name = ((struct paint_data *) data)->name;
     GtkStyle *style;
-    char* filename=g_strdup_printf("%s.jpg",name);
-    char* path = g_build_filename(gaim_user_dir(), "icons", "gaym", filename, NULL);
-    gaim_debug_misc("popups","trying to load image %s\n",path);
-    GError* err=NULL;
-    GdkPixbuf* pixbuf = gdk_pixbuf_new_from_file(path, &err);	
-    if(err)
-    {
-	gaim_debug_error("popups","Pixbuf error: %s\n",err->message);
-	g_error_free(err);
+    char *filename = g_strdup_printf("%s.jpg", name);
+    char *path =
+        g_build_filename(gaim_user_dir(), "icons", "gaym", filename, NULL);
+    gaim_debug_misc("popups", "trying to load image %s\n", path);
+    GError *err = NULL;
+    GdkPixbuf *pixbuf = gdk_pixbuf_new_from_file(path, &err);
+    if (err) {
+        gaim_debug_error("popups", "Pixbuf error: %s\n", err->message);
+        g_error_free(err);
     }
     g_free(filename);
     g_free(path);
@@ -66,18 +68,19 @@
                        -1, -1);
 
 #if GTK_CHECK_VERSION(2,2,0)
-     gdk_draw_pixbuf(GDK_DRAWABLE(tipwindow->window), NULL, pixbuf,
-     0, 0, 4, 4, -1, -1, GDK_RGB_DITHER_NONE, 0, 0);
+    gdk_draw_pixbuf(GDK_DRAWABLE(tipwindow->window), NULL, pixbuf,
+                    0, 0, 4, 4, -1, -1, GDK_RGB_DITHER_NONE, 0, 0);
 #else
-     gdk_pixbuf_render_to_drawable(pixbuf,
-     GDK_DRAWABLE(tipwindow->window), NULL, 0, 0, 4, 4, -1, -1,
-     GDK_RGB_DITHER_NONE, 0, 0);
+    gdk_pixbuf_render_to_drawable(pixbuf,
+                                  GDK_DRAWABLE(tipwindow->window), NULL, 0,
+                                  0, 4, 4, -1, -1, GDK_RGB_DITHER_NONE, 0,
+                                  0);
 #endif
 
     gtk_paint_layout(style, tipwindow->window, GTK_STATE_NORMAL, TRUE,
-                     NULL, tipwindow, "tooltip", 57, 4, layout);
+                     NULL, tipwindow, "tooltip", 65, 4, layout);
 
-    g_object_unref (pixbuf);
+    g_object_unref(pixbuf);
     g_object_unref(layout);
     g_free(tooltiptext);
     g_free(data);
@@ -100,12 +103,14 @@
     guint *timeout;
     GtkWidget *tipwindow;
     GtkWidget *tv = data->tv;
-    
+
     GaymTooltipType type = data->type;
     struct gaym_conn *gaym = data->gaym;
     g_free(data);
     GaimPluginProtocolInfo *prpl_info =
-        GAIM_PLUGIN_PROTOCOL_INFO(gaim_find_prpl (gaim_account_get_protocol_id (gaym->account)));
+        GAIM_PLUGIN_PROTOCOL_INFO(gaim_find_prpl
+                                  (gaim_account_get_protocol_id
+                                   (gaym->account)));
 
     timeout = (guint *) g_hash_table_lookup(popup_timeouts, tv);
     /* we check to see if we're still supposed to be moving, now that gtk
@@ -158,8 +163,7 @@
     g_return_val_if_fail(tooltiptext != NULL, FALSE);
 
     tipwindow = g_hash_table_lookup(popups, tv);
-    if (tipwindow)
-    {
+    if (tipwindow) {
         g_hash_table_remove(popups, tv);
     }
     tipwindow = gtk_window_new(GTK_WINDOW_POPUP);
@@ -168,10 +172,10 @@
     gtk_widget_set_app_paintable(tipwindow, TRUE);
     gtk_window_set_resizable(GTK_WINDOW(tipwindow), FALSE);
     gtk_widget_set_name(tipwindow, "gtk-tooltips");
-    
-    struct paint_data* pdata=g_new0(struct paint_data,1);
-    pdata->tooltiptext=tooltiptext;
-    pdata->name=name;
+
+    struct paint_data *pdata = g_new0(struct paint_data, 1);
+    pdata->tooltiptext = tooltiptext;
+    pdata->name = name;
     g_signal_connect(G_OBJECT(tipwindow), "expose_event",
                      G_CALLBACK(namelist_paint_tip), pdata);
     gtk_widget_ensure_style(tipwindow);
@@ -203,8 +207,8 @@
 
     /* 57 is the size of a large status icon plus 4 pixels padding on each 
        side.  I should #define this or something */
-    w = w + 57;
-    h = MAX(h, 57);
+    w = w + 65;
+    h = MAX(h, 65);
 
 #if GTK_CHECK_VERSION(2,2,0)
     if (w > mon_size.width)
@@ -248,7 +252,8 @@
 }
 
 
-static gboolean namelist_motion_cb(GtkWidget * tv, GdkEventMotion * event, gpointer gaym)
+static gboolean namelist_motion_cb(GtkWidget * tv, GdkEventMotion * event,
+                                   gpointer gaym)
 {
     GtkTreeModel *ls = NULL;
     GtkTreePath *path = NULL;
@@ -275,15 +280,15 @@
             return FALSE;
         /* We've left the cell.  Remove the timeout and create a new one
            below */
-	
+
         g_hash_table_remove(popups, tv);
         g_source_remove(*timeout);
     }
 
     gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(tv), event->x, event->y,
                                   &path, NULL, NULL, NULL);
-    if(G_UNLIKELY(path == NULL))
-	return FALSE;
+    if (G_UNLIKELY(path == NULL))
+        return FALSE;
     struct timeout_cb_data *timeout_data =
         g_new0(struct timeout_cb_data, 1);
     timeout_data->tv = tv;
@@ -302,11 +307,12 @@
     return TRUE;
 }
 
-static void tab_leave_cb(GtkWidget * event, GdkEventCrossing * e, gpointer n)
+static void tab_leave_cb(GtkWidget * event, GdkEventCrossing * e,
+                         gpointer n)
 {
-    //Prevent clicks from demolishing popup.
-    if(e->mode != GDK_CROSSING_NORMAL)
-	return;
+    // Prevent clicks from demolishing popup.
+    if (e->mode != GDK_CROSSING_NORMAL)
+        return;
     GtkWidget *tab = gtk_bin_get_child(GTK_BIN(event));
     guint *timeout = g_hash_table_lookup(popup_timeouts, tab);
     g_hash_table_remove(popups, tab);
@@ -319,7 +325,8 @@
 }
 
 
-static gboolean tab_entry_cb(GtkWidget * event, GdkEventCrossing * crossing, gpointer conv)
+static gboolean tab_entry_cb(GtkWidget * event,
+                             GdkEventCrossing * crossing, gpointer conv)
 {
 
     guint *timeout;
@@ -354,15 +361,15 @@
     return TRUE;
 }
 
-void add_chat_popup_stuff(GaimConversation* c) {
-    
+void add_chat_popup_stuff(GaimConversation * c)
+{
+
     GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
     GaimGtkChatPane *gtkchat = gtkconv->u.chat;
     GaimConnection *gc = gaim_conversation_get_gc(c);
-    
+
     g_signal_connect(G_OBJECT(gtkchat->list), "motion-notify-event",
-                     G_CALLBACK(namelist_motion_cb),
-                     gc->proto_data);
+                     G_CALLBACK(namelist_motion_cb), gc->proto_data);
     g_signal_connect(G_OBJECT(gtkchat->list), "leave-notify-event",
                      G_CALLBACK(namelist_leave_cb), NULL);
 
@@ -373,28 +380,40 @@
 
 
 }
-void add_im_popup_stuff(GaimConversation* c) {
-	GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-        GtkWidget *event = gtk_event_box_new();
-        gtk_widget_ref(gtkconv->tab_label);
-        gtk_container_remove(GTK_CONTAINER(gtkconv->tabby), GTK_WIDGET(gtkconv->tab_label));
-        gtk_widget_add_events(event, GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK);
-        g_signal_connect(G_OBJECT(event), "enter-notify-event", G_CALLBACK(tab_entry_cb), c);
-        g_signal_connect(G_OBJECT(event), "leave-notify-event", G_CALLBACK(tab_leave_cb), c);
-        gtk_box_pack_start(GTK_BOX(gtkconv->tabby), GTK_WIDGET(event), TRUE, TRUE, 0);
-        gtk_widget_show(GTK_WIDGET(event));
-        gtk_container_add(GTK_CONTAINER(event), GTK_WIDGET(gtkconv->tab_label));
-        gtk_widget_unref(gtkconv->tab_label);
-        gtk_widget_show(GTK_WIDGET(gtkconv->tab_label));
-        g_hash_table_insert(popup_timeouts, gtkconv->tab_label, g_new0(guint, 1));
+
+void add_im_popup_stuff(GaimConversation * c)
+{
+    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
+    GtkWidget *event = gtk_event_box_new();
+    gtk_widget_ref(gtkconv->tab_label);
+    gtk_container_remove(GTK_CONTAINER(gtkconv->tabby),
+                         GTK_WIDGET(gtkconv->tab_label));
+    gtk_widget_add_events(event,
+                          GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK);
+    g_signal_connect(G_OBJECT(event), "enter-notify-event",
+                     G_CALLBACK(tab_entry_cb), c);
+    g_signal_connect(G_OBJECT(event), "leave-notify-event",
+                     G_CALLBACK(tab_leave_cb), c);
+    gtk_box_pack_start(GTK_BOX(gtkconv->tabby), GTK_WIDGET(event), TRUE,
+                       TRUE, 0);
+    gtk_widget_show(GTK_WIDGET(event));
+    gtk_container_add(GTK_CONTAINER(event),
+                      GTK_WIDGET(gtkconv->tab_label));
+    gtk_widget_unref(gtkconv->tab_label);
+    gtk_widget_show(GTK_WIDGET(gtkconv->tab_label));
+    g_hash_table_insert(popup_timeouts, gtkconv->tab_label,
+                        g_new0(guint, 1));
 }
 
-void init_popups(){
-    popup_rects = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
+void init_popups()
+{
+    popup_rects =
+        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
 
-    popup_timeouts = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
+    popup_timeouts =
+        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
 
-    popups = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, (GDestroyNotify) gtk_widget_destroy);
+    popups =
+        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL,
+                              (GDestroyNotify) gtk_widget_destroy);
 }
-
-

Modified: qrc/trunk/gaym-extras/chaticon.c
===================================================================
--- qrc/trunk/gaym-extras/chaticon.c	2005-07-27 07:47:36 UTC (rev 248)
+++ qrc/trunk/gaym-extras/chaticon.c	2005-07-28 14:31:20 UTC (rev 249)
@@ -153,7 +153,8 @@
 
     icon_data->event = gtk_event_box_new();
     gtk_container_add(GTK_CONTAINER(icon_data->frame), icon_data->event);
-    gtk_widget_set_size_request(GTK_WIDGET(icon_data->frame), scale_width, scale_height);
+    gtk_widget_set_size_request(GTK_WIDGET(icon_data->frame), scale_width,
+                                scale_height);
 
     // g_signal_connect(G_OBJECT(icon_data->event), "button-press-event",
     // G_CALLBACK(icon_menu), conv);
@@ -182,7 +183,8 @@
 
     struct fetch_thumbnail_data *d = (struct fetch_thumbnail_data *) data;
 
-    gaim_debug_misc("chaticon","Check for update: %x %s %s %i\n",c,name,d->who, d->pic_data_len);
+    gaim_debug_misc("chaticon", "Check for update: %x %s %s %i\n", c, name,
+                    d->who, d->pic_data_len);
     g_return_val_if_fail(name_needing_update != NULL, FALSE);
 
     if (!strcmp(d->who, name_needing_update)) {
@@ -201,32 +203,31 @@
         return;
     }
     if (len && !g_strrstr_len(pic_data, len, "Server Error")) {
-	char* dir;	
-	if ((!d->from_file) && (dir = g_build_filename(gaim_user_dir(), "icons", "gaym", NULL) != NULL)) {
-	    d->pic_data = pic_data;
-	    d->pic_data_len = len;
-	    gaim_build_dir(dir, S_IRUSR | S_IWUSR | S_IXUSR);
-	    char* filename = g_strdup_printf("%s.jpg",d->who);
-	    char* path = g_build_filename(dir, filename, NULL);
-	    FILE* file;
-	    if ((file = g_fopen(path, "wb")))
-	    {
-		fwrite(pic_data, 1, len, file);
-	        fclose(file);
-	    }
-	    else
-	    {
-		gaim_debug_misc("chaticon","Couldn't write file\n");
-	    }
-	    g_free(filename);
-	    g_free(path);
-	    g_free(dir);
-	}
+        char *dir;
+        if ((dir =
+             g_build_filename(gaim_user_dir(), "icons", "gaym",
+                              NULL)) != NULL) {
+            d->pic_data = pic_data;
+            d->pic_data_len = len;
+            gaim_build_dir(dir, S_IRUSR | S_IWUSR | S_IXUSR);
+            char *filename = g_strdup_printf("%s.jpg", d->who);
+            char *path = g_build_filename(dir, filename, NULL);
+            FILE *file;
+            if ((file = g_fopen(path, "wb"))) {
+                fwrite(pic_data, 1, len, file);
+                fclose(file);
+            } else {
+                gaim_debug_misc("chaticon", "Couldn't write file\n");
+            }
+            g_free(filename);
+            g_free(path);
+            g_free(dir);
+        }
     } else {
         d->pic_data = 0;
         d->pic_data_len = 0;
     }
-     
+
     g_hash_table_foreach_remove(pending_updates,
                                 (GHRFunc) check_for_update, d);
     g_free(d);
@@ -257,44 +258,44 @@
     if (icon_data->event != NULL)
         gtk_widget_destroy(icon_data->event);
     icon_data->event = NULL;
-    
-    
-    char* dir = g_build_filename(gaim_user_dir(), "icons", "gaym", NULL);
-    char* filename = g_strdup_printf("%s.jpg",name);
-    char* path=NULL;
-    FILE* file;
+
+
+    char *dir = g_build_filename(gaim_user_dir(), "icons", "gaym", NULL);
+    char *filename = g_strdup_printf("%s.jpg", name);
+    char *path = NULL;
+    FILE *file;
     struct stat st;
-    struct fetch_thumbnail_data *data=g_new0(struct fetch_thumbnail_data,1);
-    
-    if ((dir != NULL) && (filename != NULL) && (path = g_build_filename(dir, filename, NULL)));
-    {
-	if (!g_stat(path, &st) && (file = g_fopen(path, "rb")))
-	{
-	    data->pic_data = g_malloc(st.st_size);
-	    data->who=name;
-	    data->pic_data_len = st.st_size;
-	    data->from_file = TRUE;
-	    fread(data->pic_data, 1, st.st_size, file);
-	    fclose(file);
-	}
-	g_free(dir);
-	g_free(filename);
-	g_free(path);
-	g_hash_table_replace(pending_updates, c, name);
-	fetch_thumbnail_cb(data, data->pic_data, data->pic_data_len);
-	return;
+    struct fetch_thumbnail_data *data =
+        g_new0(struct fetch_thumbnail_data, 1);
+    path = g_build_filename(dir, filename, NULL);
+    if (path && !g_stat(path, &st)) {
+        if (file = g_fopen(path, "rb")) {
+            data->pic_data = g_malloc(st.st_size);
+            data->who = name;
+            data->pic_data_len = st.st_size;
+            data->from_file = TRUE;
+            fread(data->pic_data, 1, st.st_size, file);
+            fclose(file);
+        }
+        g_free(dir);
+        g_free(filename);
+        g_free(path);
+
+        gaym_gtkconv_update_thumbnail(c, data);
+        fetch_thumbnail_cb(data, data->pic_data, data->pic_data_len);
+        return;
     }
     // Get GaymBuddy struct for the thumbnail URL.
     cm = g_hash_table_lookup(gaym->channel_members, name);
-    if(!cm)
-	return;
+    if (!cm)
+        return;
 
-    
+
     // Fetch thumbnail.
 
     char *hashurl = g_hash_table_lookup(gaym->confighash,
                                         "mini-profile-panel.thumbnail-prefix");
-   
+
     data = g_new0(struct fetch_thumbnail_data, 1);
     data->who = name;
     data->from_file = FALSE;
@@ -306,10 +307,12 @@
     g_hash_table_replace(pending_updates, c, name);
 
 }
-void add_chat_icon_stuff(GaimConversation *c) {
-    
+
+void add_chat_icon_stuff(GaimConversation * c)
+{
+
     GtkTreeModel *ls;
-    
+
     GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
     GaimGtkChatPane *gtkchat = gtkconv->u.chat;
     GaimPluginProtocolInfo *prpl_info = NULL;
@@ -320,7 +323,7 @@
         prpl_info = GAIM_PLUGIN_PROTOCOL_INFO(account->gc->prpl);
     GtkTreeSelection *select =
         gtk_tree_view_get_selection(GTK_TREE_VIEW(gtkchat->list));
-    
+
     gtk_tree_selection_set_mode(select, GTK_SELECTION_SINGLE);
 
     ls = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
@@ -337,7 +340,7 @@
     icon_data->iter = NULL;
     icon_data->show_icon = TRUE;
     icon_data->icon_container = gtk_vbox_new(FALSE, 0);
-    
+
     gtk_widget_set_size_request(GTK_WIDGET(icon_data->icon_container),
                                 prpl_info->icon_spec.max_width,
                                 prpl_info->icon_spec.max_height);
@@ -352,7 +355,7 @@
     gtk_widget_show(icon_data->frame);
     gtk_box_pack_end(GTK_BOX(icon_data->icon_container_parent),
                      icon_data->icon_container, FALSE, FALSE, 0);
-    
+
     icon_data->event = gtk_event_box_new();
     gtk_container_add(GTK_CONTAINER(icon_data->frame), icon_data->event);
 
@@ -364,8 +367,10 @@
 
 
 }
-void init_chat_icons() {
 
+void init_chat_icons()
+{
+
     icons = g_hash_table_new(g_direct_hash, g_direct_equal);
     pending_updates = g_hash_table_new(g_direct_hash, g_direct_equal);
 }

Modified: qrc/trunk/gaym-extras/chatsort.c
===================================================================
--- qrc/trunk/gaym-extras/chatsort.c	2005-07-27 07:47:36 UTC (rev 248)
+++ qrc/trunk/gaym-extras/chatsort.c	2005-07-28 14:31:20 UTC (rev 249)
@@ -122,11 +122,12 @@
     }
 
 }
-void add_chat_sort_functions(GaimConversation* c) {
-     
+void add_chat_sort_functions(GaimConversation * c)
+{
+
     GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
     GaimGtkChatPane *gtkchat = gtkconv->u.chat;
-    
+
     GtkBox *iconbox = (GtkBox *) gtkconv->info->parent;
     GtkWidget *button = gtk_button_new_with_label("E");
     gtk_button_set_relief(GTK_BUTTON(button), GTK_RELIEF_NONE);

Modified: qrc/trunk/gaym-extras/gaym-extras.c
===================================================================
--- qrc/trunk/gaym-extras/gaym-extras.c	2005-07-27 07:47:36 UTC (rev 248)
+++ qrc/trunk/gaym-extras/gaym-extras.c	2005-07-28 14:31:20 UTC (rev 249)
@@ -8,16 +8,17 @@
 
 
 
-//Adds motion handlers to IM tab labels.
+// Adds motion handlers to IM tab labels.
 static void redo_im_window(GaimConversation * c)
 {
-    if (c && c->type == GAIM_CONV_IM) 
-	add_im_popup_stuff(c);
+    if (c && c->type == GAIM_CONV_IM)
+        add_im_popup_stuff(c);
 }
 
 
-static void update_info_cb(GaimAccount* account, char* name) {
-    gaim_debug_misc("gaym-extras","info update\n");
+static void update_info_cb(GaimAccount * account, char *name)
+{
+    gaim_debug_misc("gaym-extras", "info update\n");
 }
 
 static void redochatwindow(GaimConversation * c)
@@ -31,17 +32,17 @@
 {
     init_chat_icons();
     init_popups();
-    
+
     gaim_signal_connect(gaim_conversations_get_handle(), "chat-joined",
                         plugin, GAIM_CALLBACK(redochatwindow), NULL);
-    
+
     gaim_signal_connect(gaim_conversations_get_handle(),
                         "conversation-created", plugin,
                         GAIM_CALLBACK(redo_im_window), NULL);
-    
+
     gaim_signal_connect(gaim_accounts_get_handle(), "info-updated", plugin,
                         GAIM_CALLBACK(update_info_cb), NULL);
-    
+
     gaim_signal_connect(gaim_conversations_get_handle(),
                         "deleting-conversation", plugin,
                         GAIM_CALLBACK(clean_popup_stuff), NULL);

Modified: qrc/trunk/gaym-extras/roombrowse.c
===================================================================
--- qrc/trunk/gaym-extras/roombrowse.c	2005-07-27 07:47:36 UTC (rev 248)
+++ qrc/trunk/gaym-extras/roombrowse.c	2005-07-28 14:31:20 UTC (rev 249)
@@ -433,5 +433,3 @@
     gaim_debug_misc("roombrowse", "Callback registered!\n");
     return TRUE;
 }
-
-



From jblebrun at berlios.de  Thu Jul 28 17:09:29 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Thu, 28 Jul 2005 17:09:29 +0200
Subject: [Qrc-svn] r250 - qrc/trunk/gaym/src
Message-ID: <200507281509.j6SF9TxO024488@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-28 17:09:28 +0200 (Thu, 28 Jul 2005)
New Revision: 250

Modified:
   qrc/trunk/gaym/src/gaym.c
Log:
Fix preferences crash


Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-28 14:31:20 UTC (rev 249)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-28 15:09:28 UTC (rev 250)
@@ -1556,7 +1556,7 @@
     NULL,                                                 /**< unload         */
     NULL,                                                 /**< destroy        */
 
-    gaym_get_channel_member_reference,                    /**< ui_info        */
+    NULL,				                   /**< ui_info        */
     &prpl_info,                                           /**< extra_info     */
     &prefs_info,
     gaym_actions



From jblebrun at berlios.de  Sat Jul 30 11:02:18 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Sat, 30 Jul 2005 11:02:18 +0200
Subject: [Qrc-svn] r251 - qrc/trunk
Message-ID: <200507300902.j6U92I8g005721@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-30 11:02:17 +0200 (Sat, 30 Jul 2005)
New Revision: 251

Modified:
   qrc/trunk/configure.ac
Log:
Added --with-gaim-prefix to specify which gaim the library should be installed for.



Modified: qrc/trunk/configure.ac
===================================================================
--- qrc/trunk/configure.ac	2005-07-28 15:09:28 UTC (rev 250)
+++ qrc/trunk/configure.ac	2005-07-30 09:02:17 UTC (rev 251)
@@ -65,6 +65,11 @@
 fi
 
 # Checks for libraries.
+AC_ARG_WITH([gaim-prefix],
+	[AS_HELP_STRING(--with-gaim-prefix,specify the prefix where gaim is found)],
+	PKG_CONFIG_PATH=$withval/lib/pkgconfig,[])
+export PKG_CONFIG_PATH
+
 PKG_PROG_PKG_CONFIG([$REQUIRED_PKG_CONFIG])
 if test "$enable_gaym_extras" = "yes" ; then
 	PKG_CHECK_MODULES([GTK], [$REQUIRED_GTK],
@@ -74,17 +79,12 @@
 		]
 	)
 fi
-AC_ARG_WITH([gaim-prefix],
-	[AS_HELP_STRING(--with-gaim-prefix,specify the prefix where gaim is found)],
-	PKG_CONFIG_PATH=$withval/lib/pkgconfig,[])
-export PKG_CONFIG_PATH
 PKG_CHECK_MODULES([GAIM], [$REQUIRED_GAIM],
 	[
 	AC_SUBST(GAIM_CFLAGS)
 	AC_SUBST(GAIM_LIBS)
 	]
 )
-
 AC_ARG_VAR([GAIM_DATADIR], [datadir of GAIM, overriding pkg-config])dnl
 AC_ARG_VAR([GAIM_LIBDIR], [libdir of GAIM, overriding pkg-config])dnl
 AC_CACHE_CHECK([for GAIM][_DATADIR], [pkg_cv_][GAIM][_DATADIR],



From jblebrun at berlios.de  Sat Jul 30 11:07:05 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Sat, 30 Jul 2005 11:07:05 +0200
Subject: [Qrc-svn] r252 - qrc/trunk/gaym-extras
Message-ID: <200507300907.j6U9750i006025@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-30 11:07:03 +0200 (Sat, 30 Jul 2005)
New Revision: 252

Modified:
   qrc/trunk/gaym-extras/bio-popups.c
   qrc/trunk/gaym-extras/chaticon.c
   qrc/trunk/gaym-extras/gaym-extras.c
   qrc/trunk/gaym-extras/gaym-extras.h
Log:
gaym-extras.c: Don't handle events for non-gaym conversations.
gaym-extras.h: Misc cleanup
chaticon.c: fixed more bugs than I want to talk about. Moved image fetching to the gaym side.
popups.c: bug fixes. image fetching is on the gaym side. titles don't have an ugly box around them anymore.

Todo: fix scaling of icon in chat windows, or scrap and let popups dominate.



Modified: qrc/trunk/gaym-extras/bio-popups.c
===================================================================
--- qrc/trunk/gaym-extras/bio-popups.c	2005-07-30 09:02:17 UTC (rev 251)
+++ qrc/trunk/gaym-extras/bio-popups.c	2005-07-30 09:07:03 UTC (rev 252)
@@ -6,6 +6,8 @@
 void clean_popup_stuff(GaimConversation * c)
 {
 
+    if (!g_strrstr(gaim_account_get_protocol_id(c->account),"prpl-gaym"))
+	    return;
     GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
     if (c->type == GAIM_CONV_IM) {
         g_hash_table_remove(popup_timeouts, gtkconv->tab_label);
@@ -38,23 +40,38 @@
 static void namelist_paint_tip(GtkWidget * tipwindow,
                                GdkEventExpose * event, gpointer data)
 {
-    char *tooltiptext = ((struct paint_data *) data)->tooltiptext;
+    char *tooltiptext= ((struct paint_data *) data)->tooltiptext;
     const char *name = ((struct paint_data *) data)->name;
-    GtkStyle *style;
-    char *filename = g_strdup_printf("%s.jpg", name);
-    char *path =
-        g_build_filename(gaim_user_dir(), "icons", "gaym", filename, NULL);
-    gaim_debug_misc("popups", "trying to load image %s\n", path);
-    GError *err = NULL;
-    GdkPixbuf *pixbuf = gdk_pixbuf_new_from_file(path, &err);
-    if (err) {
-        gaim_debug_error("popups", "Pixbuf error: %s\n", err->message);
-        g_error_free(err);
+    GaimAccount* account = ((struct paint_data *)data)->account;
+    GDir* gdir=NULL;
+    GError* err=NULL;
+    GtkStyle *style=NULL;
+    GdkPixbuf *pixbuf=NULL;
+    const char *filename=NULL;
+    char* dirname=NULL;
+    char* path=NULL;
+   
+    dirname=g_build_filename(gaim_user_dir(), "icons", "gaym", name, NULL);
+    if(dirname) 
+    {
+	gdir=g_dir_open(dirname, 0 , &err);
+	if(gdir)
+	{
+	    while(filename=g_dir_read_name(gdir))
+	    {	
+		path=g_build_filename(dirname,filename,NULL);
+		if(path)
+		{
+		    pixbuf=gdk_pixbuf_new_from_file(path, &err);
+		    g_free(path);
+		}
+	    }
+	    g_free(gdir);
+	}
+	g_free(dirname);
     }
-    g_free(filename);
-    g_free(path);
-
-    // GAIM_STATUS_ICON_LARGE);
+	
+    
     PangoLayout *layout;
 
     layout = gtk_widget_create_pango_layout(tipwindow, NULL);
@@ -106,7 +123,7 @@
 
     GaymTooltipType type = data->type;
     struct gaym_conn *gaym = data->gaym;
-    g_free(data);
+    
     GaimPluginProtocolInfo *prpl_info =
         GAIM_PLUGIN_PROTOCOL_INFO(gaim_find_prpl
                                   (gaim_account_get_protocol_id
@@ -149,15 +166,9 @@
     tooltiptext = prpl_info->tooltip_text(gb);
     g_free(gb->name);
     g_free(gb);
-    if (!tooltiptext) {
-        guint *timeout = g_hash_table_lookup(popup_timeouts, tv);
-        if (timeout) {
-            int delay =
-                gaim_prefs_get_int("/gaim/gtk/blist/tooltip_delay");
-            g_timeout_add(delay, (GSourceFunc) tooltip_timeout, data);
-        }
+
+    if (!tooltiptext) 
         return FALSE;
-    }
 
 
     g_return_val_if_fail(tooltiptext != NULL, FALSE);
@@ -175,7 +186,8 @@
 
     struct paint_data *pdata = g_new0(struct paint_data, 1);
     pdata->tooltiptext = tooltiptext;
-    pdata->name = name;
+    pdata->name = gaim_normalize(gaym->account, name);
+    pdata->account = gaym->account;
     g_signal_connect(G_OBJECT(tipwindow), "expose_event",
                      G_CALLBACK(namelist_paint_tip), pdata);
     gtk_widget_ensure_style(tipwindow);
@@ -308,12 +320,17 @@
 }
 
 static void tab_leave_cb(GtkWidget * event, GdkEventCrossing * e,
-                         gpointer n)
+                         gpointer conv)
 {
+    
+    GaimConversation *c = (GaimConversation *) conv;
+   
+    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
     // Prevent clicks from demolishing popup.
     if (e->mode != GDK_CROSSING_NORMAL)
         return;
-    GtkWidget *tab = gtk_bin_get_child(GTK_BIN(event));
+    GtkWidget *tab = gtkconv->tab_label;
+  
     guint *timeout = g_hash_table_lookup(popup_timeouts, tab);
     g_hash_table_remove(popups, tab);
 
@@ -325,7 +342,7 @@
 }
 
 
-static gboolean tab_entry_cb(GtkWidget * event,
+static gboolean tab_entry_cb(GtkWidget *event,
                              GdkEventCrossing * crossing, gpointer conv)
 {
 
@@ -333,8 +350,10 @@
     guint delay;
     GaimConversation *c = (GaimConversation *) conv;
     struct gaym_conn *gaym = gaim_conversation_get_gc(c)->proto_data;
+    
+    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
 
-    GtkWidget *tab = gtk_bin_get_child(GTK_BIN(event));
+    GtkWidget *tab = gtkconv->tab_label;
     timeout = g_hash_table_lookup(popup_timeouts, tab);
 
     delay = gaim_prefs_get_int("/gaim/gtk/blist/tooltip_delay");
@@ -385,9 +404,22 @@
 {
     GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
     GtkWidget *event = gtk_event_box_new();
+    GtkWidget *hbox = gtk_hbox_new(FALSE, 6);
+    
+    gtk_widget_ref(gtkconv->icon);
+    gtk_container_remove(GTK_CONTAINER(gtkconv->tabby),
+                         GTK_WIDGET(gtkconv->icon));
+    gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(gtkconv->icon), FALSE, FALSE, 0);
+    gtk_widget_ref(gtkconv->icon);
+    gtk_widget_unref(gtkconv->icon);
+
     gtk_widget_ref(gtkconv->tab_label);
     gtk_container_remove(GTK_CONTAINER(gtkconv->tabby),
                          GTK_WIDGET(gtkconv->tab_label));
+    gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(gtkconv->tab_label), FALSE, FALSE, 0);
+    gtk_widget_unref(gtkconv->tab_label);
+    
+        
     gtk_widget_add_events(event,
                           GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK);
     g_signal_connect(G_OBJECT(event), "enter-notify-event",
@@ -396,11 +428,12 @@
                      G_CALLBACK(tab_leave_cb), c);
     gtk_box_pack_start(GTK_BOX(gtkconv->tabby), GTK_WIDGET(event), TRUE,
                        TRUE, 0);
+    gtk_box_reorder_child(GTK_BOX(gtkconv->tabby), GTK_WIDGET(event), 0);
     gtk_widget_show(GTK_WIDGET(event));
+    gtk_widget_show(GTK_WIDGET(hbox));
+    gtk_event_box_set_visible_window(GTK_EVENT_BOX(event), FALSE);
     gtk_container_add(GTK_CONTAINER(event),
-                      GTK_WIDGET(gtkconv->tab_label));
-    gtk_widget_unref(gtkconv->tab_label);
-    gtk_widget_show(GTK_WIDGET(gtkconv->tab_label));
+                      GTK_WIDGET(hbox));
     g_hash_table_insert(popup_timeouts, gtkconv->tab_label,
                         g_new0(guint, 1));
 }

Modified: qrc/trunk/gaym-extras/chaticon.c
===================================================================
--- qrc/trunk/gaym-extras/chaticon.c	2005-07-30 09:02:17 UTC (rev 251)
+++ qrc/trunk/gaym-extras/chaticon.c	2005-07-30 09:07:03 UTC (rev 252)
@@ -1,12 +1,10 @@
 #include "gaym-extras.h"
 GHashTable *icons;
-GHashTable *pending_updates;
-static void
-get_icon_scale_size(GdkPixbufAnimation * icon, GaimBuddyIconSpec * spec,
+void get_icon_scale_size(GdkPixbuf * icon, GaimBuddyIconSpec * spec,
                     int *width, int *height)
 {
-    *width = gdk_pixbuf_animation_get_width(icon);
-    *height = gdk_pixbuf_animation_get_height(icon);
+    *width = gdk_pixbuf_get_width(icon);
+    *height = gdk_pixbuf_get_height(icon);
 
     /* this should eventually get smarter about preserving the aspect
        ratio when scaling, but gimmie a break, I just woke up */
@@ -29,22 +27,18 @@
         *height = 100;
 }
 
-void gaym_gtkconv_update_thumbnail(GaimConversation * conv, struct fetch_thumbnail_data
-                                   *thumbnail_data)
+void gaym_update_thumbnail(GaimConversation * conv, GdkPixbuf* pixbuf) 
 {
     GaimGtkConversation *gtkconv;
 
     char filename[256];
-    FILE *file;
     GError *err = NULL;
 
-    size_t len;
-
-    GdkPixbuf *buf;
     GdkPixbuf *scale;
     GdkPixmap *pm;
     GdkBitmap *bm;
-    int scale_width, scale_height;
+    int scale_width=0, 
+	scale_height=0;
 
 
     GaimAccount *account;
@@ -57,34 +51,13 @@
 
     GaymChatIcon *icon_data = g_hash_table_lookup(icons, conv);
 
-    if (!thumbnail_data)
-        return;
     if (!icon_data->show_icon)
         return;
 
-    const char *data = thumbnail_data->pic_data;
-    len = thumbnail_data->pic_data_len;
-
     account = gaim_conversation_get_account(conv);
     if (account && account->gc)
         prpl_info = GAIM_PLUGIN_PROTOCOL_INFO(account->gc->prpl);
 
-
-    if (icon_data->anim != NULL)
-        g_object_unref(G_OBJECT(icon_data->anim));
-
-    icon_data->anim = NULL;
-
-    if (icon_data->icon_timer != 0)
-        g_source_remove(icon_data->icon_timer);
-
-    icon_data->icon_timer = 0;
-
-    if (icon_data->iter != NULL)
-        g_object_unref(G_OBJECT(icon_data->iter));
-
-    icon_data->iter = NULL;
-
     if (!gaim_prefs_get_bool
         ("/gaim/gtk/conversations/im/show_buddy_icons"))
         return;
@@ -93,59 +66,17 @@
         return;
 
 
-    /* this is such an evil hack, i don't know why i'm even considering
-       it. we'll do it differently when gdk-pixbuf-loader isn't leaky
-       anymore. */
-    /* gdk-pixbuf-loader was leaky? is it still? */
 
-    g_snprintf(filename, sizeof(filename),
-               "%s" G_DIR_SEPARATOR_S "gaimicon-%s.%d",
-               g_get_tmp_dir(), thumbnail_data->who, getpid());
-
-    if (!(file = g_fopen(filename, "wb")))
-        return;
-
-    fwrite(data, 1, len, file);
-    fclose(file);
-    icon_data->anim = gdk_pixbuf_animation_new_from_file(filename, &err);
-
-    /* make sure we remove the file as soon as possible */
-    g_unlink(filename);
-
-    if (err) {
-        gaim_debug(GAIM_DEBUG_ERROR, "gtkconv",
-                   "Buddy icon error: %s\n", err->message);
-        g_error_free(err);
-    }
-
-
-
-    if (!icon_data->anim)
-        return;
-
-    if (gdk_pixbuf_animation_is_static_image(icon_data->anim)) {
-        icon_data->iter = NULL;
-        buf = gdk_pixbuf_animation_get_static_image(icon_data->anim);
-    } else {
-        icon_data->iter = gdk_pixbuf_animation_get_iter(icon_data->anim, NULL); /* LEAK 
-                                                                                 */
-        buf = gdk_pixbuf_animation_iter_get_pixbuf(icon_data->iter);
-    }
-
-    get_icon_scale_size(icon_data->anim,
-                        prpl_info ? &prpl_info->icon_spec : NULL,
-                        &scale_width, &scale_height);
+    //get_icon_scale_size(icon_data->pixbuf,
+    //                    prpl_info ? &prpl_info->icon_spec : NULL,
+    //                    &scale_width, &scale_height);
+    double aspect=gdk_pixbuf_get_width(pixbuf)/gdk_pixbuf_get_height(pixbuf); 
+    gaim_debug_misc("popups","w: %i, h: %i, a: %d\n",gdk_pixbuf_get_width(pixbuf), gdk_pixbuf_get_height(pixbuf), aspect);
     scale =
-        gdk_pixbuf_scale_simple(buf,
-                                MAX(gdk_pixbuf_get_width(buf) *
-                                    scale_width /
-                                    gdk_pixbuf_animation_get_width
-                                    (icon_data->anim), 1),
-                                MAX(gdk_pixbuf_get_height(buf) *
-                                    scale_height /
-                                    gdk_pixbuf_animation_get_height
-                                    (icon_data->anim), 1),
-                                GDK_INTERP_NEAREST);
+        gdk_pixbuf_scale_simple(pixbuf,
+                                57*aspect,//gdk_pixbuf_get_width(icon_data->pixbuf) * scale_width,
+                                77,//gdk_pixbuf_get_height(icon_data->buf) * scale_width,
+                                GDK_INTERP_HYPER);
 
     gdk_pixbuf_render_pixmap_and_mask(scale, &pm, &bm, 100);
     g_object_unref(G_OBJECT(scale));
@@ -153,17 +84,18 @@
 
     icon_data->event = gtk_event_box_new();
     gtk_container_add(GTK_CONTAINER(icon_data->frame), icon_data->event);
-    gtk_widget_set_size_request(GTK_WIDGET(icon_data->frame), scale_width,
-                                scale_height);
+    gtk_widget_set_size_request(GTK_WIDGET(icon_data->frame), 57,
+                                77);
 
-    // g_signal_connect(G_OBJECT(icon_data->event), "button-press-event",
-    // G_CALLBACK(icon_menu), conv);
+    //g_signal_connect(G_OBJECT(icon_data->event), "button-press-event",
+    //G_CALLBACK(icon_menu), conv);
     gtk_widget_show(icon_data->event);
     icon_data->icon = gtk_image_new_from_pixmap(pm, bm);
     gtk_container_add(GTK_CONTAINER(icon_data->event), icon_data->icon);
     gtk_widget_show(icon_data->icon);
 
-    g_object_unref(G_OBJECT(pm));
+    if(pm)
+        g_object_unref(G_OBJECT(pm));
 
     if (bm)
         g_object_unref(G_OBJECT(bm));
@@ -171,69 +103,7 @@
 
 }
 
-static gboolean check_for_update(gpointer * conversation,
-                                 const gpointer * name, gpointer * data)
-{
-    g_return_val_if_fail(conversation != NULL, TRUE);
-    g_return_val_if_fail(name != NULL, TRUE);
-    g_return_val_if_fail(data != NULL, TRUE);
 
-    GaimConversation *c = (GaimConversation *) conversation;
-    char *name_needing_update = (char *) name;
-
-    struct fetch_thumbnail_data *d = (struct fetch_thumbnail_data *) data;
-
-    gaim_debug_misc("chaticon", "Check for update: %x %s %s %i\n", c, name,
-                    d->who, d->pic_data_len);
-    g_return_val_if_fail(name_needing_update != NULL, FALSE);
-
-    if (!strcmp(d->who, name_needing_update)) {
-        gaym_gtkconv_update_thumbnail(c, d);
-        return TRUE;
-    }
-    return TRUE;
-}
-
-void fetch_thumbnail_cb(void *user_data, const char *pic_data, size_t len)
-{
-    if (!user_data)
-        return;
-    struct fetch_thumbnail_data *d = user_data;
-    if (!pic_data) {
-        return;
-    }
-    if (len && !g_strrstr_len(pic_data, len, "Server Error")) {
-        char *dir;
-        if ((dir =
-             g_build_filename(gaim_user_dir(), "icons", "gaym",
-                              NULL)) != NULL) {
-            d->pic_data = pic_data;
-            d->pic_data_len = len;
-            gaim_build_dir(dir, S_IRUSR | S_IWUSR | S_IXUSR);
-            char *filename = g_strdup_printf("%s.jpg", d->who);
-            char *path = g_build_filename(dir, filename, NULL);
-            FILE *file;
-            if ((file = g_fopen(path, "wb"))) {
-                fwrite(pic_data, 1, len, file);
-                fclose(file);
-            } else {
-                gaim_debug_misc("chaticon", "Couldn't write file\n");
-            }
-            g_free(filename);
-            g_free(path);
-            g_free(dir);
-        }
-    } else {
-        d->pic_data = 0;
-        d->pic_data_len = 0;
-    }
-
-    g_hash_table_foreach_remove(pending_updates,
-                                (GHRFunc) check_for_update, d);
-    g_free(d);
-}
-
-
 static void changed_cb(GtkTreeSelection * selection, gpointer conv)
 {
 
@@ -241,11 +111,11 @@
     g_return_if_fail(conv != NULL);
 
     GaimConversation *c = (GaimConversation *) conv;
-    GaymBuddy *cm;
-    struct gaym_conn *gaym = c->account->gc->proto_data;
 
     GtkTreeIter iter;
-    GtkTreeModel *model;
+    GtkTreeModel *model=NULL;
+    GError *err=NULL;
+    GdkPixbuf *pixbuf=NULL;
     gchar *name;
 
     if (!gtk_tree_selection_get_selected(selection, &model, &iter))
@@ -259,53 +129,42 @@
         gtk_widget_destroy(icon_data->event);
     icon_data->event = NULL;
 
+    gtk_widget_grab_focus(GTK_WIDGET(model)->parent);
 
-    char *dir = g_build_filename(gaim_user_dir(), "icons", "gaym", NULL);
-    char *filename = g_strdup_printf("%s.jpg", name);
-    char *path = NULL;
-    FILE *file;
-    struct stat st;
-    struct fetch_thumbnail_data *data =
-        g_new0(struct fetch_thumbnail_data, 1);
-    path = g_build_filename(dir, filename, NULL);
-    if (path && !g_stat(path, &st)) {
-        if (file = g_fopen(path, "rb")) {
-            data->pic_data = g_malloc(st.st_size);
-            data->who = name;
-            data->pic_data_len = st.st_size;
-            data->from_file = TRUE;
-            fread(data->pic_data, 1, st.st_size, file);
-            fclose(file);
-        }
-        g_free(dir);
-        g_free(filename);
-        g_free(path);
 
-        gaym_gtkconv_update_thumbnail(c, data);
-        fetch_thumbnail_cb(data, data->pic_data, data->pic_data_len);
-        return;
+    GDir* gdir=NULL;
+    const char *filename=NULL;
+    char* dirname=NULL;
+    char* path=NULL;
+    char* normalized=g_utf8_strdown(name, strlen(name));
+    dirname=g_build_filename(gaim_user_dir(), "icons", "gaym", normalized, NULL);
+    gaim_debug_misc("check","checking dirname %s\n",dirname);
+    if(dirname) 
+    {
+	gdir=g_dir_open(dirname, 0 , &err);
+	if(gdir)
+	{
+	    filename=g_dir_read_name(gdir); //don't free filename: owned by glib.
+	    if(filename)
+	    {	
+		path=g_build_filename(dirname,filename,NULL);
+		gaim_debug_misc("check","trying file: %s\n",path);
+		if(path)
+		    pixbuf=gdk_pixbuf_new_from_file(path, &err);
+		    g_free(path);
+	    }
+	    g_free(gdir);
+	}
+	g_free(dirname);
     }
-    // Get GaymBuddy struct for the thumbnail URL.
-    cm = g_hash_table_lookup(gaym->channel_members, name);
-    if (!cm)
-        return;
+	
 
+    if(pixbuf)
+	gaym_update_thumbnail(c, pixbuf);
+    
+    g_object_unref(pixbuf);
+    return;
 
-    // Fetch thumbnail.
-
-    char *hashurl = g_hash_table_lookup(gaym->confighash,
-                                        "mini-profile-panel.thumbnail-prefix");
-
-    data = g_new0(struct fetch_thumbnail_data, 1);
-    data->who = name;
-    data->from_file = FALSE;
-    char *url = g_strdup_printf("%s%s", hashurl, cm->thumbnail);
-    gaim_url_fetch(url, FALSE, "Mozilla/4.0", FALSE,
-                   fetch_thumbnail_cb, data);
-
-    // Add entry to hash table for tracking.
-    g_hash_table_replace(pending_updates, c, name);
-
 }
 
 void add_chat_icon_stuff(GaimConversation * c)
@@ -336,14 +195,12 @@
     icon_data->icon_container_parent = GTK_WIDGET(hbox);
     icon_data->icon_container = NULL;
     icon_data->icon = NULL;
-    icon_data->anim = NULL;
-    icon_data->iter = NULL;
     icon_data->show_icon = TRUE;
     icon_data->icon_container = gtk_vbox_new(FALSE, 0);
 
     gtk_widget_set_size_request(GTK_WIDGET(icon_data->icon_container),
-                                prpl_info->icon_spec.max_width,
-                                prpl_info->icon_spec.max_height);
+                                57,77);// prpl_info->icon_spec.max_width,
+                                //prpl_info->icon_spec.max_height);
 
 
     icon_data->frame = gtk_frame_new(NULL);
@@ -372,5 +229,4 @@
 {
 
     icons = g_hash_table_new(g_direct_hash, g_direct_equal);
-    pending_updates = g_hash_table_new(g_direct_hash, g_direct_equal);
 }

Modified: qrc/trunk/gaym-extras/gaym-extras.c
===================================================================
--- qrc/trunk/gaym-extras/gaym-extras.c	2005-07-30 09:02:17 UTC (rev 251)
+++ qrc/trunk/gaym-extras/gaym-extras.c	2005-07-30 09:07:03 UTC (rev 252)
@@ -11,6 +11,8 @@
 // Adds motion handlers to IM tab labels.
 static void redo_im_window(GaimConversation * c)
 {
+    if (!g_strrstr(gaim_account_get_protocol_id(c->account),"prpl-gaym"))
+	    return;
     if (c && c->type == GAIM_CONV_IM)
         add_im_popup_stuff(c);
 }
@@ -18,11 +20,15 @@
 
 static void update_info_cb(GaimAccount * account, char *name)
 {
+    if (!g_strrstr(gaim_account_get_protocol_id(account),"prpl-gaym"))
+	    return;
     gaim_debug_misc("gaym-extras", "info update\n");
 }
 
 static void redochatwindow(GaimConversation * c)
 {
+    if (!g_strrstr(gaim_account_get_protocol_id(c->account),"prpl-gaym"))
+	    return;
     add_chat_sort_functions(c);
     add_chat_popup_stuff(c);
     add_chat_icon_stuff(c);
@@ -47,6 +53,7 @@
                         "deleting-conversation", plugin,
                         GAIM_CALLBACK(clean_popup_stuff), NULL);
 
+
     return TRUE;
 }
 

Modified: qrc/trunk/gaym-extras/gaym-extras.h
===================================================================
--- qrc/trunk/gaym-extras/gaym-extras.h	2005-07-30 09:02:17 UTC (rev 251)
+++ qrc/trunk/gaym-extras/gaym-extras.h	2005-07-30 09:07:03 UTC (rev 252)
@@ -24,7 +24,9 @@
 struct paint_data {
     char *tooltiptext;
     const char *name;
+    GaimAccount* account;
 };
+
 // Additional UI info for a conversation.
 // We may be able to clean this up, some.
 typedef struct _GaymChatIcon {
@@ -36,11 +38,6 @@
     GtkWidget *icon;
     GtkWidget *event;
     gboolean show_icon;
-    GdkPixbufAnimation *anim;
-    GdkPixbufAnimationIter *iter;
-    gboolean animate;
-    guint32 icon_timer;
-    GtkWidget *bio_area;
 
 } GaymChatIcon;
 
@@ -62,7 +59,7 @@
 };
 
 
-
+void get_icon_scale_size(GdkPixbuf* icon, GaimBuddyIconSpec * spec,int *width, int *height);
 void clean_popup_stuff(GaimConversation * c);
 void add_chat_icon_stuff(GaimConversation *c);
 void add_chat_popup_stuff(GaimConversation *c);



From jblebrun at berlios.de  Sat Jul 30 11:09:23 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Sat, 30 Jul 2005 11:09:23 +0200
Subject: [Qrc-svn] r253 - qrc/trunk/gaym/src
Message-ID: <200507300909.j6U99NCL006219@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-30 11:09:22 +0200 (Sat, 30 Jul 2005)
New Revision: 253

Modified:
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gaym.h
   qrc/trunk/gaym/src/gayminfo.c
   qrc/trunk/gaym/src/gayminfo.h
   qrc/trunk/gaym/src/helpers.c
   qrc/trunk/gaym/src/msgs.c
Log:
helpers.c:  refactoring
gayminfo.c: file caching of thumbnail fetches.

Misc cleanup.



Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-30 09:07:03 UTC (rev 252)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-30 09:09:22 UTC (rev 253)
@@ -510,8 +510,6 @@
      * for thumbails inside the IM conversation window if the
      * person is not already on the buddy list
      */
-    gaym->im_thumbnail_needed =
-        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
 
     buf = g_strdup_printf(_("Signon: %s"), username);
     gaim_connection_update_progress(gc, buf, 1, 6);
@@ -537,7 +535,7 @@
     gaym->confighash = gaym_properties_new(config_text);
     g_return_if_fail(gaym->confighash != NULL);
 
-    synchronize_deny_list(gc, gaym->confighash);
+    //synchronize_deny_list(gc, gaym->confighash);
 
     return;
 }
@@ -686,7 +684,6 @@
     g_hash_table_destroy(gaym->msgs);
     g_hash_table_destroy(gaym->info_window_needed);
     g_hash_table_destroy(gaym->entry_order);
-    g_hash_table_destroy(gaym->im_thumbnail_needed);
     if (gaym->motd)
         g_string_free(gaym->motd, TRUE);
 
@@ -1438,10 +1435,6 @@
          * with the WHOIS to get the photo for the IM thumbnail
          */
 
-        char *normalized =
-            g_strdup(gaim_normalize(gc->account, conv->name));
-        g_hash_table_insert(gaym->im_thumbnail_needed, normalized,
-                            normalized);
 
         name = gaym_nick_to_gcom_strdup(conv->name);
         buf = gaym_format(gaym, "vn", "WHOIS", name);
@@ -1597,11 +1590,13 @@
 
     gaim_signal_register(gaim_accounts_get_handle(),
                          "info-updated",
-                         gaim_marshal_VOID__POINTER_POINTER, NULL, 3,
+                         gaim_marshal_VOID__POINTER_POINTER, NULL, 2,
                          gaim_value_new(GAIM_TYPE_SUBTYPE,
                                         GAIM_SUBTYPE_ACCOUNT),
                          gaim_value_new(GAIM_TYPE_POINTER,
                                         GAIM_TYPE_CHAR));
+    
+    
 
     gaim_prefs_add_none("/plugins/prpl/gaym");
     gaim_prefs_add_int("/plugins/prpl/gaym/chat_room_instances", 4);

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-30 09:07:03 UTC (rev 252)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-30 09:09:22 UTC (rev 253)
@@ -80,7 +80,6 @@
 
     gboolean blist_updating;
     GHashTable *info_window_needed;
-    GHashTable *im_thumbnail_needed;
 
     GString *motd;
     GString *names;

Modified: qrc/trunk/gaym/src/gayminfo.c
===================================================================
--- qrc/trunk/gaym/src/gayminfo.c	2005-07-30 09:07:03 UTC (rev 252)
+++ qrc/trunk/gaym/src/gayminfo.c	2005-07-30 09:09:22 UTC (rev 253)
@@ -111,6 +111,56 @@
 
     }
 }
+void gaym_fetch_thumbnail_cb(void *user_data, const char *pic_data,
+                             size_t len)
+{
+    if (!user_data)
+        return;
+    struct gaym_fetch_thumbnail_data *d = user_data;
+    if (!pic_data) {
+        return;
+    }
+    
+    if (len && !g_strrstr_len(pic_data, len, "Server Error")) {
+        char *dir = g_build_filename(gaim_user_dir(), "icons", "gaym", d->who, NULL);
+        char *filename = g_strdup(d->filename);
+        char *path = g_build_filename(dir, filename, NULL);
+	gaim_debug_misc("gayminfo","dir: %s\n",dir);
+	gaim_debug_misc("gayminfo","filename: %s\n",filename);
+	gaim_debug_misc("gayminfo","path: %s\n",path);
+	if(!g_file_test(dir, G_FILE_TEST_EXISTS))
+            gaim_build_dir(dir, S_IRUSR | S_IWUSR | S_IXUSR);
+	
+	if(path && !g_file_test(path, G_FILE_TEST_EXISTS)) {
+            FILE *file;
+            if ((file = g_fopen(path, "wb"))) {
+                fwrite(pic_data, 1, len, file);
+                fclose(file);
+            } else {
+                gaim_debug_misc("fetch_thumbnail_cb", "Couldn't write file\n");
+            }
+            g_free(filename);
+            g_free(path);
+            g_free(dir);
+        }
+    }
+    if (GAIM_CONNECTION_IS_VALID(d->gc) && len) {
+        gaim_signal_emit(gaim_accounts_get_handle(), "info-updated",
+                         d->gc, NULL, d->who);
+        if(gaim_find_conversation_with_account(d->who, d->gc->account)) 
+	{
+	   gaim_buddy_icons_set_for_user(gaim_connection_get_account(d->gc),
+                                      d->who, (void *) pic_data, len);
+	}
+	   
+    } else {
+        gaim_debug_error("gaym", "Fetching buddy icon failed.\n");
+    }
+
+    g_free(d->who);
+    g_free(d);
+}
+
 void gaym_buddy_status(struct gaym_conn *gaym, char *name,
                        gboolean online, char *info)
 {
@@ -150,31 +200,54 @@
     struct gaym_buddy *ib = g_hash_table_lookup(gaym->buddies, name);
 
     char *normalized = g_strdup(gaim_normalize(gaym->account, name));
-    char *im_thumbnail =
-        g_hash_table_lookup(gaym->im_thumbnail_needed, normalized);
-
+    
     if (thumbnail) {
-        if ((ib && gaim_utf8_strcasecmp(thumbnail, ib->thumbnail))
-            || im_thumbnail) {
-
-            char *hashurl = NULL;
-            hashurl =
-                g_hash_table_lookup(gaym->confighash,
-                                    "mini-profile-panel.thumbnail-prefix");
-            g_return_if_fail(hashurl != NULL);
-            data = g_new0(struct gaym_fetch_thumbnail_data, 1);
-            data->gc = gaim_account_get_connection(gaym->account);
-            data->who = g_strdup(name);
-            url = g_strdup_printf("%s%s", hashurl, thumbnail);
-            gaim_url_fetch(url, FALSE, "Mozilla/4.0", FALSE,
-                           gaym_fetch_thumbnail_cb, data);
-            g_free(url);
-        }
+	gboolean do_fetch=1;
+	GError* err=NULL;
+        if (!ib || gaim_utf8_strcasecmp(thumbnail, ib->thumbnail)) {
+	    char* dirname=g_build_filename(gaim_user_dir(), "icons", "gaym", gaim_normalize(gaym->account,name), NULL);
+	    GDir* gdir=g_dir_open(dirname, 0 , &err);
+	    if(gdir)
+	    {
+	        const char* filename;
+		
+	        while((filename=g_dir_read_name(gdir))) //don't free filename: owned by glib.
+		{
+		    char* thumbnail_base=g_path_get_basename(thumbnail);
+		    gaim_debug_misc("gaym","compared %s and %s\n",thumbnail_base, filename);
+		    if(!gaim_utf8_strcasecmp(thumbnail_base, filename))
+		    {
+			do_fetch=0;
+			break;
+		    }
+		    g_free(thumbnail_base);
+		}	
+	    }
+	    if(do_fetch) {
+		
+		gaim_debug_misc("gaym","********************************************\n");
+		gaim_debug_misc("gaym","*****************FETCH**********************\n");
+		gaim_debug_misc("gaym","********************************************\n");
+		char *hashurl = NULL;
+		hashurl =
+		    g_hash_table_lookup(gaym->confighash,
+					"mini-profile-panel.thumbnail-prefix");
+		g_return_if_fail(hashurl != NULL);
+		data = g_new0(struct gaym_fetch_thumbnail_data, 1);
+		data->gc = gaim_account_get_connection(gaym->account);
+		data->who = g_strdup(gaim_normalize(gaym->account,name));
+		data->filename=g_strdup(g_strrstr(thumbnail, "/"));
+		gaim_debug_misc("gayminfo","Found filename: %s\n",data->filename);
+		url = g_strdup_printf("%s%s", hashurl, thumbnail);
+		g_free(thumbnail);
+		gaim_url_fetch(url, FALSE, "Mozilla/4.0", FALSE,
+			       gaym_fetch_thumbnail_cb, data);
+		g_free(url);
+	    }
+    
+	}
     }
 
-    if (im_thumbnail) {
-        g_hash_table_remove(gaym->im_thumbnail_needed, normalized);
-    }
     g_free(normalized);
 
     if (ib) {

Modified: qrc/trunk/gaym/src/gayminfo.h
===================================================================
--- qrc/trunk/gaym/src/gayminfo.h	2005-07-30 09:07:03 UTC (rev 252)
+++ qrc/trunk/gaym/src/gayminfo.h	2005-07-30 09:09:22 UTC (rev 253)
@@ -35,6 +35,7 @@
 struct gaym_fetch_thumbnail_data {
     GaimConnection *gc;
     char *who;
+    char *filename;
     char *bio;
     char *stats;
     // const char *pic_data;

Modified: qrc/trunk/gaym/src/helpers.c
===================================================================
--- qrc/trunk/gaym/src/helpers.c	2005-07-30 09:07:03 UTC (rev 252)
+++ qrc/trunk/gaym/src/helpers.c	2005-07-30 09:09:22 UTC (rev 253)
@@ -20,7 +20,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #include "internal.h"
-
+#include "debug.h"
 #include "helpers.h"
 
 void gcom_nick_to_gaym(char *nick)
@@ -205,25 +205,27 @@
 
 void replace_dollar_n(gpointer key, gpointer value, gpointer user_data)
 {
-    int i = 0;
-    gchar *tmpstr = (gchar *) value;
+ 
     /**
      * replace $[0-9] with %s, so we can use printf style
      * processing with the provided property values
      */
-    for (i = 0; i < strlen(tmpstr); i++) {
-        if (tmpstr[i] == '$') {
-            if (g_ascii_isdigit(tmpstr[i + 1])) {
-                tmpstr[i] = '%';
-                tmpstr[i + 1] = 's';
-                i++;
-            }
-        }
+    char* pos=(char*)value;
+    while((pos=(strchr(pos, '$'))))
+    {
+	pos++;
+	if(g_ascii_isdigit(pos))
+	{
+		*pos='s';
+		*(pos-1)='%';
+		
+	}
     }
 }
 
 GHashTable *gaym_properties_new(const gchar * str)
 {
+    
     gchar *tmpstr = NULL;
     gchar **tmparr = NULL;
     gchar **proparr = NULL;
@@ -240,12 +242,21 @@
     /**
      * strip out continuation character followed by newline 
      */
-    tmparr = g_strsplit(tmpstr, "\\\n", -1);
-    g_free(tmpstr);
-    tmpstr = g_strjoinv(NULL, tmparr);
-    g_strfreev(tmparr);
-
+    //tmparr = g_strsplit(tmpstr, "\\\n", -1);
+    //g_free(tmpstr);
+    //tmpstr = g_strjoinv(NULL, tmparr);
+    //g_strfreev(tmparr);
     /**
+     * Since the properties get stripped of spaces later,
+     * just replace \\\n with <space>\n in-place, for speed.
+     * */
+    char* pos=tmpstr;
+    while((pos=g_strrstr(pos, "\\\n")))
+    {
+	*pos=' ';
+	*(pos+1)=' ';
+    }
+    /**
      * We're getting close.  Now we need an array as follows:
      *
      * property=value
@@ -280,10 +291,12 @@
         proparr = g_strsplit(tmparr[i], "=", 2);
         if (proparr[0] && strlen(g_strstrip(proparr[0])) > 0
             && proparr[1] && strlen(g_strstrip(proparr[1])) > 0) {
-            g_hash_table_insert(props, g_strdup(proparr[0]),
+            
+		g_hash_table_insert(props, g_strdup(proparr[0]),
                                 g_strdup(proparr[1]));
-            g_strfreev(proparr);
+	    
         }
+	g_strfreev(proparr);
     }
 
     g_strfreev(tmparr);

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-30 09:07:03 UTC (rev 252)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-30 09:09:22 UTC (rev 253)
@@ -85,30 +85,6 @@
     serv_got_im(gc, args[1], args[2], GAIM_CONV_IM_AUTO_RESP, time(NULL));
 }
 
-void gaym_fetch_thumbnail_cb(void *user_data, const char *pic_data,
-                             size_t len)
-{
-    if (!user_data)
-        return;
-    struct gaym_fetch_thumbnail_data *d = user_data;
-    if (!pic_data) {
-        gaim_signal_emit(gaim_accounts_get_handle(), "buddy-icon-fetched",
-                         d->gc, NULL, d->who);
-        return;
-    }
-
-
-    if (GAIM_CONNECTION_IS_VALID(d->gc) && len) {
-        gaim_buddy_icons_set_for_user(gaim_connection_get_account(d->gc),
-                                      d->who, (void *) pic_data, len);
-    } else {
-        gaim_debug_error("gaym", "Fetching buddy icon failed.\n");
-    }
-
-    g_free(d->who);
-    g_free(d);
-}
-
 static void gaym_fetch_photo_cb(void *user_data, const char *info_data,
                                 size_t len)
 {



From jblebrun at berlios.de  Sat Jul 30 18:50:48 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Sat, 30 Jul 2005 18:50:48 +0200
Subject: [Qrc-svn] r254 - in qrc/trunk: gaym/src gaym-extras
Message-ID: <200507301650.j6UGomis025740@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-30 18:50:31 +0200 (Sat, 30 Jul 2005)
New Revision: 254

Modified:
   qrc/trunk/gaym-extras/bio-popups.c
   qrc/trunk/gaym-extras/chaticon.c
   qrc/trunk/gaym-extras/gaym-extras.h
   qrc/trunk/gaym/src/helpers.c
Log:
Misc chaticon/popup fixes.
Popups show name now.



Modified: qrc/trunk/gaym/src/helpers.c
===================================================================
--- qrc/trunk/gaym/src/helpers.c	2005-07-30 09:09:22 UTC (rev 253)
+++ qrc/trunk/gaym/src/helpers.c	2005-07-30 16:50:31 UTC (rev 254)
@@ -210,11 +210,11 @@
      * replace $[0-9] with %s, so we can use printf style
      * processing with the provided property values
      */
-    char* pos=(char*)value;
+    gchar* pos=(gchar*)value;
     while((pos=(strchr(pos, '$'))))
     {
 	pos++;
-	if(g_ascii_isdigit(pos))
+	if(g_ascii_isdigit(*pos))
 	{
 		*pos='s';
 		*(pos-1)='%';
@@ -460,7 +460,8 @@
 char *build_tooltip_text(struct gaym_buddy *ib)
 {
     char *escaped;
-    GString *tooltip = g_string_new("");
+     GString *tooltip = g_string_new("");
+    g_string_printf(tooltip, "<b><i>%s</i></b>",ib->name);
 
     g_return_val_if_fail(ib != NULL, NULL);
 
@@ -495,7 +496,7 @@
         g_string_append_printf(tooltip, _(" No info."));
     }
 
-    g_string_erase(tooltip, 0, 1);
+    //g_string_erase(tooltip, 0, 1);
 
     return g_string_free(tooltip, FALSE);
 }

Modified: qrc/trunk/gaym-extras/bio-popups.c
===================================================================
--- qrc/trunk/gaym-extras/bio-popups.c	2005-07-30 09:09:22 UTC (rev 253)
+++ qrc/trunk/gaym-extras/bio-popups.c	2005-07-30 16:50:31 UTC (rev 254)
@@ -40,38 +40,12 @@
 static void namelist_paint_tip(GtkWidget * tipwindow,
                                GdkEventExpose * event, gpointer data)
 {
+    g_return_if_fail(data);
+	
     char *tooltiptext= ((struct paint_data *) data)->tooltiptext;
-    const char *name = ((struct paint_data *) data)->name;
-    GaimAccount* account = ((struct paint_data *)data)->account;
-    GDir* gdir=NULL;
-    GError* err=NULL;
+    GdkPixbuf* pixbuf = ((struct paint_data *)data)->pixbuf;
     GtkStyle *style=NULL;
-    GdkPixbuf *pixbuf=NULL;
-    const char *filename=NULL;
-    char* dirname=NULL;
-    char* path=NULL;
-   
-    dirname=g_build_filename(gaim_user_dir(), "icons", "gaym", name, NULL);
-    if(dirname) 
-    {
-	gdir=g_dir_open(dirname, 0 , &err);
-	if(gdir)
-	{
-	    while(filename=g_dir_read_name(gdir))
-	    {	
-		path=g_build_filename(dirname,filename,NULL);
-		if(path)
-		{
-		    pixbuf=gdk_pixbuf_new_from_file(path, &err);
-		    g_free(path);
-		}
-	    }
-	    g_free(gdir);
-	}
-	g_free(dirname);
-    }
-	
-    
+        
     PangoLayout *layout;
 
     layout = gtk_widget_create_pango_layout(tipwindow, NULL);
@@ -104,6 +78,34 @@
 
     return;
 }
+GdkPixbuf* lookup_cached_thumbnail(GaimAccount* account, const char*fullname) {
+    GDir* gdir=NULL;
+    GError* err=NULL;
+    GdkPixbuf *pixbuf=NULL;
+    const char *filename=NULL;
+    char* dirname=NULL;
+    char* path=NULL;
+    const char* name= gaim_normalize(account, fullname);
+    dirname=g_build_filename(gaim_user_dir(), "icons", "gaym", name, NULL);
+    if(dirname) 
+    {
+	gdir=g_dir_open(dirname, 0 , &err);
+	if(gdir)
+	{
+	    filename=g_dir_read_name(gdir); //don't free filename: owned by glib.
+	    if(filename)
+	    {	
+		path=g_build_filename(dirname,filename,NULL);
+		if(path)
+		    pixbuf=gdk_pixbuf_new_from_file(path, &err);
+		    g_free(path);
+	    }
+	    g_free(gdir);
+	}
+	g_free(dirname);
+    }
+    return pixbuf;
+}
 
 static gboolean tooltip_timeout(struct timeout_cb_data *data)
 {
@@ -158,6 +160,8 @@
         name = gtk_label_get_text(GTK_LABEL(tv));
     } else
         return FALSE;
+    
+    	
 
 
     GaimBuddy *gb = g_new0(GaimBuddy, 1);
@@ -170,7 +174,7 @@
     if (!tooltiptext) 
         return FALSE;
 
-
+    
     g_return_val_if_fail(tooltiptext != NULL, FALSE);
 
     tipwindow = g_hash_table_lookup(popups, tv);
@@ -186,8 +190,7 @@
 
     struct paint_data *pdata = g_new0(struct paint_data, 1);
     pdata->tooltiptext = tooltiptext;
-    pdata->name = gaim_normalize(gaym->account, name);
-    pdata->account = gaym->account;
+    pdata->pixbuf = lookup_cached_thumbnail(gaym->account, name);
     g_signal_connect(G_OBJECT(tipwindow), "expose_event",
                      G_CALLBACK(namelist_paint_tip), pdata);
     gtk_widget_ensure_style(tipwindow);
@@ -219,8 +222,8 @@
 
     /* 57 is the size of a large status icon plus 4 pixels padding on each 
        side.  I should #define this or something */
-    w = w + 65;
-    h = MAX(h, 65);
+    w = w + gdk_pixbuf_get_width(pdata->pixbuf) + 4;
+    h = MAX(h, gdk_pixbuf_get_height(pdata->pixbuf)+4);
 
 #if GTK_CHECK_VERSION(2,2,0)
     if (w > mon_size.width)

Modified: qrc/trunk/gaym-extras/chaticon.c
===================================================================
--- qrc/trunk/gaym-extras/chaticon.c	2005-07-30 09:09:22 UTC (rev 253)
+++ qrc/trunk/gaym-extras/chaticon.c	2005-07-30 16:50:31 UTC (rev 254)
@@ -5,7 +5,7 @@
 {
     *width = gdk_pixbuf_get_width(icon);
     *height = gdk_pixbuf_get_height(icon);
-
+    gaim_debug_misc("popups","current: w: %i, h: %i\n", *width,*height);
     /* this should eventually get smarter about preserving the aspect
        ratio when scaling, but gimmie a break, I just woke up */
     if (spec && spec->scale_rules & GAIM_ICON_SCALE_DISPLAY) {
@@ -25,18 +25,16 @@
         *width = 100;
     if (*height > 100)
         *height = 100;
+    gaim_debug_misc("popups","scaled: w: %i, h: %i\n", *width,*height);
 }
 
 void gaym_update_thumbnail(GaimConversation * conv, GdkPixbuf* pixbuf) 
 {
     GaimGtkConversation *gtkconv;
 
-    char filename[256];
-    GError *err = NULL;
-
     GdkPixbuf *scale;
-    GdkPixmap *pm;
-    GdkBitmap *bm;
+    GdkPixmap *pm=NULL;
+    GdkBitmap *bm=NULL;
     int scale_width=0, 
 	scale_height=0;
 
@@ -67,16 +65,16 @@
 
 
 
-    //get_icon_scale_size(icon_data->pixbuf,
-    //                    prpl_info ? &prpl_info->icon_spec : NULL,
-    //                    &scale_width, &scale_height);
-    double aspect=gdk_pixbuf_get_width(pixbuf)/gdk_pixbuf_get_height(pixbuf); 
-    gaim_debug_misc("popups","w: %i, h: %i, a: %d\n",gdk_pixbuf_get_width(pixbuf), gdk_pixbuf_get_height(pixbuf), aspect);
+    get_icon_scale_size(pixbuf,
+                        prpl_info ? &prpl_info->icon_spec : NULL,
+                        &scale_width, &scale_height);
+    //double aspect=(double)gdk_pixbuf_get_width(pixbuf)/(double)gdk_pixbuf_get_height(pixbuf); 
+
     scale =
         gdk_pixbuf_scale_simple(pixbuf,
-                                57*aspect,//gdk_pixbuf_get_width(icon_data->pixbuf) * scale_width,
-                                77,//gdk_pixbuf_get_height(icon_data->buf) * scale_width,
-                                GDK_INTERP_HYPER);
+                                scale_width,
+                                scale_height,
+                                GDK_INTERP_BILINEAR);
 
     gdk_pixbuf_render_pixmap_and_mask(scale, &pm, &bm, 100);
     g_object_unref(G_OBJECT(scale));
@@ -114,7 +112,6 @@
 
     GtkTreeIter iter;
     GtkTreeModel *model=NULL;
-    GError *err=NULL;
     GdkPixbuf *pixbuf=NULL;
     gchar *name;
 
@@ -131,34 +128,8 @@
 
     gtk_widget_grab_focus(GTK_WIDGET(model)->parent);
 
-
-    GDir* gdir=NULL;
-    const char *filename=NULL;
-    char* dirname=NULL;
-    char* path=NULL;
-    char* normalized=g_utf8_strdown(name, strlen(name));
-    dirname=g_build_filename(gaim_user_dir(), "icons", "gaym", normalized, NULL);
-    gaim_debug_misc("check","checking dirname %s\n",dirname);
-    if(dirname) 
-    {
-	gdir=g_dir_open(dirname, 0 , &err);
-	if(gdir)
-	{
-	    filename=g_dir_read_name(gdir); //don't free filename: owned by glib.
-	    if(filename)
-	    {	
-		path=g_build_filename(dirname,filename,NULL);
-		gaim_debug_misc("check","trying file: %s\n",path);
-		if(path)
-		    pixbuf=gdk_pixbuf_new_from_file(path, &err);
-		    g_free(path);
-	    }
-	    g_free(gdir);
-	}
-	g_free(dirname);
-    }
-	
-
+    pixbuf=lookup_cached_thumbnail(c->account, name);
+ 
     if(pixbuf)
 	gaym_update_thumbnail(c, pixbuf);
     
@@ -199,7 +170,7 @@
     icon_data->icon_container = gtk_vbox_new(FALSE, 0);
 
     gtk_widget_set_size_request(GTK_WIDGET(icon_data->icon_container),
-                                57,77);// prpl_info->icon_spec.max_width,
+                                57,77);//prpl_info->icon_spec.max_width,
                                 //prpl_info->icon_spec.max_height);
 
 

Modified: qrc/trunk/gaym-extras/gaym-extras.h
===================================================================
--- qrc/trunk/gaym-extras/gaym-extras.h	2005-07-30 09:09:22 UTC (rev 253)
+++ qrc/trunk/gaym-extras/gaym-extras.h	2005-07-30 16:50:31 UTC (rev 254)
@@ -23,8 +23,7 @@
 
 struct paint_data {
     char *tooltiptext;
-    const char *name;
-    GaimAccount* account;
+    GdkPixbuf* pixbuf;
 };
 
 // Additional UI info for a conversation.
@@ -59,6 +58,7 @@
 };
 
 
+GdkPixbuf* lookup_cached_thumbnail(GaimAccount* account, const char*fullname);
 void get_icon_scale_size(GdkPixbuf* icon, GaimBuddyIconSpec * spec,int *width, int *height);
 void clean_popup_stuff(GaimConversation * c);
 void add_chat_icon_stuff(GaimConversation *c);



From jblebrun at berlios.de  Sat Jul 30 19:36:57 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Sat, 30 Jul 2005 19:36:57 +0200
Subject: [Qrc-svn] r255 - qrc/tags
Message-ID: <200507301736.j6UHavRD006136@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-30 19:36:47 +0200 (Sat, 30 Jul 2005)
New Revision: 255

Added:
   qrc/tags/stable-7-30/
Log:
Tagging r250 as stable.



Copied: qrc/tags/stable-7-30 (from rev 250, qrc/trunk)



From jblebrun at berlios.de  Sat Jul 30 23:32:58 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Sat, 30 Jul 2005 23:32:58 +0200
Subject: [Qrc-svn] r256 - in qrc/trunk: . gaym-extras gaym-extras/pixmaps gaym-extras/src gaym-extras/src/.deps gaym-extras/src/.libs nsis
Message-ID: <200507302132.j6ULWwTQ028769@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-30 23:32:57 +0200 (Sat, 30 Jul 2005)
New Revision: 256

Added:
   qrc/trunk/gaym-extras/pixmaps/
   qrc/trunk/gaym-extras/pixmaps/Makefile
   qrc/trunk/gaym-extras/pixmaps/Makefile.am
   qrc/trunk/gaym-extras/pixmaps/Makefile.in
   qrc/trunk/gaym-extras/pixmaps/alpha.png
   qrc/trunk/gaym-extras/pixmaps/entry.png
   qrc/trunk/gaym-extras/pixmaps/pic.png
   qrc/trunk/gaym-extras/src/
   qrc/trunk/gaym-extras/src/.chatsort.c.swp
   qrc/trunk/gaym-extras/src/.deps/
   qrc/trunk/gaym-extras/src/.deps/bio-popups.Plo
   qrc/trunk/gaym-extras/src/.deps/chaticon.Plo
   qrc/trunk/gaym-extras/src/.deps/chatsort.Plo
   qrc/trunk/gaym-extras/src/.deps/gaym-extras.Plo
   qrc/trunk/gaym-extras/src/.libs/
   qrc/trunk/gaym-extras/src/.libs/libgaym-extras.lai
   qrc/trunk/gaym-extras/src/.libs/libgaym-extras.so
   qrc/trunk/gaym-extras/src/Makefile
   qrc/trunk/gaym-extras/src/Makefile.am
   qrc/trunk/gaym-extras/src/Makefile.in
   qrc/trunk/gaym-extras/src/bio-popups.c
   qrc/trunk/gaym-extras/src/chaticon.c
   qrc/trunk/gaym-extras/src/chatsort.c
   qrc/trunk/gaym-extras/src/gaym-extras.c
   qrc/trunk/gaym-extras/src/gaym-extras.h
   qrc/trunk/gaym-extras/src/roombrowse.c
Removed:
   qrc/trunk/gaym-extras/bio-popups.c
   qrc/trunk/gaym-extras/chaticon.c
   qrc/trunk/gaym-extras/chatsort.c
   qrc/trunk/gaym-extras/gaym-extras.c
   qrc/trunk/gaym-extras/gaym-extras.h
   qrc/trunk/gaym-extras/roombrowse.c
Modified:
   qrc/trunk/configure.ac
   qrc/trunk/gaym-extras/Makefile.am
   qrc/trunk/nsis/installer.nsi
Log:
Reorganized gaym-extras directory.
Include icons on the sort order button.
Cleaned up sort order code.
Updated build scripts to reflect changes and new icons.



Modified: qrc/trunk/configure.ac
===================================================================
--- qrc/trunk/configure.ac	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/configure.ac	2005-07-30 21:32:57 UTC (rev 256)
@@ -128,6 +128,8 @@
                  gaym/pixmaps/Makefile
                  gaym/src/Makefile
                  gaym-extras/Makefile
+		 gaym-extras/src/Makefile
+                 gaym-extras/pixmaps/Makefile
                  nsis/Makefile
 		 nsis/locale/Makefile])
 AC_OUTPUT

Modified: qrc/trunk/gaym-extras/Makefile.am
===================================================================
--- qrc/trunk/gaym-extras/Makefile.am	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/Makefile.am	2005-07-30 21:32:57 UTC (rev 256)
@@ -1,26 +1,2 @@
-pkgdir = \
-	$(GAIM_LIBDIR)/gaim
-
-GAYMSOURCES = \
-	gaym-extras.c chatsort.c bio-popups.c chaticon.c gaym-extras.h
-
-AM_CFLAGS = \
-	$(st)
-
-libgaym_extras_la_LDFLAGS = \
-	-module \
-	-avoid-version \
-	$(GTK_LIBS) \
-	$(GAIM_LIBS)
-
-pkg_LTLIBRARIES = \
-	libgaym-extras.la
-
-libgaym_extras_la_SOURCES = \
-	$(GAYMSOURCES)
-
-AM_CPPFLAGS = \
-	$(DEBUG_CFLAGS) \
-	$(GTK_CFLAGS) \
-	$(GAIM_CFLAGS)
-	
+SUBDIRS = src\
+	pixmaps

Deleted: qrc/trunk/gaym-extras/bio-popups.c
===================================================================
--- qrc/trunk/gaym-extras/bio-popups.c	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/bio-popups.c	2005-07-30 21:32:57 UTC (rev 256)
@@ -1,455 +0,0 @@
-#include "gaym-extras.h"
-// Consider combining into one popup hash...
-GHashTable *popup_rects;
-GHashTable *popup_timeouts;
-GHashTable *popups;
-void clean_popup_stuff(GaimConversation * c)
-{
-
-    if (!g_strrstr(gaim_account_get_protocol_id(c->account),"prpl-gaym"))
-	    return;
-    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-    if (c->type == GAIM_CONV_IM) {
-        g_hash_table_remove(popup_timeouts, gtkconv->tab_label);
-        g_hash_table_remove(popups, gtkconv->tab_label);
-    } else if (c->type == GAIM_CONV_CHAT) {
-        GaimGtkChatPane *gtkchat = gtkconv->u.chat;
-        g_hash_table_remove(popup_timeouts, gtkchat->list);
-        g_hash_table_remove(popup_rects, gtkchat->list);
-        g_hash_table_remove(popups, gtkchat->list);
-    }
-
-}
-
-static void namelist_leave_cb(GtkWidget * tv, GdkEventCrossing * e,
-                              gpointer n)
-{
-    // This prevent clicks from demloishing popups.
-    if (e->mode != GDK_CROSSING_NORMAL)
-        return;
-
-    guint *timeout = g_hash_table_lookup(popup_timeouts, tv);
-    g_hash_table_remove(popups, tv);
-
-    if (*timeout) {
-        g_source_remove(*timeout);
-        *timeout = 0;
-    }
-}
-
-static void namelist_paint_tip(GtkWidget * tipwindow,
-                               GdkEventExpose * event, gpointer data)
-{
-    g_return_if_fail(data);
-	
-    char *tooltiptext= ((struct paint_data *) data)->tooltiptext;
-    GdkPixbuf* pixbuf = ((struct paint_data *)data)->pixbuf;
-    GtkStyle *style=NULL;
-        
-    PangoLayout *layout;
-
-    layout = gtk_widget_create_pango_layout(tipwindow, NULL);
-    pango_layout_set_markup(layout, tooltiptext, strlen(tooltiptext));
-    pango_layout_set_wrap(layout, PANGO_WRAP_WORD);
-    pango_layout_set_width(layout, 300000);
-    style = tipwindow->style;
-
-    gtk_paint_flat_box(style, tipwindow->window, GTK_STATE_NORMAL,
-                       GTK_SHADOW_OUT, NULL, tipwindow, "tooltip", 0, 0,
-                       -1, -1);
-
-#if GTK_CHECK_VERSION(2,2,0)
-    gdk_draw_pixbuf(GDK_DRAWABLE(tipwindow->window), NULL, pixbuf,
-                    0, 0, 4, 4, -1, -1, GDK_RGB_DITHER_NONE, 0, 0);
-#else
-    gdk_pixbuf_render_to_drawable(pixbuf,
-                                  GDK_DRAWABLE(tipwindow->window), NULL, 0,
-                                  0, 4, 4, -1, -1, GDK_RGB_DITHER_NONE, 0,
-                                  0);
-#endif
-
-    gtk_paint_layout(style, tipwindow->window, GTK_STATE_NORMAL, TRUE,
-                     NULL, tipwindow, "tooltip", 65, 4, layout);
-
-    g_object_unref(pixbuf);
-    g_object_unref(layout);
-    g_free(tooltiptext);
-    g_free(data);
-
-    return;
-}
-GdkPixbuf* lookup_cached_thumbnail(GaimAccount* account, const char*fullname) {
-    GDir* gdir=NULL;
-    GError* err=NULL;
-    GdkPixbuf *pixbuf=NULL;
-    const char *filename=NULL;
-    char* dirname=NULL;
-    char* path=NULL;
-    const char* name= gaim_normalize(account, fullname);
-    dirname=g_build_filename(gaim_user_dir(), "icons", "gaym", name, NULL);
-    if(dirname) 
-    {
-	gdir=g_dir_open(dirname, 0 , &err);
-	if(gdir)
-	{
-	    filename=g_dir_read_name(gdir); //don't free filename: owned by glib.
-	    if(filename)
-	    {	
-		path=g_build_filename(dirname,filename,NULL);
-		if(path)
-		    pixbuf=gdk_pixbuf_new_from_file(path, &err);
-		    g_free(path);
-	    }
-	    g_free(gdir);
-	}
-	g_free(dirname);
-    }
-    return pixbuf;
-}
-
-static gboolean tooltip_timeout(struct timeout_cb_data *data)
-{
-    const gchar *name;
-    int scr_w, scr_h, w, h, x, y;
-#if GTK_CHECK_VERSION(2,2,0)
-    int mon_num;
-    GdkScreen *screen = NULL;
-#endif
-    PangoLayout *layout;
-    gboolean tooltip_top = FALSE;
-    char *tooltiptext = NULL;
-    GdkRectangle mon_size;
-    guint *timeout;
-    GtkWidget *tipwindow;
-    GtkWidget *tv = data->tv;
-
-    GaymTooltipType type = data->type;
-    struct gaym_conn *gaym = data->gaym;
-    
-    GaimPluginProtocolInfo *prpl_info =
-        GAIM_PLUGIN_PROTOCOL_INFO(gaim_find_prpl
-                                  (gaim_account_get_protocol_id
-                                   (gaym->account)));
-
-    timeout = (guint *) g_hash_table_lookup(popup_timeouts, tv);
-    /* we check to see if we're still supposed to be moving, now that gtk
-       events have happened, and the mouse might not still be in the buddy 
-       list */
-    while (gtk_events_pending())
-        gtk_main_iteration();
-    if (!(*timeout)) {
-        return FALSE;
-    }
-
-    if (type == TOOLTIP_CHAT) {
-        GtkTreePath *path;
-        GtkTreeIter iter;
-        GtkTreeModel *model;
-        GdkRectangle *rect;
-
-        rect = g_hash_table_lookup(popup_rects, tv);
-        if (!gtk_tree_view_get_path_at_pos
-            (GTK_TREE_VIEW(tv), rect->x, rect->y, &path, NULL, NULL, NULL))
-            return FALSE;
-        model = gtk_tree_view_get_model(GTK_TREE_VIEW(tv));
-        gtk_tree_model_get_iter(model, &iter, path);
-        gtk_tree_model_get(model, &iter, CHAT_USERS_NAME_COLUMN, &name,
-                           -1);
-        gtk_tree_path_free(path);
-    } else if (type == TOOLTIP_IM) {
-        name = gtk_label_get_text(GTK_LABEL(tv));
-    } else
-        return FALSE;
-    
-    	
-
-
-    GaimBuddy *gb = g_new0(GaimBuddy, 1);
-    gb->name = g_strdup(name);
-    gb->account = gaym->account;
-    tooltiptext = prpl_info->tooltip_text(gb);
-    g_free(gb->name);
-    g_free(gb);
-
-    if (!tooltiptext) 
-        return FALSE;
-
-    
-    g_return_val_if_fail(tooltiptext != NULL, FALSE);
-
-    tipwindow = g_hash_table_lookup(popups, tv);
-    if (tipwindow) {
-        g_hash_table_remove(popups, tv);
-    }
-    tipwindow = gtk_window_new(GTK_WINDOW_POPUP);
-    g_hash_table_insert(popups, tv, tipwindow);
-
-    gtk_widget_set_app_paintable(tipwindow, TRUE);
-    gtk_window_set_resizable(GTK_WINDOW(tipwindow), FALSE);
-    gtk_widget_set_name(tipwindow, "gtk-tooltips");
-
-    struct paint_data *pdata = g_new0(struct paint_data, 1);
-    pdata->tooltiptext = tooltiptext;
-    pdata->pixbuf = lookup_cached_thumbnail(gaym->account, name);
-    g_signal_connect(G_OBJECT(tipwindow), "expose_event",
-                     G_CALLBACK(namelist_paint_tip), pdata);
-    gtk_widget_ensure_style(tipwindow);
-    layout = gtk_widget_create_pango_layout(tipwindow, NULL);
-    pango_layout_set_wrap(layout, PANGO_WRAP_WORD);
-    pango_layout_set_width(layout, 300000);
-    pango_layout_set_markup(layout, tooltiptext, strlen(tooltiptext));
-    pango_layout_get_size(layout, &w, &h);
-
-#if GTK_CHECK_VERSION(2,2,0)
-    gdk_display_get_pointer(gdk_display_get_default(), &screen, &x, &y,
-                            NULL);
-    mon_num = gdk_screen_get_monitor_at_point(screen, x, y);
-    gdk_screen_get_monitor_geometry(screen, mon_num, &mon_size);
-
-    scr_w = mon_size.width + mon_size.x;
-    scr_h = mon_size.height + mon_size.y;
-#else
-    scr_w = gdk_screen_width();
-    scr_h = gdk_screen_height();
-    gdk_window_get_pointer(NULL, &x, &y, NULL);
-    mon_size.x = 0;
-    mon_size.y = 0;
-#endif
-
-
-    w = PANGO_PIXELS(w) + 8;
-    h = PANGO_PIXELS(h) + 8;
-
-    /* 57 is the size of a large status icon plus 4 pixels padding on each 
-       side.  I should #define this or something */
-    w = w + gdk_pixbuf_get_width(pdata->pixbuf) + 4;
-    h = MAX(h, gdk_pixbuf_get_height(pdata->pixbuf)+4);
-
-#if GTK_CHECK_VERSION(2,2,0)
-    if (w > mon_size.width)
-        w = mon_size.width - 10;
-
-    if (h > mon_size.height)
-        h = mon_size.height - 10;
-#endif
-
-    // Find the conversation window here....
-    // if (GTK_WIDGET_NO_WINDOW(window))
-    // y+=window->allocation.y;
-
-    x -= ((w >> 1) + 4);
-
-    if ((y + h + 4) > scr_h || tooltip_top)
-        y = y - h - 5;
-    else
-        y = y + 6;
-
-    if (y < mon_size.y)
-        y = mon_size.y;
-
-    if (y != mon_size.y) {
-        if ((x + w) > scr_w)
-            x -= (x + w + 5) - scr_w;
-        else if (x < mon_size.x)
-            x = mon_size.x;
-    } else {
-        x -= (w / 2 + 10);
-        if (x < mon_size.x)
-            x = mon_size.x;
-    }
-
-    g_object_unref(layout);
-    gtk_widget_set_size_request(tipwindow, w, h);
-    gtk_window_move(GTK_WINDOW(tipwindow), x, y);
-    gtk_widget_show(tipwindow);
-
-    return FALSE;
-}
-
-
-static gboolean namelist_motion_cb(GtkWidget * tv, GdkEventMotion * event,
-                                   gpointer gaym)
-{
-    GtkTreeModel *ls = NULL;
-    GtkTreePath *path = NULL;
-    GtkTreeIter iter;
-    char *name;
-    static int count = 0;
-    gboolean tf;
-    GdkRectangle *rect;
-    guint *timeout;
-    count++;
-    guint delay;
-    rect = g_hash_table_lookup(popup_rects, tv);
-    g_return_val_if_fail(rect != NULL, FALSE);
-
-    timeout = g_hash_table_lookup(popup_timeouts, tv);
-
-    delay = gaim_prefs_get_int("/gaim/gtk/blist/tooltip_delay");
-
-    if (delay == 0)
-        return FALSE;
-
-    if (*timeout) {
-        if ((event->y > rect->y) && ((event->y - rect->height) < rect->y))
-            return FALSE;
-        /* We've left the cell.  Remove the timeout and create a new one
-           below */
-
-        g_hash_table_remove(popups, tv);
-        g_source_remove(*timeout);
-    }
-
-    gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(tv), event->x, event->y,
-                                  &path, NULL, NULL, NULL);
-    if (G_UNLIKELY(path == NULL))
-        return FALSE;
-    struct timeout_cb_data *timeout_data =
-        g_new0(struct timeout_cb_data, 1);
-    timeout_data->tv = tv;
-    timeout_data->gaym = gaym;
-    timeout_data->type = TOOLTIP_CHAT;
-    *timeout =
-        g_timeout_add(delay, (GSourceFunc) tooltip_timeout, timeout_data);
-
-    gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, rect);
-
-    ls = gtk_tree_view_get_model(GTK_TREE_VIEW(tv));
-    tf = gtk_tree_model_get_iter(ls, &iter, path);
-    gtk_tree_model_get(ls, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
-    gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, rect);
-
-    return TRUE;
-}
-
-static void tab_leave_cb(GtkWidget * event, GdkEventCrossing * e,
-                         gpointer conv)
-{
-    
-    GaimConversation *c = (GaimConversation *) conv;
-   
-    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-    // Prevent clicks from demolishing popup.
-    if (e->mode != GDK_CROSSING_NORMAL)
-        return;
-    GtkWidget *tab = gtkconv->tab_label;
-  
-    guint *timeout = g_hash_table_lookup(popup_timeouts, tab);
-    g_hash_table_remove(popups, tab);
-
-
-    if (timeout && *timeout) {
-        g_source_remove(*timeout);
-        *timeout = 0;
-    }
-}
-
-
-static gboolean tab_entry_cb(GtkWidget *event,
-                             GdkEventCrossing * crossing, gpointer conv)
-{
-
-    guint *timeout;
-    guint delay;
-    GaimConversation *c = (GaimConversation *) conv;
-    struct gaym_conn *gaym = gaim_conversation_get_gc(c)->proto_data;
-    
-    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-
-    GtkWidget *tab = gtkconv->tab_label;
-    timeout = g_hash_table_lookup(popup_timeouts, tab);
-
-    delay = gaim_prefs_get_int("/gaim/gtk/blist/tooltip_delay");
-
-    if (delay == 0)
-        return FALSE;
-
-    if (timeout && *timeout)
-        return FALSE;
-
-    // g_hash_table_remove(popups, tab);
-    // g_source_remove(*timeout);
-
-
-
-    struct timeout_cb_data *timeout_data =
-        g_new0(struct timeout_cb_data, 1);
-    timeout_data->tv = tab;
-    timeout_data->gaym = gaym;
-    timeout_data->type = TOOLTIP_IM;
-    *timeout =
-        g_timeout_add(delay, (GSourceFunc) tooltip_timeout, timeout_data);
-
-    return TRUE;
-}
-
-void add_chat_popup_stuff(GaimConversation * c)
-{
-
-    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-    GaimGtkChatPane *gtkchat = gtkconv->u.chat;
-    GaimConnection *gc = gaim_conversation_get_gc(c);
-
-    g_signal_connect(G_OBJECT(gtkchat->list), "motion-notify-event",
-                     G_CALLBACK(namelist_motion_cb), gc->proto_data);
-    g_signal_connect(G_OBJECT(gtkchat->list), "leave-notify-event",
-                     G_CALLBACK(namelist_leave_cb), NULL);
-
-
-    g_hash_table_insert(popup_rects, gtkchat->list,
-                        g_new0(GdkRectangle, 1));
-    g_hash_table_insert(popup_timeouts, gtkchat->list, g_new0(guint, 1));
-
-
-}
-
-void add_im_popup_stuff(GaimConversation * c)
-{
-    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-    GtkWidget *event = gtk_event_box_new();
-    GtkWidget *hbox = gtk_hbox_new(FALSE, 6);
-    
-    gtk_widget_ref(gtkconv->icon);
-    gtk_container_remove(GTK_CONTAINER(gtkconv->tabby),
-                         GTK_WIDGET(gtkconv->icon));
-    gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(gtkconv->icon), FALSE, FALSE, 0);
-    gtk_widget_ref(gtkconv->icon);
-    gtk_widget_unref(gtkconv->icon);
-
-    gtk_widget_ref(gtkconv->tab_label);
-    gtk_container_remove(GTK_CONTAINER(gtkconv->tabby),
-                         GTK_WIDGET(gtkconv->tab_label));
-    gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(gtkconv->tab_label), FALSE, FALSE, 0);
-    gtk_widget_unref(gtkconv->tab_label);
-    
-        
-    gtk_widget_add_events(event,
-                          GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK);
-    g_signal_connect(G_OBJECT(event), "enter-notify-event",
-                     G_CALLBACK(tab_entry_cb), c);
-    g_signal_connect(G_OBJECT(event), "leave-notify-event",
-                     G_CALLBACK(tab_leave_cb), c);
-    gtk_box_pack_start(GTK_BOX(gtkconv->tabby), GTK_WIDGET(event), TRUE,
-                       TRUE, 0);
-    gtk_box_reorder_child(GTK_BOX(gtkconv->tabby), GTK_WIDGET(event), 0);
-    gtk_widget_show(GTK_WIDGET(event));
-    gtk_widget_show(GTK_WIDGET(hbox));
-    gtk_event_box_set_visible_window(GTK_EVENT_BOX(event), FALSE);
-    gtk_container_add(GTK_CONTAINER(event),
-                      GTK_WIDGET(hbox));
-    g_hash_table_insert(popup_timeouts, gtkconv->tab_label,
-                        g_new0(guint, 1));
-}
-
-void init_popups()
-{
-    popup_rects =
-        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
-
-    popup_timeouts =
-        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
-
-    popups =
-        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL,
-                              (GDestroyNotify) gtk_widget_destroy);
-}

Deleted: qrc/trunk/gaym-extras/chaticon.c
===================================================================
--- qrc/trunk/gaym-extras/chaticon.c	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/chaticon.c	2005-07-30 21:32:57 UTC (rev 256)
@@ -1,203 +0,0 @@
-#include "gaym-extras.h"
-GHashTable *icons;
-void get_icon_scale_size(GdkPixbuf * icon, GaimBuddyIconSpec * spec,
-                    int *width, int *height)
-{
-    *width = gdk_pixbuf_get_width(icon);
-    *height = gdk_pixbuf_get_height(icon);
-    gaim_debug_misc("popups","current: w: %i, h: %i\n", *width,*height);
-    /* this should eventually get smarter about preserving the aspect
-       ratio when scaling, but gimmie a break, I just woke up */
-    if (spec && spec->scale_rules & GAIM_ICON_SCALE_DISPLAY) {
-        if (*width < spec->min_width)
-            *width = spec->min_width;
-        else if (*width > spec->max_width)
-            *width = spec->max_width;
-
-        if (*height < spec->min_height)
-            *height = spec->min_height;
-        else if (*height > spec->max_height)
-            *height = spec->max_height;
-    }
-
-    /* and now for some arbitrary sanity checks */
-    if (*width > 100)
-        *width = 100;
-    if (*height > 100)
-        *height = 100;
-    gaim_debug_misc("popups","scaled: w: %i, h: %i\n", *width,*height);
-}
-
-void gaym_update_thumbnail(GaimConversation * conv, GdkPixbuf* pixbuf) 
-{
-    GaimGtkConversation *gtkconv;
-
-    GdkPixbuf *scale;
-    GdkPixmap *pm=NULL;
-    GdkBitmap *bm=NULL;
-    int scale_width=0, 
-	scale_height=0;
-
-
-    GaimAccount *account;
-    GaimPluginProtocolInfo *prpl_info = NULL;
-    g_return_if_fail(conv != NULL);
-    g_return_if_fail(GAIM_IS_GTK_CONVERSATION(conv));
-    g_return_if_fail(gaim_conversation_get_type(conv) == GAIM_CONV_CHAT);
-
-    gtkconv = GAIM_GTK_CONVERSATION(conv);
-
-    GaymChatIcon *icon_data = g_hash_table_lookup(icons, conv);
-
-    if (!icon_data->show_icon)
-        return;
-
-    account = gaim_conversation_get_account(conv);
-    if (account && account->gc)
-        prpl_info = GAIM_PLUGIN_PROTOCOL_INFO(account->gc->prpl);
-
-    if (!gaim_prefs_get_bool
-        ("/gaim/gtk/conversations/im/show_buddy_icons"))
-        return;
-
-    if (gaim_conversation_get_gc(conv) == NULL)
-        return;
-
-
-
-    get_icon_scale_size(pixbuf,
-                        prpl_info ? &prpl_info->icon_spec : NULL,
-                        &scale_width, &scale_height);
-    //double aspect=(double)gdk_pixbuf_get_width(pixbuf)/(double)gdk_pixbuf_get_height(pixbuf); 
-
-    scale =
-        gdk_pixbuf_scale_simple(pixbuf,
-                                scale_width,
-                                scale_height,
-                                GDK_INTERP_BILINEAR);
-
-    gdk_pixbuf_render_pixmap_and_mask(scale, &pm, &bm, 100);
-    g_object_unref(G_OBJECT(scale));
-
-
-    icon_data->event = gtk_event_box_new();
-    gtk_container_add(GTK_CONTAINER(icon_data->frame), icon_data->event);
-    gtk_widget_set_size_request(GTK_WIDGET(icon_data->frame), 57,
-                                77);
-
-    //g_signal_connect(G_OBJECT(icon_data->event), "button-press-event",
-    //G_CALLBACK(icon_menu), conv);
-    gtk_widget_show(icon_data->event);
-    icon_data->icon = gtk_image_new_from_pixmap(pm, bm);
-    gtk_container_add(GTK_CONTAINER(icon_data->event), icon_data->icon);
-    gtk_widget_show(icon_data->icon);
-
-    if(pm)
-        g_object_unref(G_OBJECT(pm));
-
-    if (bm)
-        g_object_unref(G_OBJECT(bm));
-
-
-}
-
-
-static void changed_cb(GtkTreeSelection * selection, gpointer conv)
-{
-
-    g_return_if_fail(selection != NULL);
-    g_return_if_fail(conv != NULL);
-
-    GaimConversation *c = (GaimConversation *) conv;
-
-    GtkTreeIter iter;
-    GtkTreeModel *model=NULL;
-    GdkPixbuf *pixbuf=NULL;
-    gchar *name;
-
-    if (!gtk_tree_selection_get_selected(selection, &model, &iter))
-        return;
-
-    gtk_tree_model_get(model, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
-
-    /* Remove the current icon stuff */
-    GaymChatIcon *icon_data = g_hash_table_lookup(icons, c);
-    if (icon_data->event != NULL)
-        gtk_widget_destroy(icon_data->event);
-    icon_data->event = NULL;
-
-    gtk_widget_grab_focus(GTK_WIDGET(model)->parent);
-
-    pixbuf=lookup_cached_thumbnail(c->account, name);
- 
-    if(pixbuf)
-	gaym_update_thumbnail(c, pixbuf);
-    
-    g_object_unref(pixbuf);
-    return;
-
-}
-
-void add_chat_icon_stuff(GaimConversation * c)
-{
-
-    GtkTreeModel *ls;
-
-    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-    GaimGtkChatPane *gtkchat = gtkconv->u.chat;
-    GaimPluginProtocolInfo *prpl_info = NULL;
-    GaimAccount *account = gaim_conversation_get_account(c);
-    GaymChatIcon *icon_data = g_new0(GaymChatIcon, 1);
-
-    if (account && account->gc)
-        prpl_info = GAIM_PLUGIN_PROTOCOL_INFO(account->gc->prpl);
-    GtkTreeSelection *select =
-        gtk_tree_view_get_selection(GTK_TREE_VIEW(gtkchat->list));
-
-    gtk_tree_selection_set_mode(select, GTK_SELECTION_SINGLE);
-
-    ls = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
-
-    GtkBox *hbox = GTK_BOX(gtkconv->lower_hbox);
-
-    g_signal_connect(G_OBJECT(select), "changed", G_CALLBACK(changed_cb),
-                     c);
-
-    icon_data->icon_container_parent = GTK_WIDGET(hbox);
-    icon_data->icon_container = NULL;
-    icon_data->icon = NULL;
-    icon_data->show_icon = TRUE;
-    icon_data->icon_container = gtk_vbox_new(FALSE, 0);
-
-    gtk_widget_set_size_request(GTK_WIDGET(icon_data->icon_container),
-                                57,77);//prpl_info->icon_spec.max_width,
-                                //prpl_info->icon_spec.max_height);
-
-
-    icon_data->frame = gtk_frame_new(NULL);
-    gtk_frame_set_shadow_type(GTK_FRAME(icon_data->frame),
-                              (GTK_SHADOW_IN));
-    gtk_box_pack_start(GTK_BOX(icon_data->icon_container),
-                       icon_data->frame, FALSE, FALSE, 0);
-    gtk_widget_show(icon_data->icon_container);
-    gtk_widget_show(icon_data->frame);
-    gtk_box_pack_end(GTK_BOX(icon_data->icon_container_parent),
-                     icon_data->icon_container, FALSE, FALSE, 0);
-
-    icon_data->event = gtk_event_box_new();
-    gtk_container_add(GTK_CONTAINER(icon_data->frame), icon_data->event);
-
-    // Maybe add menu functionality later.
-    // g_signal_connect(G_OBJECT(icon_data->event), "button-press-event",
-    // G_CALLBACK(icon_menu), conv);
-    gtk_widget_show(icon_data->event);
-    g_hash_table_insert(icons, c, icon_data);
-
-
-}
-
-void init_chat_icons()
-{
-
-    icons = g_hash_table_new(g_direct_hash, g_direct_equal);
-}

Deleted: qrc/trunk/gaym-extras/chatsort.c
===================================================================
--- qrc/trunk/gaym-extras/chatsort.c	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/chatsort.c	2005-07-30 21:32:57 UTC (rev 256)
@@ -1,142 +0,0 @@
-#include "gaym-extras.h"
-
-static gint
-sort_chat_users_by_entry(GtkTreeModel * model, GtkTreeIter * a,
-                         GtkTreeIter * b, gpointer userdata)
-{
-    GaimConvChatBuddyFlags f1 = 0, f2 = 0;
-    char *user1 = NULL, *user2 = NULL;
-    gint ret = 0;
-
-    gtk_tree_model_get(model, a, CHAT_USERS_NAME_COLUMN, &user1,
-                       CHAT_USERS_FLAGS_COLUMN, &f1, -1);
-    gtk_tree_model_get(model, b, CHAT_USERS_NAME_COLUMN, &user2,
-                       CHAT_USERS_FLAGS_COLUMN, &f2, -1);
-
-    if (user1 == NULL || user2 == NULL) {
-        if (!(user1 == NULL && user2 == NULL))
-            ret = (user1 == NULL) ? -1 : 1;
-    } else if (f1 != f2) {
-        /* sort more important users first */
-        ret = (f1 > f2) ? -1 : 1;
-    } else {
-        ret = g_utf8_collate(user1, user2);
-    }
-
-    g_free(user1);
-    g_free(user2);
-    return ret;
-}
-
-static gint
-sort_chat_users_by_alpha(GtkTreeModel * model, GtkTreeIter * a,
-                         GtkTreeIter * b, gpointer userdata)
-{
-    char *user1 = NULL, *user2 = NULL;
-    gint ret = 0;
-
-    gtk_tree_model_get(model, a, CHAT_USERS_NAME_COLUMN, &user1, -1);
-    gtk_tree_model_get(model, b, CHAT_USERS_NAME_COLUMN, &user2, -1);
-
-    if (user1 == NULL || user2 == NULL) {
-        if (!(user1 == NULL && user2 == NULL))
-            ret = (user1 == NULL) ? -1 : 1;
-    } else {
-        ret = g_utf8_collate(user1, user2);
-    }
-
-    g_free(user1);
-    g_free(user2);
-    return ret;
-}
-
-
-static gint
-sort_chat_users_by_category(GtkTreeModel * model, GtkTreeIter * a,
-                            GtkTreeIter * b, gpointer userdata)
-{
-    GaimConvChatBuddyFlags f1 = 0, f2 = 0;
-    gint flag_mask = 0x000F;
-    char *user1 = NULL, *user2 = NULL;
-    gint ret = 0;
-
-    gtk_tree_model_get(model, a, CHAT_USERS_NAME_COLUMN, &user1,
-                       CHAT_USERS_FLAGS_COLUMN, &f1, -1);
-    gtk_tree_model_get(model, b, CHAT_USERS_NAME_COLUMN, &user2,
-                       CHAT_USERS_FLAGS_COLUMN, &f2, -1);
-
-    f1 = f1 & flag_mask;
-    f2 = f2 & flag_mask;
-
-    if (user1 == NULL || user2 == NULL) {
-        if (!(user1 == NULL && user2 == NULL))
-            ret = (user1 == NULL) ? -1 : 1;
-    } else if (f1 != f2) {
-        /* sort more important users first */
-        ret = (f1 > f2) ? -1 : 1;
-    } else {
-        ret = g_utf8_collate(user1, user2);
-    }
-
-    g_free(user1);
-    g_free(user2);
-    return ret;
-}
-
-
-
-void change_sort_order(GtkWidget * button, void *data)
-{
-
-    static GaymSortOrder order = SORT_ENTRY;
-
-
-    GtkTreeView *list = (GtkTreeView *) data;
-    GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(list));
-    gaim_debug_misc("chatsort", "list: %x, data: %x, model: %x\n", list,
-                    data, model);
-    if (order == SORT_ALPHA) {
-        order = SORT_CATEGORY;
-        gaim_debug_misc("chatsort", "Change to entry order");
-        gtk_button_set_label(GTK_BUTTON(button), "E");
-        gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model),
-                                        CHAT_USERS_NAME_COLUMN,
-                                        sort_chat_users_by_category, NULL,
-                                        NULL);
-    } else if (order == SORT_CATEGORY) {
-        order = SORT_ENTRY;
-        gaim_debug_misc("chatsort", "Change to category order");
-        gtk_button_set_label(GTK_BUTTON(button), "P");
-        gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model),
-                                        CHAT_USERS_NAME_COLUMN,
-                                        sort_chat_users_by_entry, NULL,
-                                        NULL);
-    } else {
-        order = SORT_ALPHA;
-        gaim_debug_misc("chatsort", "Change to alpha order");
-        gtk_button_set_label(GTK_BUTTON(button), "A");
-        gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model),
-                                        CHAT_USERS_NAME_COLUMN,
-                                        sort_chat_users_by_alpha, NULL,
-                                        NULL);
-    }
-
-}
-void add_chat_sort_functions(GaimConversation * c)
-{
-
-    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-    GaimGtkChatPane *gtkchat = gtkconv->u.chat;
-
-    GtkBox *iconbox = (GtkBox *) gtkconv->info->parent;
-    GtkWidget *button = gtk_button_new_with_label("E");
-    gtk_button_set_relief(GTK_BUTTON(button), GTK_RELIEF_NONE);
-    gtk_box_pack_end(iconbox, button, FALSE, FALSE, 0);
-    gtk_widget_show(button);
-    g_signal_connect(G_OBJECT(button), "clicked",
-                     G_CALLBACK(change_sort_order), gtkchat->list);
-    gaim_debug_misc("chatsort", "Connected signal with data %x\n",
-                    gtkchat->list);
-
-
-}

Deleted: qrc/trunk/gaym-extras/gaym-extras.c
===================================================================
--- qrc/trunk/gaym-extras/gaym-extras.c	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/gaym-extras.c	2005-07-30 21:32:57 UTC (rev 256)
@@ -1,88 +0,0 @@
-/* Show icons in chat room windows */
-
-
-#include "gaym-extras.h"
-
-
-#define GAYM_EXTRAS_PLUGIN_ID "gtk-gaym-extras"
-
-
-
-// Adds motion handlers to IM tab labels.
-static void redo_im_window(GaimConversation * c)
-{
-    if (!g_strrstr(gaim_account_get_protocol_id(c->account),"prpl-gaym"))
-	    return;
-    if (c && c->type == GAIM_CONV_IM)
-        add_im_popup_stuff(c);
-}
-
-
-static void update_info_cb(GaimAccount * account, char *name)
-{
-    if (!g_strrstr(gaim_account_get_protocol_id(account),"prpl-gaym"))
-	    return;
-    gaim_debug_misc("gaym-extras", "info update\n");
-}
-
-static void redochatwindow(GaimConversation * c)
-{
-    if (!g_strrstr(gaim_account_get_protocol_id(c->account),"prpl-gaym"))
-	    return;
-    add_chat_sort_functions(c);
-    add_chat_popup_stuff(c);
-    add_chat_icon_stuff(c);
-}
-
-static gboolean plugin_load(GaimPlugin * plugin)
-{
-    init_chat_icons();
-    init_popups();
-
-    gaim_signal_connect(gaim_conversations_get_handle(), "chat-joined",
-                        plugin, GAIM_CALLBACK(redochatwindow), NULL);
-
-    gaim_signal_connect(gaim_conversations_get_handle(),
-                        "conversation-created", plugin,
-                        GAIM_CALLBACK(redo_im_window), NULL);
-
-    gaim_signal_connect(gaim_accounts_get_handle(), "info-updated", plugin,
-                        GAIM_CALLBACK(update_info_cb), NULL);
-
-    gaim_signal_connect(gaim_conversations_get_handle(),
-                        "deleting-conversation", plugin,
-                        GAIM_CALLBACK(clean_popup_stuff), NULL);
-
-
-    return TRUE;
-}
-
-static GaimPluginInfo info = {
-    GAIM_PLUGIN_MAGIC,
-    GAIM_MAJOR_VERSION,
-    GAIM_MINOR_VERSION,
-    GAIM_PLUGIN_STANDARD,
-    GAIM_GTK_PLUGIN_TYPE,
-    0,
-    NULL,
-    GAIM_PRIORITY_DEFAULT,
-    GAYM_EXTRAS_PLUGIN_ID,
-    N_("Gaym Extras"),
-    VERSION,
-    N_("GUI-related additions for the gaym protocol plugin."),
-    N_("Current functionality provided by this plugin:\n1. Allows namelist sort order in rooms to be changed.\n2. Shows thumbnails for currently selected user in rooms.\n3. Popup displays bio when you hover over a name in the namelist.\n4. Popup shows bio when you hover over an IM tab."),
-    "Jason LeBrun gaym at jasonlebrun.info",
-    GAIM_WEBSITE,
-    plugin_load,
-    NULL,
-    NULL,
-    NULL,
-    NULL,
-    NULL
-};
-
-static void init_plugin(GaimPlugin * plugin)
-{
-}
-
-GAIM_INIT_PLUGIN(history, init_plugin, info)

Deleted: qrc/trunk/gaym-extras/gaym-extras.h
===================================================================
--- qrc/trunk/gaym-extras/gaym-extras.h	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/gaym-extras.h	2005-07-30 21:32:57 UTC (rev 256)
@@ -1,69 +0,0 @@
-#include "internal.h"
-#include "gtkgaim.h"
-
-#include "conversation.h"
-#include "debug.h"
-#include "prefs.h"
-#include "signals.h"
-#include "util.h"
-#include "version.h"
-#include "buddyicon.h"
-#include "prpl.h"
-
-#include "gtkconv.h"
-#include "gtkplugin.h"
-
-#include "../gaym/src/gaym.h"
-struct fetch_thumbnail_data {
-    const char *who;
-    char *pic_data;
-    gint pic_data_len;
-    gboolean from_file;
-};
-
-struct paint_data {
-    char *tooltiptext;
-    GdkPixbuf* pixbuf;
-};
-
-// Additional UI info for a conversation.
-// We may be able to clean this up, some.
-typedef struct _GaymChatIcon {
-
-    GaimConversation *conv;
-    GtkWidget *icon_container_parent;
-    GtkWidget *icon_container;
-    GtkWidget *frame;
-    GtkWidget *icon;
-    GtkWidget *event;
-    gboolean show_icon;
-
-} GaymChatIcon;
-
-typedef enum {
-    SORT_ALPHA,
-    SORT_ENTRY,
-    SORT_CATEGORY,
-} GaymSortOrder;
-
-typedef enum {
-    TOOLTIP_CHAT,
-    TOOLTIP_IM,
-} GaymTooltipType;
-
-struct timeout_cb_data {
-    GaymTooltipType type;
-    GtkWidget *tv;
-    struct gaym_conn *gaym;
-};
-
-
-GdkPixbuf* lookup_cached_thumbnail(GaimAccount* account, const char*fullname);
-void get_icon_scale_size(GdkPixbuf* icon, GaimBuddyIconSpec * spec,int *width, int *height);
-void clean_popup_stuff(GaimConversation * c);
-void add_chat_icon_stuff(GaimConversation *c);
-void add_chat_popup_stuff(GaimConversation *c);
-void add_chat_sort_functions(GaimConversation *c);
-void add_im_popup_stuff(GaimConversation* c);
-void init_chat_icons();
-void init_popups();

Added: qrc/trunk/gaym-extras/pixmaps/Makefile
===================================================================
--- qrc/trunk/gaym-extras/pixmaps/Makefile	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/pixmaps/Makefile	2005-07-30 21:32:57 UTC (rev 256)
@@ -0,0 +1,380 @@
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# gaym-extras/pixmaps/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+srcdir = .
+top_srcdir = ../..
+
+pkgdatadir = $(datadir)/qrc
+pkglibdir = $(libdir)/qrc
+pkgincludedir = $(includedir)/qrc
+top_builddir = ../..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = /bin/install -c
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = i686-pc-linux-gnu
+host_triplet = i686-pc-linux-gnu
+target_triplet = i686-pc-linux-gnu
+subdir = gaym-extras/pixmaps
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(gaymsortpixdir)"
+gaymsortpixDATA_INSTALL = $(INSTALL_DATA)
+DATA = $(gaymsortpix_DATA)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = ${SHELL} /home/jason/packages/qrc-dev/missing --run aclocal-1.9
+AMDEP_FALSE = #
+AMDEP_TRUE = 
+AMTAR = ${SHELL} /home/jason/packages/qrc-dev/missing --run tar
+AR = ar
+AS = as
+AUTOCONF = ${SHELL} /home/jason/packages/qrc-dev/missing --run autoconf
+AUTOHEADER = ${SHELL} /home/jason/packages/qrc-dev/missing --run autoheader
+AUTOMAKE = ${SHELL} /home/jason/packages/qrc-dev/missing --run automake-1.9
+AWK = gawk
+CC = gcc
+CCDEPMODE = depmode=gcc3
+CFLAGS = -g -O2 -Wall -g3
+COND_BOT_CHALLENGER_FALSE = #
+COND_BOT_CHALLENGER_TRUE = 
+COND_GAYM_EXTRAS_FALSE = #
+COND_GAYM_EXTRAS_TRUE = 
+COND_GAYM_FALSE = #
+COND_GAYM_TRUE = 
+CPP = gcc -E
+CPPFLAGS = 
+CXX = g++
+CXXCPP = g++ -E
+CXXDEPMODE = depmode=gcc3
+CXXFLAGS = -g -O2
+CYGPATH_W = echo
+DEFS = -DHAVE_CONFIG_H
+DEPDIR = .deps
+DLLTOOL = dlltool
+ECHO = echo
+ECHO_C = 
+ECHO_N = -n
+ECHO_T = 
+EGREP = grep -E
+EXEEXT = 
+F77 = g77
+FFLAGS = -g -O2
+GAIM_CFLAGS = -I/usr/local/include/gaim -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include  
+GAIM_DATADIR = /usr/local/share
+GAIM_LIBDIR = /usr/local/lib
+GAIM_LIBS = -lglib-2.0  
+GTK_CFLAGS = -DXTHREADS -D_REENTRANT -DXUSE_MTSAFE_API -I/usr/include/gtk-2.0 -I/usr/lib/gtk-2.0/include -I/usr/include/atk-1.0 -I/usr/include/pango-1.0 -I/usr/include/freetype2 -I/usr/include/freetype2/config -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include  
+GTK_LIBS = -lgtk-x11-2.0 -lgdk-x11-2.0 -latk-1.0 -lgdk_pixbuf-2.0 -lm -lpangoxft-1.0 -lpangox-1.0 -lpango-1.0 -lgobject-2.0 -lgmodule-2.0 -ldl -lglib-2.0  
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
+LDFLAGS = 
+LIBOBJS = 
+LIBS = 
+LIBTOOL = $(SHELL) $(top_builddir)/libtool --silent
+LN_S = ln -s
+LTLIBOBJS = 
+MAKEINFO = ${SHELL} /home/jason/packages/qrc-dev/missing --run makeinfo
+OBJDUMP = objdump
+OBJEXT = o
+PACKAGE = qrc
+PACKAGE_BUGREPORT = gaymplugin at yahoogroups.com
+PACKAGE_NAME = qrc
+PACKAGE_STRING = qrc 0.34.1+svn
+PACKAGE_TARNAME = qrc
+PACKAGE_VERSION = 0.34.1+svn
+PATH_SEPARATOR = :
+PKG_CONFIG = /usr/bin/pkg-config
+RANLIB = ranlib
+REQUIRED_GAIM = gaim >= 1.2 gaim < 2.0
+REQUIRED_GTK = gtk+-2.0
+REQUIRED_PKG_CONFIG = 0.15.0
+SET_MAKE = 
+SHELL = /bin/sh
+STRIP = strip
+VERSION = 0.34.1+svn
+ac_ct_AR = ar
+ac_ct_AS = 
+ac_ct_CC = gcc
+ac_ct_CXX = g++
+ac_ct_DLLTOOL = 
+ac_ct_F77 = g77
+ac_ct_OBJDUMP = 
+ac_ct_RANLIB = ranlib
+ac_ct_STRIP = strip
+ac_pt_PKG_CONFIG = 
+am__fastdepCC_FALSE = #
+am__fastdepCC_TRUE = 
+am__fastdepCXX_FALSE = #
+am__fastdepCXX_TRUE = 
+am__include = include
+am__leading_dot = .
+am__quote = 
+am__tar = ${AMTAR} chof - "$$tardir"
+am__untar = ${AMTAR} xf -
+bindir = ${exec_prefix}/bin
+build = i686-pc-linux-gnu
+build_alias = 
+build_cpu = i686
+build_os = linux-gnu
+build_vendor = pc
+datadir = ${prefix}/share
+exec_prefix = ${prefix}
+host = i686-pc-linux-gnu
+host_alias = 
+host_cpu = i686
+host_os = linux-gnu
+host_vendor = pc
+includedir = ${prefix}/include
+infodir = ${prefix}/info
+install_sh = /home/jason/packages/qrc-dev/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+localstatedir = ${prefix}/var
+mandir = ${prefix}/man
+mkdir_p = mkdir -p --
+oldincludedir = /usr/include
+prefix = /usr/local
+program_transform_name = s,x,x,
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+sysconfdir = ${prefix}/etc
+target = i686-pc-linux-gnu
+target_alias = 
+target_cpu = i686
+target_os = linux-gnu
+target_vendor = pc
+EXTRA_DIST = \
+	alpha.png \
+	entry.png \
+	pic.png 
+
+gaymsortpixdir = \
+	$(GAIM_DATADIR)/pixmaps/gaim/gaym
+
+gaymsortpix_DATA = \
+	alpha.png\
+	entry.png\
+	pic.png
+
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  gaym-extras/pixmaps/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  gaym-extras/pixmaps/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+install-gaymsortpixDATA: $(gaymsortpix_DATA)
+	@$(NORMAL_INSTALL)
+	test -z "$(gaymsortpixdir)" || $(mkdir_p) "$(DESTDIR)$(gaymsortpixdir)"
+	@list='$(gaymsortpix_DATA)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(gaymsortpixDATA_INSTALL) '$$d$$p' '$(DESTDIR)$(gaymsortpixdir)/$$f'"; \
+	  $(gaymsortpixDATA_INSTALL) "$$d$$p" "$(DESTDIR)$(gaymsortpixdir)/$$f"; \
+	done
+
+uninstall-gaymsortpixDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(gaymsortpix_DATA)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(gaymsortpixdir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(gaymsortpixdir)/$$f"; \
+	done
+tags: TAGS
+TAGS:
+
+ctags: CTAGS
+CTAGS:
+
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(DATA)
+installdirs:
+	for dir in "$(DESTDIR)$(gaymsortpixdir)"; do \
+	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-libtool
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-gaymsortpixDATA
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-gaymsortpixDATA uninstall-info-am
+
+.PHONY: all all-am check check-am clean clean-generic clean-libtool \
+	distclean distclean-generic distclean-libtool distdir dvi \
+	dvi-am html html-am info info-am install install-am \
+	install-data install-data-am install-exec install-exec-am \
+	install-gaymsortpixDATA install-info install-info-am \
+	install-man install-strip installcheck installcheck-am \
+	installdirs maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \
+	ps ps-am uninstall uninstall-am uninstall-gaymsortpixDATA \
+	uninstall-info-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: qrc/trunk/gaym-extras/pixmaps/Makefile.am
===================================================================
--- qrc/trunk/gaym-extras/pixmaps/Makefile.am	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/pixmaps/Makefile.am	2005-07-30 21:32:57 UTC (rev 256)
@@ -0,0 +1,15 @@
+EXTRA_DIST = \
+	alpha.png \
+	entry.png \
+	pic.png 
+
+gaymsortpixdir = \
+	$(GAIM_DATADIR)/pixmaps/gaim/gaym
+
+gaymsortpix_DATA = \
+	alpha.png\
+	entry.png\
+	pic.png
+
+
+

Added: qrc/trunk/gaym-extras/pixmaps/Makefile.in
===================================================================
--- qrc/trunk/gaym-extras/pixmaps/Makefile.in	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/pixmaps/Makefile.in	2005-07-30 21:32:57 UTC (rev 256)
@@ -0,0 +1,380 @@
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+ at SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+subdir = gaym-extras/pixmaps
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(gaymsortpixdir)"
+gaymsortpixDATA_INSTALL = $(INSTALL_DATA)
+DATA = $(gaymsortpix_DATA)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+COND_BOT_CHALLENGER_FALSE = @COND_BOT_CHALLENGER_FALSE@
+COND_BOT_CHALLENGER_TRUE = @COND_BOT_CHALLENGER_TRUE@
+COND_GAYM_EXTRAS_FALSE = @COND_GAYM_EXTRAS_FALSE@
+COND_GAYM_EXTRAS_TRUE = @COND_GAYM_EXTRAS_TRUE@
+COND_GAYM_FALSE = @COND_GAYM_FALSE@
+COND_GAYM_TRUE = @COND_GAYM_TRUE@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GAIM_CFLAGS = @GAIM_CFLAGS@
+GAIM_DATADIR = @GAIM_DATADIR@
+GAIM_LIBDIR = @GAIM_LIBDIR@
+GAIM_LIBS = @GAIM_LIBS@
+GTK_CFLAGS = @GTK_CFLAGS@
+GTK_LIBS = @GTK_LIBS@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PKG_CONFIG = @PKG_CONFIG@
+RANLIB = @RANLIB@
+REQUIRED_GAIM = @REQUIRED_GAIM@
+REQUIRED_GTK = @REQUIRED_GTK@
+REQUIRED_PKG_CONFIG = @REQUIRED_PKG_CONFIG@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_AS = @ac_ct_AS@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_DLLTOOL = @ac_ct_DLLTOOL@
+ac_ct_F77 = @ac_ct_F77@
+ac_ct_OBJDUMP = @ac_ct_OBJDUMP@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_pt_PKG_CONFIG = @ac_pt_PKG_CONFIG@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+EXTRA_DIST = \
+	alpha.png \
+	entry.png \
+	pic.png 
+
+gaymsortpixdir = \
+	$(GAIM_DATADIR)/pixmaps/gaim/gaym
+
+gaymsortpix_DATA = \
+	alpha.png\
+	entry.png\
+	pic.png
+
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  gaym-extras/pixmaps/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  gaym-extras/pixmaps/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+install-gaymsortpixDATA: $(gaymsortpix_DATA)
+	@$(NORMAL_INSTALL)
+	test -z "$(gaymsortpixdir)" || $(mkdir_p) "$(DESTDIR)$(gaymsortpixdir)"
+	@list='$(gaymsortpix_DATA)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(gaymsortpixDATA_INSTALL) '$$d$$p' '$(DESTDIR)$(gaymsortpixdir)/$$f'"; \
+	  $(gaymsortpixDATA_INSTALL) "$$d$$p" "$(DESTDIR)$(gaymsortpixdir)/$$f"; \
+	done
+
+uninstall-gaymsortpixDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(gaymsortpix_DATA)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(gaymsortpixdir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(gaymsortpixdir)/$$f"; \
+	done
+tags: TAGS
+TAGS:
+
+ctags: CTAGS
+CTAGS:
+
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(DATA)
+installdirs:
+	for dir in "$(DESTDIR)$(gaymsortpixdir)"; do \
+	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-libtool
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-gaymsortpixDATA
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-gaymsortpixDATA uninstall-info-am
+
+.PHONY: all all-am check check-am clean clean-generic clean-libtool \
+	distclean distclean-generic distclean-libtool distdir dvi \
+	dvi-am html html-am info info-am install install-am \
+	install-data install-data-am install-exec install-exec-am \
+	install-gaymsortpixDATA install-info install-info-am \
+	install-man install-strip installcheck installcheck-am \
+	installdirs maintainer-clean maintainer-clean-generic \
+	mostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \
+	ps ps-am uninstall uninstall-am uninstall-gaymsortpixDATA \
+	uninstall-info-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: qrc/trunk/gaym-extras/pixmaps/alpha.png
===================================================================
(Binary files differ)


Property changes on: qrc/trunk/gaym-extras/pixmaps/alpha.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: qrc/trunk/gaym-extras/pixmaps/entry.png
===================================================================
(Binary files differ)


Property changes on: qrc/trunk/gaym-extras/pixmaps/entry.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: qrc/trunk/gaym-extras/pixmaps/pic.png
===================================================================
(Binary files differ)


Property changes on: qrc/trunk/gaym-extras/pixmaps/pic.png
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Deleted: qrc/trunk/gaym-extras/roombrowse.c
===================================================================
--- qrc/trunk/gaym-extras/roombrowse.c	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/roombrowse.c	2005-07-30 21:32:57 UTC (rev 256)
@@ -1,435 +0,0 @@
-/* Puts last 4k of log in new conversations a la Everybuddy (and then
-   stolen by Trillian "Pro") */
-
-#include "internal.h"
-#include "gtkgaim.h"
-
-#include "conversation.h"
-#include "debug.h"
-#include "log.h"
-#include "prefs.h"
-#include "signals.h"
-#include "util.h"
-#include "version.h"
-#include "prpl.h"
-
-#include "gtkconv.h"
-#include "gtkimhtml.h"
-#include "gtkplugin.h"
-#include "gtkdialogs.h"
-#include "gtkutils.h"
-#include "gtkblist.h"
-#include "gtkimhtmltoolbar.h"
-#include <gdk/gdkkeysyms.h>
-
-#define CHATSORT_PLUGIN_ID "gtk-chatsort"
-#define CHATSORT_USERS_COLUMNS 4
-#define CHATSORT_USERS_ENTRY_COLUMN 3
-
-/**
- * Unused variables:
- *
- * static GList *browsers = NULL;
- */
-
-struct RoomBrowseInfo {
-
-    GaimAccount *account;
-    GaimConnection *gc;
-};
-
-static GtkWidget *setup_roombrowse_pane(GaimConversation * conv)
-{
-    GaimGtkConversation *gtkconv;
-    GaimGtkChatPane *gtkchat;
-    GaimConnection *gc;
-    GtkWidget *vpaned, *hpaned;
-    GtkWidget *vbox;
-
-        /**
-	 * Unused variables:
-	 *
-	 * GaimPluginProtocolInfo *prpl_info = NULL;
-	 * GtkWidget *hbox;
-	 * GtkWidget *lbox, *bbox;
-	 * GtkWidget *label;
-	 * GtkWidget *list;
-	 * GtkWidget *button;
-	 * GtkWidget *sw;
-	 * GtkListStore *ls;
-	 * GtkCellRenderer *rend;
-	 * GtkTreeViewColumn *col;
-	 * GList *focus_chain = NULL;
-	 */
-
-    gtkconv = GAIM_GTK_CONVERSATION(conv);
-    gtkchat = gtkconv->u.chat;
-    gc = gaim_conversation_get_gc(conv);
-
-    /* Setup the outer pane. */
-    vpaned = gtk_vpaned_new();
-    gtk_widget_show(vpaned);
-    /* Setup the top part of the pane. */
-    vbox = gtk_vbox_new(FALSE, 6);
-    gtk_paned_pack1(GTK_PANED(vpaned), vbox, TRUE, TRUE);
-    gtk_widget_show(vbox);
-
-    /* Setup the horizontal pane. */
-    hpaned = gtk_hpaned_new();
-    gtk_box_pack_start(GTK_BOX(vbox), hpaned, TRUE, TRUE, 0);
-    gtk_widget_show(hpaned);
-
-    /* Setup the scrolled window to put gtkimhtml in. */
-    gtkconv->sw = gtk_scrolled_window_new(NULL, NULL);
-    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(gtkconv->sw),
-                                   GTK_POLICY_AUTOMATIC,
-                                   GTK_POLICY_ALWAYS);
-    gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(gtkconv->sw),
-                                        GTK_SHADOW_IN);
-    gtk_paned_pack1(GTK_PANED(hpaned), gtkconv->sw, TRUE, TRUE);
-
-    gtk_widget_set_size_request(gtkconv->sw,
-                                gaim_prefs_get_int
-                                ("/gaim/gtk/conversations/chat/default_width"),
-                                gaim_prefs_get_int
-                                ("/gaim/gtk/conversations/chat/default_height"));
-
-    // g_signal_connect(G_OBJECT(gtkconv->sw), "size-allocate",
-    // G_CALLBACK(size_allocate_cb), conv);
-
-    gtk_widget_show(gtkconv->sw);
-
-    return vpaned;
-}
-
-static gint close_conv_cb(GtkWidget * w, gpointer d)
-{
-    GaimConversation *conv = (GaimConversation *) d;
-
-    gaim_conversation_destroy(conv);
-
-    return TRUE;
-}
-
-GdkPixbuf *get_tab_icon(GaimConversation * conv, gboolean small_icon)
-{
-    GaimAccount *account = NULL;
-    const char *name = NULL;
-    GdkPixbuf *status = NULL;
-
-    g_return_val_if_fail(conv != NULL, NULL);
-
-    account = gaim_conversation_get_account(conv);
-    name = gaim_conversation_get_name(conv);
-
-    g_return_val_if_fail(account != NULL, NULL);
-    g_return_val_if_fail(name != NULL, NULL);
-
-
-    if (gaim_conversation_get_type(conv) == GAIM_CONV_IM) {
-        GaimBuddy *b = gaim_find_buddy(account, name);
-        if (b != NULL) {
-            status = gaim_gtk_blist_get_status_icon((GaimBlistNode *) b,
-                                                    (small_icon ?
-                                                     GAIM_STATUS_ICON_SMALL
-                                                     :
-                                                     GAIM_STATUS_ICON_LARGE));
-        }
-    }
-
-    if (!status) {
-        GdkPixbuf *pixbuf;
-        pixbuf = create_prpl_icon(account);
-
-        if (small_icon && pixbuf != NULL) {
-            status = gdk_pixbuf_scale_simple(pixbuf, 15, 15,
-                                             GDK_INTERP_BILINEAR);
-            g_object_unref(pixbuf);
-        } else
-            status = pixbuf;
-    }
-    return status;
-}
-
-/**
- * Unused function
- */
-#if 0
-static void update_tab_icon(GaimConversation * conv)
-{
-    GaimGtkConversation *gtkconv;
-    GaimConvWindow *win = gaim_conversation_get_window(conv);
-    GaimAccount *account;
-    const char *name;
-    GdkPixbuf *status = NULL;
-
-    g_return_if_fail(conv != NULL);
-
-    gtkconv = GAIM_GTK_CONVERSATION(conv);
-    name = gaim_conversation_get_name(conv);
-    account = gaim_conversation_get_account(conv);
-
-    status = get_tab_icon(conv, TRUE);
-
-    g_return_if_fail(status != NULL);
-
-    gtk_image_set_from_pixbuf(GTK_IMAGE(gtkconv->icon), status);
-    gtk_image_set_from_pixbuf(GTK_IMAGE(gtkconv->menu_icon), status);
-
-    if (status != NULL)
-        g_object_unref(status);
-
-    if (gaim_conv_window_get_active_conversation(win) == conv &&
-        gtkconv->u.im->anim == NULL) {
-        status = get_tab_icon(conv, FALSE);
-
-        gtk_window_set_icon(GTK_WINDOW(GAIM_GTK_WINDOW(win)->window),
-                            status);
-
-        if (status != NULL)
-            g_object_unref(status);
-    }
-}
-#endif
-
-/* Courtesy of Galeon! */
-static void
-tab_close_button_state_changed_cb(GtkWidget * widget,
-                                  GtkStateType prev_state)
-{
-    if (GTK_WIDGET_STATE(widget) == GTK_STATE_ACTIVE)
-        gtk_widget_set_state(widget, GTK_STATE_NORMAL);
-}
-
-static void
-roombrowse_gtk_add_conversation(GaimConvWindow * win,
-                                GaimConversation * conv)
-{
-    GaimGtkWindow *gtkwin;
-    GaimGtkConversation *gtkconv, *focus_gtkconv;
-    GaimConversation *focus_conv;
-    GtkWidget *pane = NULL;
-    GtkWidget *tab_cont;
-    GtkWidget *tabby, *menu_tabby;
-    GtkWidget *close_image;
-    gboolean new_ui;
-    GaimConversationType conv_type;
-    const char *name;
-
-    name = gaim_conversation_get_name(conv);
-    conv_type = gaim_conversation_get_type(conv);
-    gtkwin = GAIM_GTK_WINDOW(win);
-
-    if (conv->ui_data != NULL) {
-        gtkconv = (GaimGtkConversation *) conv->ui_data;
-
-        tab_cont = gtkconv->tab_cont;
-
-        new_ui = FALSE;
-    } else {
-        gtkconv = g_malloc0(sizeof(GaimGtkConversation));
-        conv->ui_data = gtkconv;
-
-        /* Setup some initial variables. */
-        gtkconv->sg = gtk_size_group_new(GTK_SIZE_GROUP_BOTH);
-        gtkconv->tooltips = gtk_tooltips_new();
-
-        gaim_debug_misc("roombrowse", "setting up pane\n");
-        pane = setup_roombrowse_pane(conv);
-
-        gaim_debug_misc("roombrowse", "set up pane\n");
-
-        if (pane == NULL) {
-            g_free(gtkconv);
-            conv->ui_data = NULL;
-
-            return;
-        }
-
-
-
-        /* Setup the container for the tab. */
-        gtkconv->tab_cont = tab_cont = gtk_vbox_new(FALSE, 6);
-        gtk_container_set_border_width(GTK_CONTAINER(tab_cont), 6);
-        gtk_container_add(GTK_CONTAINER(tab_cont), pane);
-        gtk_widget_show(pane);
-
-        new_ui = TRUE;
-
-        gtkconv->make_sound = FALSE;
-        gtkconv->show_formatting_toolbar = FALSE;
-        gtkconv->show_timestamps = FALSE;
-
-        g_signal_connect_swapped(G_OBJECT(pane), "focus",
-                                 G_CALLBACK(gtk_widget_grab_focus),
-                                 gtkconv->entry);
-    }
-
-    gaim_debug_misc("roombrowse", "Setting up tabs\n");
-    gtkconv->tabby = tabby = gtk_hbox_new(FALSE, 6);
-    gtkconv->menu_tabby = menu_tabby = gtk_hbox_new(FALSE, 6);
-    gtkconv->entry = gtk_imhtml_new(NULL, NULL);
-    gtkconv->toolbar = gtk_imhtmltoolbar_new();
-
-    gaim_debug_misc("roombrowse", "Setting up close button\n");
-    /* Close button. */
-    gtkconv->close = gtk_button_new();
-    gtk_widget_set_size_request(GTK_WIDGET(gtkconv->close), 16, 16);
-    gtk_button_set_relief(GTK_BUTTON(gtkconv->close), GTK_RELIEF_NONE);
-    close_image =
-        gtk_image_new_from_stock(GTK_STOCK_CLOSE, GTK_ICON_SIZE_MENU);
-    gtk_widget_show(close_image);
-    gtk_container_add(GTK_CONTAINER(gtkconv->close), close_image);
-    gtk_tooltips_set_tip(gtkconv->tooltips, gtkconv->close,
-                         _("Close conversation"), NULL);
-
-    g_signal_connect(G_OBJECT(gtkconv->close), "clicked",
-                     G_CALLBACK(close_conv_cb), conv);
-
-    /* 
-     * I love Galeon. They have a fix for that stupid annoying visible
-     * border bug. I love you guys! -- ChipX86
-     */
-    g_signal_connect(G_OBJECT(gtkconv->close), "state_changed",
-                     G_CALLBACK(tab_close_button_state_changed_cb), NULL);
-
-    /* Status icon. */
-    gtkconv->icon = gtk_image_new();
-    gtkconv->menu_icon = gtk_image_new();
-    // update_tab_icon(conv);
-
-    /* Tab label. */
-    gtkconv->tab_label = gtk_label_new(gaim_conversation_get_title(conv));
-    gtkconv->menu_label = gtk_label_new(gaim_conversation_get_title(conv));
-#if 0
-    gtk_misc_set_alignment(GTK_MISC(gtkconv->tab_label), 0.00, 0.5);
-    gtk_misc_set_padding(GTK_MISC(gtkconv->tab_label), 4, 0);
-#endif
-
-    gaim_debug_misc("roombrowse", "Packing\n");
-    /* Pack it all together. */
-    gtk_box_pack_start(GTK_BOX(tabby), gtkconv->icon, FALSE, FALSE, 0);
-    gtk_box_pack_start(GTK_BOX(menu_tabby), gtkconv->menu_icon,
-                       FALSE, FALSE, 0);
-
-    gtk_widget_show_all(gtkconv->icon);
-    gtk_widget_show_all(gtkconv->menu_icon);
-
-    gtk_box_pack_start(GTK_BOX(tabby), gtkconv->tab_label, TRUE, TRUE, 0);
-    gtk_box_pack_start(GTK_BOX(menu_tabby), gtkconv->menu_label, TRUE,
-                       TRUE, 0);
-    gtk_widget_show(gtkconv->tab_label);
-    gtk_widget_show(gtkconv->menu_label);
-    gtk_misc_set_alignment(GTK_MISC(gtkconv->menu_label), 0, 0);
-
-    gtk_box_pack_start(GTK_BOX(tabby), gtkconv->close, FALSE, FALSE, 0);
-    if (gaim_prefs_get_bool("/gaim/gtk/conversations/close_on_tabs"))
-        gtk_widget_show(gtkconv->close);
-
-    gtk_widget_show(tabby);
-    gtk_widget_show(menu_tabby);
-
-    if (gaim_conversation_get_type(conv) == GAIM_CONV_IM)
-        gaim_gtkconv_update_buddy_icon(conv);
-
-    gaim_debug_misc("roombrowse", "Adding to notebook\n");
-    gaim_debug_misc("roombrowse", "gtkwin->notebook=%x\n",
-                    gtkwin->notebook);
-    gaim_debug_misc("roombrowse", "gtkwin=%x\n", gtkwin);
-    gaim_debug_misc("roombrowse", "tabby=%x\n", tabby);
-    gaim_debug_misc("roombrowse", "menu_tabby=%x\n", menu_tabby);
-    gaim_debug_misc("roombrowse", "tab_cont=%x\n", tab_cont);
-
-    /* Add this pane to the conversation's notebook. */
-    int n = gtk_notebook_get_n_pages(GTK_NOTEBOOK(gtkwin->notebook));
-    gaim_debug_misc("roombrowse:", "Notebook has %d pages\n", n);
-    gtk_notebook_append_page_menu(GTK_NOTEBOOK(gtkwin->notebook), tab_cont,
-                                  tabby, menu_tabby);
-    gaim_debug_misc("roombrowse", "Got through append_page_menu\n");
-    gtk_widget_show(tab_cont);
-
-    if (gaim_conv_window_get_conversation_count(win) == 1) {
-        /* Er, bug in notebooks? Switch to the page manually. */
-        gtk_notebook_set_current_page(GTK_NOTEBOOK(gtkwin->notebook), 0);
-
-        gtk_notebook_set_show_tabs(GTK_NOTEBOOK(gtkwin->notebook),
-                                   gaim_prefs_get_bool
-                                   ("/gaim/gtk/conversations/tabs"));
-    } else
-        gtk_notebook_set_show_tabs(GTK_NOTEBOOK(gtkwin->notebook), TRUE);
-    gaim_debug_misc("roombrowse", "FOcus stuff\n");
-    focus_conv = g_list_nth_data(gaim_conv_window_get_conversations(win),
-                                 gtk_notebook_get_current_page(GTK_NOTEBOOK
-                                                               (gtkwin->
-                                                                notebook)));
-    focus_gtkconv = GAIM_GTK_CONVERSATION(focus_conv);
-    gtk_widget_grab_focus(focus_gtkconv->entry);
-
-    if (!new_ui)
-        g_object_unref(gtkconv->tab_cont);
-}
-
-
-static void roombrowse_menu_cb(GaimBlistNode * node, gpointer data)
-{
-    GaimConvWindow *win = gaim_get_first_window_with_type(GAIM_CONV_MISC);
-    GaimConversation *conv = g_new0(GaimConversation, 1);
-
-    GaimAccount *account = ((GaimChat *) node)->account;
-    if (!win)
-        win = gaim_conv_window_new();
-    GaimChat *chat = ((GaimChat *) node);
-    char *room = g_strdup(g_hash_table_lookup(chat->components, "name"));
-
-
-    gaim_debug_misc("roombrowser", "In cb with node=%x, account=%x\n",
-                    node, account);
-    conv = gaim_conversation_new(GAIM_CONV_MISC, account, room);
-
-    gaim_conversation_set_logging(conv, FALSE);
-
-    roombrowse_gtk_add_conversation(conv->window, conv);
-    gaim_conv_window_show(conv->window);
-
-    g_free(room);
-
-}
-static void roombrowse_menu_create(GaimBlistNode * node, GList ** menu)
-{
-
-    char *label, *room;
-
-    struct gaym_conn *gaym;
-    GaimChat *chat = (GaimChat *) node;
-
-    gaim_debug_misc("roombrowse", "In callback\n");
-    if (node->type != GAIM_BLIST_CHAT_NODE)
-        return;
-
-    gaym = chat->account->gc->proto_data;
-
-    room = g_strdup(g_hash_table_lookup(chat->components, "name"));
-    gaim_debug_misc("roombrowse", "Room name: %s\n", room);
-    if (!room)
-        return;
-
-
-    label = g_strdup_printf("Lurk in %s", room);
-    GaimBlistNodeAction *act = gaim_blist_node_action_new(label,
-                                                          roombrowse_menu_cb,
-                                                          chat->account);
-
-    *menu = g_list_append(*menu, act);
-    // g_free(label);
-}
-static gboolean roombrowse_load(GaimPlugin * plugin)
-{
-    gaim_signal_connect(gaim_blist_get_handle(),
-                        "blist-node-extended-menu",
-                        plugin, GAIM_CALLBACK(roombrowse_menu_create),
-                        NULL);
-
-
-    gaim_debug_misc("roombrowse", "Callback registered!\n");
-    return TRUE;
-}

Added: qrc/trunk/gaym-extras/src/.chatsort.c.swp
===================================================================
(Binary files differ)


Property changes on: qrc/trunk/gaym-extras/src/.chatsort.c.swp
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: qrc/trunk/gaym-extras/src/.deps/bio-popups.Plo
===================================================================
--- qrc/trunk/gaym-extras/src/.deps/bio-popups.Plo	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/src/.deps/bio-popups.Plo	2005-07-30 21:32:57 UTC (rev 256)
@@ -0,0 +1,1283 @@
+bio-popups.lo .libs/bio-popups.o: bio-popups.c gaym-extras.h \
+  /usr/local/include/gaim/internal.h ../../config.h /usr/include/locale.h \
+  /usr/include/features.h /usr/include/sys/cdefs.h \
+  /usr/include/gnu/stubs.h \
+  /usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/stddef.h \
+  /usr/include/bits/locale.h /usr/include/sys/stat.h \
+  /usr/include/bits/types.h /usr/include/bits/wordsize.h \
+  /usr/include/bits/typesizes.h /usr/include/time.h \
+  /usr/include/bits/stat.h /usr/include/sys/time.h \
+  /usr/include/bits/time.h /usr/include/sys/select.h \
+  /usr/include/bits/select.h /usr/include/bits/sigset.h \
+  /usr/include/sys/types.h /usr/include/endian.h \
+  /usr/include/bits/endian.h /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h /usr/include/bits/sched.h \
+  /usr/include/sys/wait.h /usr/include/signal.h \
+  /usr/include/bits/signum.h /usr/include/bits/siginfo.h \
+  /usr/include/bits/sigaction.h /usr/include/bits/sigcontext.h \
+  /usr/include/asm/sigcontext.h /usr/include/linux/compiler.h \
+  /usr/include/bits/sigstack.h /usr/include/bits/sigthread.h \
+  /usr/include/sys/resource.h /usr/include/bits/resource.h \
+  /usr/include/bits/waitflags.h /usr/include/bits/waitstatus.h \
+  /usr/include/ctype.h /usr/include/errno.h /usr/include/bits/errno.h \
+  /usr/include/linux/errno.h /usr/include/asm/errno.h \
+  /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+  /usr/include/fcntl.h /usr/include/bits/fcntl.h /usr/include/math.h \
+  /usr/include/bits/huge_val.h /usr/include/bits/mathdef.h \
+  /usr/include/bits/mathcalls.h /usr/include/bits/mathinline.h \
+  /usr/include/stdio.h /usr/include/libio.h /usr/include/_G_config.h \
+  /usr/include/wchar.h /usr/include/bits/wchar.h /usr/include/gconv.h \
+  /usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/stdarg.h \
+  /usr/include/bits/stdio_lim.h /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h /usr/include/stdlib.h /usr/include/alloca.h \
+  /usr/include/string.h /usr/include/bits/string.h \
+  /usr/include/bits/string2.h /usr/include/glib-2.0/gmodule.h \
+  /usr/include/glib-2.0/glib.h /usr/include/glib-2.0/glib/galloca.h \
+  /usr/include/glib-2.0/glib/gtypes.h \
+  /usr/lib/glib-2.0/include/glibconfig.h \
+  /usr/include/glib-2.0/glib/gmacros.h \
+  /usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/limits.h \
+  /usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/syslimits.h \
+  /usr/include/limits.h /usr/include/bits/posix1_lim.h \
+  /usr/include/bits/local_lim.h /usr/include/linux/limits.h \
+  /usr/include/bits/posix2_lim.h \
+  /usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/float.h \
+  /usr/include/glib-2.0/glib/garray.h \
+  /usr/include/glib-2.0/glib/gasyncqueue.h \
+  /usr/include/glib-2.0/glib/gthread.h \
+  /usr/include/glib-2.0/glib/gerror.h /usr/include/glib-2.0/glib/gquark.h \
+  /usr/include/glib-2.0/glib/gatomic.h \
+  /usr/include/glib-2.0/glib/gbacktrace.h \
+  /usr/include/glib-2.0/glib/gcache.h /usr/include/glib-2.0/glib/glist.h \
+  /usr/include/glib-2.0/glib/gmem.h \
+  /usr/include/glib-2.0/glib/gcompletion.h \
+  /usr/include/glib-2.0/glib/gconvert.h \
+  /usr/include/glib-2.0/glib/gdataset.h \
+  /usr/include/glib-2.0/glib/gdate.h /usr/include/glib-2.0/glib/gdir.h \
+  /usr/include/glib-2.0/glib/gfileutils.h \
+  /usr/include/glib-2.0/glib/ghash.h /usr/include/glib-2.0/glib/ghook.h \
+  /usr/include/glib-2.0/glib/giochannel.h \
+  /usr/include/glib-2.0/glib/gmain.h /usr/include/glib-2.0/glib/gslist.h \
+  /usr/include/glib-2.0/glib/gstring.h \
+  /usr/include/glib-2.0/glib/gunicode.h \
+  /usr/include/glib-2.0/glib/gutils.h \
+  /usr/include/glib-2.0/glib/gkeyfile.h \
+  /usr/include/glib-2.0/glib/gmarkup.h \
+  /usr/include/glib-2.0/glib/gmessages.h \
+  /usr/include/glib-2.0/glib/gnode.h /usr/include/glib-2.0/glib/goption.h \
+  /usr/include/glib-2.0/glib/gpattern.h \
+  /usr/include/glib-2.0/glib/gprimes.h \
+  /usr/include/glib-2.0/glib/gqsort.h /usr/include/glib-2.0/glib/gqueue.h \
+  /usr/include/glib-2.0/glib/grand.h /usr/include/glib-2.0/glib/grel.h \
+  /usr/include/glib-2.0/glib/gscanner.h \
+  /usr/include/glib-2.0/glib/gshell.h /usr/include/glib-2.0/glib/gspawn.h \
+  /usr/include/glib-2.0/glib/gstrfuncs.h \
+  /usr/include/glib-2.0/glib/gthreadpool.h \
+  /usr/include/glib-2.0/glib/gtimer.h /usr/include/glib-2.0/glib/gtree.h \
+  /usr/include/dlfcn.h /usr/include/bits/dlfcn.h \
+  /usr/include/netinet/in.h /usr/include/stdint.h \
+  /usr/include/sys/socket.h /usr/include/sys/uio.h \
+  /usr/include/bits/uio.h /usr/include/bits/socket.h \
+  /usr/include/bits/sockaddr.h /usr/include/asm/socket.h \
+  /usr/include/asm/sockios.h /usr/include/bits/in.h \
+  /usr/include/bits/byteswap.h /usr/include/arpa/inet.h \
+  /usr/include/sys/un.h /usr/include/sys/utsname.h \
+  /usr/include/bits/utsname.h /usr/include/netdb.h \
+  /usr/include/rpc/netdb.h /usr/include/bits/netdb.h \
+  /usr/include/unistd.h /usr/include/bits/posix_opt.h \
+  /usr/include/bits/confname.h /usr/include/getopt.h \
+  /usr/include/glib-2.0/glib/gstdio.h \
+  /usr/include/glib-2.0/glib/gprintf.h /usr/local/include/gaim/prefix.h \
+  /usr/local/include/gaim/gtkgaim.h /usr/include/gtk-2.0/gdk/gdkx.h \
+  /usr/include/gtk-2.0/gdk/gdkprivate.h \
+  /usr/include/gtk-2.0/gdk/gdktypes.h \
+  /usr/include/pango-1.0/pango/pango.h \
+  /usr/include/pango-1.0/pango/pango-attributes.h \
+  /usr/include/pango-1.0/pango/pango-font.h \
+  /usr/include/pango-1.0/pango/pango-coverage.h \
+  /usr/include/pango-1.0/pango/pango-types.h \
+  /usr/include/glib-2.0/glib-object.h \
+  /usr/include/glib-2.0/gobject/gboxed.h \
+  /usr/include/glib-2.0/gobject/gtype.h \
+  /usr/include/glib-2.0/gobject/genums.h \
+  /usr/include/glib-2.0/gobject/gobject.h \
+  /usr/include/glib-2.0/gobject/gvalue.h \
+  /usr/include/glib-2.0/gobject/gparam.h \
+  /usr/include/glib-2.0/gobject/gclosure.h \
+  /usr/include/glib-2.0/gobject/gsignal.h \
+  /usr/include/glib-2.0/gobject/gmarshal.h \
+  /usr/include/glib-2.0/gobject/gparamspecs.h \
+  /usr/include/glib-2.0/gobject/gsourceclosure.h \
+  /usr/include/glib-2.0/gobject/gtypemodule.h \
+  /usr/include/glib-2.0/gobject/gtypeplugin.h \
+  /usr/include/glib-2.0/gobject/gvaluearray.h \
+  /usr/include/glib-2.0/gobject/gvaluetypes.h \
+  /usr/include/pango-1.0/pango/pango-break.h \
+  /usr/include/pango-1.0/pango/pango-item.h \
+  /usr/include/pango-1.0/pango/pango-context.h \
+  /usr/include/pango-1.0/pango/pango-fontmap.h \
+  /usr/include/pango-1.0/pango/pango-fontset.h \
+  /usr/include/pango-1.0/pango/pango-engine.h \
+  /usr/include/pango-1.0/pango/pango-glyph.h \
+  /usr/include/pango-1.0/pango/pango-script.h \
+  /usr/include/pango-1.0/pango/pango-enum-types.h \
+  /usr/include/pango-1.0/pango/pango-layout.h \
+  /usr/include/pango-1.0/pango/pango-glyph-item.h \
+  /usr/include/pango-1.0/pango/pango-tabs.h \
+  /usr/include/pango-1.0/pango/pango-renderer.h \
+  /usr/lib/gtk-2.0/include/gdkconfig.h \
+  /usr/include/gtk-2.0/gdk/gdkevents.h \
+  /usr/include/gtk-2.0/gdk/gdkcolor.h /usr/include/gtk-2.0/gdk/gdkdnd.h \
+  /usr/include/gtk-2.0/gdk/gdkinput.h /usr/include/gtk-2.0/gdk/gdkfont.h \
+  /usr/include/gtk-2.0/gdk/gdkgc.h /usr/include/gtk-2.0/gdk/gdkimage.h \
+  /usr/include/gtk-2.0/gdk/gdkregion.h \
+  /usr/include/gtk-2.0/gdk/gdkvisual.h \
+  /usr/include/gtk-2.0/gdk/gdkwindow.h \
+  /usr/include/gtk-2.0/gdk/gdkdrawable.h \
+  /usr/include/gtk-2.0/gdk/gdkrgb.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-features.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-core.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-transform.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-animation.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-io.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-loader.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-enum-types.h \
+  /usr/include/gtk-2.0/gdk/gdkcursor.h /usr/include/X11/Xlib.h \
+  /usr/include/X11/X.h /usr/include/X11/Xfuncproto.h \
+  /usr/include/X11/Xosdefs.h /usr/include/X11/Xutil.h \
+  /usr/include/gtk-2.0/gtk/gtk.h /usr/include/gtk-2.0/gdk/gdk.h \
+  /usr/include/gtk-2.0/gdk/gdkdisplay.h \
+  /usr/include/gtk-2.0/gdk/gdkenumtypes.h \
+  /usr/include/gtk-2.0/gdk/gdkkeys.h \
+  /usr/include/gtk-2.0/gdk/gdkdisplaymanager.h \
+  /usr/include/gtk-2.0/gdk/gdkpango.h \
+  /usr/include/gtk-2.0/gdk/gdkpixbuf.h \
+  /usr/include/gtk-2.0/gdk/gdkpixmap.h \
+  /usr/include/gtk-2.0/gdk/gdkproperty.h \
+  /usr/include/gtk-2.0/gdk/gdkscreen.h \
+  /usr/include/gtk-2.0/gdk/gdkselection.h \
+  /usr/include/gtk-2.0/gdk/gdkspawn.h \
+  /usr/include/gtk-2.0/gtk/gtkaboutdialog.h \
+  /usr/include/gtk-2.0/gtk/gtkdialog.h \
+  /usr/include/gtk-2.0/gtk/gtkwindow.h \
+  /usr/include/gtk-2.0/gtk/gtkaccelgroup.h \
+  /usr/include/gtk-2.0/gtk/gtkenums.h /usr/include/gtk-2.0/gtk/gtkbin.h \
+  /usr/include/gtk-2.0/gtk/gtkcontainer.h \
+  /usr/include/gtk-2.0/gtk/gtkwidget.h \
+  /usr/include/gtk-2.0/gtk/gtkobject.h \
+  /usr/include/gtk-2.0/gtk/gtktypeutils.h \
+  /usr/include/gtk-2.0/gtk/gtktypebuiltins.h \
+  /usr/include/gtk-2.0/gtk/gtkdebug.h \
+  /usr/include/gtk-2.0/gtk/gtkadjustment.h \
+  /usr/include/gtk-2.0/gtk/gtkstyle.h \
+  /usr/include/gtk-2.0/gtk/gtksettings.h /usr/include/gtk-2.0/gtk/gtkrc.h \
+  /usr/include/atk-1.0/atk/atkobject.h \
+  /usr/include/atk-1.0/atk/atkstate.h \
+  /usr/include/atk-1.0/atk/atkrelationtype.h \
+  /usr/include/gtk-2.0/gtk/gtkaccellabel.h \
+  /usr/include/gtk-2.0/gtk/gtklabel.h /usr/include/gtk-2.0/gtk/gtkmisc.h \
+  /usr/include/gtk-2.0/gtk/gtkmenu.h \
+  /usr/include/gtk-2.0/gtk/gtkmenushell.h \
+  /usr/include/gtk-2.0/gtk/gtkaccelmap.h \
+  /usr/include/gtk-2.0/gtk/gtkaccessible.h /usr/include/atk-1.0/atk/atk.h \
+  /usr/include/atk-1.0/atk/atkaction.h \
+  /usr/include/atk-1.0/atk/atkcomponent.h \
+  /usr/include/atk-1.0/atk/atkutil.h \
+  /usr/include/atk-1.0/atk/atkdocument.h \
+  /usr/include/atk-1.0/atk/atkeditabletext.h \
+  /usr/include/atk-1.0/atk/atktext.h \
+  /usr/include/atk-1.0/atk/atkgobjectaccessible.h \
+  /usr/include/atk-1.0/atk/atkhyperlink.h \
+  /usr/include/atk-1.0/atk/atkhypertext.h \
+  /usr/include/atk-1.0/atk/atkimage.h \
+  /usr/include/atk-1.0/atk/atknoopobject.h \
+  /usr/include/atk-1.0/atk/atknoopobjectfactory.h \
+  /usr/include/atk-1.0/atk/atkobjectfactory.h \
+  /usr/include/atk-1.0/atk/atkregistry.h \
+  /usr/include/atk-1.0/atk/atkobjectfactory.h \
+  /usr/include/atk-1.0/atk/atkrelation.h \
+  /usr/include/atk-1.0/atk/atkrelationset.h \
+  /usr/include/atk-1.0/atk/atkselection.h \
+  /usr/include/atk-1.0/atk/atkstateset.h \
+  /usr/include/atk-1.0/atk/atkstreamablecontent.h \
+  /usr/include/atk-1.0/atk/atktable.h /usr/include/atk-1.0/atk/atkvalue.h \
+  /usr/include/gtk-2.0/gtk/gtkaction.h \
+  /usr/include/gtk-2.0/gtk/gtkactiongroup.h \
+  /usr/include/gtk-2.0/gtk/gtkitemfactory.h \
+  /usr/include/gtk-2.0/gtk/gtkalignment.h \
+  /usr/include/gtk-2.0/gtk/gtkarrow.h \
+  /usr/include/gtk-2.0/gtk/gtkaspectframe.h \
+  /usr/include/gtk-2.0/gtk/gtkframe.h /usr/include/gtk-2.0/gtk/gtkbbox.h \
+  /usr/include/gtk-2.0/gtk/gtkbox.h \
+  /usr/include/gtk-2.0/gtk/gtkbindings.h \
+  /usr/include/gtk-2.0/gtk/gtkbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkimage.h \
+  /usr/include/gtk-2.0/gtk/gtkcalendar.h \
+  /usr/include/gtk-2.0/gtk/gtksignal.h \
+  /usr/include/gtk-2.0/gtk/gtkmarshal.h \
+  /usr/include/gtk-2.0/gtk/gtkcelllayout.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrenderer.h \
+  /usr/include/gtk-2.0/gtk/gtkcelleditable.h \
+  /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h \
+  /usr/include/gtk-2.0/gtk/gtktreemodel.h \
+  /usr/include/gtk-2.0/gtk/gtktreesortable.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrenderercombo.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrenderertext.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrendererpixbuf.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrendererprogress.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrenderertoggle.h \
+  /usr/include/gtk-2.0/gtk/gtkcellview.h \
+  /usr/include/gtk-2.0/gtk/gtkcheckbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktogglebutton.h \
+  /usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtkmenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtkitem.h \
+  /usr/include/gtk-2.0/gtk/gtkclipboard.h \
+  /usr/include/gtk-2.0/gtk/gtkselection.h \
+  /usr/include/gtk-2.0/gtk/gtkclist.h \
+  /usr/include/gtk-2.0/gtk/gtkhscrollbar.h \
+  /usr/include/gtk-2.0/gtk/gtkscrollbar.h \
+  /usr/include/gtk-2.0/gtk/gtkrange.h \
+  /usr/include/gtk-2.0/gtk/gtkvscrollbar.h \
+  /usr/include/gtk-2.0/gtk/gtkcolorbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkcolorsel.h \
+  /usr/include/gtk-2.0/gtk/gtkvbox.h \
+  /usr/include/gtk-2.0/gtk/gtkcolorseldialog.h \
+  /usr/include/gtk-2.0/gtk/gtkcombo.h /usr/include/gtk-2.0/gtk/gtkhbox.h \
+  /usr/include/gtk-2.0/gtk/gtkcombobox.h \
+  /usr/include/gtk-2.0/gtk/gtktreeview.h \
+  /usr/include/gtk-2.0/gtk/gtkdnd.h \
+  /usr/include/gtk-2.0/gtk/gtkcomboboxentry.h \
+  /usr/include/gtk-2.0/gtk/gtkctree.h /usr/include/gtk-2.0/gtk/gtkcurve.h \
+  /usr/include/gtk-2.0/gtk/gtkdrawingarea.h \
+  /usr/include/gtk-2.0/gtk/gtkeditable.h \
+  /usr/include/gtk-2.0/gtk/gtkentry.h \
+  /usr/include/gtk-2.0/gtk/gtkimcontext.h \
+  /usr/include/gtk-2.0/gtk/gtkentrycompletion.h \
+  /usr/include/gtk-2.0/gtk/gtkliststore.h \
+  /usr/include/gtk-2.0/gtk/gtktreemodelfilter.h \
+  /usr/include/gtk-2.0/gtk/gtkeventbox.h \
+  /usr/include/gtk-2.0/gtk/gtkexpander.h \
+  /usr/include/gtk-2.0/gtk/gtkfilesel.h \
+  /usr/include/gtk-2.0/gtk/gtkfixed.h \
+  /usr/include/gtk-2.0/gtk/gtkfilechooserbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkfilechooser.h \
+  /usr/include/gtk-2.0/gtk/gtkfilefilter.h \
+  /usr/include/gtk-2.0/gtk/gtkfilechooserdialog.h \
+  /usr/include/gtk-2.0/gtk/gtkfilechooser.h \
+  /usr/include/gtk-2.0/gtk/gtkfilechooserwidget.h \
+  /usr/include/gtk-2.0/gtk/gtkfontbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkfontsel.h \
+  /usr/include/gtk-2.0/gtk/gtkgamma.h /usr/include/gtk-2.0/gtk/gtkgc.h \
+  /usr/include/gtk-2.0/gtk/gtkhandlebox.h \
+  /usr/include/gtk-2.0/gtk/gtkhbbox.h \
+  /usr/include/gtk-2.0/gtk/gtkhpaned.h \
+  /usr/include/gtk-2.0/gtk/gtkpaned.h \
+  /usr/include/gtk-2.0/gtk/gtkhruler.h \
+  /usr/include/gtk-2.0/gtk/gtkruler.h \
+  /usr/include/gtk-2.0/gtk/gtkhscale.h \
+  /usr/include/gtk-2.0/gtk/gtkscale.h \
+  /usr/include/gtk-2.0/gtk/gtkhseparator.h \
+  /usr/include/gtk-2.0/gtk/gtkseparator.h \
+  /usr/include/gtk-2.0/gtk/gtkiconfactory.h \
+  /usr/include/gtk-2.0/gtk/gtkicontheme.h \
+  /usr/include/gtk-2.0/gtk/gtkiconview.h \
+  /usr/include/gtk-2.0/gtk/gtkimagemenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtkimcontextsimple.h \
+  /usr/include/gtk-2.0/gtk/gtkimmulticontext.h \
+  /usr/include/gtk-2.0/gtk/gtkinputdialog.h \
+  /usr/include/gtk-2.0/gtk/gtkinvisible.h \
+  /usr/include/gtk-2.0/gtk/gtklayout.h /usr/include/gtk-2.0/gtk/gtklist.h \
+  /usr/include/gtk-2.0/gtk/gtklistitem.h \
+  /usr/include/gtk-2.0/gtk/gtkmain.h \
+  /usr/include/gtk-2.0/gtk/gtkmenubar.h \
+  /usr/include/gtk-2.0/gtk/gtkmenutoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkmenu.h \
+  /usr/include/gtk-2.0/gtk/gtktoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktoolitem.h \
+  /usr/include/gtk-2.0/gtk/gtktooltips.h \
+  /usr/include/gtk-2.0/gtk/gtkmessagedialog.h \
+  /usr/include/gtk-2.0/gtk/gtkmodules.h \
+  /usr/include/gtk-2.0/gtk/gtknotebook.h \
+  /usr/include/gtk-2.0/gtk/gtkoldeditable.h \
+  /usr/include/gtk-2.0/gtk/gtkoptionmenu.h \
+  /usr/include/gtk-2.0/gtk/gtkpixmap.h /usr/include/gtk-2.0/gtk/gtkplug.h \
+  /usr/include/gtk-2.0/gtk/gtksocket.h \
+  /usr/include/gtk-2.0/gtk/gtkpreview.h \
+  /usr/include/gtk-2.0/gtk/gtkprogress.h \
+  /usr/include/gtk-2.0/gtk/gtkprogressbar.h \
+  /usr/include/gtk-2.0/gtk/gtkradioaction.h \
+  /usr/include/gtk-2.0/gtk/gtktoggleaction.h \
+  /usr/include/gtk-2.0/gtk/gtkradiobutton.h \
+  /usr/include/gtk-2.0/gtk/gtkradiomenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtkradiotoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h \
+  /usr/include/gtk-2.0/gtk/gtkviewport.h \
+  /usr/include/gtk-2.0/gtk/gtkseparatormenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtkseparatortoolitem.h \
+  /usr/include/gtk-2.0/gtk/gtksizegroup.h \
+  /usr/include/gtk-2.0/gtk/gtkspinbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkstatusbar.h \
+  /usr/include/gtk-2.0/gtk/gtkstock.h /usr/include/gtk-2.0/gtk/gtktable.h \
+  /usr/include/gtk-2.0/gtk/gtktearoffmenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtktext.h \
+  /usr/include/gtk-2.0/gtk/gtktextbuffer.h \
+  /usr/include/gtk-2.0/gtk/gtktexttagtable.h \
+  /usr/include/gtk-2.0/gtk/gtktexttag.h \
+  /usr/include/gtk-2.0/gtk/gtktextiter.h \
+  /usr/include/gtk-2.0/gtk/gtktextchild.h \
+  /usr/include/gtk-2.0/gtk/gtktextmark.h \
+  /usr/include/gtk-2.0/gtk/gtktextview.h \
+  /usr/include/gtk-2.0/gtk/gtktipsquery.h \
+  /usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktoolbar.h \
+  /usr/include/gtk-2.0/gtk/gtktoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktoolitem.h \
+  /usr/include/gtk-2.0/gtk/gtktree.h \
+  /usr/include/gtk-2.0/gtk/gtktreednd.h \
+  /usr/include/gtk-2.0/gtk/gtktreeitem.h \
+  /usr/include/gtk-2.0/gtk/gtktreemodelsort.h \
+  /usr/include/gtk-2.0/gtk/gtktreeselection.h \
+  /usr/include/gtk-2.0/gtk/gtktreestore.h \
+  /usr/include/gtk-2.0/gtk/gtkuimanager.h \
+  /usr/include/gtk-2.0/gtk/gtkvbbox.h \
+  /usr/include/gtk-2.0/gtk/gtkversion.h \
+  /usr/include/gtk-2.0/gtk/gtkvpaned.h \
+  /usr/include/gtk-2.0/gtk/gtkvruler.h \
+  /usr/include/gtk-2.0/gtk/gtkvscale.h \
+  /usr/include/gtk-2.0/gtk/gtkvseparator.h \
+  /usr/local/include/gaim/conversation.h \
+  /usr/local/include/gaim/account.h /usr/local/include/gaim/connection.h \
+  /usr/local/include/gaim/plugin.h /usr/local/include/gaim/signals.h \
+  /usr/local/include/gaim/value.h /usr/local/include/gaim/pluginpref.h \
+  /usr/local/include/gaim/prefs.h /usr/local/include/gaim/log.h \
+  /usr/local/include/gaim/conversation.h /usr/local/include/gaim/proxy.h \
+  /usr/local/include/gaim/eventloop.h /usr/local/include/gaim/prpl.h \
+  /usr/local/include/gaim/blist.h /usr/local/include/gaim/buddyicon.h \
+  /usr/local/include/gaim/server.h /usr/local/include/gaim/debug.h \
+  /usr/local/include/gaim/prefs.h /usr/local/include/gaim/signals.h \
+  /usr/local/include/gaim/util.h /usr/local/include/gaim/version.h \
+  /usr/local/include/gaim/buddyicon.h /usr/local/include/gaim/prpl.h \
+  /usr/local/include/gaim/gtkconv.h /usr/local/include/gaim/gtkgaim.h \
+  /usr/local/include/gaim/gtkplugin.h
+
+gaym-extras.h:
+
+/usr/local/include/gaim/internal.h:
+
+../../config.h:
+
+/usr/include/locale.h:
+
+/usr/include/features.h:
+
+/usr/include/sys/cdefs.h:
+
+/usr/include/gnu/stubs.h:
+
+/usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/stddef.h:
+
+/usr/include/bits/locale.h:
+
+/usr/include/sys/stat.h:
+
+/usr/include/bits/types.h:
+
+/usr/include/bits/wordsize.h:
+
+/usr/include/bits/typesizes.h:
+
+/usr/include/time.h:
+
+/usr/include/bits/stat.h:
+
+/usr/include/sys/time.h:
+
+/usr/include/bits/time.h:
+
+/usr/include/sys/select.h:
+
+/usr/include/bits/select.h:
+
+/usr/include/bits/sigset.h:
+
+/usr/include/sys/types.h:
+
+/usr/include/endian.h:
+
+/usr/include/bits/endian.h:
+
+/usr/include/sys/sysmacros.h:
+
+/usr/include/bits/pthreadtypes.h:
+
+/usr/include/bits/sched.h:
+
+/usr/include/sys/wait.h:
+
+/usr/include/signal.h:
+
+/usr/include/bits/signum.h:
+
+/usr/include/bits/siginfo.h:
+
+/usr/include/bits/sigaction.h:
+
+/usr/include/bits/sigcontext.h:
+
+/usr/include/asm/sigcontext.h:
+
+/usr/include/linux/compiler.h:
+
+/usr/include/bits/sigstack.h:
+
+/usr/include/bits/sigthread.h:
+
+/usr/include/sys/resource.h:
+
+/usr/include/bits/resource.h:
+
+/usr/include/bits/waitflags.h:
+
+/usr/include/bits/waitstatus.h:
+
+/usr/include/ctype.h:
+
+/usr/include/errno.h:
+
+/usr/include/bits/errno.h:
+
+/usr/include/linux/errno.h:
+
+/usr/include/asm/errno.h:
+
+/usr/include/asm-generic/errno.h:
+
+/usr/include/asm-generic/errno-base.h:
+
+/usr/include/fcntl.h:
+
+/usr/include/bits/fcntl.h:
+
+/usr/include/math.h:
+
+/usr/include/bits/huge_val.h:
+
+/usr/include/bits/mathdef.h:
+
+/usr/include/bits/mathcalls.h:
+
+/usr/include/bits/mathinline.h:
+
+/usr/include/stdio.h:
+
+/usr/include/libio.h:
+
+/usr/include/_G_config.h:
+
+/usr/include/wchar.h:
+
+/usr/include/bits/wchar.h:
+
+/usr/include/gconv.h:
+
+/usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/stdarg.h:
+
+/usr/include/bits/stdio_lim.h:
+
+/usr/include/bits/sys_errlist.h:
+
+/usr/include/bits/stdio.h:
+
+/usr/include/stdlib.h:
+
+/usr/include/alloca.h:
+
+/usr/include/string.h:
+
+/usr/include/bits/string.h:
+
+/usr/include/bits/string2.h:
+
+/usr/include/glib-2.0/gmodule.h:
+
+/usr/include/glib-2.0/glib.h:
+
+/usr/include/glib-2.0/glib/galloca.h:
+
+/usr/include/glib-2.0/glib/gtypes.h:
+
+/usr/lib/glib-2.0/include/glibconfig.h:
+
+/usr/include/glib-2.0/glib/gmacros.h:
+
+/usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/limits.h:
+
+/usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/syslimits.h:
+
+/usr/include/limits.h:
+
+/usr/include/bits/posix1_lim.h:
+
+/usr/include/bits/local_lim.h:
+
+/usr/include/linux/limits.h:
+
+/usr/include/bits/posix2_lim.h:
+
+/usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/float.h:
+
+/usr/include/glib-2.0/glib/garray.h:
+
+/usr/include/glib-2.0/glib/gasyncqueue.h:
+
+/usr/include/glib-2.0/glib/gthread.h:
+
+/usr/include/glib-2.0/glib/gerror.h:
+
+/usr/include/glib-2.0/glib/gquark.h:
+
+/usr/include/glib-2.0/glib/gatomic.h:
+
+/usr/include/glib-2.0/glib/gbacktrace.h:
+
+/usr/include/glib-2.0/glib/gcache.h:
+
+/usr/include/glib-2.0/glib/glist.h:
+
+/usr/include/glib-2.0/glib/gmem.h:
+
+/usr/include/glib-2.0/glib/gcompletion.h:
+
+/usr/include/glib-2.0/glib/gconvert.h:
+
+/usr/include/glib-2.0/glib/gdataset.h:
+
+/usr/include/glib-2.0/glib/gdate.h:
+
+/usr/include/glib-2.0/glib/gdir.h:
+
+/usr/include/glib-2.0/glib/gfileutils.h:
+
+/usr/include/glib-2.0/glib/ghash.h:
+
+/usr/include/glib-2.0/glib/ghook.h:
+
+/usr/include/glib-2.0/glib/giochannel.h:
+
+/usr/include/glib-2.0/glib/gmain.h:
+
+/usr/include/glib-2.0/glib/gslist.h:
+
+/usr/include/glib-2.0/glib/gstring.h:
+
+/usr/include/glib-2.0/glib/gunicode.h:
+
+/usr/include/glib-2.0/glib/gutils.h:
+
+/usr/include/glib-2.0/glib/gkeyfile.h:
+
+/usr/include/glib-2.0/glib/gmarkup.h:
+
+/usr/include/glib-2.0/glib/gmessages.h:
+
+/usr/include/glib-2.0/glib/gnode.h:
+
+/usr/include/glib-2.0/glib/goption.h:
+
+/usr/include/glib-2.0/glib/gpattern.h:
+
+/usr/include/glib-2.0/glib/gprimes.h:
+
+/usr/include/glib-2.0/glib/gqsort.h:
+
+/usr/include/glib-2.0/glib/gqueue.h:
+
+/usr/include/glib-2.0/glib/grand.h:
+
+/usr/include/glib-2.0/glib/grel.h:
+
+/usr/include/glib-2.0/glib/gscanner.h:
+
+/usr/include/glib-2.0/glib/gshell.h:
+
+/usr/include/glib-2.0/glib/gspawn.h:
+
+/usr/include/glib-2.0/glib/gstrfuncs.h:
+
+/usr/include/glib-2.0/glib/gthreadpool.h:
+
+/usr/include/glib-2.0/glib/gtimer.h:
+
+/usr/include/glib-2.0/glib/gtree.h:
+
+/usr/include/dlfcn.h:
+
+/usr/include/bits/dlfcn.h:
+
+/usr/include/netinet/in.h:
+
+/usr/include/stdint.h:
+
+/usr/include/sys/socket.h:
+
+/usr/include/sys/uio.h:
+
+/usr/include/bits/uio.h:
+
+/usr/include/bits/socket.h:
+
+/usr/include/bits/sockaddr.h:
+
+/usr/include/asm/socket.h:
+
+/usr/include/asm/sockios.h:
+
+/usr/include/bits/in.h:
+
+/usr/include/bits/byteswap.h:
+
+/usr/include/arpa/inet.h:
+
+/usr/include/sys/un.h:
+
+/usr/include/sys/utsname.h:
+
+/usr/include/bits/utsname.h:
+
+/usr/include/netdb.h:
+
+/usr/include/rpc/netdb.h:
+
+/usr/include/bits/netdb.h:
+
+/usr/include/unistd.h:
+
+/usr/include/bits/posix_opt.h:
+
+/usr/include/bits/confname.h:
+
+/usr/include/getopt.h:
+
+/usr/include/glib-2.0/glib/gstdio.h:
+
+/usr/include/glib-2.0/glib/gprintf.h:
+
+/usr/local/include/gaim/prefix.h:
+
+/usr/local/include/gaim/gtkgaim.h:
+
+/usr/include/gtk-2.0/gdk/gdkx.h:
+
+/usr/include/gtk-2.0/gdk/gdkprivate.h:
+
+/usr/include/gtk-2.0/gdk/gdktypes.h:
+
+/usr/include/pango-1.0/pango/pango.h:
+
+/usr/include/pango-1.0/pango/pango-attributes.h:
+
+/usr/include/pango-1.0/pango/pango-font.h:
+
+/usr/include/pango-1.0/pango/pango-coverage.h:
+
+/usr/include/pango-1.0/pango/pango-types.h:
+
+/usr/include/glib-2.0/glib-object.h:
+
+/usr/include/glib-2.0/gobject/gboxed.h:
+
+/usr/include/glib-2.0/gobject/gtype.h:
+
+/usr/include/glib-2.0/gobject/genums.h:
+
+/usr/include/glib-2.0/gobject/gobject.h:
+
+/usr/include/glib-2.0/gobject/gvalue.h:
+
+/usr/include/glib-2.0/gobject/gparam.h:
+
+/usr/include/glib-2.0/gobject/gclosure.h:
+
+/usr/include/glib-2.0/gobject/gsignal.h:
+
+/usr/include/glib-2.0/gobject/gmarshal.h:
+
+/usr/include/glib-2.0/gobject/gparamspecs.h:
+
+/usr/include/glib-2.0/gobject/gsourceclosure.h:
+
+/usr/include/glib-2.0/gobject/gtypemodule.h:
+
+/usr/include/glib-2.0/gobject/gtypeplugin.h:
+
+/usr/include/glib-2.0/gobject/gvaluearray.h:
+
+/usr/include/glib-2.0/gobject/gvaluetypes.h:
+
+/usr/include/pango-1.0/pango/pango-break.h:
+
+/usr/include/pango-1.0/pango/pango-item.h:
+
+/usr/include/pango-1.0/pango/pango-context.h:
+
+/usr/include/pango-1.0/pango/pango-fontmap.h:
+
+/usr/include/pango-1.0/pango/pango-fontset.h:
+
+/usr/include/pango-1.0/pango/pango-engine.h:
+
+/usr/include/pango-1.0/pango/pango-glyph.h:
+
+/usr/include/pango-1.0/pango/pango-script.h:
+
+/usr/include/pango-1.0/pango/pango-enum-types.h:
+
+/usr/include/pango-1.0/pango/pango-layout.h:
+
+/usr/include/pango-1.0/pango/pango-glyph-item.h:
+
+/usr/include/pango-1.0/pango/pango-tabs.h:
+
+/usr/include/pango-1.0/pango/pango-renderer.h:
+
+/usr/lib/gtk-2.0/include/gdkconfig.h:
+
+/usr/include/gtk-2.0/gdk/gdkevents.h:
+
+/usr/include/gtk-2.0/gdk/gdkcolor.h:
+
+/usr/include/gtk-2.0/gdk/gdkdnd.h:
+
+/usr/include/gtk-2.0/gdk/gdkinput.h:
+
+/usr/include/gtk-2.0/gdk/gdkfont.h:
+
+/usr/include/gtk-2.0/gdk/gdkgc.h:
+
+/usr/include/gtk-2.0/gdk/gdkimage.h:
+
+/usr/include/gtk-2.0/gdk/gdkregion.h:
+
+/usr/include/gtk-2.0/gdk/gdkvisual.h:
+
+/usr/include/gtk-2.0/gdk/gdkwindow.h:
+
+/usr/include/gtk-2.0/gdk/gdkdrawable.h:
+
+/usr/include/gtk-2.0/gdk/gdkrgb.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-features.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-core.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-transform.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-animation.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-io.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-loader.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-enum-types.h:
+
+/usr/include/gtk-2.0/gdk/gdkcursor.h:
+
+/usr/include/X11/Xlib.h:
+
+/usr/include/X11/X.h:
+
+/usr/include/X11/Xfuncproto.h:
+
+/usr/include/X11/Xosdefs.h:
+
+/usr/include/X11/Xutil.h:
+
+/usr/include/gtk-2.0/gtk/gtk.h:
+
+/usr/include/gtk-2.0/gdk/gdk.h:
+
+/usr/include/gtk-2.0/gdk/gdkdisplay.h:
+
+/usr/include/gtk-2.0/gdk/gdkenumtypes.h:
+
+/usr/include/gtk-2.0/gdk/gdkkeys.h:
+
+/usr/include/gtk-2.0/gdk/gdkdisplaymanager.h:
+
+/usr/include/gtk-2.0/gdk/gdkpango.h:
+
+/usr/include/gtk-2.0/gdk/gdkpixbuf.h:
+
+/usr/include/gtk-2.0/gdk/gdkpixmap.h:
+
+/usr/include/gtk-2.0/gdk/gdkproperty.h:
+
+/usr/include/gtk-2.0/gdk/gdkscreen.h:
+
+/usr/include/gtk-2.0/gdk/gdkselection.h:
+
+/usr/include/gtk-2.0/gdk/gdkspawn.h:
+
+/usr/include/gtk-2.0/gtk/gtkaboutdialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkdialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkwindow.h:
+
+/usr/include/gtk-2.0/gtk/gtkaccelgroup.h:
+
+/usr/include/gtk-2.0/gtk/gtkenums.h:
+
+/usr/include/gtk-2.0/gtk/gtkbin.h:
+
+/usr/include/gtk-2.0/gtk/gtkcontainer.h:
+
+/usr/include/gtk-2.0/gtk/gtkwidget.h:
+
+/usr/include/gtk-2.0/gtk/gtkobject.h:
+
+/usr/include/gtk-2.0/gtk/gtktypeutils.h:
+
+/usr/include/gtk-2.0/gtk/gtktypebuiltins.h:
+
+/usr/include/gtk-2.0/gtk/gtkdebug.h:
+
+/usr/include/gtk-2.0/gtk/gtkadjustment.h:
+
+/usr/include/gtk-2.0/gtk/gtkstyle.h:
+
+/usr/include/gtk-2.0/gtk/gtksettings.h:
+
+/usr/include/gtk-2.0/gtk/gtkrc.h:
+
+/usr/include/atk-1.0/atk/atkobject.h:
+
+/usr/include/atk-1.0/atk/atkstate.h:
+
+/usr/include/atk-1.0/atk/atkrelationtype.h:
+
+/usr/include/gtk-2.0/gtk/gtkaccellabel.h:
+
+/usr/include/gtk-2.0/gtk/gtklabel.h:
+
+/usr/include/gtk-2.0/gtk/gtkmisc.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenu.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenushell.h:
+
+/usr/include/gtk-2.0/gtk/gtkaccelmap.h:
+
+/usr/include/gtk-2.0/gtk/gtkaccessible.h:
+
+/usr/include/atk-1.0/atk/atk.h:
+
+/usr/include/atk-1.0/atk/atkaction.h:
+
+/usr/include/atk-1.0/atk/atkcomponent.h:
+
+/usr/include/atk-1.0/atk/atkutil.h:
+
+/usr/include/atk-1.0/atk/atkdocument.h:
+
+/usr/include/atk-1.0/atk/atkeditabletext.h:
+
+/usr/include/atk-1.0/atk/atktext.h:
+
+/usr/include/atk-1.0/atk/atkgobjectaccessible.h:
+
+/usr/include/atk-1.0/atk/atkhyperlink.h:
+
+/usr/include/atk-1.0/atk/atkhypertext.h:
+
+/usr/include/atk-1.0/atk/atkimage.h:
+
+/usr/include/atk-1.0/atk/atknoopobject.h:
+
+/usr/include/atk-1.0/atk/atknoopobjectfactory.h:
+
+/usr/include/atk-1.0/atk/atkobjectfactory.h:
+
+/usr/include/atk-1.0/atk/atkregistry.h:
+
+/usr/include/atk-1.0/atk/atkobjectfactory.h:
+
+/usr/include/atk-1.0/atk/atkrelation.h:
+
+/usr/include/atk-1.0/atk/atkrelationset.h:
+
+/usr/include/atk-1.0/atk/atkselection.h:
+
+/usr/include/atk-1.0/atk/atkstateset.h:
+
+/usr/include/atk-1.0/atk/atkstreamablecontent.h:
+
+/usr/include/atk-1.0/atk/atktable.h:
+
+/usr/include/atk-1.0/atk/atkvalue.h:
+
+/usr/include/gtk-2.0/gtk/gtkaction.h:
+
+/usr/include/gtk-2.0/gtk/gtkactiongroup.h:
+
+/usr/include/gtk-2.0/gtk/gtkitemfactory.h:
+
+/usr/include/gtk-2.0/gtk/gtkalignment.h:
+
+/usr/include/gtk-2.0/gtk/gtkarrow.h:
+
+/usr/include/gtk-2.0/gtk/gtkaspectframe.h:
+
+/usr/include/gtk-2.0/gtk/gtkframe.h:
+
+/usr/include/gtk-2.0/gtk/gtkbbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkbindings.h:
+
+/usr/include/gtk-2.0/gtk/gtkbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkimage.h:
+
+/usr/include/gtk-2.0/gtk/gtkcalendar.h:
+
+/usr/include/gtk-2.0/gtk/gtksignal.h:
+
+/usr/include/gtk-2.0/gtk/gtkmarshal.h:
+
+/usr/include/gtk-2.0/gtk/gtkcelllayout.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrenderer.h:
+
+/usr/include/gtk-2.0/gtk/gtkcelleditable.h:
+
+/usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h:
+
+/usr/include/gtk-2.0/gtk/gtktreemodel.h:
+
+/usr/include/gtk-2.0/gtk/gtktreesortable.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrenderercombo.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrenderertext.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrendererpixbuf.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrendererprogress.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrenderertoggle.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellview.h:
+
+/usr/include/gtk-2.0/gtk/gtkcheckbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktogglebutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkclipboard.h:
+
+/usr/include/gtk-2.0/gtk/gtkselection.h:
+
+/usr/include/gtk-2.0/gtk/gtkclist.h:
+
+/usr/include/gtk-2.0/gtk/gtkhscrollbar.h:
+
+/usr/include/gtk-2.0/gtk/gtkscrollbar.h:
+
+/usr/include/gtk-2.0/gtk/gtkrange.h:
+
+/usr/include/gtk-2.0/gtk/gtkvscrollbar.h:
+
+/usr/include/gtk-2.0/gtk/gtkcolorbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkcolorsel.h:
+
+/usr/include/gtk-2.0/gtk/gtkvbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkcolorseldialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkcombo.h:
+
+/usr/include/gtk-2.0/gtk/gtkhbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkcombobox.h:
+
+/usr/include/gtk-2.0/gtk/gtktreeview.h:
+
+/usr/include/gtk-2.0/gtk/gtkdnd.h:
+
+/usr/include/gtk-2.0/gtk/gtkcomboboxentry.h:
+
+/usr/include/gtk-2.0/gtk/gtkctree.h:
+
+/usr/include/gtk-2.0/gtk/gtkcurve.h:
+
+/usr/include/gtk-2.0/gtk/gtkdrawingarea.h:
+
+/usr/include/gtk-2.0/gtk/gtkeditable.h:
+
+/usr/include/gtk-2.0/gtk/gtkentry.h:
+
+/usr/include/gtk-2.0/gtk/gtkimcontext.h:
+
+/usr/include/gtk-2.0/gtk/gtkentrycompletion.h:
+
+/usr/include/gtk-2.0/gtk/gtkliststore.h:
+
+/usr/include/gtk-2.0/gtk/gtktreemodelfilter.h:
+
+/usr/include/gtk-2.0/gtk/gtkeventbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkexpander.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilesel.h:
+
+/usr/include/gtk-2.0/gtk/gtkfixed.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilechooserbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilechooser.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilefilter.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilechooserdialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilechooser.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilechooserwidget.h:
+
+/usr/include/gtk-2.0/gtk/gtkfontbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkfontsel.h:
+
+/usr/include/gtk-2.0/gtk/gtkgamma.h:
+
+/usr/include/gtk-2.0/gtk/gtkgc.h:
+
+/usr/include/gtk-2.0/gtk/gtkhandlebox.h:
+
+/usr/include/gtk-2.0/gtk/gtkhbbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkhpaned.h:
+
+/usr/include/gtk-2.0/gtk/gtkpaned.h:
+
+/usr/include/gtk-2.0/gtk/gtkhruler.h:
+
+/usr/include/gtk-2.0/gtk/gtkruler.h:
+
+/usr/include/gtk-2.0/gtk/gtkhscale.h:
+
+/usr/include/gtk-2.0/gtk/gtkscale.h:
+
+/usr/include/gtk-2.0/gtk/gtkhseparator.h:
+
+/usr/include/gtk-2.0/gtk/gtkseparator.h:
+
+/usr/include/gtk-2.0/gtk/gtkiconfactory.h:
+
+/usr/include/gtk-2.0/gtk/gtkicontheme.h:
+
+/usr/include/gtk-2.0/gtk/gtkiconview.h:
+
+/usr/include/gtk-2.0/gtk/gtkimagemenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkimcontextsimple.h:
+
+/usr/include/gtk-2.0/gtk/gtkimmulticontext.h:
+
+/usr/include/gtk-2.0/gtk/gtkinputdialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkinvisible.h:
+
+/usr/include/gtk-2.0/gtk/gtklayout.h:
+
+/usr/include/gtk-2.0/gtk/gtklist.h:
+
+/usr/include/gtk-2.0/gtk/gtklistitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkmain.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenubar.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenutoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenu.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolitem.h:
+
+/usr/include/gtk-2.0/gtk/gtktooltips.h:
+
+/usr/include/gtk-2.0/gtk/gtkmessagedialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkmodules.h:
+
+/usr/include/gtk-2.0/gtk/gtknotebook.h:
+
+/usr/include/gtk-2.0/gtk/gtkoldeditable.h:
+
+/usr/include/gtk-2.0/gtk/gtkoptionmenu.h:
+
+/usr/include/gtk-2.0/gtk/gtkpixmap.h:
+
+/usr/include/gtk-2.0/gtk/gtkplug.h:
+
+/usr/include/gtk-2.0/gtk/gtksocket.h:
+
+/usr/include/gtk-2.0/gtk/gtkpreview.h:
+
+/usr/include/gtk-2.0/gtk/gtkprogress.h:
+
+/usr/include/gtk-2.0/gtk/gtkprogressbar.h:
+
+/usr/include/gtk-2.0/gtk/gtkradioaction.h:
+
+/usr/include/gtk-2.0/gtk/gtktoggleaction.h:
+
+/usr/include/gtk-2.0/gtk/gtkradiobutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkradiomenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkradiotoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkscrolledwindow.h:
+
+/usr/include/gtk-2.0/gtk/gtkviewport.h:
+
+/usr/include/gtk-2.0/gtk/gtkseparatormenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkseparatortoolitem.h:
+
+/usr/include/gtk-2.0/gtk/gtksizegroup.h:
+
+/usr/include/gtk-2.0/gtk/gtkspinbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkstatusbar.h:
+
+/usr/include/gtk-2.0/gtk/gtkstock.h:
+
+/usr/include/gtk-2.0/gtk/gtktable.h:
+
+/usr/include/gtk-2.0/gtk/gtktearoffmenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtktext.h:
+
+/usr/include/gtk-2.0/gtk/gtktextbuffer.h:
+
+/usr/include/gtk-2.0/gtk/gtktexttagtable.h:
+
+/usr/include/gtk-2.0/gtk/gtktexttag.h:
+
+/usr/include/gtk-2.0/gtk/gtktextiter.h:
+
+/usr/include/gtk-2.0/gtk/gtktextchild.h:
+
+/usr/include/gtk-2.0/gtk/gtktextmark.h:
+
+/usr/include/gtk-2.0/gtk/gtktextview.h:
+
+/usr/include/gtk-2.0/gtk/gtktipsquery.h:
+
+/usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolbar.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolitem.h:
+
+/usr/include/gtk-2.0/gtk/gtktree.h:
+
+/usr/include/gtk-2.0/gtk/gtktreednd.h:
+
+/usr/include/gtk-2.0/gtk/gtktreeitem.h:
+
+/usr/include/gtk-2.0/gtk/gtktreemodelsort.h:
+
+/usr/include/gtk-2.0/gtk/gtktreeselection.h:
+
+/usr/include/gtk-2.0/gtk/gtktreestore.h:
+
+/usr/include/gtk-2.0/gtk/gtkuimanager.h:
+
+/usr/include/gtk-2.0/gtk/gtkvbbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkversion.h:
+
+/usr/include/gtk-2.0/gtk/gtkvpaned.h:
+
+/usr/include/gtk-2.0/gtk/gtkvruler.h:
+
+/usr/include/gtk-2.0/gtk/gtkvscale.h:
+
+/usr/include/gtk-2.0/gtk/gtkvseparator.h:
+
+/usr/local/include/gaim/conversation.h:
+
+/usr/local/include/gaim/account.h:
+
+/usr/local/include/gaim/connection.h:
+
+/usr/local/include/gaim/plugin.h:
+
+/usr/local/include/gaim/signals.h:
+
+/usr/local/include/gaim/value.h:
+
+/usr/local/include/gaim/pluginpref.h:
+
+/usr/local/include/gaim/prefs.h:
+
+/usr/local/include/gaim/log.h:
+
+/usr/local/include/gaim/conversation.h:
+
+/usr/local/include/gaim/proxy.h:
+
+/usr/local/include/gaim/eventloop.h:
+
+/usr/local/include/gaim/prpl.h:
+
+/usr/local/include/gaim/blist.h:
+
+/usr/local/include/gaim/buddyicon.h:
+
+/usr/local/include/gaim/server.h:
+
+/usr/local/include/gaim/debug.h:
+
+/usr/local/include/gaim/prefs.h:
+
+/usr/local/include/gaim/signals.h:
+
+/usr/local/include/gaim/util.h:
+
+/usr/local/include/gaim/version.h:
+
+/usr/local/include/gaim/buddyicon.h:
+
+/usr/local/include/gaim/prpl.h:
+
+/usr/local/include/gaim/gtkconv.h:
+
+/usr/local/include/gaim/gtkgaim.h:
+
+/usr/local/include/gaim/gtkplugin.h:

Added: qrc/trunk/gaym-extras/src/.deps/chaticon.Plo
===================================================================
--- qrc/trunk/gaym-extras/src/.deps/chaticon.Plo	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/src/.deps/chaticon.Plo	2005-07-30 21:32:57 UTC (rev 256)
@@ -0,0 +1,1283 @@
+chaticon.lo .libs/chaticon.o: chaticon.c gaym-extras.h \
+  /usr/local/include/gaim/internal.h ../../config.h /usr/include/locale.h \
+  /usr/include/features.h /usr/include/sys/cdefs.h \
+  /usr/include/gnu/stubs.h \
+  /usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/stddef.h \
+  /usr/include/bits/locale.h /usr/include/sys/stat.h \
+  /usr/include/bits/types.h /usr/include/bits/wordsize.h \
+  /usr/include/bits/typesizes.h /usr/include/time.h \
+  /usr/include/bits/stat.h /usr/include/sys/time.h \
+  /usr/include/bits/time.h /usr/include/sys/select.h \
+  /usr/include/bits/select.h /usr/include/bits/sigset.h \
+  /usr/include/sys/types.h /usr/include/endian.h \
+  /usr/include/bits/endian.h /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h /usr/include/bits/sched.h \
+  /usr/include/sys/wait.h /usr/include/signal.h \
+  /usr/include/bits/signum.h /usr/include/bits/siginfo.h \
+  /usr/include/bits/sigaction.h /usr/include/bits/sigcontext.h \
+  /usr/include/asm/sigcontext.h /usr/include/linux/compiler.h \
+  /usr/include/bits/sigstack.h /usr/include/bits/sigthread.h \
+  /usr/include/sys/resource.h /usr/include/bits/resource.h \
+  /usr/include/bits/waitflags.h /usr/include/bits/waitstatus.h \
+  /usr/include/ctype.h /usr/include/errno.h /usr/include/bits/errno.h \
+  /usr/include/linux/errno.h /usr/include/asm/errno.h \
+  /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+  /usr/include/fcntl.h /usr/include/bits/fcntl.h /usr/include/math.h \
+  /usr/include/bits/huge_val.h /usr/include/bits/mathdef.h \
+  /usr/include/bits/mathcalls.h /usr/include/bits/mathinline.h \
+  /usr/include/stdio.h /usr/include/libio.h /usr/include/_G_config.h \
+  /usr/include/wchar.h /usr/include/bits/wchar.h /usr/include/gconv.h \
+  /usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/stdarg.h \
+  /usr/include/bits/stdio_lim.h /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h /usr/include/stdlib.h /usr/include/alloca.h \
+  /usr/include/string.h /usr/include/bits/string.h \
+  /usr/include/bits/string2.h /usr/include/glib-2.0/gmodule.h \
+  /usr/include/glib-2.0/glib.h /usr/include/glib-2.0/glib/galloca.h \
+  /usr/include/glib-2.0/glib/gtypes.h \
+  /usr/lib/glib-2.0/include/glibconfig.h \
+  /usr/include/glib-2.0/glib/gmacros.h \
+  /usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/limits.h \
+  /usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/syslimits.h \
+  /usr/include/limits.h /usr/include/bits/posix1_lim.h \
+  /usr/include/bits/local_lim.h /usr/include/linux/limits.h \
+  /usr/include/bits/posix2_lim.h \
+  /usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/float.h \
+  /usr/include/glib-2.0/glib/garray.h \
+  /usr/include/glib-2.0/glib/gasyncqueue.h \
+  /usr/include/glib-2.0/glib/gthread.h \
+  /usr/include/glib-2.0/glib/gerror.h /usr/include/glib-2.0/glib/gquark.h \
+  /usr/include/glib-2.0/glib/gatomic.h \
+  /usr/include/glib-2.0/glib/gbacktrace.h \
+  /usr/include/glib-2.0/glib/gcache.h /usr/include/glib-2.0/glib/glist.h \
+  /usr/include/glib-2.0/glib/gmem.h \
+  /usr/include/glib-2.0/glib/gcompletion.h \
+  /usr/include/glib-2.0/glib/gconvert.h \
+  /usr/include/glib-2.0/glib/gdataset.h \
+  /usr/include/glib-2.0/glib/gdate.h /usr/include/glib-2.0/glib/gdir.h \
+  /usr/include/glib-2.0/glib/gfileutils.h \
+  /usr/include/glib-2.0/glib/ghash.h /usr/include/glib-2.0/glib/ghook.h \
+  /usr/include/glib-2.0/glib/giochannel.h \
+  /usr/include/glib-2.0/glib/gmain.h /usr/include/glib-2.0/glib/gslist.h \
+  /usr/include/glib-2.0/glib/gstring.h \
+  /usr/include/glib-2.0/glib/gunicode.h \
+  /usr/include/glib-2.0/glib/gutils.h \
+  /usr/include/glib-2.0/glib/gkeyfile.h \
+  /usr/include/glib-2.0/glib/gmarkup.h \
+  /usr/include/glib-2.0/glib/gmessages.h \
+  /usr/include/glib-2.0/glib/gnode.h /usr/include/glib-2.0/glib/goption.h \
+  /usr/include/glib-2.0/glib/gpattern.h \
+  /usr/include/glib-2.0/glib/gprimes.h \
+  /usr/include/glib-2.0/glib/gqsort.h /usr/include/glib-2.0/glib/gqueue.h \
+  /usr/include/glib-2.0/glib/grand.h /usr/include/glib-2.0/glib/grel.h \
+  /usr/include/glib-2.0/glib/gscanner.h \
+  /usr/include/glib-2.0/glib/gshell.h /usr/include/glib-2.0/glib/gspawn.h \
+  /usr/include/glib-2.0/glib/gstrfuncs.h \
+  /usr/include/glib-2.0/glib/gthreadpool.h \
+  /usr/include/glib-2.0/glib/gtimer.h /usr/include/glib-2.0/glib/gtree.h \
+  /usr/include/dlfcn.h /usr/include/bits/dlfcn.h \
+  /usr/include/netinet/in.h /usr/include/stdint.h \
+  /usr/include/sys/socket.h /usr/include/sys/uio.h \
+  /usr/include/bits/uio.h /usr/include/bits/socket.h \
+  /usr/include/bits/sockaddr.h /usr/include/asm/socket.h \
+  /usr/include/asm/sockios.h /usr/include/bits/in.h \
+  /usr/include/bits/byteswap.h /usr/include/arpa/inet.h \
+  /usr/include/sys/un.h /usr/include/sys/utsname.h \
+  /usr/include/bits/utsname.h /usr/include/netdb.h \
+  /usr/include/rpc/netdb.h /usr/include/bits/netdb.h \
+  /usr/include/unistd.h /usr/include/bits/posix_opt.h \
+  /usr/include/bits/confname.h /usr/include/getopt.h \
+  /usr/include/glib-2.0/glib/gstdio.h \
+  /usr/include/glib-2.0/glib/gprintf.h /usr/local/include/gaim/prefix.h \
+  /usr/local/include/gaim/gtkgaim.h /usr/include/gtk-2.0/gdk/gdkx.h \
+  /usr/include/gtk-2.0/gdk/gdkprivate.h \
+  /usr/include/gtk-2.0/gdk/gdktypes.h \
+  /usr/include/pango-1.0/pango/pango.h \
+  /usr/include/pango-1.0/pango/pango-attributes.h \
+  /usr/include/pango-1.0/pango/pango-font.h \
+  /usr/include/pango-1.0/pango/pango-coverage.h \
+  /usr/include/pango-1.0/pango/pango-types.h \
+  /usr/include/glib-2.0/glib-object.h \
+  /usr/include/glib-2.0/gobject/gboxed.h \
+  /usr/include/glib-2.0/gobject/gtype.h \
+  /usr/include/glib-2.0/gobject/genums.h \
+  /usr/include/glib-2.0/gobject/gobject.h \
+  /usr/include/glib-2.0/gobject/gvalue.h \
+  /usr/include/glib-2.0/gobject/gparam.h \
+  /usr/include/glib-2.0/gobject/gclosure.h \
+  /usr/include/glib-2.0/gobject/gsignal.h \
+  /usr/include/glib-2.0/gobject/gmarshal.h \
+  /usr/include/glib-2.0/gobject/gparamspecs.h \
+  /usr/include/glib-2.0/gobject/gsourceclosure.h \
+  /usr/include/glib-2.0/gobject/gtypemodule.h \
+  /usr/include/glib-2.0/gobject/gtypeplugin.h \
+  /usr/include/glib-2.0/gobject/gvaluearray.h \
+  /usr/include/glib-2.0/gobject/gvaluetypes.h \
+  /usr/include/pango-1.0/pango/pango-break.h \
+  /usr/include/pango-1.0/pango/pango-item.h \
+  /usr/include/pango-1.0/pango/pango-context.h \
+  /usr/include/pango-1.0/pango/pango-fontmap.h \
+  /usr/include/pango-1.0/pango/pango-fontset.h \
+  /usr/include/pango-1.0/pango/pango-engine.h \
+  /usr/include/pango-1.0/pango/pango-glyph.h \
+  /usr/include/pango-1.0/pango/pango-script.h \
+  /usr/include/pango-1.0/pango/pango-enum-types.h \
+  /usr/include/pango-1.0/pango/pango-layout.h \
+  /usr/include/pango-1.0/pango/pango-glyph-item.h \
+  /usr/include/pango-1.0/pango/pango-tabs.h \
+  /usr/include/pango-1.0/pango/pango-renderer.h \
+  /usr/lib/gtk-2.0/include/gdkconfig.h \
+  /usr/include/gtk-2.0/gdk/gdkevents.h \
+  /usr/include/gtk-2.0/gdk/gdkcolor.h /usr/include/gtk-2.0/gdk/gdkdnd.h \
+  /usr/include/gtk-2.0/gdk/gdkinput.h /usr/include/gtk-2.0/gdk/gdkfont.h \
+  /usr/include/gtk-2.0/gdk/gdkgc.h /usr/include/gtk-2.0/gdk/gdkimage.h \
+  /usr/include/gtk-2.0/gdk/gdkregion.h \
+  /usr/include/gtk-2.0/gdk/gdkvisual.h \
+  /usr/include/gtk-2.0/gdk/gdkwindow.h \
+  /usr/include/gtk-2.0/gdk/gdkdrawable.h \
+  /usr/include/gtk-2.0/gdk/gdkrgb.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-features.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-core.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-transform.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-animation.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-io.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-loader.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-enum-types.h \
+  /usr/include/gtk-2.0/gdk/gdkcursor.h /usr/include/X11/Xlib.h \
+  /usr/include/X11/X.h /usr/include/X11/Xfuncproto.h \
+  /usr/include/X11/Xosdefs.h /usr/include/X11/Xutil.h \
+  /usr/include/gtk-2.0/gtk/gtk.h /usr/include/gtk-2.0/gdk/gdk.h \
+  /usr/include/gtk-2.0/gdk/gdkdisplay.h \
+  /usr/include/gtk-2.0/gdk/gdkenumtypes.h \
+  /usr/include/gtk-2.0/gdk/gdkkeys.h \
+  /usr/include/gtk-2.0/gdk/gdkdisplaymanager.h \
+  /usr/include/gtk-2.0/gdk/gdkpango.h \
+  /usr/include/gtk-2.0/gdk/gdkpixbuf.h \
+  /usr/include/gtk-2.0/gdk/gdkpixmap.h \
+  /usr/include/gtk-2.0/gdk/gdkproperty.h \
+  /usr/include/gtk-2.0/gdk/gdkscreen.h \
+  /usr/include/gtk-2.0/gdk/gdkselection.h \
+  /usr/include/gtk-2.0/gdk/gdkspawn.h \
+  /usr/include/gtk-2.0/gtk/gtkaboutdialog.h \
+  /usr/include/gtk-2.0/gtk/gtkdialog.h \
+  /usr/include/gtk-2.0/gtk/gtkwindow.h \
+  /usr/include/gtk-2.0/gtk/gtkaccelgroup.h \
+  /usr/include/gtk-2.0/gtk/gtkenums.h /usr/include/gtk-2.0/gtk/gtkbin.h \
+  /usr/include/gtk-2.0/gtk/gtkcontainer.h \
+  /usr/include/gtk-2.0/gtk/gtkwidget.h \
+  /usr/include/gtk-2.0/gtk/gtkobject.h \
+  /usr/include/gtk-2.0/gtk/gtktypeutils.h \
+  /usr/include/gtk-2.0/gtk/gtktypebuiltins.h \
+  /usr/include/gtk-2.0/gtk/gtkdebug.h \
+  /usr/include/gtk-2.0/gtk/gtkadjustment.h \
+  /usr/include/gtk-2.0/gtk/gtkstyle.h \
+  /usr/include/gtk-2.0/gtk/gtksettings.h /usr/include/gtk-2.0/gtk/gtkrc.h \
+  /usr/include/atk-1.0/atk/atkobject.h \
+  /usr/include/atk-1.0/atk/atkstate.h \
+  /usr/include/atk-1.0/atk/atkrelationtype.h \
+  /usr/include/gtk-2.0/gtk/gtkaccellabel.h \
+  /usr/include/gtk-2.0/gtk/gtklabel.h /usr/include/gtk-2.0/gtk/gtkmisc.h \
+  /usr/include/gtk-2.0/gtk/gtkmenu.h \
+  /usr/include/gtk-2.0/gtk/gtkmenushell.h \
+  /usr/include/gtk-2.0/gtk/gtkaccelmap.h \
+  /usr/include/gtk-2.0/gtk/gtkaccessible.h /usr/include/atk-1.0/atk/atk.h \
+  /usr/include/atk-1.0/atk/atkaction.h \
+  /usr/include/atk-1.0/atk/atkcomponent.h \
+  /usr/include/atk-1.0/atk/atkutil.h \
+  /usr/include/atk-1.0/atk/atkdocument.h \
+  /usr/include/atk-1.0/atk/atkeditabletext.h \
+  /usr/include/atk-1.0/atk/atktext.h \
+  /usr/include/atk-1.0/atk/atkgobjectaccessible.h \
+  /usr/include/atk-1.0/atk/atkhyperlink.h \
+  /usr/include/atk-1.0/atk/atkhypertext.h \
+  /usr/include/atk-1.0/atk/atkimage.h \
+  /usr/include/atk-1.0/atk/atknoopobject.h \
+  /usr/include/atk-1.0/atk/atknoopobjectfactory.h \
+  /usr/include/atk-1.0/atk/atkobjectfactory.h \
+  /usr/include/atk-1.0/atk/atkregistry.h \
+  /usr/include/atk-1.0/atk/atkobjectfactory.h \
+  /usr/include/atk-1.0/atk/atkrelation.h \
+  /usr/include/atk-1.0/atk/atkrelationset.h \
+  /usr/include/atk-1.0/atk/atkselection.h \
+  /usr/include/atk-1.0/atk/atkstateset.h \
+  /usr/include/atk-1.0/atk/atkstreamablecontent.h \
+  /usr/include/atk-1.0/atk/atktable.h /usr/include/atk-1.0/atk/atkvalue.h \
+  /usr/include/gtk-2.0/gtk/gtkaction.h \
+  /usr/include/gtk-2.0/gtk/gtkactiongroup.h \
+  /usr/include/gtk-2.0/gtk/gtkitemfactory.h \
+  /usr/include/gtk-2.0/gtk/gtkalignment.h \
+  /usr/include/gtk-2.0/gtk/gtkarrow.h \
+  /usr/include/gtk-2.0/gtk/gtkaspectframe.h \
+  /usr/include/gtk-2.0/gtk/gtkframe.h /usr/include/gtk-2.0/gtk/gtkbbox.h \
+  /usr/include/gtk-2.0/gtk/gtkbox.h \
+  /usr/include/gtk-2.0/gtk/gtkbindings.h \
+  /usr/include/gtk-2.0/gtk/gtkbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkimage.h \
+  /usr/include/gtk-2.0/gtk/gtkcalendar.h \
+  /usr/include/gtk-2.0/gtk/gtksignal.h \
+  /usr/include/gtk-2.0/gtk/gtkmarshal.h \
+  /usr/include/gtk-2.0/gtk/gtkcelllayout.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrenderer.h \
+  /usr/include/gtk-2.0/gtk/gtkcelleditable.h \
+  /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h \
+  /usr/include/gtk-2.0/gtk/gtktreemodel.h \
+  /usr/include/gtk-2.0/gtk/gtktreesortable.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrenderercombo.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrenderertext.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrendererpixbuf.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrendererprogress.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrenderertoggle.h \
+  /usr/include/gtk-2.0/gtk/gtkcellview.h \
+  /usr/include/gtk-2.0/gtk/gtkcheckbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktogglebutton.h \
+  /usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtkmenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtkitem.h \
+  /usr/include/gtk-2.0/gtk/gtkclipboard.h \
+  /usr/include/gtk-2.0/gtk/gtkselection.h \
+  /usr/include/gtk-2.0/gtk/gtkclist.h \
+  /usr/include/gtk-2.0/gtk/gtkhscrollbar.h \
+  /usr/include/gtk-2.0/gtk/gtkscrollbar.h \
+  /usr/include/gtk-2.0/gtk/gtkrange.h \
+  /usr/include/gtk-2.0/gtk/gtkvscrollbar.h \
+  /usr/include/gtk-2.0/gtk/gtkcolorbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkcolorsel.h \
+  /usr/include/gtk-2.0/gtk/gtkvbox.h \
+  /usr/include/gtk-2.0/gtk/gtkcolorseldialog.h \
+  /usr/include/gtk-2.0/gtk/gtkcombo.h /usr/include/gtk-2.0/gtk/gtkhbox.h \
+  /usr/include/gtk-2.0/gtk/gtkcombobox.h \
+  /usr/include/gtk-2.0/gtk/gtktreeview.h \
+  /usr/include/gtk-2.0/gtk/gtkdnd.h \
+  /usr/include/gtk-2.0/gtk/gtkcomboboxentry.h \
+  /usr/include/gtk-2.0/gtk/gtkctree.h /usr/include/gtk-2.0/gtk/gtkcurve.h \
+  /usr/include/gtk-2.0/gtk/gtkdrawingarea.h \
+  /usr/include/gtk-2.0/gtk/gtkeditable.h \
+  /usr/include/gtk-2.0/gtk/gtkentry.h \
+  /usr/include/gtk-2.0/gtk/gtkimcontext.h \
+  /usr/include/gtk-2.0/gtk/gtkentrycompletion.h \
+  /usr/include/gtk-2.0/gtk/gtkliststore.h \
+  /usr/include/gtk-2.0/gtk/gtktreemodelfilter.h \
+  /usr/include/gtk-2.0/gtk/gtkeventbox.h \
+  /usr/include/gtk-2.0/gtk/gtkexpander.h \
+  /usr/include/gtk-2.0/gtk/gtkfilesel.h \
+  /usr/include/gtk-2.0/gtk/gtkfixed.h \
+  /usr/include/gtk-2.0/gtk/gtkfilechooserbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkfilechooser.h \
+  /usr/include/gtk-2.0/gtk/gtkfilefilter.h \
+  /usr/include/gtk-2.0/gtk/gtkfilechooserdialog.h \
+  /usr/include/gtk-2.0/gtk/gtkfilechooser.h \
+  /usr/include/gtk-2.0/gtk/gtkfilechooserwidget.h \
+  /usr/include/gtk-2.0/gtk/gtkfontbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkfontsel.h \
+  /usr/include/gtk-2.0/gtk/gtkgamma.h /usr/include/gtk-2.0/gtk/gtkgc.h \
+  /usr/include/gtk-2.0/gtk/gtkhandlebox.h \
+  /usr/include/gtk-2.0/gtk/gtkhbbox.h \
+  /usr/include/gtk-2.0/gtk/gtkhpaned.h \
+  /usr/include/gtk-2.0/gtk/gtkpaned.h \
+  /usr/include/gtk-2.0/gtk/gtkhruler.h \
+  /usr/include/gtk-2.0/gtk/gtkruler.h \
+  /usr/include/gtk-2.0/gtk/gtkhscale.h \
+  /usr/include/gtk-2.0/gtk/gtkscale.h \
+  /usr/include/gtk-2.0/gtk/gtkhseparator.h \
+  /usr/include/gtk-2.0/gtk/gtkseparator.h \
+  /usr/include/gtk-2.0/gtk/gtkiconfactory.h \
+  /usr/include/gtk-2.0/gtk/gtkicontheme.h \
+  /usr/include/gtk-2.0/gtk/gtkiconview.h \
+  /usr/include/gtk-2.0/gtk/gtkimagemenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtkimcontextsimple.h \
+  /usr/include/gtk-2.0/gtk/gtkimmulticontext.h \
+  /usr/include/gtk-2.0/gtk/gtkinputdialog.h \
+  /usr/include/gtk-2.0/gtk/gtkinvisible.h \
+  /usr/include/gtk-2.0/gtk/gtklayout.h /usr/include/gtk-2.0/gtk/gtklist.h \
+  /usr/include/gtk-2.0/gtk/gtklistitem.h \
+  /usr/include/gtk-2.0/gtk/gtkmain.h \
+  /usr/include/gtk-2.0/gtk/gtkmenubar.h \
+  /usr/include/gtk-2.0/gtk/gtkmenutoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkmenu.h \
+  /usr/include/gtk-2.0/gtk/gtktoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktoolitem.h \
+  /usr/include/gtk-2.0/gtk/gtktooltips.h \
+  /usr/include/gtk-2.0/gtk/gtkmessagedialog.h \
+  /usr/include/gtk-2.0/gtk/gtkmodules.h \
+  /usr/include/gtk-2.0/gtk/gtknotebook.h \
+  /usr/include/gtk-2.0/gtk/gtkoldeditable.h \
+  /usr/include/gtk-2.0/gtk/gtkoptionmenu.h \
+  /usr/include/gtk-2.0/gtk/gtkpixmap.h /usr/include/gtk-2.0/gtk/gtkplug.h \
+  /usr/include/gtk-2.0/gtk/gtksocket.h \
+  /usr/include/gtk-2.0/gtk/gtkpreview.h \
+  /usr/include/gtk-2.0/gtk/gtkprogress.h \
+  /usr/include/gtk-2.0/gtk/gtkprogressbar.h \
+  /usr/include/gtk-2.0/gtk/gtkradioaction.h \
+  /usr/include/gtk-2.0/gtk/gtktoggleaction.h \
+  /usr/include/gtk-2.0/gtk/gtkradiobutton.h \
+  /usr/include/gtk-2.0/gtk/gtkradiomenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtkradiotoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h \
+  /usr/include/gtk-2.0/gtk/gtkviewport.h \
+  /usr/include/gtk-2.0/gtk/gtkseparatormenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtkseparatortoolitem.h \
+  /usr/include/gtk-2.0/gtk/gtksizegroup.h \
+  /usr/include/gtk-2.0/gtk/gtkspinbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkstatusbar.h \
+  /usr/include/gtk-2.0/gtk/gtkstock.h /usr/include/gtk-2.0/gtk/gtktable.h \
+  /usr/include/gtk-2.0/gtk/gtktearoffmenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtktext.h \
+  /usr/include/gtk-2.0/gtk/gtktextbuffer.h \
+  /usr/include/gtk-2.0/gtk/gtktexttagtable.h \
+  /usr/include/gtk-2.0/gtk/gtktexttag.h \
+  /usr/include/gtk-2.0/gtk/gtktextiter.h \
+  /usr/include/gtk-2.0/gtk/gtktextchild.h \
+  /usr/include/gtk-2.0/gtk/gtktextmark.h \
+  /usr/include/gtk-2.0/gtk/gtktextview.h \
+  /usr/include/gtk-2.0/gtk/gtktipsquery.h \
+  /usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktoolbar.h \
+  /usr/include/gtk-2.0/gtk/gtktoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktoolitem.h \
+  /usr/include/gtk-2.0/gtk/gtktree.h \
+  /usr/include/gtk-2.0/gtk/gtktreednd.h \
+  /usr/include/gtk-2.0/gtk/gtktreeitem.h \
+  /usr/include/gtk-2.0/gtk/gtktreemodelsort.h \
+  /usr/include/gtk-2.0/gtk/gtktreeselection.h \
+  /usr/include/gtk-2.0/gtk/gtktreestore.h \
+  /usr/include/gtk-2.0/gtk/gtkuimanager.h \
+  /usr/include/gtk-2.0/gtk/gtkvbbox.h \
+  /usr/include/gtk-2.0/gtk/gtkversion.h \
+  /usr/include/gtk-2.0/gtk/gtkvpaned.h \
+  /usr/include/gtk-2.0/gtk/gtkvruler.h \
+  /usr/include/gtk-2.0/gtk/gtkvscale.h \
+  /usr/include/gtk-2.0/gtk/gtkvseparator.h \
+  /usr/local/include/gaim/conversation.h \
+  /usr/local/include/gaim/account.h /usr/local/include/gaim/connection.h \
+  /usr/local/include/gaim/plugin.h /usr/local/include/gaim/signals.h \
+  /usr/local/include/gaim/value.h /usr/local/include/gaim/pluginpref.h \
+  /usr/local/include/gaim/prefs.h /usr/local/include/gaim/log.h \
+  /usr/local/include/gaim/conversation.h /usr/local/include/gaim/proxy.h \
+  /usr/local/include/gaim/eventloop.h /usr/local/include/gaim/prpl.h \
+  /usr/local/include/gaim/blist.h /usr/local/include/gaim/buddyicon.h \
+  /usr/local/include/gaim/server.h /usr/local/include/gaim/debug.h \
+  /usr/local/include/gaim/prefs.h /usr/local/include/gaim/signals.h \
+  /usr/local/include/gaim/util.h /usr/local/include/gaim/version.h \
+  /usr/local/include/gaim/buddyicon.h /usr/local/include/gaim/prpl.h \
+  /usr/local/include/gaim/gtkconv.h /usr/local/include/gaim/gtkgaim.h \
+  /usr/local/include/gaim/gtkplugin.h
+
+gaym-extras.h:
+
+/usr/local/include/gaim/internal.h:
+
+../../config.h:
+
+/usr/include/locale.h:
+
+/usr/include/features.h:
+
+/usr/include/sys/cdefs.h:
+
+/usr/include/gnu/stubs.h:
+
+/usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/stddef.h:
+
+/usr/include/bits/locale.h:
+
+/usr/include/sys/stat.h:
+
+/usr/include/bits/types.h:
+
+/usr/include/bits/wordsize.h:
+
+/usr/include/bits/typesizes.h:
+
+/usr/include/time.h:
+
+/usr/include/bits/stat.h:
+
+/usr/include/sys/time.h:
+
+/usr/include/bits/time.h:
+
+/usr/include/sys/select.h:
+
+/usr/include/bits/select.h:
+
+/usr/include/bits/sigset.h:
+
+/usr/include/sys/types.h:
+
+/usr/include/endian.h:
+
+/usr/include/bits/endian.h:
+
+/usr/include/sys/sysmacros.h:
+
+/usr/include/bits/pthreadtypes.h:
+
+/usr/include/bits/sched.h:
+
+/usr/include/sys/wait.h:
+
+/usr/include/signal.h:
+
+/usr/include/bits/signum.h:
+
+/usr/include/bits/siginfo.h:
+
+/usr/include/bits/sigaction.h:
+
+/usr/include/bits/sigcontext.h:
+
+/usr/include/asm/sigcontext.h:
+
+/usr/include/linux/compiler.h:
+
+/usr/include/bits/sigstack.h:
+
+/usr/include/bits/sigthread.h:
+
+/usr/include/sys/resource.h:
+
+/usr/include/bits/resource.h:
+
+/usr/include/bits/waitflags.h:
+
+/usr/include/bits/waitstatus.h:
+
+/usr/include/ctype.h:
+
+/usr/include/errno.h:
+
+/usr/include/bits/errno.h:
+
+/usr/include/linux/errno.h:
+
+/usr/include/asm/errno.h:
+
+/usr/include/asm-generic/errno.h:
+
+/usr/include/asm-generic/errno-base.h:
+
+/usr/include/fcntl.h:
+
+/usr/include/bits/fcntl.h:
+
+/usr/include/math.h:
+
+/usr/include/bits/huge_val.h:
+
+/usr/include/bits/mathdef.h:
+
+/usr/include/bits/mathcalls.h:
+
+/usr/include/bits/mathinline.h:
+
+/usr/include/stdio.h:
+
+/usr/include/libio.h:
+
+/usr/include/_G_config.h:
+
+/usr/include/wchar.h:
+
+/usr/include/bits/wchar.h:
+
+/usr/include/gconv.h:
+
+/usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/stdarg.h:
+
+/usr/include/bits/stdio_lim.h:
+
+/usr/include/bits/sys_errlist.h:
+
+/usr/include/bits/stdio.h:
+
+/usr/include/stdlib.h:
+
+/usr/include/alloca.h:
+
+/usr/include/string.h:
+
+/usr/include/bits/string.h:
+
+/usr/include/bits/string2.h:
+
+/usr/include/glib-2.0/gmodule.h:
+
+/usr/include/glib-2.0/glib.h:
+
+/usr/include/glib-2.0/glib/galloca.h:
+
+/usr/include/glib-2.0/glib/gtypes.h:
+
+/usr/lib/glib-2.0/include/glibconfig.h:
+
+/usr/include/glib-2.0/glib/gmacros.h:
+
+/usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/limits.h:
+
+/usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/syslimits.h:
+
+/usr/include/limits.h:
+
+/usr/include/bits/posix1_lim.h:
+
+/usr/include/bits/local_lim.h:
+
+/usr/include/linux/limits.h:
+
+/usr/include/bits/posix2_lim.h:
+
+/usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/float.h:
+
+/usr/include/glib-2.0/glib/garray.h:
+
+/usr/include/glib-2.0/glib/gasyncqueue.h:
+
+/usr/include/glib-2.0/glib/gthread.h:
+
+/usr/include/glib-2.0/glib/gerror.h:
+
+/usr/include/glib-2.0/glib/gquark.h:
+
+/usr/include/glib-2.0/glib/gatomic.h:
+
+/usr/include/glib-2.0/glib/gbacktrace.h:
+
+/usr/include/glib-2.0/glib/gcache.h:
+
+/usr/include/glib-2.0/glib/glist.h:
+
+/usr/include/glib-2.0/glib/gmem.h:
+
+/usr/include/glib-2.0/glib/gcompletion.h:
+
+/usr/include/glib-2.0/glib/gconvert.h:
+
+/usr/include/glib-2.0/glib/gdataset.h:
+
+/usr/include/glib-2.0/glib/gdate.h:
+
+/usr/include/glib-2.0/glib/gdir.h:
+
+/usr/include/glib-2.0/glib/gfileutils.h:
+
+/usr/include/glib-2.0/glib/ghash.h:
+
+/usr/include/glib-2.0/glib/ghook.h:
+
+/usr/include/glib-2.0/glib/giochannel.h:
+
+/usr/include/glib-2.0/glib/gmain.h:
+
+/usr/include/glib-2.0/glib/gslist.h:
+
+/usr/include/glib-2.0/glib/gstring.h:
+
+/usr/include/glib-2.0/glib/gunicode.h:
+
+/usr/include/glib-2.0/glib/gutils.h:
+
+/usr/include/glib-2.0/glib/gkeyfile.h:
+
+/usr/include/glib-2.0/glib/gmarkup.h:
+
+/usr/include/glib-2.0/glib/gmessages.h:
+
+/usr/include/glib-2.0/glib/gnode.h:
+
+/usr/include/glib-2.0/glib/goption.h:
+
+/usr/include/glib-2.0/glib/gpattern.h:
+
+/usr/include/glib-2.0/glib/gprimes.h:
+
+/usr/include/glib-2.0/glib/gqsort.h:
+
+/usr/include/glib-2.0/glib/gqueue.h:
+
+/usr/include/glib-2.0/glib/grand.h:
+
+/usr/include/glib-2.0/glib/grel.h:
+
+/usr/include/glib-2.0/glib/gscanner.h:
+
+/usr/include/glib-2.0/glib/gshell.h:
+
+/usr/include/glib-2.0/glib/gspawn.h:
+
+/usr/include/glib-2.0/glib/gstrfuncs.h:
+
+/usr/include/glib-2.0/glib/gthreadpool.h:
+
+/usr/include/glib-2.0/glib/gtimer.h:
+
+/usr/include/glib-2.0/glib/gtree.h:
+
+/usr/include/dlfcn.h:
+
+/usr/include/bits/dlfcn.h:
+
+/usr/include/netinet/in.h:
+
+/usr/include/stdint.h:
+
+/usr/include/sys/socket.h:
+
+/usr/include/sys/uio.h:
+
+/usr/include/bits/uio.h:
+
+/usr/include/bits/socket.h:
+
+/usr/include/bits/sockaddr.h:
+
+/usr/include/asm/socket.h:
+
+/usr/include/asm/sockios.h:
+
+/usr/include/bits/in.h:
+
+/usr/include/bits/byteswap.h:
+
+/usr/include/arpa/inet.h:
+
+/usr/include/sys/un.h:
+
+/usr/include/sys/utsname.h:
+
+/usr/include/bits/utsname.h:
+
+/usr/include/netdb.h:
+
+/usr/include/rpc/netdb.h:
+
+/usr/include/bits/netdb.h:
+
+/usr/include/unistd.h:
+
+/usr/include/bits/posix_opt.h:
+
+/usr/include/bits/confname.h:
+
+/usr/include/getopt.h:
+
+/usr/include/glib-2.0/glib/gstdio.h:
+
+/usr/include/glib-2.0/glib/gprintf.h:
+
+/usr/local/include/gaim/prefix.h:
+
+/usr/local/include/gaim/gtkgaim.h:
+
+/usr/include/gtk-2.0/gdk/gdkx.h:
+
+/usr/include/gtk-2.0/gdk/gdkprivate.h:
+
+/usr/include/gtk-2.0/gdk/gdktypes.h:
+
+/usr/include/pango-1.0/pango/pango.h:
+
+/usr/include/pango-1.0/pango/pango-attributes.h:
+
+/usr/include/pango-1.0/pango/pango-font.h:
+
+/usr/include/pango-1.0/pango/pango-coverage.h:
+
+/usr/include/pango-1.0/pango/pango-types.h:
+
+/usr/include/glib-2.0/glib-object.h:
+
+/usr/include/glib-2.0/gobject/gboxed.h:
+
+/usr/include/glib-2.0/gobject/gtype.h:
+
+/usr/include/glib-2.0/gobject/genums.h:
+
+/usr/include/glib-2.0/gobject/gobject.h:
+
+/usr/include/glib-2.0/gobject/gvalue.h:
+
+/usr/include/glib-2.0/gobject/gparam.h:
+
+/usr/include/glib-2.0/gobject/gclosure.h:
+
+/usr/include/glib-2.0/gobject/gsignal.h:
+
+/usr/include/glib-2.0/gobject/gmarshal.h:
+
+/usr/include/glib-2.0/gobject/gparamspecs.h:
+
+/usr/include/glib-2.0/gobject/gsourceclosure.h:
+
+/usr/include/glib-2.0/gobject/gtypemodule.h:
+
+/usr/include/glib-2.0/gobject/gtypeplugin.h:
+
+/usr/include/glib-2.0/gobject/gvaluearray.h:
+
+/usr/include/glib-2.0/gobject/gvaluetypes.h:
+
+/usr/include/pango-1.0/pango/pango-break.h:
+
+/usr/include/pango-1.0/pango/pango-item.h:
+
+/usr/include/pango-1.0/pango/pango-context.h:
+
+/usr/include/pango-1.0/pango/pango-fontmap.h:
+
+/usr/include/pango-1.0/pango/pango-fontset.h:
+
+/usr/include/pango-1.0/pango/pango-engine.h:
+
+/usr/include/pango-1.0/pango/pango-glyph.h:
+
+/usr/include/pango-1.0/pango/pango-script.h:
+
+/usr/include/pango-1.0/pango/pango-enum-types.h:
+
+/usr/include/pango-1.0/pango/pango-layout.h:
+
+/usr/include/pango-1.0/pango/pango-glyph-item.h:
+
+/usr/include/pango-1.0/pango/pango-tabs.h:
+
+/usr/include/pango-1.0/pango/pango-renderer.h:
+
+/usr/lib/gtk-2.0/include/gdkconfig.h:
+
+/usr/include/gtk-2.0/gdk/gdkevents.h:
+
+/usr/include/gtk-2.0/gdk/gdkcolor.h:
+
+/usr/include/gtk-2.0/gdk/gdkdnd.h:
+
+/usr/include/gtk-2.0/gdk/gdkinput.h:
+
+/usr/include/gtk-2.0/gdk/gdkfont.h:
+
+/usr/include/gtk-2.0/gdk/gdkgc.h:
+
+/usr/include/gtk-2.0/gdk/gdkimage.h:
+
+/usr/include/gtk-2.0/gdk/gdkregion.h:
+
+/usr/include/gtk-2.0/gdk/gdkvisual.h:
+
+/usr/include/gtk-2.0/gdk/gdkwindow.h:
+
+/usr/include/gtk-2.0/gdk/gdkdrawable.h:
+
+/usr/include/gtk-2.0/gdk/gdkrgb.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-features.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-core.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-transform.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-animation.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-io.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-loader.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-enum-types.h:
+
+/usr/include/gtk-2.0/gdk/gdkcursor.h:
+
+/usr/include/X11/Xlib.h:
+
+/usr/include/X11/X.h:
+
+/usr/include/X11/Xfuncproto.h:
+
+/usr/include/X11/Xosdefs.h:
+
+/usr/include/X11/Xutil.h:
+
+/usr/include/gtk-2.0/gtk/gtk.h:
+
+/usr/include/gtk-2.0/gdk/gdk.h:
+
+/usr/include/gtk-2.0/gdk/gdkdisplay.h:
+
+/usr/include/gtk-2.0/gdk/gdkenumtypes.h:
+
+/usr/include/gtk-2.0/gdk/gdkkeys.h:
+
+/usr/include/gtk-2.0/gdk/gdkdisplaymanager.h:
+
+/usr/include/gtk-2.0/gdk/gdkpango.h:
+
+/usr/include/gtk-2.0/gdk/gdkpixbuf.h:
+
+/usr/include/gtk-2.0/gdk/gdkpixmap.h:
+
+/usr/include/gtk-2.0/gdk/gdkproperty.h:
+
+/usr/include/gtk-2.0/gdk/gdkscreen.h:
+
+/usr/include/gtk-2.0/gdk/gdkselection.h:
+
+/usr/include/gtk-2.0/gdk/gdkspawn.h:
+
+/usr/include/gtk-2.0/gtk/gtkaboutdialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkdialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkwindow.h:
+
+/usr/include/gtk-2.0/gtk/gtkaccelgroup.h:
+
+/usr/include/gtk-2.0/gtk/gtkenums.h:
+
+/usr/include/gtk-2.0/gtk/gtkbin.h:
+
+/usr/include/gtk-2.0/gtk/gtkcontainer.h:
+
+/usr/include/gtk-2.0/gtk/gtkwidget.h:
+
+/usr/include/gtk-2.0/gtk/gtkobject.h:
+
+/usr/include/gtk-2.0/gtk/gtktypeutils.h:
+
+/usr/include/gtk-2.0/gtk/gtktypebuiltins.h:
+
+/usr/include/gtk-2.0/gtk/gtkdebug.h:
+
+/usr/include/gtk-2.0/gtk/gtkadjustment.h:
+
+/usr/include/gtk-2.0/gtk/gtkstyle.h:
+
+/usr/include/gtk-2.0/gtk/gtksettings.h:
+
+/usr/include/gtk-2.0/gtk/gtkrc.h:
+
+/usr/include/atk-1.0/atk/atkobject.h:
+
+/usr/include/atk-1.0/atk/atkstate.h:
+
+/usr/include/atk-1.0/atk/atkrelationtype.h:
+
+/usr/include/gtk-2.0/gtk/gtkaccellabel.h:
+
+/usr/include/gtk-2.0/gtk/gtklabel.h:
+
+/usr/include/gtk-2.0/gtk/gtkmisc.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenu.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenushell.h:
+
+/usr/include/gtk-2.0/gtk/gtkaccelmap.h:
+
+/usr/include/gtk-2.0/gtk/gtkaccessible.h:
+
+/usr/include/atk-1.0/atk/atk.h:
+
+/usr/include/atk-1.0/atk/atkaction.h:
+
+/usr/include/atk-1.0/atk/atkcomponent.h:
+
+/usr/include/atk-1.0/atk/atkutil.h:
+
+/usr/include/atk-1.0/atk/atkdocument.h:
+
+/usr/include/atk-1.0/atk/atkeditabletext.h:
+
+/usr/include/atk-1.0/atk/atktext.h:
+
+/usr/include/atk-1.0/atk/atkgobjectaccessible.h:
+
+/usr/include/atk-1.0/atk/atkhyperlink.h:
+
+/usr/include/atk-1.0/atk/atkhypertext.h:
+
+/usr/include/atk-1.0/atk/atkimage.h:
+
+/usr/include/atk-1.0/atk/atknoopobject.h:
+
+/usr/include/atk-1.0/atk/atknoopobjectfactory.h:
+
+/usr/include/atk-1.0/atk/atkobjectfactory.h:
+
+/usr/include/atk-1.0/atk/atkregistry.h:
+
+/usr/include/atk-1.0/atk/atkobjectfactory.h:
+
+/usr/include/atk-1.0/atk/atkrelation.h:
+
+/usr/include/atk-1.0/atk/atkrelationset.h:
+
+/usr/include/atk-1.0/atk/atkselection.h:
+
+/usr/include/atk-1.0/atk/atkstateset.h:
+
+/usr/include/atk-1.0/atk/atkstreamablecontent.h:
+
+/usr/include/atk-1.0/atk/atktable.h:
+
+/usr/include/atk-1.0/atk/atkvalue.h:
+
+/usr/include/gtk-2.0/gtk/gtkaction.h:
+
+/usr/include/gtk-2.0/gtk/gtkactiongroup.h:
+
+/usr/include/gtk-2.0/gtk/gtkitemfactory.h:
+
+/usr/include/gtk-2.0/gtk/gtkalignment.h:
+
+/usr/include/gtk-2.0/gtk/gtkarrow.h:
+
+/usr/include/gtk-2.0/gtk/gtkaspectframe.h:
+
+/usr/include/gtk-2.0/gtk/gtkframe.h:
+
+/usr/include/gtk-2.0/gtk/gtkbbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkbindings.h:
+
+/usr/include/gtk-2.0/gtk/gtkbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkimage.h:
+
+/usr/include/gtk-2.0/gtk/gtkcalendar.h:
+
+/usr/include/gtk-2.0/gtk/gtksignal.h:
+
+/usr/include/gtk-2.0/gtk/gtkmarshal.h:
+
+/usr/include/gtk-2.0/gtk/gtkcelllayout.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrenderer.h:
+
+/usr/include/gtk-2.0/gtk/gtkcelleditable.h:
+
+/usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h:
+
+/usr/include/gtk-2.0/gtk/gtktreemodel.h:
+
+/usr/include/gtk-2.0/gtk/gtktreesortable.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrenderercombo.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrenderertext.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrendererpixbuf.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrendererprogress.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrenderertoggle.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellview.h:
+
+/usr/include/gtk-2.0/gtk/gtkcheckbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktogglebutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkclipboard.h:
+
+/usr/include/gtk-2.0/gtk/gtkselection.h:
+
+/usr/include/gtk-2.0/gtk/gtkclist.h:
+
+/usr/include/gtk-2.0/gtk/gtkhscrollbar.h:
+
+/usr/include/gtk-2.0/gtk/gtkscrollbar.h:
+
+/usr/include/gtk-2.0/gtk/gtkrange.h:
+
+/usr/include/gtk-2.0/gtk/gtkvscrollbar.h:
+
+/usr/include/gtk-2.0/gtk/gtkcolorbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkcolorsel.h:
+
+/usr/include/gtk-2.0/gtk/gtkvbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkcolorseldialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkcombo.h:
+
+/usr/include/gtk-2.0/gtk/gtkhbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkcombobox.h:
+
+/usr/include/gtk-2.0/gtk/gtktreeview.h:
+
+/usr/include/gtk-2.0/gtk/gtkdnd.h:
+
+/usr/include/gtk-2.0/gtk/gtkcomboboxentry.h:
+
+/usr/include/gtk-2.0/gtk/gtkctree.h:
+
+/usr/include/gtk-2.0/gtk/gtkcurve.h:
+
+/usr/include/gtk-2.0/gtk/gtkdrawingarea.h:
+
+/usr/include/gtk-2.0/gtk/gtkeditable.h:
+
+/usr/include/gtk-2.0/gtk/gtkentry.h:
+
+/usr/include/gtk-2.0/gtk/gtkimcontext.h:
+
+/usr/include/gtk-2.0/gtk/gtkentrycompletion.h:
+
+/usr/include/gtk-2.0/gtk/gtkliststore.h:
+
+/usr/include/gtk-2.0/gtk/gtktreemodelfilter.h:
+
+/usr/include/gtk-2.0/gtk/gtkeventbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkexpander.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilesel.h:
+
+/usr/include/gtk-2.0/gtk/gtkfixed.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilechooserbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilechooser.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilefilter.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilechooserdialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilechooser.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilechooserwidget.h:
+
+/usr/include/gtk-2.0/gtk/gtkfontbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkfontsel.h:
+
+/usr/include/gtk-2.0/gtk/gtkgamma.h:
+
+/usr/include/gtk-2.0/gtk/gtkgc.h:
+
+/usr/include/gtk-2.0/gtk/gtkhandlebox.h:
+
+/usr/include/gtk-2.0/gtk/gtkhbbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkhpaned.h:
+
+/usr/include/gtk-2.0/gtk/gtkpaned.h:
+
+/usr/include/gtk-2.0/gtk/gtkhruler.h:
+
+/usr/include/gtk-2.0/gtk/gtkruler.h:
+
+/usr/include/gtk-2.0/gtk/gtkhscale.h:
+
+/usr/include/gtk-2.0/gtk/gtkscale.h:
+
+/usr/include/gtk-2.0/gtk/gtkhseparator.h:
+
+/usr/include/gtk-2.0/gtk/gtkseparator.h:
+
+/usr/include/gtk-2.0/gtk/gtkiconfactory.h:
+
+/usr/include/gtk-2.0/gtk/gtkicontheme.h:
+
+/usr/include/gtk-2.0/gtk/gtkiconview.h:
+
+/usr/include/gtk-2.0/gtk/gtkimagemenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkimcontextsimple.h:
+
+/usr/include/gtk-2.0/gtk/gtkimmulticontext.h:
+
+/usr/include/gtk-2.0/gtk/gtkinputdialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkinvisible.h:
+
+/usr/include/gtk-2.0/gtk/gtklayout.h:
+
+/usr/include/gtk-2.0/gtk/gtklist.h:
+
+/usr/include/gtk-2.0/gtk/gtklistitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkmain.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenubar.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenutoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenu.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolitem.h:
+
+/usr/include/gtk-2.0/gtk/gtktooltips.h:
+
+/usr/include/gtk-2.0/gtk/gtkmessagedialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkmodules.h:
+
+/usr/include/gtk-2.0/gtk/gtknotebook.h:
+
+/usr/include/gtk-2.0/gtk/gtkoldeditable.h:
+
+/usr/include/gtk-2.0/gtk/gtkoptionmenu.h:
+
+/usr/include/gtk-2.0/gtk/gtkpixmap.h:
+
+/usr/include/gtk-2.0/gtk/gtkplug.h:
+
+/usr/include/gtk-2.0/gtk/gtksocket.h:
+
+/usr/include/gtk-2.0/gtk/gtkpreview.h:
+
+/usr/include/gtk-2.0/gtk/gtkprogress.h:
+
+/usr/include/gtk-2.0/gtk/gtkprogressbar.h:
+
+/usr/include/gtk-2.0/gtk/gtkradioaction.h:
+
+/usr/include/gtk-2.0/gtk/gtktoggleaction.h:
+
+/usr/include/gtk-2.0/gtk/gtkradiobutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkradiomenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkradiotoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkscrolledwindow.h:
+
+/usr/include/gtk-2.0/gtk/gtkviewport.h:
+
+/usr/include/gtk-2.0/gtk/gtkseparatormenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkseparatortoolitem.h:
+
+/usr/include/gtk-2.0/gtk/gtksizegroup.h:
+
+/usr/include/gtk-2.0/gtk/gtkspinbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkstatusbar.h:
+
+/usr/include/gtk-2.0/gtk/gtkstock.h:
+
+/usr/include/gtk-2.0/gtk/gtktable.h:
+
+/usr/include/gtk-2.0/gtk/gtktearoffmenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtktext.h:
+
+/usr/include/gtk-2.0/gtk/gtktextbuffer.h:
+
+/usr/include/gtk-2.0/gtk/gtktexttagtable.h:
+
+/usr/include/gtk-2.0/gtk/gtktexttag.h:
+
+/usr/include/gtk-2.0/gtk/gtktextiter.h:
+
+/usr/include/gtk-2.0/gtk/gtktextchild.h:
+
+/usr/include/gtk-2.0/gtk/gtktextmark.h:
+
+/usr/include/gtk-2.0/gtk/gtktextview.h:
+
+/usr/include/gtk-2.0/gtk/gtktipsquery.h:
+
+/usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolbar.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolitem.h:
+
+/usr/include/gtk-2.0/gtk/gtktree.h:
+
+/usr/include/gtk-2.0/gtk/gtktreednd.h:
+
+/usr/include/gtk-2.0/gtk/gtktreeitem.h:
+
+/usr/include/gtk-2.0/gtk/gtktreemodelsort.h:
+
+/usr/include/gtk-2.0/gtk/gtktreeselection.h:
+
+/usr/include/gtk-2.0/gtk/gtktreestore.h:
+
+/usr/include/gtk-2.0/gtk/gtkuimanager.h:
+
+/usr/include/gtk-2.0/gtk/gtkvbbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkversion.h:
+
+/usr/include/gtk-2.0/gtk/gtkvpaned.h:
+
+/usr/include/gtk-2.0/gtk/gtkvruler.h:
+
+/usr/include/gtk-2.0/gtk/gtkvscale.h:
+
+/usr/include/gtk-2.0/gtk/gtkvseparator.h:
+
+/usr/local/include/gaim/conversation.h:
+
+/usr/local/include/gaim/account.h:
+
+/usr/local/include/gaim/connection.h:
+
+/usr/local/include/gaim/plugin.h:
+
+/usr/local/include/gaim/signals.h:
+
+/usr/local/include/gaim/value.h:
+
+/usr/local/include/gaim/pluginpref.h:
+
+/usr/local/include/gaim/prefs.h:
+
+/usr/local/include/gaim/log.h:
+
+/usr/local/include/gaim/conversation.h:
+
+/usr/local/include/gaim/proxy.h:
+
+/usr/local/include/gaim/eventloop.h:
+
+/usr/local/include/gaim/prpl.h:
+
+/usr/local/include/gaim/blist.h:
+
+/usr/local/include/gaim/buddyicon.h:
+
+/usr/local/include/gaim/server.h:
+
+/usr/local/include/gaim/debug.h:
+
+/usr/local/include/gaim/prefs.h:
+
+/usr/local/include/gaim/signals.h:
+
+/usr/local/include/gaim/util.h:
+
+/usr/local/include/gaim/version.h:
+
+/usr/local/include/gaim/buddyicon.h:
+
+/usr/local/include/gaim/prpl.h:
+
+/usr/local/include/gaim/gtkconv.h:
+
+/usr/local/include/gaim/gtkgaim.h:
+
+/usr/local/include/gaim/gtkplugin.h:

Added: qrc/trunk/gaym-extras/src/.deps/chatsort.Plo
===================================================================
--- qrc/trunk/gaym-extras/src/.deps/chatsort.Plo	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/src/.deps/chatsort.Plo	2005-07-30 21:32:57 UTC (rev 256)
@@ -0,0 +1,1283 @@
+chatsort.lo .libs/chatsort.o: chatsort.c gaym-extras.h \
+  /usr/local/include/gaim/internal.h ../../config.h /usr/include/locale.h \
+  /usr/include/features.h /usr/include/sys/cdefs.h \
+  /usr/include/gnu/stubs.h \
+  /usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/stddef.h \
+  /usr/include/bits/locale.h /usr/include/sys/stat.h \
+  /usr/include/bits/types.h /usr/include/bits/wordsize.h \
+  /usr/include/bits/typesizes.h /usr/include/time.h \
+  /usr/include/bits/stat.h /usr/include/sys/time.h \
+  /usr/include/bits/time.h /usr/include/sys/select.h \
+  /usr/include/bits/select.h /usr/include/bits/sigset.h \
+  /usr/include/sys/types.h /usr/include/endian.h \
+  /usr/include/bits/endian.h /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h /usr/include/bits/sched.h \
+  /usr/include/sys/wait.h /usr/include/signal.h \
+  /usr/include/bits/signum.h /usr/include/bits/siginfo.h \
+  /usr/include/bits/sigaction.h /usr/include/bits/sigcontext.h \
+  /usr/include/asm/sigcontext.h /usr/include/linux/compiler.h \
+  /usr/include/bits/sigstack.h /usr/include/bits/sigthread.h \
+  /usr/include/sys/resource.h /usr/include/bits/resource.h \
+  /usr/include/bits/waitflags.h /usr/include/bits/waitstatus.h \
+  /usr/include/ctype.h /usr/include/errno.h /usr/include/bits/errno.h \
+  /usr/include/linux/errno.h /usr/include/asm/errno.h \
+  /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+  /usr/include/fcntl.h /usr/include/bits/fcntl.h /usr/include/math.h \
+  /usr/include/bits/huge_val.h /usr/include/bits/mathdef.h \
+  /usr/include/bits/mathcalls.h /usr/include/bits/mathinline.h \
+  /usr/include/stdio.h /usr/include/libio.h /usr/include/_G_config.h \
+  /usr/include/wchar.h /usr/include/bits/wchar.h /usr/include/gconv.h \
+  /usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/stdarg.h \
+  /usr/include/bits/stdio_lim.h /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h /usr/include/stdlib.h /usr/include/alloca.h \
+  /usr/include/string.h /usr/include/bits/string.h \
+  /usr/include/bits/string2.h /usr/include/glib-2.0/gmodule.h \
+  /usr/include/glib-2.0/glib.h /usr/include/glib-2.0/glib/galloca.h \
+  /usr/include/glib-2.0/glib/gtypes.h \
+  /usr/lib/glib-2.0/include/glibconfig.h \
+  /usr/include/glib-2.0/glib/gmacros.h \
+  /usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/limits.h \
+  /usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/syslimits.h \
+  /usr/include/limits.h /usr/include/bits/posix1_lim.h \
+  /usr/include/bits/local_lim.h /usr/include/linux/limits.h \
+  /usr/include/bits/posix2_lim.h \
+  /usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/float.h \
+  /usr/include/glib-2.0/glib/garray.h \
+  /usr/include/glib-2.0/glib/gasyncqueue.h \
+  /usr/include/glib-2.0/glib/gthread.h \
+  /usr/include/glib-2.0/glib/gerror.h /usr/include/glib-2.0/glib/gquark.h \
+  /usr/include/glib-2.0/glib/gatomic.h \
+  /usr/include/glib-2.0/glib/gbacktrace.h \
+  /usr/include/glib-2.0/glib/gcache.h /usr/include/glib-2.0/glib/glist.h \
+  /usr/include/glib-2.0/glib/gmem.h \
+  /usr/include/glib-2.0/glib/gcompletion.h \
+  /usr/include/glib-2.0/glib/gconvert.h \
+  /usr/include/glib-2.0/glib/gdataset.h \
+  /usr/include/glib-2.0/glib/gdate.h /usr/include/glib-2.0/glib/gdir.h \
+  /usr/include/glib-2.0/glib/gfileutils.h \
+  /usr/include/glib-2.0/glib/ghash.h /usr/include/glib-2.0/glib/ghook.h \
+  /usr/include/glib-2.0/glib/giochannel.h \
+  /usr/include/glib-2.0/glib/gmain.h /usr/include/glib-2.0/glib/gslist.h \
+  /usr/include/glib-2.0/glib/gstring.h \
+  /usr/include/glib-2.0/glib/gunicode.h \
+  /usr/include/glib-2.0/glib/gutils.h \
+  /usr/include/glib-2.0/glib/gkeyfile.h \
+  /usr/include/glib-2.0/glib/gmarkup.h \
+  /usr/include/glib-2.0/glib/gmessages.h \
+  /usr/include/glib-2.0/glib/gnode.h /usr/include/glib-2.0/glib/goption.h \
+  /usr/include/glib-2.0/glib/gpattern.h \
+  /usr/include/glib-2.0/glib/gprimes.h \
+  /usr/include/glib-2.0/glib/gqsort.h /usr/include/glib-2.0/glib/gqueue.h \
+  /usr/include/glib-2.0/glib/grand.h /usr/include/glib-2.0/glib/grel.h \
+  /usr/include/glib-2.0/glib/gscanner.h \
+  /usr/include/glib-2.0/glib/gshell.h /usr/include/glib-2.0/glib/gspawn.h \
+  /usr/include/glib-2.0/glib/gstrfuncs.h \
+  /usr/include/glib-2.0/glib/gthreadpool.h \
+  /usr/include/glib-2.0/glib/gtimer.h /usr/include/glib-2.0/glib/gtree.h \
+  /usr/include/dlfcn.h /usr/include/bits/dlfcn.h \
+  /usr/include/netinet/in.h /usr/include/stdint.h \
+  /usr/include/sys/socket.h /usr/include/sys/uio.h \
+  /usr/include/bits/uio.h /usr/include/bits/socket.h \
+  /usr/include/bits/sockaddr.h /usr/include/asm/socket.h \
+  /usr/include/asm/sockios.h /usr/include/bits/in.h \
+  /usr/include/bits/byteswap.h /usr/include/arpa/inet.h \
+  /usr/include/sys/un.h /usr/include/sys/utsname.h \
+  /usr/include/bits/utsname.h /usr/include/netdb.h \
+  /usr/include/rpc/netdb.h /usr/include/bits/netdb.h \
+  /usr/include/unistd.h /usr/include/bits/posix_opt.h \
+  /usr/include/bits/confname.h /usr/include/getopt.h \
+  /usr/include/glib-2.0/glib/gstdio.h \
+  /usr/include/glib-2.0/glib/gprintf.h /usr/local/include/gaim/prefix.h \
+  /usr/local/include/gaim/gtkgaim.h /usr/include/gtk-2.0/gdk/gdkx.h \
+  /usr/include/gtk-2.0/gdk/gdkprivate.h \
+  /usr/include/gtk-2.0/gdk/gdktypes.h \
+  /usr/include/pango-1.0/pango/pango.h \
+  /usr/include/pango-1.0/pango/pango-attributes.h \
+  /usr/include/pango-1.0/pango/pango-font.h \
+  /usr/include/pango-1.0/pango/pango-coverage.h \
+  /usr/include/pango-1.0/pango/pango-types.h \
+  /usr/include/glib-2.0/glib-object.h \
+  /usr/include/glib-2.0/gobject/gboxed.h \
+  /usr/include/glib-2.0/gobject/gtype.h \
+  /usr/include/glib-2.0/gobject/genums.h \
+  /usr/include/glib-2.0/gobject/gobject.h \
+  /usr/include/glib-2.0/gobject/gvalue.h \
+  /usr/include/glib-2.0/gobject/gparam.h \
+  /usr/include/glib-2.0/gobject/gclosure.h \
+  /usr/include/glib-2.0/gobject/gsignal.h \
+  /usr/include/glib-2.0/gobject/gmarshal.h \
+  /usr/include/glib-2.0/gobject/gparamspecs.h \
+  /usr/include/glib-2.0/gobject/gsourceclosure.h \
+  /usr/include/glib-2.0/gobject/gtypemodule.h \
+  /usr/include/glib-2.0/gobject/gtypeplugin.h \
+  /usr/include/glib-2.0/gobject/gvaluearray.h \
+  /usr/include/glib-2.0/gobject/gvaluetypes.h \
+  /usr/include/pango-1.0/pango/pango-break.h \
+  /usr/include/pango-1.0/pango/pango-item.h \
+  /usr/include/pango-1.0/pango/pango-context.h \
+  /usr/include/pango-1.0/pango/pango-fontmap.h \
+  /usr/include/pango-1.0/pango/pango-fontset.h \
+  /usr/include/pango-1.0/pango/pango-engine.h \
+  /usr/include/pango-1.0/pango/pango-glyph.h \
+  /usr/include/pango-1.0/pango/pango-script.h \
+  /usr/include/pango-1.0/pango/pango-enum-types.h \
+  /usr/include/pango-1.0/pango/pango-layout.h \
+  /usr/include/pango-1.0/pango/pango-glyph-item.h \
+  /usr/include/pango-1.0/pango/pango-tabs.h \
+  /usr/include/pango-1.0/pango/pango-renderer.h \
+  /usr/lib/gtk-2.0/include/gdkconfig.h \
+  /usr/include/gtk-2.0/gdk/gdkevents.h \
+  /usr/include/gtk-2.0/gdk/gdkcolor.h /usr/include/gtk-2.0/gdk/gdkdnd.h \
+  /usr/include/gtk-2.0/gdk/gdkinput.h /usr/include/gtk-2.0/gdk/gdkfont.h \
+  /usr/include/gtk-2.0/gdk/gdkgc.h /usr/include/gtk-2.0/gdk/gdkimage.h \
+  /usr/include/gtk-2.0/gdk/gdkregion.h \
+  /usr/include/gtk-2.0/gdk/gdkvisual.h \
+  /usr/include/gtk-2.0/gdk/gdkwindow.h \
+  /usr/include/gtk-2.0/gdk/gdkdrawable.h \
+  /usr/include/gtk-2.0/gdk/gdkrgb.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-features.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-core.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-transform.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-animation.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-io.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-loader.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-enum-types.h \
+  /usr/include/gtk-2.0/gdk/gdkcursor.h /usr/include/X11/Xlib.h \
+  /usr/include/X11/X.h /usr/include/X11/Xfuncproto.h \
+  /usr/include/X11/Xosdefs.h /usr/include/X11/Xutil.h \
+  /usr/include/gtk-2.0/gtk/gtk.h /usr/include/gtk-2.0/gdk/gdk.h \
+  /usr/include/gtk-2.0/gdk/gdkdisplay.h \
+  /usr/include/gtk-2.0/gdk/gdkenumtypes.h \
+  /usr/include/gtk-2.0/gdk/gdkkeys.h \
+  /usr/include/gtk-2.0/gdk/gdkdisplaymanager.h \
+  /usr/include/gtk-2.0/gdk/gdkpango.h \
+  /usr/include/gtk-2.0/gdk/gdkpixbuf.h \
+  /usr/include/gtk-2.0/gdk/gdkpixmap.h \
+  /usr/include/gtk-2.0/gdk/gdkproperty.h \
+  /usr/include/gtk-2.0/gdk/gdkscreen.h \
+  /usr/include/gtk-2.0/gdk/gdkselection.h \
+  /usr/include/gtk-2.0/gdk/gdkspawn.h \
+  /usr/include/gtk-2.0/gtk/gtkaboutdialog.h \
+  /usr/include/gtk-2.0/gtk/gtkdialog.h \
+  /usr/include/gtk-2.0/gtk/gtkwindow.h \
+  /usr/include/gtk-2.0/gtk/gtkaccelgroup.h \
+  /usr/include/gtk-2.0/gtk/gtkenums.h /usr/include/gtk-2.0/gtk/gtkbin.h \
+  /usr/include/gtk-2.0/gtk/gtkcontainer.h \
+  /usr/include/gtk-2.0/gtk/gtkwidget.h \
+  /usr/include/gtk-2.0/gtk/gtkobject.h \
+  /usr/include/gtk-2.0/gtk/gtktypeutils.h \
+  /usr/include/gtk-2.0/gtk/gtktypebuiltins.h \
+  /usr/include/gtk-2.0/gtk/gtkdebug.h \
+  /usr/include/gtk-2.0/gtk/gtkadjustment.h \
+  /usr/include/gtk-2.0/gtk/gtkstyle.h \
+  /usr/include/gtk-2.0/gtk/gtksettings.h /usr/include/gtk-2.0/gtk/gtkrc.h \
+  /usr/include/atk-1.0/atk/atkobject.h \
+  /usr/include/atk-1.0/atk/atkstate.h \
+  /usr/include/atk-1.0/atk/atkrelationtype.h \
+  /usr/include/gtk-2.0/gtk/gtkaccellabel.h \
+  /usr/include/gtk-2.0/gtk/gtklabel.h /usr/include/gtk-2.0/gtk/gtkmisc.h \
+  /usr/include/gtk-2.0/gtk/gtkmenu.h \
+  /usr/include/gtk-2.0/gtk/gtkmenushell.h \
+  /usr/include/gtk-2.0/gtk/gtkaccelmap.h \
+  /usr/include/gtk-2.0/gtk/gtkaccessible.h /usr/include/atk-1.0/atk/atk.h \
+  /usr/include/atk-1.0/atk/atkaction.h \
+  /usr/include/atk-1.0/atk/atkcomponent.h \
+  /usr/include/atk-1.0/atk/atkutil.h \
+  /usr/include/atk-1.0/atk/atkdocument.h \
+  /usr/include/atk-1.0/atk/atkeditabletext.h \
+  /usr/include/atk-1.0/atk/atktext.h \
+  /usr/include/atk-1.0/atk/atkgobjectaccessible.h \
+  /usr/include/atk-1.0/atk/atkhyperlink.h \
+  /usr/include/atk-1.0/atk/atkhypertext.h \
+  /usr/include/atk-1.0/atk/atkimage.h \
+  /usr/include/atk-1.0/atk/atknoopobject.h \
+  /usr/include/atk-1.0/atk/atknoopobjectfactory.h \
+  /usr/include/atk-1.0/atk/atkobjectfactory.h \
+  /usr/include/atk-1.0/atk/atkregistry.h \
+  /usr/include/atk-1.0/atk/atkobjectfactory.h \
+  /usr/include/atk-1.0/atk/atkrelation.h \
+  /usr/include/atk-1.0/atk/atkrelationset.h \
+  /usr/include/atk-1.0/atk/atkselection.h \
+  /usr/include/atk-1.0/atk/atkstateset.h \
+  /usr/include/atk-1.0/atk/atkstreamablecontent.h \
+  /usr/include/atk-1.0/atk/atktable.h /usr/include/atk-1.0/atk/atkvalue.h \
+  /usr/include/gtk-2.0/gtk/gtkaction.h \
+  /usr/include/gtk-2.0/gtk/gtkactiongroup.h \
+  /usr/include/gtk-2.0/gtk/gtkitemfactory.h \
+  /usr/include/gtk-2.0/gtk/gtkalignment.h \
+  /usr/include/gtk-2.0/gtk/gtkarrow.h \
+  /usr/include/gtk-2.0/gtk/gtkaspectframe.h \
+  /usr/include/gtk-2.0/gtk/gtkframe.h /usr/include/gtk-2.0/gtk/gtkbbox.h \
+  /usr/include/gtk-2.0/gtk/gtkbox.h \
+  /usr/include/gtk-2.0/gtk/gtkbindings.h \
+  /usr/include/gtk-2.0/gtk/gtkbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkimage.h \
+  /usr/include/gtk-2.0/gtk/gtkcalendar.h \
+  /usr/include/gtk-2.0/gtk/gtksignal.h \
+  /usr/include/gtk-2.0/gtk/gtkmarshal.h \
+  /usr/include/gtk-2.0/gtk/gtkcelllayout.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrenderer.h \
+  /usr/include/gtk-2.0/gtk/gtkcelleditable.h \
+  /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h \
+  /usr/include/gtk-2.0/gtk/gtktreemodel.h \
+  /usr/include/gtk-2.0/gtk/gtktreesortable.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrenderercombo.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrenderertext.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrendererpixbuf.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrendererprogress.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrenderertoggle.h \
+  /usr/include/gtk-2.0/gtk/gtkcellview.h \
+  /usr/include/gtk-2.0/gtk/gtkcheckbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktogglebutton.h \
+  /usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtkmenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtkitem.h \
+  /usr/include/gtk-2.0/gtk/gtkclipboard.h \
+  /usr/include/gtk-2.0/gtk/gtkselection.h \
+  /usr/include/gtk-2.0/gtk/gtkclist.h \
+  /usr/include/gtk-2.0/gtk/gtkhscrollbar.h \
+  /usr/include/gtk-2.0/gtk/gtkscrollbar.h \
+  /usr/include/gtk-2.0/gtk/gtkrange.h \
+  /usr/include/gtk-2.0/gtk/gtkvscrollbar.h \
+  /usr/include/gtk-2.0/gtk/gtkcolorbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkcolorsel.h \
+  /usr/include/gtk-2.0/gtk/gtkvbox.h \
+  /usr/include/gtk-2.0/gtk/gtkcolorseldialog.h \
+  /usr/include/gtk-2.0/gtk/gtkcombo.h /usr/include/gtk-2.0/gtk/gtkhbox.h \
+  /usr/include/gtk-2.0/gtk/gtkcombobox.h \
+  /usr/include/gtk-2.0/gtk/gtktreeview.h \
+  /usr/include/gtk-2.0/gtk/gtkdnd.h \
+  /usr/include/gtk-2.0/gtk/gtkcomboboxentry.h \
+  /usr/include/gtk-2.0/gtk/gtkctree.h /usr/include/gtk-2.0/gtk/gtkcurve.h \
+  /usr/include/gtk-2.0/gtk/gtkdrawingarea.h \
+  /usr/include/gtk-2.0/gtk/gtkeditable.h \
+  /usr/include/gtk-2.0/gtk/gtkentry.h \
+  /usr/include/gtk-2.0/gtk/gtkimcontext.h \
+  /usr/include/gtk-2.0/gtk/gtkentrycompletion.h \
+  /usr/include/gtk-2.0/gtk/gtkliststore.h \
+  /usr/include/gtk-2.0/gtk/gtktreemodelfilter.h \
+  /usr/include/gtk-2.0/gtk/gtkeventbox.h \
+  /usr/include/gtk-2.0/gtk/gtkexpander.h \
+  /usr/include/gtk-2.0/gtk/gtkfilesel.h \
+  /usr/include/gtk-2.0/gtk/gtkfixed.h \
+  /usr/include/gtk-2.0/gtk/gtkfilechooserbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkfilechooser.h \
+  /usr/include/gtk-2.0/gtk/gtkfilefilter.h \
+  /usr/include/gtk-2.0/gtk/gtkfilechooserdialog.h \
+  /usr/include/gtk-2.0/gtk/gtkfilechooser.h \
+  /usr/include/gtk-2.0/gtk/gtkfilechooserwidget.h \
+  /usr/include/gtk-2.0/gtk/gtkfontbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkfontsel.h \
+  /usr/include/gtk-2.0/gtk/gtkgamma.h /usr/include/gtk-2.0/gtk/gtkgc.h \
+  /usr/include/gtk-2.0/gtk/gtkhandlebox.h \
+  /usr/include/gtk-2.0/gtk/gtkhbbox.h \
+  /usr/include/gtk-2.0/gtk/gtkhpaned.h \
+  /usr/include/gtk-2.0/gtk/gtkpaned.h \
+  /usr/include/gtk-2.0/gtk/gtkhruler.h \
+  /usr/include/gtk-2.0/gtk/gtkruler.h \
+  /usr/include/gtk-2.0/gtk/gtkhscale.h \
+  /usr/include/gtk-2.0/gtk/gtkscale.h \
+  /usr/include/gtk-2.0/gtk/gtkhseparator.h \
+  /usr/include/gtk-2.0/gtk/gtkseparator.h \
+  /usr/include/gtk-2.0/gtk/gtkiconfactory.h \
+  /usr/include/gtk-2.0/gtk/gtkicontheme.h \
+  /usr/include/gtk-2.0/gtk/gtkiconview.h \
+  /usr/include/gtk-2.0/gtk/gtkimagemenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtkimcontextsimple.h \
+  /usr/include/gtk-2.0/gtk/gtkimmulticontext.h \
+  /usr/include/gtk-2.0/gtk/gtkinputdialog.h \
+  /usr/include/gtk-2.0/gtk/gtkinvisible.h \
+  /usr/include/gtk-2.0/gtk/gtklayout.h /usr/include/gtk-2.0/gtk/gtklist.h \
+  /usr/include/gtk-2.0/gtk/gtklistitem.h \
+  /usr/include/gtk-2.0/gtk/gtkmain.h \
+  /usr/include/gtk-2.0/gtk/gtkmenubar.h \
+  /usr/include/gtk-2.0/gtk/gtkmenutoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkmenu.h \
+  /usr/include/gtk-2.0/gtk/gtktoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktoolitem.h \
+  /usr/include/gtk-2.0/gtk/gtktooltips.h \
+  /usr/include/gtk-2.0/gtk/gtkmessagedialog.h \
+  /usr/include/gtk-2.0/gtk/gtkmodules.h \
+  /usr/include/gtk-2.0/gtk/gtknotebook.h \
+  /usr/include/gtk-2.0/gtk/gtkoldeditable.h \
+  /usr/include/gtk-2.0/gtk/gtkoptionmenu.h \
+  /usr/include/gtk-2.0/gtk/gtkpixmap.h /usr/include/gtk-2.0/gtk/gtkplug.h \
+  /usr/include/gtk-2.0/gtk/gtksocket.h \
+  /usr/include/gtk-2.0/gtk/gtkpreview.h \
+  /usr/include/gtk-2.0/gtk/gtkprogress.h \
+  /usr/include/gtk-2.0/gtk/gtkprogressbar.h \
+  /usr/include/gtk-2.0/gtk/gtkradioaction.h \
+  /usr/include/gtk-2.0/gtk/gtktoggleaction.h \
+  /usr/include/gtk-2.0/gtk/gtkradiobutton.h \
+  /usr/include/gtk-2.0/gtk/gtkradiomenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtkradiotoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h \
+  /usr/include/gtk-2.0/gtk/gtkviewport.h \
+  /usr/include/gtk-2.0/gtk/gtkseparatormenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtkseparatortoolitem.h \
+  /usr/include/gtk-2.0/gtk/gtksizegroup.h \
+  /usr/include/gtk-2.0/gtk/gtkspinbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkstatusbar.h \
+  /usr/include/gtk-2.0/gtk/gtkstock.h /usr/include/gtk-2.0/gtk/gtktable.h \
+  /usr/include/gtk-2.0/gtk/gtktearoffmenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtktext.h \
+  /usr/include/gtk-2.0/gtk/gtktextbuffer.h \
+  /usr/include/gtk-2.0/gtk/gtktexttagtable.h \
+  /usr/include/gtk-2.0/gtk/gtktexttag.h \
+  /usr/include/gtk-2.0/gtk/gtktextiter.h \
+  /usr/include/gtk-2.0/gtk/gtktextchild.h \
+  /usr/include/gtk-2.0/gtk/gtktextmark.h \
+  /usr/include/gtk-2.0/gtk/gtktextview.h \
+  /usr/include/gtk-2.0/gtk/gtktipsquery.h \
+  /usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktoolbar.h \
+  /usr/include/gtk-2.0/gtk/gtktoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktoolitem.h \
+  /usr/include/gtk-2.0/gtk/gtktree.h \
+  /usr/include/gtk-2.0/gtk/gtktreednd.h \
+  /usr/include/gtk-2.0/gtk/gtktreeitem.h \
+  /usr/include/gtk-2.0/gtk/gtktreemodelsort.h \
+  /usr/include/gtk-2.0/gtk/gtktreeselection.h \
+  /usr/include/gtk-2.0/gtk/gtktreestore.h \
+  /usr/include/gtk-2.0/gtk/gtkuimanager.h \
+  /usr/include/gtk-2.0/gtk/gtkvbbox.h \
+  /usr/include/gtk-2.0/gtk/gtkversion.h \
+  /usr/include/gtk-2.0/gtk/gtkvpaned.h \
+  /usr/include/gtk-2.0/gtk/gtkvruler.h \
+  /usr/include/gtk-2.0/gtk/gtkvscale.h \
+  /usr/include/gtk-2.0/gtk/gtkvseparator.h \
+  /usr/local/include/gaim/conversation.h \
+  /usr/local/include/gaim/account.h /usr/local/include/gaim/connection.h \
+  /usr/local/include/gaim/plugin.h /usr/local/include/gaim/signals.h \
+  /usr/local/include/gaim/value.h /usr/local/include/gaim/pluginpref.h \
+  /usr/local/include/gaim/prefs.h /usr/local/include/gaim/log.h \
+  /usr/local/include/gaim/conversation.h /usr/local/include/gaim/proxy.h \
+  /usr/local/include/gaim/eventloop.h /usr/local/include/gaim/prpl.h \
+  /usr/local/include/gaim/blist.h /usr/local/include/gaim/buddyicon.h \
+  /usr/local/include/gaim/server.h /usr/local/include/gaim/debug.h \
+  /usr/local/include/gaim/prefs.h /usr/local/include/gaim/signals.h \
+  /usr/local/include/gaim/util.h /usr/local/include/gaim/version.h \
+  /usr/local/include/gaim/buddyicon.h /usr/local/include/gaim/prpl.h \
+  /usr/local/include/gaim/gtkconv.h /usr/local/include/gaim/gtkgaim.h \
+  /usr/local/include/gaim/gtkplugin.h
+
+gaym-extras.h:
+
+/usr/local/include/gaim/internal.h:
+
+../../config.h:
+
+/usr/include/locale.h:
+
+/usr/include/features.h:
+
+/usr/include/sys/cdefs.h:
+
+/usr/include/gnu/stubs.h:
+
+/usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/stddef.h:
+
+/usr/include/bits/locale.h:
+
+/usr/include/sys/stat.h:
+
+/usr/include/bits/types.h:
+
+/usr/include/bits/wordsize.h:
+
+/usr/include/bits/typesizes.h:
+
+/usr/include/time.h:
+
+/usr/include/bits/stat.h:
+
+/usr/include/sys/time.h:
+
+/usr/include/bits/time.h:
+
+/usr/include/sys/select.h:
+
+/usr/include/bits/select.h:
+
+/usr/include/bits/sigset.h:
+
+/usr/include/sys/types.h:
+
+/usr/include/endian.h:
+
+/usr/include/bits/endian.h:
+
+/usr/include/sys/sysmacros.h:
+
+/usr/include/bits/pthreadtypes.h:
+
+/usr/include/bits/sched.h:
+
+/usr/include/sys/wait.h:
+
+/usr/include/signal.h:
+
+/usr/include/bits/signum.h:
+
+/usr/include/bits/siginfo.h:
+
+/usr/include/bits/sigaction.h:
+
+/usr/include/bits/sigcontext.h:
+
+/usr/include/asm/sigcontext.h:
+
+/usr/include/linux/compiler.h:
+
+/usr/include/bits/sigstack.h:
+
+/usr/include/bits/sigthread.h:
+
+/usr/include/sys/resource.h:
+
+/usr/include/bits/resource.h:
+
+/usr/include/bits/waitflags.h:
+
+/usr/include/bits/waitstatus.h:
+
+/usr/include/ctype.h:
+
+/usr/include/errno.h:
+
+/usr/include/bits/errno.h:
+
+/usr/include/linux/errno.h:
+
+/usr/include/asm/errno.h:
+
+/usr/include/asm-generic/errno.h:
+
+/usr/include/asm-generic/errno-base.h:
+
+/usr/include/fcntl.h:
+
+/usr/include/bits/fcntl.h:
+
+/usr/include/math.h:
+
+/usr/include/bits/huge_val.h:
+
+/usr/include/bits/mathdef.h:
+
+/usr/include/bits/mathcalls.h:
+
+/usr/include/bits/mathinline.h:
+
+/usr/include/stdio.h:
+
+/usr/include/libio.h:
+
+/usr/include/_G_config.h:
+
+/usr/include/wchar.h:
+
+/usr/include/bits/wchar.h:
+
+/usr/include/gconv.h:
+
+/usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/stdarg.h:
+
+/usr/include/bits/stdio_lim.h:
+
+/usr/include/bits/sys_errlist.h:
+
+/usr/include/bits/stdio.h:
+
+/usr/include/stdlib.h:
+
+/usr/include/alloca.h:
+
+/usr/include/string.h:
+
+/usr/include/bits/string.h:
+
+/usr/include/bits/string2.h:
+
+/usr/include/glib-2.0/gmodule.h:
+
+/usr/include/glib-2.0/glib.h:
+
+/usr/include/glib-2.0/glib/galloca.h:
+
+/usr/include/glib-2.0/glib/gtypes.h:
+
+/usr/lib/glib-2.0/include/glibconfig.h:
+
+/usr/include/glib-2.0/glib/gmacros.h:
+
+/usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/limits.h:
+
+/usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/syslimits.h:
+
+/usr/include/limits.h:
+
+/usr/include/bits/posix1_lim.h:
+
+/usr/include/bits/local_lim.h:
+
+/usr/include/linux/limits.h:
+
+/usr/include/bits/posix2_lim.h:
+
+/usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/float.h:
+
+/usr/include/glib-2.0/glib/garray.h:
+
+/usr/include/glib-2.0/glib/gasyncqueue.h:
+
+/usr/include/glib-2.0/glib/gthread.h:
+
+/usr/include/glib-2.0/glib/gerror.h:
+
+/usr/include/glib-2.0/glib/gquark.h:
+
+/usr/include/glib-2.0/glib/gatomic.h:
+
+/usr/include/glib-2.0/glib/gbacktrace.h:
+
+/usr/include/glib-2.0/glib/gcache.h:
+
+/usr/include/glib-2.0/glib/glist.h:
+
+/usr/include/glib-2.0/glib/gmem.h:
+
+/usr/include/glib-2.0/glib/gcompletion.h:
+
+/usr/include/glib-2.0/glib/gconvert.h:
+
+/usr/include/glib-2.0/glib/gdataset.h:
+
+/usr/include/glib-2.0/glib/gdate.h:
+
+/usr/include/glib-2.0/glib/gdir.h:
+
+/usr/include/glib-2.0/glib/gfileutils.h:
+
+/usr/include/glib-2.0/glib/ghash.h:
+
+/usr/include/glib-2.0/glib/ghook.h:
+
+/usr/include/glib-2.0/glib/giochannel.h:
+
+/usr/include/glib-2.0/glib/gmain.h:
+
+/usr/include/glib-2.0/glib/gslist.h:
+
+/usr/include/glib-2.0/glib/gstring.h:
+
+/usr/include/glib-2.0/glib/gunicode.h:
+
+/usr/include/glib-2.0/glib/gutils.h:
+
+/usr/include/glib-2.0/glib/gkeyfile.h:
+
+/usr/include/glib-2.0/glib/gmarkup.h:
+
+/usr/include/glib-2.0/glib/gmessages.h:
+
+/usr/include/glib-2.0/glib/gnode.h:
+
+/usr/include/glib-2.0/glib/goption.h:
+
+/usr/include/glib-2.0/glib/gpattern.h:
+
+/usr/include/glib-2.0/glib/gprimes.h:
+
+/usr/include/glib-2.0/glib/gqsort.h:
+
+/usr/include/glib-2.0/glib/gqueue.h:
+
+/usr/include/glib-2.0/glib/grand.h:
+
+/usr/include/glib-2.0/glib/grel.h:
+
+/usr/include/glib-2.0/glib/gscanner.h:
+
+/usr/include/glib-2.0/glib/gshell.h:
+
+/usr/include/glib-2.0/glib/gspawn.h:
+
+/usr/include/glib-2.0/glib/gstrfuncs.h:
+
+/usr/include/glib-2.0/glib/gthreadpool.h:
+
+/usr/include/glib-2.0/glib/gtimer.h:
+
+/usr/include/glib-2.0/glib/gtree.h:
+
+/usr/include/dlfcn.h:
+
+/usr/include/bits/dlfcn.h:
+
+/usr/include/netinet/in.h:
+
+/usr/include/stdint.h:
+
+/usr/include/sys/socket.h:
+
+/usr/include/sys/uio.h:
+
+/usr/include/bits/uio.h:
+
+/usr/include/bits/socket.h:
+
+/usr/include/bits/sockaddr.h:
+
+/usr/include/asm/socket.h:
+
+/usr/include/asm/sockios.h:
+
+/usr/include/bits/in.h:
+
+/usr/include/bits/byteswap.h:
+
+/usr/include/arpa/inet.h:
+
+/usr/include/sys/un.h:
+
+/usr/include/sys/utsname.h:
+
+/usr/include/bits/utsname.h:
+
+/usr/include/netdb.h:
+
+/usr/include/rpc/netdb.h:
+
+/usr/include/bits/netdb.h:
+
+/usr/include/unistd.h:
+
+/usr/include/bits/posix_opt.h:
+
+/usr/include/bits/confname.h:
+
+/usr/include/getopt.h:
+
+/usr/include/glib-2.0/glib/gstdio.h:
+
+/usr/include/glib-2.0/glib/gprintf.h:
+
+/usr/local/include/gaim/prefix.h:
+
+/usr/local/include/gaim/gtkgaim.h:
+
+/usr/include/gtk-2.0/gdk/gdkx.h:
+
+/usr/include/gtk-2.0/gdk/gdkprivate.h:
+
+/usr/include/gtk-2.0/gdk/gdktypes.h:
+
+/usr/include/pango-1.0/pango/pango.h:
+
+/usr/include/pango-1.0/pango/pango-attributes.h:
+
+/usr/include/pango-1.0/pango/pango-font.h:
+
+/usr/include/pango-1.0/pango/pango-coverage.h:
+
+/usr/include/pango-1.0/pango/pango-types.h:
+
+/usr/include/glib-2.0/glib-object.h:
+
+/usr/include/glib-2.0/gobject/gboxed.h:
+
+/usr/include/glib-2.0/gobject/gtype.h:
+
+/usr/include/glib-2.0/gobject/genums.h:
+
+/usr/include/glib-2.0/gobject/gobject.h:
+
+/usr/include/glib-2.0/gobject/gvalue.h:
+
+/usr/include/glib-2.0/gobject/gparam.h:
+
+/usr/include/glib-2.0/gobject/gclosure.h:
+
+/usr/include/glib-2.0/gobject/gsignal.h:
+
+/usr/include/glib-2.0/gobject/gmarshal.h:
+
+/usr/include/glib-2.0/gobject/gparamspecs.h:
+
+/usr/include/glib-2.0/gobject/gsourceclosure.h:
+
+/usr/include/glib-2.0/gobject/gtypemodule.h:
+
+/usr/include/glib-2.0/gobject/gtypeplugin.h:
+
+/usr/include/glib-2.0/gobject/gvaluearray.h:
+
+/usr/include/glib-2.0/gobject/gvaluetypes.h:
+
+/usr/include/pango-1.0/pango/pango-break.h:
+
+/usr/include/pango-1.0/pango/pango-item.h:
+
+/usr/include/pango-1.0/pango/pango-context.h:
+
+/usr/include/pango-1.0/pango/pango-fontmap.h:
+
+/usr/include/pango-1.0/pango/pango-fontset.h:
+
+/usr/include/pango-1.0/pango/pango-engine.h:
+
+/usr/include/pango-1.0/pango/pango-glyph.h:
+
+/usr/include/pango-1.0/pango/pango-script.h:
+
+/usr/include/pango-1.0/pango/pango-enum-types.h:
+
+/usr/include/pango-1.0/pango/pango-layout.h:
+
+/usr/include/pango-1.0/pango/pango-glyph-item.h:
+
+/usr/include/pango-1.0/pango/pango-tabs.h:
+
+/usr/include/pango-1.0/pango/pango-renderer.h:
+
+/usr/lib/gtk-2.0/include/gdkconfig.h:
+
+/usr/include/gtk-2.0/gdk/gdkevents.h:
+
+/usr/include/gtk-2.0/gdk/gdkcolor.h:
+
+/usr/include/gtk-2.0/gdk/gdkdnd.h:
+
+/usr/include/gtk-2.0/gdk/gdkinput.h:
+
+/usr/include/gtk-2.0/gdk/gdkfont.h:
+
+/usr/include/gtk-2.0/gdk/gdkgc.h:
+
+/usr/include/gtk-2.0/gdk/gdkimage.h:
+
+/usr/include/gtk-2.0/gdk/gdkregion.h:
+
+/usr/include/gtk-2.0/gdk/gdkvisual.h:
+
+/usr/include/gtk-2.0/gdk/gdkwindow.h:
+
+/usr/include/gtk-2.0/gdk/gdkdrawable.h:
+
+/usr/include/gtk-2.0/gdk/gdkrgb.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-features.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-core.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-transform.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-animation.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-io.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-loader.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-enum-types.h:
+
+/usr/include/gtk-2.0/gdk/gdkcursor.h:
+
+/usr/include/X11/Xlib.h:
+
+/usr/include/X11/X.h:
+
+/usr/include/X11/Xfuncproto.h:
+
+/usr/include/X11/Xosdefs.h:
+
+/usr/include/X11/Xutil.h:
+
+/usr/include/gtk-2.0/gtk/gtk.h:
+
+/usr/include/gtk-2.0/gdk/gdk.h:
+
+/usr/include/gtk-2.0/gdk/gdkdisplay.h:
+
+/usr/include/gtk-2.0/gdk/gdkenumtypes.h:
+
+/usr/include/gtk-2.0/gdk/gdkkeys.h:
+
+/usr/include/gtk-2.0/gdk/gdkdisplaymanager.h:
+
+/usr/include/gtk-2.0/gdk/gdkpango.h:
+
+/usr/include/gtk-2.0/gdk/gdkpixbuf.h:
+
+/usr/include/gtk-2.0/gdk/gdkpixmap.h:
+
+/usr/include/gtk-2.0/gdk/gdkproperty.h:
+
+/usr/include/gtk-2.0/gdk/gdkscreen.h:
+
+/usr/include/gtk-2.0/gdk/gdkselection.h:
+
+/usr/include/gtk-2.0/gdk/gdkspawn.h:
+
+/usr/include/gtk-2.0/gtk/gtkaboutdialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkdialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkwindow.h:
+
+/usr/include/gtk-2.0/gtk/gtkaccelgroup.h:
+
+/usr/include/gtk-2.0/gtk/gtkenums.h:
+
+/usr/include/gtk-2.0/gtk/gtkbin.h:
+
+/usr/include/gtk-2.0/gtk/gtkcontainer.h:
+
+/usr/include/gtk-2.0/gtk/gtkwidget.h:
+
+/usr/include/gtk-2.0/gtk/gtkobject.h:
+
+/usr/include/gtk-2.0/gtk/gtktypeutils.h:
+
+/usr/include/gtk-2.0/gtk/gtktypebuiltins.h:
+
+/usr/include/gtk-2.0/gtk/gtkdebug.h:
+
+/usr/include/gtk-2.0/gtk/gtkadjustment.h:
+
+/usr/include/gtk-2.0/gtk/gtkstyle.h:
+
+/usr/include/gtk-2.0/gtk/gtksettings.h:
+
+/usr/include/gtk-2.0/gtk/gtkrc.h:
+
+/usr/include/atk-1.0/atk/atkobject.h:
+
+/usr/include/atk-1.0/atk/atkstate.h:
+
+/usr/include/atk-1.0/atk/atkrelationtype.h:
+
+/usr/include/gtk-2.0/gtk/gtkaccellabel.h:
+
+/usr/include/gtk-2.0/gtk/gtklabel.h:
+
+/usr/include/gtk-2.0/gtk/gtkmisc.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenu.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenushell.h:
+
+/usr/include/gtk-2.0/gtk/gtkaccelmap.h:
+
+/usr/include/gtk-2.0/gtk/gtkaccessible.h:
+
+/usr/include/atk-1.0/atk/atk.h:
+
+/usr/include/atk-1.0/atk/atkaction.h:
+
+/usr/include/atk-1.0/atk/atkcomponent.h:
+
+/usr/include/atk-1.0/atk/atkutil.h:
+
+/usr/include/atk-1.0/atk/atkdocument.h:
+
+/usr/include/atk-1.0/atk/atkeditabletext.h:
+
+/usr/include/atk-1.0/atk/atktext.h:
+
+/usr/include/atk-1.0/atk/atkgobjectaccessible.h:
+
+/usr/include/atk-1.0/atk/atkhyperlink.h:
+
+/usr/include/atk-1.0/atk/atkhypertext.h:
+
+/usr/include/atk-1.0/atk/atkimage.h:
+
+/usr/include/atk-1.0/atk/atknoopobject.h:
+
+/usr/include/atk-1.0/atk/atknoopobjectfactory.h:
+
+/usr/include/atk-1.0/atk/atkobjectfactory.h:
+
+/usr/include/atk-1.0/atk/atkregistry.h:
+
+/usr/include/atk-1.0/atk/atkobjectfactory.h:
+
+/usr/include/atk-1.0/atk/atkrelation.h:
+
+/usr/include/atk-1.0/atk/atkrelationset.h:
+
+/usr/include/atk-1.0/atk/atkselection.h:
+
+/usr/include/atk-1.0/atk/atkstateset.h:
+
+/usr/include/atk-1.0/atk/atkstreamablecontent.h:
+
+/usr/include/atk-1.0/atk/atktable.h:
+
+/usr/include/atk-1.0/atk/atkvalue.h:
+
+/usr/include/gtk-2.0/gtk/gtkaction.h:
+
+/usr/include/gtk-2.0/gtk/gtkactiongroup.h:
+
+/usr/include/gtk-2.0/gtk/gtkitemfactory.h:
+
+/usr/include/gtk-2.0/gtk/gtkalignment.h:
+
+/usr/include/gtk-2.0/gtk/gtkarrow.h:
+
+/usr/include/gtk-2.0/gtk/gtkaspectframe.h:
+
+/usr/include/gtk-2.0/gtk/gtkframe.h:
+
+/usr/include/gtk-2.0/gtk/gtkbbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkbindings.h:
+
+/usr/include/gtk-2.0/gtk/gtkbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkimage.h:
+
+/usr/include/gtk-2.0/gtk/gtkcalendar.h:
+
+/usr/include/gtk-2.0/gtk/gtksignal.h:
+
+/usr/include/gtk-2.0/gtk/gtkmarshal.h:
+
+/usr/include/gtk-2.0/gtk/gtkcelllayout.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrenderer.h:
+
+/usr/include/gtk-2.0/gtk/gtkcelleditable.h:
+
+/usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h:
+
+/usr/include/gtk-2.0/gtk/gtktreemodel.h:
+
+/usr/include/gtk-2.0/gtk/gtktreesortable.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrenderercombo.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrenderertext.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrendererpixbuf.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrendererprogress.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrenderertoggle.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellview.h:
+
+/usr/include/gtk-2.0/gtk/gtkcheckbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktogglebutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkclipboard.h:
+
+/usr/include/gtk-2.0/gtk/gtkselection.h:
+
+/usr/include/gtk-2.0/gtk/gtkclist.h:
+
+/usr/include/gtk-2.0/gtk/gtkhscrollbar.h:
+
+/usr/include/gtk-2.0/gtk/gtkscrollbar.h:
+
+/usr/include/gtk-2.0/gtk/gtkrange.h:
+
+/usr/include/gtk-2.0/gtk/gtkvscrollbar.h:
+
+/usr/include/gtk-2.0/gtk/gtkcolorbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkcolorsel.h:
+
+/usr/include/gtk-2.0/gtk/gtkvbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkcolorseldialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkcombo.h:
+
+/usr/include/gtk-2.0/gtk/gtkhbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkcombobox.h:
+
+/usr/include/gtk-2.0/gtk/gtktreeview.h:
+
+/usr/include/gtk-2.0/gtk/gtkdnd.h:
+
+/usr/include/gtk-2.0/gtk/gtkcomboboxentry.h:
+
+/usr/include/gtk-2.0/gtk/gtkctree.h:
+
+/usr/include/gtk-2.0/gtk/gtkcurve.h:
+
+/usr/include/gtk-2.0/gtk/gtkdrawingarea.h:
+
+/usr/include/gtk-2.0/gtk/gtkeditable.h:
+
+/usr/include/gtk-2.0/gtk/gtkentry.h:
+
+/usr/include/gtk-2.0/gtk/gtkimcontext.h:
+
+/usr/include/gtk-2.0/gtk/gtkentrycompletion.h:
+
+/usr/include/gtk-2.0/gtk/gtkliststore.h:
+
+/usr/include/gtk-2.0/gtk/gtktreemodelfilter.h:
+
+/usr/include/gtk-2.0/gtk/gtkeventbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkexpander.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilesel.h:
+
+/usr/include/gtk-2.0/gtk/gtkfixed.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilechooserbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilechooser.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilefilter.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilechooserdialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilechooser.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilechooserwidget.h:
+
+/usr/include/gtk-2.0/gtk/gtkfontbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkfontsel.h:
+
+/usr/include/gtk-2.0/gtk/gtkgamma.h:
+
+/usr/include/gtk-2.0/gtk/gtkgc.h:
+
+/usr/include/gtk-2.0/gtk/gtkhandlebox.h:
+
+/usr/include/gtk-2.0/gtk/gtkhbbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkhpaned.h:
+
+/usr/include/gtk-2.0/gtk/gtkpaned.h:
+
+/usr/include/gtk-2.0/gtk/gtkhruler.h:
+
+/usr/include/gtk-2.0/gtk/gtkruler.h:
+
+/usr/include/gtk-2.0/gtk/gtkhscale.h:
+
+/usr/include/gtk-2.0/gtk/gtkscale.h:
+
+/usr/include/gtk-2.0/gtk/gtkhseparator.h:
+
+/usr/include/gtk-2.0/gtk/gtkseparator.h:
+
+/usr/include/gtk-2.0/gtk/gtkiconfactory.h:
+
+/usr/include/gtk-2.0/gtk/gtkicontheme.h:
+
+/usr/include/gtk-2.0/gtk/gtkiconview.h:
+
+/usr/include/gtk-2.0/gtk/gtkimagemenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkimcontextsimple.h:
+
+/usr/include/gtk-2.0/gtk/gtkimmulticontext.h:
+
+/usr/include/gtk-2.0/gtk/gtkinputdialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkinvisible.h:
+
+/usr/include/gtk-2.0/gtk/gtklayout.h:
+
+/usr/include/gtk-2.0/gtk/gtklist.h:
+
+/usr/include/gtk-2.0/gtk/gtklistitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkmain.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenubar.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenutoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenu.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolitem.h:
+
+/usr/include/gtk-2.0/gtk/gtktooltips.h:
+
+/usr/include/gtk-2.0/gtk/gtkmessagedialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkmodules.h:
+
+/usr/include/gtk-2.0/gtk/gtknotebook.h:
+
+/usr/include/gtk-2.0/gtk/gtkoldeditable.h:
+
+/usr/include/gtk-2.0/gtk/gtkoptionmenu.h:
+
+/usr/include/gtk-2.0/gtk/gtkpixmap.h:
+
+/usr/include/gtk-2.0/gtk/gtkplug.h:
+
+/usr/include/gtk-2.0/gtk/gtksocket.h:
+
+/usr/include/gtk-2.0/gtk/gtkpreview.h:
+
+/usr/include/gtk-2.0/gtk/gtkprogress.h:
+
+/usr/include/gtk-2.0/gtk/gtkprogressbar.h:
+
+/usr/include/gtk-2.0/gtk/gtkradioaction.h:
+
+/usr/include/gtk-2.0/gtk/gtktoggleaction.h:
+
+/usr/include/gtk-2.0/gtk/gtkradiobutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkradiomenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkradiotoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkscrolledwindow.h:
+
+/usr/include/gtk-2.0/gtk/gtkviewport.h:
+
+/usr/include/gtk-2.0/gtk/gtkseparatormenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkseparatortoolitem.h:
+
+/usr/include/gtk-2.0/gtk/gtksizegroup.h:
+
+/usr/include/gtk-2.0/gtk/gtkspinbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkstatusbar.h:
+
+/usr/include/gtk-2.0/gtk/gtkstock.h:
+
+/usr/include/gtk-2.0/gtk/gtktable.h:
+
+/usr/include/gtk-2.0/gtk/gtktearoffmenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtktext.h:
+
+/usr/include/gtk-2.0/gtk/gtktextbuffer.h:
+
+/usr/include/gtk-2.0/gtk/gtktexttagtable.h:
+
+/usr/include/gtk-2.0/gtk/gtktexttag.h:
+
+/usr/include/gtk-2.0/gtk/gtktextiter.h:
+
+/usr/include/gtk-2.0/gtk/gtktextchild.h:
+
+/usr/include/gtk-2.0/gtk/gtktextmark.h:
+
+/usr/include/gtk-2.0/gtk/gtktextview.h:
+
+/usr/include/gtk-2.0/gtk/gtktipsquery.h:
+
+/usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolbar.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolitem.h:
+
+/usr/include/gtk-2.0/gtk/gtktree.h:
+
+/usr/include/gtk-2.0/gtk/gtktreednd.h:
+
+/usr/include/gtk-2.0/gtk/gtktreeitem.h:
+
+/usr/include/gtk-2.0/gtk/gtktreemodelsort.h:
+
+/usr/include/gtk-2.0/gtk/gtktreeselection.h:
+
+/usr/include/gtk-2.0/gtk/gtktreestore.h:
+
+/usr/include/gtk-2.0/gtk/gtkuimanager.h:
+
+/usr/include/gtk-2.0/gtk/gtkvbbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkversion.h:
+
+/usr/include/gtk-2.0/gtk/gtkvpaned.h:
+
+/usr/include/gtk-2.0/gtk/gtkvruler.h:
+
+/usr/include/gtk-2.0/gtk/gtkvscale.h:
+
+/usr/include/gtk-2.0/gtk/gtkvseparator.h:
+
+/usr/local/include/gaim/conversation.h:
+
+/usr/local/include/gaim/account.h:
+
+/usr/local/include/gaim/connection.h:
+
+/usr/local/include/gaim/plugin.h:
+
+/usr/local/include/gaim/signals.h:
+
+/usr/local/include/gaim/value.h:
+
+/usr/local/include/gaim/pluginpref.h:
+
+/usr/local/include/gaim/prefs.h:
+
+/usr/local/include/gaim/log.h:
+
+/usr/local/include/gaim/conversation.h:
+
+/usr/local/include/gaim/proxy.h:
+
+/usr/local/include/gaim/eventloop.h:
+
+/usr/local/include/gaim/prpl.h:
+
+/usr/local/include/gaim/blist.h:
+
+/usr/local/include/gaim/buddyicon.h:
+
+/usr/local/include/gaim/server.h:
+
+/usr/local/include/gaim/debug.h:
+
+/usr/local/include/gaim/prefs.h:
+
+/usr/local/include/gaim/signals.h:
+
+/usr/local/include/gaim/util.h:
+
+/usr/local/include/gaim/version.h:
+
+/usr/local/include/gaim/buddyicon.h:
+
+/usr/local/include/gaim/prpl.h:
+
+/usr/local/include/gaim/gtkconv.h:
+
+/usr/local/include/gaim/gtkgaim.h:
+
+/usr/local/include/gaim/gtkplugin.h:

Added: qrc/trunk/gaym-extras/src/.deps/gaym-extras.Plo
===================================================================
--- qrc/trunk/gaym-extras/src/.deps/gaym-extras.Plo	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/src/.deps/gaym-extras.Plo	2005-07-30 21:32:57 UTC (rev 256)
@@ -0,0 +1,1283 @@
+gaym-extras.lo .libs/gaym-extras.o: gaym-extras.c gaym-extras.h \
+  /usr/local/include/gaim/internal.h ../../config.h /usr/include/locale.h \
+  /usr/include/features.h /usr/include/sys/cdefs.h \
+  /usr/include/gnu/stubs.h \
+  /usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/stddef.h \
+  /usr/include/bits/locale.h /usr/include/sys/stat.h \
+  /usr/include/bits/types.h /usr/include/bits/wordsize.h \
+  /usr/include/bits/typesizes.h /usr/include/time.h \
+  /usr/include/bits/stat.h /usr/include/sys/time.h \
+  /usr/include/bits/time.h /usr/include/sys/select.h \
+  /usr/include/bits/select.h /usr/include/bits/sigset.h \
+  /usr/include/sys/types.h /usr/include/endian.h \
+  /usr/include/bits/endian.h /usr/include/sys/sysmacros.h \
+  /usr/include/bits/pthreadtypes.h /usr/include/bits/sched.h \
+  /usr/include/sys/wait.h /usr/include/signal.h \
+  /usr/include/bits/signum.h /usr/include/bits/siginfo.h \
+  /usr/include/bits/sigaction.h /usr/include/bits/sigcontext.h \
+  /usr/include/asm/sigcontext.h /usr/include/linux/compiler.h \
+  /usr/include/bits/sigstack.h /usr/include/bits/sigthread.h \
+  /usr/include/sys/resource.h /usr/include/bits/resource.h \
+  /usr/include/bits/waitflags.h /usr/include/bits/waitstatus.h \
+  /usr/include/ctype.h /usr/include/errno.h /usr/include/bits/errno.h \
+  /usr/include/linux/errno.h /usr/include/asm/errno.h \
+  /usr/include/asm-generic/errno.h /usr/include/asm-generic/errno-base.h \
+  /usr/include/fcntl.h /usr/include/bits/fcntl.h /usr/include/math.h \
+  /usr/include/bits/huge_val.h /usr/include/bits/mathdef.h \
+  /usr/include/bits/mathcalls.h /usr/include/bits/mathinline.h \
+  /usr/include/stdio.h /usr/include/libio.h /usr/include/_G_config.h \
+  /usr/include/wchar.h /usr/include/bits/wchar.h /usr/include/gconv.h \
+  /usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/stdarg.h \
+  /usr/include/bits/stdio_lim.h /usr/include/bits/sys_errlist.h \
+  /usr/include/bits/stdio.h /usr/include/stdlib.h /usr/include/alloca.h \
+  /usr/include/string.h /usr/include/bits/string.h \
+  /usr/include/bits/string2.h /usr/include/glib-2.0/gmodule.h \
+  /usr/include/glib-2.0/glib.h /usr/include/glib-2.0/glib/galloca.h \
+  /usr/include/glib-2.0/glib/gtypes.h \
+  /usr/lib/glib-2.0/include/glibconfig.h \
+  /usr/include/glib-2.0/glib/gmacros.h \
+  /usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/limits.h \
+  /usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/syslimits.h \
+  /usr/include/limits.h /usr/include/bits/posix1_lim.h \
+  /usr/include/bits/local_lim.h /usr/include/linux/limits.h \
+  /usr/include/bits/posix2_lim.h \
+  /usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/float.h \
+  /usr/include/glib-2.0/glib/garray.h \
+  /usr/include/glib-2.0/glib/gasyncqueue.h \
+  /usr/include/glib-2.0/glib/gthread.h \
+  /usr/include/glib-2.0/glib/gerror.h /usr/include/glib-2.0/glib/gquark.h \
+  /usr/include/glib-2.0/glib/gatomic.h \
+  /usr/include/glib-2.0/glib/gbacktrace.h \
+  /usr/include/glib-2.0/glib/gcache.h /usr/include/glib-2.0/glib/glist.h \
+  /usr/include/glib-2.0/glib/gmem.h \
+  /usr/include/glib-2.0/glib/gcompletion.h \
+  /usr/include/glib-2.0/glib/gconvert.h \
+  /usr/include/glib-2.0/glib/gdataset.h \
+  /usr/include/glib-2.0/glib/gdate.h /usr/include/glib-2.0/glib/gdir.h \
+  /usr/include/glib-2.0/glib/gfileutils.h \
+  /usr/include/glib-2.0/glib/ghash.h /usr/include/glib-2.0/glib/ghook.h \
+  /usr/include/glib-2.0/glib/giochannel.h \
+  /usr/include/glib-2.0/glib/gmain.h /usr/include/glib-2.0/glib/gslist.h \
+  /usr/include/glib-2.0/glib/gstring.h \
+  /usr/include/glib-2.0/glib/gunicode.h \
+  /usr/include/glib-2.0/glib/gutils.h \
+  /usr/include/glib-2.0/glib/gkeyfile.h \
+  /usr/include/glib-2.0/glib/gmarkup.h \
+  /usr/include/glib-2.0/glib/gmessages.h \
+  /usr/include/glib-2.0/glib/gnode.h /usr/include/glib-2.0/glib/goption.h \
+  /usr/include/glib-2.0/glib/gpattern.h \
+  /usr/include/glib-2.0/glib/gprimes.h \
+  /usr/include/glib-2.0/glib/gqsort.h /usr/include/glib-2.0/glib/gqueue.h \
+  /usr/include/glib-2.0/glib/grand.h /usr/include/glib-2.0/glib/grel.h \
+  /usr/include/glib-2.0/glib/gscanner.h \
+  /usr/include/glib-2.0/glib/gshell.h /usr/include/glib-2.0/glib/gspawn.h \
+  /usr/include/glib-2.0/glib/gstrfuncs.h \
+  /usr/include/glib-2.0/glib/gthreadpool.h \
+  /usr/include/glib-2.0/glib/gtimer.h /usr/include/glib-2.0/glib/gtree.h \
+  /usr/include/dlfcn.h /usr/include/bits/dlfcn.h \
+  /usr/include/netinet/in.h /usr/include/stdint.h \
+  /usr/include/sys/socket.h /usr/include/sys/uio.h \
+  /usr/include/bits/uio.h /usr/include/bits/socket.h \
+  /usr/include/bits/sockaddr.h /usr/include/asm/socket.h \
+  /usr/include/asm/sockios.h /usr/include/bits/in.h \
+  /usr/include/bits/byteswap.h /usr/include/arpa/inet.h \
+  /usr/include/sys/un.h /usr/include/sys/utsname.h \
+  /usr/include/bits/utsname.h /usr/include/netdb.h \
+  /usr/include/rpc/netdb.h /usr/include/bits/netdb.h \
+  /usr/include/unistd.h /usr/include/bits/posix_opt.h \
+  /usr/include/bits/confname.h /usr/include/getopt.h \
+  /usr/include/glib-2.0/glib/gstdio.h \
+  /usr/include/glib-2.0/glib/gprintf.h /usr/local/include/gaim/prefix.h \
+  /usr/local/include/gaim/gtkgaim.h /usr/include/gtk-2.0/gdk/gdkx.h \
+  /usr/include/gtk-2.0/gdk/gdkprivate.h \
+  /usr/include/gtk-2.0/gdk/gdktypes.h \
+  /usr/include/pango-1.0/pango/pango.h \
+  /usr/include/pango-1.0/pango/pango-attributes.h \
+  /usr/include/pango-1.0/pango/pango-font.h \
+  /usr/include/pango-1.0/pango/pango-coverage.h \
+  /usr/include/pango-1.0/pango/pango-types.h \
+  /usr/include/glib-2.0/glib-object.h \
+  /usr/include/glib-2.0/gobject/gboxed.h \
+  /usr/include/glib-2.0/gobject/gtype.h \
+  /usr/include/glib-2.0/gobject/genums.h \
+  /usr/include/glib-2.0/gobject/gobject.h \
+  /usr/include/glib-2.0/gobject/gvalue.h \
+  /usr/include/glib-2.0/gobject/gparam.h \
+  /usr/include/glib-2.0/gobject/gclosure.h \
+  /usr/include/glib-2.0/gobject/gsignal.h \
+  /usr/include/glib-2.0/gobject/gmarshal.h \
+  /usr/include/glib-2.0/gobject/gparamspecs.h \
+  /usr/include/glib-2.0/gobject/gsourceclosure.h \
+  /usr/include/glib-2.0/gobject/gtypemodule.h \
+  /usr/include/glib-2.0/gobject/gtypeplugin.h \
+  /usr/include/glib-2.0/gobject/gvaluearray.h \
+  /usr/include/glib-2.0/gobject/gvaluetypes.h \
+  /usr/include/pango-1.0/pango/pango-break.h \
+  /usr/include/pango-1.0/pango/pango-item.h \
+  /usr/include/pango-1.0/pango/pango-context.h \
+  /usr/include/pango-1.0/pango/pango-fontmap.h \
+  /usr/include/pango-1.0/pango/pango-fontset.h \
+  /usr/include/pango-1.0/pango/pango-engine.h \
+  /usr/include/pango-1.0/pango/pango-glyph.h \
+  /usr/include/pango-1.0/pango/pango-script.h \
+  /usr/include/pango-1.0/pango/pango-enum-types.h \
+  /usr/include/pango-1.0/pango/pango-layout.h \
+  /usr/include/pango-1.0/pango/pango-glyph-item.h \
+  /usr/include/pango-1.0/pango/pango-tabs.h \
+  /usr/include/pango-1.0/pango/pango-renderer.h \
+  /usr/lib/gtk-2.0/include/gdkconfig.h \
+  /usr/include/gtk-2.0/gdk/gdkevents.h \
+  /usr/include/gtk-2.0/gdk/gdkcolor.h /usr/include/gtk-2.0/gdk/gdkdnd.h \
+  /usr/include/gtk-2.0/gdk/gdkinput.h /usr/include/gtk-2.0/gdk/gdkfont.h \
+  /usr/include/gtk-2.0/gdk/gdkgc.h /usr/include/gtk-2.0/gdk/gdkimage.h \
+  /usr/include/gtk-2.0/gdk/gdkregion.h \
+  /usr/include/gtk-2.0/gdk/gdkvisual.h \
+  /usr/include/gtk-2.0/gdk/gdkwindow.h \
+  /usr/include/gtk-2.0/gdk/gdkdrawable.h \
+  /usr/include/gtk-2.0/gdk/gdkrgb.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-features.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-core.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-transform.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-animation.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-io.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-loader.h \
+  /usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-enum-types.h \
+  /usr/include/gtk-2.0/gdk/gdkcursor.h /usr/include/X11/Xlib.h \
+  /usr/include/X11/X.h /usr/include/X11/Xfuncproto.h \
+  /usr/include/X11/Xosdefs.h /usr/include/X11/Xutil.h \
+  /usr/include/gtk-2.0/gtk/gtk.h /usr/include/gtk-2.0/gdk/gdk.h \
+  /usr/include/gtk-2.0/gdk/gdkdisplay.h \
+  /usr/include/gtk-2.0/gdk/gdkenumtypes.h \
+  /usr/include/gtk-2.0/gdk/gdkkeys.h \
+  /usr/include/gtk-2.0/gdk/gdkdisplaymanager.h \
+  /usr/include/gtk-2.0/gdk/gdkpango.h \
+  /usr/include/gtk-2.0/gdk/gdkpixbuf.h \
+  /usr/include/gtk-2.0/gdk/gdkpixmap.h \
+  /usr/include/gtk-2.0/gdk/gdkproperty.h \
+  /usr/include/gtk-2.0/gdk/gdkscreen.h \
+  /usr/include/gtk-2.0/gdk/gdkselection.h \
+  /usr/include/gtk-2.0/gdk/gdkspawn.h \
+  /usr/include/gtk-2.0/gtk/gtkaboutdialog.h \
+  /usr/include/gtk-2.0/gtk/gtkdialog.h \
+  /usr/include/gtk-2.0/gtk/gtkwindow.h \
+  /usr/include/gtk-2.0/gtk/gtkaccelgroup.h \
+  /usr/include/gtk-2.0/gtk/gtkenums.h /usr/include/gtk-2.0/gtk/gtkbin.h \
+  /usr/include/gtk-2.0/gtk/gtkcontainer.h \
+  /usr/include/gtk-2.0/gtk/gtkwidget.h \
+  /usr/include/gtk-2.0/gtk/gtkobject.h \
+  /usr/include/gtk-2.0/gtk/gtktypeutils.h \
+  /usr/include/gtk-2.0/gtk/gtktypebuiltins.h \
+  /usr/include/gtk-2.0/gtk/gtkdebug.h \
+  /usr/include/gtk-2.0/gtk/gtkadjustment.h \
+  /usr/include/gtk-2.0/gtk/gtkstyle.h \
+  /usr/include/gtk-2.0/gtk/gtksettings.h /usr/include/gtk-2.0/gtk/gtkrc.h \
+  /usr/include/atk-1.0/atk/atkobject.h \
+  /usr/include/atk-1.0/atk/atkstate.h \
+  /usr/include/atk-1.0/atk/atkrelationtype.h \
+  /usr/include/gtk-2.0/gtk/gtkaccellabel.h \
+  /usr/include/gtk-2.0/gtk/gtklabel.h /usr/include/gtk-2.0/gtk/gtkmisc.h \
+  /usr/include/gtk-2.0/gtk/gtkmenu.h \
+  /usr/include/gtk-2.0/gtk/gtkmenushell.h \
+  /usr/include/gtk-2.0/gtk/gtkaccelmap.h \
+  /usr/include/gtk-2.0/gtk/gtkaccessible.h /usr/include/atk-1.0/atk/atk.h \
+  /usr/include/atk-1.0/atk/atkaction.h \
+  /usr/include/atk-1.0/atk/atkcomponent.h \
+  /usr/include/atk-1.0/atk/atkutil.h \
+  /usr/include/atk-1.0/atk/atkdocument.h \
+  /usr/include/atk-1.0/atk/atkeditabletext.h \
+  /usr/include/atk-1.0/atk/atktext.h \
+  /usr/include/atk-1.0/atk/atkgobjectaccessible.h \
+  /usr/include/atk-1.0/atk/atkhyperlink.h \
+  /usr/include/atk-1.0/atk/atkhypertext.h \
+  /usr/include/atk-1.0/atk/atkimage.h \
+  /usr/include/atk-1.0/atk/atknoopobject.h \
+  /usr/include/atk-1.0/atk/atknoopobjectfactory.h \
+  /usr/include/atk-1.0/atk/atkobjectfactory.h \
+  /usr/include/atk-1.0/atk/atkregistry.h \
+  /usr/include/atk-1.0/atk/atkobjectfactory.h \
+  /usr/include/atk-1.0/atk/atkrelation.h \
+  /usr/include/atk-1.0/atk/atkrelationset.h \
+  /usr/include/atk-1.0/atk/atkselection.h \
+  /usr/include/atk-1.0/atk/atkstateset.h \
+  /usr/include/atk-1.0/atk/atkstreamablecontent.h \
+  /usr/include/atk-1.0/atk/atktable.h /usr/include/atk-1.0/atk/atkvalue.h \
+  /usr/include/gtk-2.0/gtk/gtkaction.h \
+  /usr/include/gtk-2.0/gtk/gtkactiongroup.h \
+  /usr/include/gtk-2.0/gtk/gtkitemfactory.h \
+  /usr/include/gtk-2.0/gtk/gtkalignment.h \
+  /usr/include/gtk-2.0/gtk/gtkarrow.h \
+  /usr/include/gtk-2.0/gtk/gtkaspectframe.h \
+  /usr/include/gtk-2.0/gtk/gtkframe.h /usr/include/gtk-2.0/gtk/gtkbbox.h \
+  /usr/include/gtk-2.0/gtk/gtkbox.h \
+  /usr/include/gtk-2.0/gtk/gtkbindings.h \
+  /usr/include/gtk-2.0/gtk/gtkbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkimage.h \
+  /usr/include/gtk-2.0/gtk/gtkcalendar.h \
+  /usr/include/gtk-2.0/gtk/gtksignal.h \
+  /usr/include/gtk-2.0/gtk/gtkmarshal.h \
+  /usr/include/gtk-2.0/gtk/gtkcelllayout.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrenderer.h \
+  /usr/include/gtk-2.0/gtk/gtkcelleditable.h \
+  /usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h \
+  /usr/include/gtk-2.0/gtk/gtktreemodel.h \
+  /usr/include/gtk-2.0/gtk/gtktreesortable.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrenderercombo.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrenderertext.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrendererpixbuf.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrendererprogress.h \
+  /usr/include/gtk-2.0/gtk/gtkcellrenderertoggle.h \
+  /usr/include/gtk-2.0/gtk/gtkcellview.h \
+  /usr/include/gtk-2.0/gtk/gtkcheckbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktogglebutton.h \
+  /usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtkmenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtkitem.h \
+  /usr/include/gtk-2.0/gtk/gtkclipboard.h \
+  /usr/include/gtk-2.0/gtk/gtkselection.h \
+  /usr/include/gtk-2.0/gtk/gtkclist.h \
+  /usr/include/gtk-2.0/gtk/gtkhscrollbar.h \
+  /usr/include/gtk-2.0/gtk/gtkscrollbar.h \
+  /usr/include/gtk-2.0/gtk/gtkrange.h \
+  /usr/include/gtk-2.0/gtk/gtkvscrollbar.h \
+  /usr/include/gtk-2.0/gtk/gtkcolorbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkcolorsel.h \
+  /usr/include/gtk-2.0/gtk/gtkvbox.h \
+  /usr/include/gtk-2.0/gtk/gtkcolorseldialog.h \
+  /usr/include/gtk-2.0/gtk/gtkcombo.h /usr/include/gtk-2.0/gtk/gtkhbox.h \
+  /usr/include/gtk-2.0/gtk/gtkcombobox.h \
+  /usr/include/gtk-2.0/gtk/gtktreeview.h \
+  /usr/include/gtk-2.0/gtk/gtkdnd.h \
+  /usr/include/gtk-2.0/gtk/gtkcomboboxentry.h \
+  /usr/include/gtk-2.0/gtk/gtkctree.h /usr/include/gtk-2.0/gtk/gtkcurve.h \
+  /usr/include/gtk-2.0/gtk/gtkdrawingarea.h \
+  /usr/include/gtk-2.0/gtk/gtkeditable.h \
+  /usr/include/gtk-2.0/gtk/gtkentry.h \
+  /usr/include/gtk-2.0/gtk/gtkimcontext.h \
+  /usr/include/gtk-2.0/gtk/gtkentrycompletion.h \
+  /usr/include/gtk-2.0/gtk/gtkliststore.h \
+  /usr/include/gtk-2.0/gtk/gtktreemodelfilter.h \
+  /usr/include/gtk-2.0/gtk/gtkeventbox.h \
+  /usr/include/gtk-2.0/gtk/gtkexpander.h \
+  /usr/include/gtk-2.0/gtk/gtkfilesel.h \
+  /usr/include/gtk-2.0/gtk/gtkfixed.h \
+  /usr/include/gtk-2.0/gtk/gtkfilechooserbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkfilechooser.h \
+  /usr/include/gtk-2.0/gtk/gtkfilefilter.h \
+  /usr/include/gtk-2.0/gtk/gtkfilechooserdialog.h \
+  /usr/include/gtk-2.0/gtk/gtkfilechooser.h \
+  /usr/include/gtk-2.0/gtk/gtkfilechooserwidget.h \
+  /usr/include/gtk-2.0/gtk/gtkfontbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkfontsel.h \
+  /usr/include/gtk-2.0/gtk/gtkgamma.h /usr/include/gtk-2.0/gtk/gtkgc.h \
+  /usr/include/gtk-2.0/gtk/gtkhandlebox.h \
+  /usr/include/gtk-2.0/gtk/gtkhbbox.h \
+  /usr/include/gtk-2.0/gtk/gtkhpaned.h \
+  /usr/include/gtk-2.0/gtk/gtkpaned.h \
+  /usr/include/gtk-2.0/gtk/gtkhruler.h \
+  /usr/include/gtk-2.0/gtk/gtkruler.h \
+  /usr/include/gtk-2.0/gtk/gtkhscale.h \
+  /usr/include/gtk-2.0/gtk/gtkscale.h \
+  /usr/include/gtk-2.0/gtk/gtkhseparator.h \
+  /usr/include/gtk-2.0/gtk/gtkseparator.h \
+  /usr/include/gtk-2.0/gtk/gtkiconfactory.h \
+  /usr/include/gtk-2.0/gtk/gtkicontheme.h \
+  /usr/include/gtk-2.0/gtk/gtkiconview.h \
+  /usr/include/gtk-2.0/gtk/gtkimagemenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtkimcontextsimple.h \
+  /usr/include/gtk-2.0/gtk/gtkimmulticontext.h \
+  /usr/include/gtk-2.0/gtk/gtkinputdialog.h \
+  /usr/include/gtk-2.0/gtk/gtkinvisible.h \
+  /usr/include/gtk-2.0/gtk/gtklayout.h /usr/include/gtk-2.0/gtk/gtklist.h \
+  /usr/include/gtk-2.0/gtk/gtklistitem.h \
+  /usr/include/gtk-2.0/gtk/gtkmain.h \
+  /usr/include/gtk-2.0/gtk/gtkmenubar.h \
+  /usr/include/gtk-2.0/gtk/gtkmenutoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkmenu.h \
+  /usr/include/gtk-2.0/gtk/gtktoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktoolitem.h \
+  /usr/include/gtk-2.0/gtk/gtktooltips.h \
+  /usr/include/gtk-2.0/gtk/gtkmessagedialog.h \
+  /usr/include/gtk-2.0/gtk/gtkmodules.h \
+  /usr/include/gtk-2.0/gtk/gtknotebook.h \
+  /usr/include/gtk-2.0/gtk/gtkoldeditable.h \
+  /usr/include/gtk-2.0/gtk/gtkoptionmenu.h \
+  /usr/include/gtk-2.0/gtk/gtkpixmap.h /usr/include/gtk-2.0/gtk/gtkplug.h \
+  /usr/include/gtk-2.0/gtk/gtksocket.h \
+  /usr/include/gtk-2.0/gtk/gtkpreview.h \
+  /usr/include/gtk-2.0/gtk/gtkprogress.h \
+  /usr/include/gtk-2.0/gtk/gtkprogressbar.h \
+  /usr/include/gtk-2.0/gtk/gtkradioaction.h \
+  /usr/include/gtk-2.0/gtk/gtktoggleaction.h \
+  /usr/include/gtk-2.0/gtk/gtkradiobutton.h \
+  /usr/include/gtk-2.0/gtk/gtkradiomenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtkradiotoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkscrolledwindow.h \
+  /usr/include/gtk-2.0/gtk/gtkviewport.h \
+  /usr/include/gtk-2.0/gtk/gtkseparatormenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtkseparatortoolitem.h \
+  /usr/include/gtk-2.0/gtk/gtksizegroup.h \
+  /usr/include/gtk-2.0/gtk/gtkspinbutton.h \
+  /usr/include/gtk-2.0/gtk/gtkstatusbar.h \
+  /usr/include/gtk-2.0/gtk/gtkstock.h /usr/include/gtk-2.0/gtk/gtktable.h \
+  /usr/include/gtk-2.0/gtk/gtktearoffmenuitem.h \
+  /usr/include/gtk-2.0/gtk/gtktext.h \
+  /usr/include/gtk-2.0/gtk/gtktextbuffer.h \
+  /usr/include/gtk-2.0/gtk/gtktexttagtable.h \
+  /usr/include/gtk-2.0/gtk/gtktexttag.h \
+  /usr/include/gtk-2.0/gtk/gtktextiter.h \
+  /usr/include/gtk-2.0/gtk/gtktextchild.h \
+  /usr/include/gtk-2.0/gtk/gtktextmark.h \
+  /usr/include/gtk-2.0/gtk/gtktextview.h \
+  /usr/include/gtk-2.0/gtk/gtktipsquery.h \
+  /usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktoolbar.h \
+  /usr/include/gtk-2.0/gtk/gtktoolbutton.h \
+  /usr/include/gtk-2.0/gtk/gtktoolitem.h \
+  /usr/include/gtk-2.0/gtk/gtktree.h \
+  /usr/include/gtk-2.0/gtk/gtktreednd.h \
+  /usr/include/gtk-2.0/gtk/gtktreeitem.h \
+  /usr/include/gtk-2.0/gtk/gtktreemodelsort.h \
+  /usr/include/gtk-2.0/gtk/gtktreeselection.h \
+  /usr/include/gtk-2.0/gtk/gtktreestore.h \
+  /usr/include/gtk-2.0/gtk/gtkuimanager.h \
+  /usr/include/gtk-2.0/gtk/gtkvbbox.h \
+  /usr/include/gtk-2.0/gtk/gtkversion.h \
+  /usr/include/gtk-2.0/gtk/gtkvpaned.h \
+  /usr/include/gtk-2.0/gtk/gtkvruler.h \
+  /usr/include/gtk-2.0/gtk/gtkvscale.h \
+  /usr/include/gtk-2.0/gtk/gtkvseparator.h \
+  /usr/local/include/gaim/conversation.h \
+  /usr/local/include/gaim/account.h /usr/local/include/gaim/connection.h \
+  /usr/local/include/gaim/plugin.h /usr/local/include/gaim/signals.h \
+  /usr/local/include/gaim/value.h /usr/local/include/gaim/pluginpref.h \
+  /usr/local/include/gaim/prefs.h /usr/local/include/gaim/log.h \
+  /usr/local/include/gaim/conversation.h /usr/local/include/gaim/proxy.h \
+  /usr/local/include/gaim/eventloop.h /usr/local/include/gaim/prpl.h \
+  /usr/local/include/gaim/blist.h /usr/local/include/gaim/buddyicon.h \
+  /usr/local/include/gaim/server.h /usr/local/include/gaim/debug.h \
+  /usr/local/include/gaim/prefs.h /usr/local/include/gaim/signals.h \
+  /usr/local/include/gaim/util.h /usr/local/include/gaim/version.h \
+  /usr/local/include/gaim/buddyicon.h /usr/local/include/gaim/prpl.h \
+  /usr/local/include/gaim/gtkconv.h /usr/local/include/gaim/gtkgaim.h \
+  /usr/local/include/gaim/gtkplugin.h
+
+gaym-extras.h:
+
+/usr/local/include/gaim/internal.h:
+
+../../config.h:
+
+/usr/include/locale.h:
+
+/usr/include/features.h:
+
+/usr/include/sys/cdefs.h:
+
+/usr/include/gnu/stubs.h:
+
+/usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/stddef.h:
+
+/usr/include/bits/locale.h:
+
+/usr/include/sys/stat.h:
+
+/usr/include/bits/types.h:
+
+/usr/include/bits/wordsize.h:
+
+/usr/include/bits/typesizes.h:
+
+/usr/include/time.h:
+
+/usr/include/bits/stat.h:
+
+/usr/include/sys/time.h:
+
+/usr/include/bits/time.h:
+
+/usr/include/sys/select.h:
+
+/usr/include/bits/select.h:
+
+/usr/include/bits/sigset.h:
+
+/usr/include/sys/types.h:
+
+/usr/include/endian.h:
+
+/usr/include/bits/endian.h:
+
+/usr/include/sys/sysmacros.h:
+
+/usr/include/bits/pthreadtypes.h:
+
+/usr/include/bits/sched.h:
+
+/usr/include/sys/wait.h:
+
+/usr/include/signal.h:
+
+/usr/include/bits/signum.h:
+
+/usr/include/bits/siginfo.h:
+
+/usr/include/bits/sigaction.h:
+
+/usr/include/bits/sigcontext.h:
+
+/usr/include/asm/sigcontext.h:
+
+/usr/include/linux/compiler.h:
+
+/usr/include/bits/sigstack.h:
+
+/usr/include/bits/sigthread.h:
+
+/usr/include/sys/resource.h:
+
+/usr/include/bits/resource.h:
+
+/usr/include/bits/waitflags.h:
+
+/usr/include/bits/waitstatus.h:
+
+/usr/include/ctype.h:
+
+/usr/include/errno.h:
+
+/usr/include/bits/errno.h:
+
+/usr/include/linux/errno.h:
+
+/usr/include/asm/errno.h:
+
+/usr/include/asm-generic/errno.h:
+
+/usr/include/asm-generic/errno-base.h:
+
+/usr/include/fcntl.h:
+
+/usr/include/bits/fcntl.h:
+
+/usr/include/math.h:
+
+/usr/include/bits/huge_val.h:
+
+/usr/include/bits/mathdef.h:
+
+/usr/include/bits/mathcalls.h:
+
+/usr/include/bits/mathinline.h:
+
+/usr/include/stdio.h:
+
+/usr/include/libio.h:
+
+/usr/include/_G_config.h:
+
+/usr/include/wchar.h:
+
+/usr/include/bits/wchar.h:
+
+/usr/include/gconv.h:
+
+/usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/stdarg.h:
+
+/usr/include/bits/stdio_lim.h:
+
+/usr/include/bits/sys_errlist.h:
+
+/usr/include/bits/stdio.h:
+
+/usr/include/stdlib.h:
+
+/usr/include/alloca.h:
+
+/usr/include/string.h:
+
+/usr/include/bits/string.h:
+
+/usr/include/bits/string2.h:
+
+/usr/include/glib-2.0/gmodule.h:
+
+/usr/include/glib-2.0/glib.h:
+
+/usr/include/glib-2.0/glib/galloca.h:
+
+/usr/include/glib-2.0/glib/gtypes.h:
+
+/usr/lib/glib-2.0/include/glibconfig.h:
+
+/usr/include/glib-2.0/glib/gmacros.h:
+
+/usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/limits.h:
+
+/usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/syslimits.h:
+
+/usr/include/limits.h:
+
+/usr/include/bits/posix1_lim.h:
+
+/usr/include/bits/local_lim.h:
+
+/usr/include/linux/limits.h:
+
+/usr/include/bits/posix2_lim.h:
+
+/usr/lib/gcc/i686-pc-linux-gnu/3.4.3-20050110/include/float.h:
+
+/usr/include/glib-2.0/glib/garray.h:
+
+/usr/include/glib-2.0/glib/gasyncqueue.h:
+
+/usr/include/glib-2.0/glib/gthread.h:
+
+/usr/include/glib-2.0/glib/gerror.h:
+
+/usr/include/glib-2.0/glib/gquark.h:
+
+/usr/include/glib-2.0/glib/gatomic.h:
+
+/usr/include/glib-2.0/glib/gbacktrace.h:
+
+/usr/include/glib-2.0/glib/gcache.h:
+
+/usr/include/glib-2.0/glib/glist.h:
+
+/usr/include/glib-2.0/glib/gmem.h:
+
+/usr/include/glib-2.0/glib/gcompletion.h:
+
+/usr/include/glib-2.0/glib/gconvert.h:
+
+/usr/include/glib-2.0/glib/gdataset.h:
+
+/usr/include/glib-2.0/glib/gdate.h:
+
+/usr/include/glib-2.0/glib/gdir.h:
+
+/usr/include/glib-2.0/glib/gfileutils.h:
+
+/usr/include/glib-2.0/glib/ghash.h:
+
+/usr/include/glib-2.0/glib/ghook.h:
+
+/usr/include/glib-2.0/glib/giochannel.h:
+
+/usr/include/glib-2.0/glib/gmain.h:
+
+/usr/include/glib-2.0/glib/gslist.h:
+
+/usr/include/glib-2.0/glib/gstring.h:
+
+/usr/include/glib-2.0/glib/gunicode.h:
+
+/usr/include/glib-2.0/glib/gutils.h:
+
+/usr/include/glib-2.0/glib/gkeyfile.h:
+
+/usr/include/glib-2.0/glib/gmarkup.h:
+
+/usr/include/glib-2.0/glib/gmessages.h:
+
+/usr/include/glib-2.0/glib/gnode.h:
+
+/usr/include/glib-2.0/glib/goption.h:
+
+/usr/include/glib-2.0/glib/gpattern.h:
+
+/usr/include/glib-2.0/glib/gprimes.h:
+
+/usr/include/glib-2.0/glib/gqsort.h:
+
+/usr/include/glib-2.0/glib/gqueue.h:
+
+/usr/include/glib-2.0/glib/grand.h:
+
+/usr/include/glib-2.0/glib/grel.h:
+
+/usr/include/glib-2.0/glib/gscanner.h:
+
+/usr/include/glib-2.0/glib/gshell.h:
+
+/usr/include/glib-2.0/glib/gspawn.h:
+
+/usr/include/glib-2.0/glib/gstrfuncs.h:
+
+/usr/include/glib-2.0/glib/gthreadpool.h:
+
+/usr/include/glib-2.0/glib/gtimer.h:
+
+/usr/include/glib-2.0/glib/gtree.h:
+
+/usr/include/dlfcn.h:
+
+/usr/include/bits/dlfcn.h:
+
+/usr/include/netinet/in.h:
+
+/usr/include/stdint.h:
+
+/usr/include/sys/socket.h:
+
+/usr/include/sys/uio.h:
+
+/usr/include/bits/uio.h:
+
+/usr/include/bits/socket.h:
+
+/usr/include/bits/sockaddr.h:
+
+/usr/include/asm/socket.h:
+
+/usr/include/asm/sockios.h:
+
+/usr/include/bits/in.h:
+
+/usr/include/bits/byteswap.h:
+
+/usr/include/arpa/inet.h:
+
+/usr/include/sys/un.h:
+
+/usr/include/sys/utsname.h:
+
+/usr/include/bits/utsname.h:
+
+/usr/include/netdb.h:
+
+/usr/include/rpc/netdb.h:
+
+/usr/include/bits/netdb.h:
+
+/usr/include/unistd.h:
+
+/usr/include/bits/posix_opt.h:
+
+/usr/include/bits/confname.h:
+
+/usr/include/getopt.h:
+
+/usr/include/glib-2.0/glib/gstdio.h:
+
+/usr/include/glib-2.0/glib/gprintf.h:
+
+/usr/local/include/gaim/prefix.h:
+
+/usr/local/include/gaim/gtkgaim.h:
+
+/usr/include/gtk-2.0/gdk/gdkx.h:
+
+/usr/include/gtk-2.0/gdk/gdkprivate.h:
+
+/usr/include/gtk-2.0/gdk/gdktypes.h:
+
+/usr/include/pango-1.0/pango/pango.h:
+
+/usr/include/pango-1.0/pango/pango-attributes.h:
+
+/usr/include/pango-1.0/pango/pango-font.h:
+
+/usr/include/pango-1.0/pango/pango-coverage.h:
+
+/usr/include/pango-1.0/pango/pango-types.h:
+
+/usr/include/glib-2.0/glib-object.h:
+
+/usr/include/glib-2.0/gobject/gboxed.h:
+
+/usr/include/glib-2.0/gobject/gtype.h:
+
+/usr/include/glib-2.0/gobject/genums.h:
+
+/usr/include/glib-2.0/gobject/gobject.h:
+
+/usr/include/glib-2.0/gobject/gvalue.h:
+
+/usr/include/glib-2.0/gobject/gparam.h:
+
+/usr/include/glib-2.0/gobject/gclosure.h:
+
+/usr/include/glib-2.0/gobject/gsignal.h:
+
+/usr/include/glib-2.0/gobject/gmarshal.h:
+
+/usr/include/glib-2.0/gobject/gparamspecs.h:
+
+/usr/include/glib-2.0/gobject/gsourceclosure.h:
+
+/usr/include/glib-2.0/gobject/gtypemodule.h:
+
+/usr/include/glib-2.0/gobject/gtypeplugin.h:
+
+/usr/include/glib-2.0/gobject/gvaluearray.h:
+
+/usr/include/glib-2.0/gobject/gvaluetypes.h:
+
+/usr/include/pango-1.0/pango/pango-break.h:
+
+/usr/include/pango-1.0/pango/pango-item.h:
+
+/usr/include/pango-1.0/pango/pango-context.h:
+
+/usr/include/pango-1.0/pango/pango-fontmap.h:
+
+/usr/include/pango-1.0/pango/pango-fontset.h:
+
+/usr/include/pango-1.0/pango/pango-engine.h:
+
+/usr/include/pango-1.0/pango/pango-glyph.h:
+
+/usr/include/pango-1.0/pango/pango-script.h:
+
+/usr/include/pango-1.0/pango/pango-enum-types.h:
+
+/usr/include/pango-1.0/pango/pango-layout.h:
+
+/usr/include/pango-1.0/pango/pango-glyph-item.h:
+
+/usr/include/pango-1.0/pango/pango-tabs.h:
+
+/usr/include/pango-1.0/pango/pango-renderer.h:
+
+/usr/lib/gtk-2.0/include/gdkconfig.h:
+
+/usr/include/gtk-2.0/gdk/gdkevents.h:
+
+/usr/include/gtk-2.0/gdk/gdkcolor.h:
+
+/usr/include/gtk-2.0/gdk/gdkdnd.h:
+
+/usr/include/gtk-2.0/gdk/gdkinput.h:
+
+/usr/include/gtk-2.0/gdk/gdkfont.h:
+
+/usr/include/gtk-2.0/gdk/gdkgc.h:
+
+/usr/include/gtk-2.0/gdk/gdkimage.h:
+
+/usr/include/gtk-2.0/gdk/gdkregion.h:
+
+/usr/include/gtk-2.0/gdk/gdkvisual.h:
+
+/usr/include/gtk-2.0/gdk/gdkwindow.h:
+
+/usr/include/gtk-2.0/gdk/gdkdrawable.h:
+
+/usr/include/gtk-2.0/gdk/gdkrgb.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-features.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-core.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-transform.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-animation.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-io.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-loader.h:
+
+/usr/include/gtk-2.0/gdk-pixbuf/gdk-pixbuf-enum-types.h:
+
+/usr/include/gtk-2.0/gdk/gdkcursor.h:
+
+/usr/include/X11/Xlib.h:
+
+/usr/include/X11/X.h:
+
+/usr/include/X11/Xfuncproto.h:
+
+/usr/include/X11/Xosdefs.h:
+
+/usr/include/X11/Xutil.h:
+
+/usr/include/gtk-2.0/gtk/gtk.h:
+
+/usr/include/gtk-2.0/gdk/gdk.h:
+
+/usr/include/gtk-2.0/gdk/gdkdisplay.h:
+
+/usr/include/gtk-2.0/gdk/gdkenumtypes.h:
+
+/usr/include/gtk-2.0/gdk/gdkkeys.h:
+
+/usr/include/gtk-2.0/gdk/gdkdisplaymanager.h:
+
+/usr/include/gtk-2.0/gdk/gdkpango.h:
+
+/usr/include/gtk-2.0/gdk/gdkpixbuf.h:
+
+/usr/include/gtk-2.0/gdk/gdkpixmap.h:
+
+/usr/include/gtk-2.0/gdk/gdkproperty.h:
+
+/usr/include/gtk-2.0/gdk/gdkscreen.h:
+
+/usr/include/gtk-2.0/gdk/gdkselection.h:
+
+/usr/include/gtk-2.0/gdk/gdkspawn.h:
+
+/usr/include/gtk-2.0/gtk/gtkaboutdialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkdialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkwindow.h:
+
+/usr/include/gtk-2.0/gtk/gtkaccelgroup.h:
+
+/usr/include/gtk-2.0/gtk/gtkenums.h:
+
+/usr/include/gtk-2.0/gtk/gtkbin.h:
+
+/usr/include/gtk-2.0/gtk/gtkcontainer.h:
+
+/usr/include/gtk-2.0/gtk/gtkwidget.h:
+
+/usr/include/gtk-2.0/gtk/gtkobject.h:
+
+/usr/include/gtk-2.0/gtk/gtktypeutils.h:
+
+/usr/include/gtk-2.0/gtk/gtktypebuiltins.h:
+
+/usr/include/gtk-2.0/gtk/gtkdebug.h:
+
+/usr/include/gtk-2.0/gtk/gtkadjustment.h:
+
+/usr/include/gtk-2.0/gtk/gtkstyle.h:
+
+/usr/include/gtk-2.0/gtk/gtksettings.h:
+
+/usr/include/gtk-2.0/gtk/gtkrc.h:
+
+/usr/include/atk-1.0/atk/atkobject.h:
+
+/usr/include/atk-1.0/atk/atkstate.h:
+
+/usr/include/atk-1.0/atk/atkrelationtype.h:
+
+/usr/include/gtk-2.0/gtk/gtkaccellabel.h:
+
+/usr/include/gtk-2.0/gtk/gtklabel.h:
+
+/usr/include/gtk-2.0/gtk/gtkmisc.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenu.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenushell.h:
+
+/usr/include/gtk-2.0/gtk/gtkaccelmap.h:
+
+/usr/include/gtk-2.0/gtk/gtkaccessible.h:
+
+/usr/include/atk-1.0/atk/atk.h:
+
+/usr/include/atk-1.0/atk/atkaction.h:
+
+/usr/include/atk-1.0/atk/atkcomponent.h:
+
+/usr/include/atk-1.0/atk/atkutil.h:
+
+/usr/include/atk-1.0/atk/atkdocument.h:
+
+/usr/include/atk-1.0/atk/atkeditabletext.h:
+
+/usr/include/atk-1.0/atk/atktext.h:
+
+/usr/include/atk-1.0/atk/atkgobjectaccessible.h:
+
+/usr/include/atk-1.0/atk/atkhyperlink.h:
+
+/usr/include/atk-1.0/atk/atkhypertext.h:
+
+/usr/include/atk-1.0/atk/atkimage.h:
+
+/usr/include/atk-1.0/atk/atknoopobject.h:
+
+/usr/include/atk-1.0/atk/atknoopobjectfactory.h:
+
+/usr/include/atk-1.0/atk/atkobjectfactory.h:
+
+/usr/include/atk-1.0/atk/atkregistry.h:
+
+/usr/include/atk-1.0/atk/atkobjectfactory.h:
+
+/usr/include/atk-1.0/atk/atkrelation.h:
+
+/usr/include/atk-1.0/atk/atkrelationset.h:
+
+/usr/include/atk-1.0/atk/atkselection.h:
+
+/usr/include/atk-1.0/atk/atkstateset.h:
+
+/usr/include/atk-1.0/atk/atkstreamablecontent.h:
+
+/usr/include/atk-1.0/atk/atktable.h:
+
+/usr/include/atk-1.0/atk/atkvalue.h:
+
+/usr/include/gtk-2.0/gtk/gtkaction.h:
+
+/usr/include/gtk-2.0/gtk/gtkactiongroup.h:
+
+/usr/include/gtk-2.0/gtk/gtkitemfactory.h:
+
+/usr/include/gtk-2.0/gtk/gtkalignment.h:
+
+/usr/include/gtk-2.0/gtk/gtkarrow.h:
+
+/usr/include/gtk-2.0/gtk/gtkaspectframe.h:
+
+/usr/include/gtk-2.0/gtk/gtkframe.h:
+
+/usr/include/gtk-2.0/gtk/gtkbbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkbindings.h:
+
+/usr/include/gtk-2.0/gtk/gtkbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkimage.h:
+
+/usr/include/gtk-2.0/gtk/gtkcalendar.h:
+
+/usr/include/gtk-2.0/gtk/gtksignal.h:
+
+/usr/include/gtk-2.0/gtk/gtkmarshal.h:
+
+/usr/include/gtk-2.0/gtk/gtkcelllayout.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrenderer.h:
+
+/usr/include/gtk-2.0/gtk/gtkcelleditable.h:
+
+/usr/include/gtk-2.0/gtk/gtktreeviewcolumn.h:
+
+/usr/include/gtk-2.0/gtk/gtktreemodel.h:
+
+/usr/include/gtk-2.0/gtk/gtktreesortable.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrenderercombo.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrenderertext.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrendererpixbuf.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrendererprogress.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellrenderertoggle.h:
+
+/usr/include/gtk-2.0/gtk/gtkcellview.h:
+
+/usr/include/gtk-2.0/gtk/gtkcheckbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktogglebutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkcheckmenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkclipboard.h:
+
+/usr/include/gtk-2.0/gtk/gtkselection.h:
+
+/usr/include/gtk-2.0/gtk/gtkclist.h:
+
+/usr/include/gtk-2.0/gtk/gtkhscrollbar.h:
+
+/usr/include/gtk-2.0/gtk/gtkscrollbar.h:
+
+/usr/include/gtk-2.0/gtk/gtkrange.h:
+
+/usr/include/gtk-2.0/gtk/gtkvscrollbar.h:
+
+/usr/include/gtk-2.0/gtk/gtkcolorbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkcolorsel.h:
+
+/usr/include/gtk-2.0/gtk/gtkvbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkcolorseldialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkcombo.h:
+
+/usr/include/gtk-2.0/gtk/gtkhbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkcombobox.h:
+
+/usr/include/gtk-2.0/gtk/gtktreeview.h:
+
+/usr/include/gtk-2.0/gtk/gtkdnd.h:
+
+/usr/include/gtk-2.0/gtk/gtkcomboboxentry.h:
+
+/usr/include/gtk-2.0/gtk/gtkctree.h:
+
+/usr/include/gtk-2.0/gtk/gtkcurve.h:
+
+/usr/include/gtk-2.0/gtk/gtkdrawingarea.h:
+
+/usr/include/gtk-2.0/gtk/gtkeditable.h:
+
+/usr/include/gtk-2.0/gtk/gtkentry.h:
+
+/usr/include/gtk-2.0/gtk/gtkimcontext.h:
+
+/usr/include/gtk-2.0/gtk/gtkentrycompletion.h:
+
+/usr/include/gtk-2.0/gtk/gtkliststore.h:
+
+/usr/include/gtk-2.0/gtk/gtktreemodelfilter.h:
+
+/usr/include/gtk-2.0/gtk/gtkeventbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkexpander.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilesel.h:
+
+/usr/include/gtk-2.0/gtk/gtkfixed.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilechooserbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilechooser.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilefilter.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilechooserdialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilechooser.h:
+
+/usr/include/gtk-2.0/gtk/gtkfilechooserwidget.h:
+
+/usr/include/gtk-2.0/gtk/gtkfontbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkfontsel.h:
+
+/usr/include/gtk-2.0/gtk/gtkgamma.h:
+
+/usr/include/gtk-2.0/gtk/gtkgc.h:
+
+/usr/include/gtk-2.0/gtk/gtkhandlebox.h:
+
+/usr/include/gtk-2.0/gtk/gtkhbbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkhpaned.h:
+
+/usr/include/gtk-2.0/gtk/gtkpaned.h:
+
+/usr/include/gtk-2.0/gtk/gtkhruler.h:
+
+/usr/include/gtk-2.0/gtk/gtkruler.h:
+
+/usr/include/gtk-2.0/gtk/gtkhscale.h:
+
+/usr/include/gtk-2.0/gtk/gtkscale.h:
+
+/usr/include/gtk-2.0/gtk/gtkhseparator.h:
+
+/usr/include/gtk-2.0/gtk/gtkseparator.h:
+
+/usr/include/gtk-2.0/gtk/gtkiconfactory.h:
+
+/usr/include/gtk-2.0/gtk/gtkicontheme.h:
+
+/usr/include/gtk-2.0/gtk/gtkiconview.h:
+
+/usr/include/gtk-2.0/gtk/gtkimagemenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkimcontextsimple.h:
+
+/usr/include/gtk-2.0/gtk/gtkimmulticontext.h:
+
+/usr/include/gtk-2.0/gtk/gtkinputdialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkinvisible.h:
+
+/usr/include/gtk-2.0/gtk/gtklayout.h:
+
+/usr/include/gtk-2.0/gtk/gtklist.h:
+
+/usr/include/gtk-2.0/gtk/gtklistitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkmain.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenubar.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenutoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkmenu.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolitem.h:
+
+/usr/include/gtk-2.0/gtk/gtktooltips.h:
+
+/usr/include/gtk-2.0/gtk/gtkmessagedialog.h:
+
+/usr/include/gtk-2.0/gtk/gtkmodules.h:
+
+/usr/include/gtk-2.0/gtk/gtknotebook.h:
+
+/usr/include/gtk-2.0/gtk/gtkoldeditable.h:
+
+/usr/include/gtk-2.0/gtk/gtkoptionmenu.h:
+
+/usr/include/gtk-2.0/gtk/gtkpixmap.h:
+
+/usr/include/gtk-2.0/gtk/gtkplug.h:
+
+/usr/include/gtk-2.0/gtk/gtksocket.h:
+
+/usr/include/gtk-2.0/gtk/gtkpreview.h:
+
+/usr/include/gtk-2.0/gtk/gtkprogress.h:
+
+/usr/include/gtk-2.0/gtk/gtkprogressbar.h:
+
+/usr/include/gtk-2.0/gtk/gtkradioaction.h:
+
+/usr/include/gtk-2.0/gtk/gtktoggleaction.h:
+
+/usr/include/gtk-2.0/gtk/gtkradiobutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkradiomenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkradiotoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkscrolledwindow.h:
+
+/usr/include/gtk-2.0/gtk/gtkviewport.h:
+
+/usr/include/gtk-2.0/gtk/gtkseparatormenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtkseparatortoolitem.h:
+
+/usr/include/gtk-2.0/gtk/gtksizegroup.h:
+
+/usr/include/gtk-2.0/gtk/gtkspinbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtkstatusbar.h:
+
+/usr/include/gtk-2.0/gtk/gtkstock.h:
+
+/usr/include/gtk-2.0/gtk/gtktable.h:
+
+/usr/include/gtk-2.0/gtk/gtktearoffmenuitem.h:
+
+/usr/include/gtk-2.0/gtk/gtktext.h:
+
+/usr/include/gtk-2.0/gtk/gtktextbuffer.h:
+
+/usr/include/gtk-2.0/gtk/gtktexttagtable.h:
+
+/usr/include/gtk-2.0/gtk/gtktexttag.h:
+
+/usr/include/gtk-2.0/gtk/gtktextiter.h:
+
+/usr/include/gtk-2.0/gtk/gtktextchild.h:
+
+/usr/include/gtk-2.0/gtk/gtktextmark.h:
+
+/usr/include/gtk-2.0/gtk/gtktextview.h:
+
+/usr/include/gtk-2.0/gtk/gtktipsquery.h:
+
+/usr/include/gtk-2.0/gtk/gtktoggletoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolbar.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolbutton.h:
+
+/usr/include/gtk-2.0/gtk/gtktoolitem.h:
+
+/usr/include/gtk-2.0/gtk/gtktree.h:
+
+/usr/include/gtk-2.0/gtk/gtktreednd.h:
+
+/usr/include/gtk-2.0/gtk/gtktreeitem.h:
+
+/usr/include/gtk-2.0/gtk/gtktreemodelsort.h:
+
+/usr/include/gtk-2.0/gtk/gtktreeselection.h:
+
+/usr/include/gtk-2.0/gtk/gtktreestore.h:
+
+/usr/include/gtk-2.0/gtk/gtkuimanager.h:
+
+/usr/include/gtk-2.0/gtk/gtkvbbox.h:
+
+/usr/include/gtk-2.0/gtk/gtkversion.h:
+
+/usr/include/gtk-2.0/gtk/gtkvpaned.h:
+
+/usr/include/gtk-2.0/gtk/gtkvruler.h:
+
+/usr/include/gtk-2.0/gtk/gtkvscale.h:
+
+/usr/include/gtk-2.0/gtk/gtkvseparator.h:
+
+/usr/local/include/gaim/conversation.h:
+
+/usr/local/include/gaim/account.h:
+
+/usr/local/include/gaim/connection.h:
+
+/usr/local/include/gaim/plugin.h:
+
+/usr/local/include/gaim/signals.h:
+
+/usr/local/include/gaim/value.h:
+
+/usr/local/include/gaim/pluginpref.h:
+
+/usr/local/include/gaim/prefs.h:
+
+/usr/local/include/gaim/log.h:
+
+/usr/local/include/gaim/conversation.h:
+
+/usr/local/include/gaim/proxy.h:
+
+/usr/local/include/gaim/eventloop.h:
+
+/usr/local/include/gaim/prpl.h:
+
+/usr/local/include/gaim/blist.h:
+
+/usr/local/include/gaim/buddyicon.h:
+
+/usr/local/include/gaim/server.h:
+
+/usr/local/include/gaim/debug.h:
+
+/usr/local/include/gaim/prefs.h:
+
+/usr/local/include/gaim/signals.h:
+
+/usr/local/include/gaim/util.h:
+
+/usr/local/include/gaim/version.h:
+
+/usr/local/include/gaim/buddyicon.h:
+
+/usr/local/include/gaim/prpl.h:
+
+/usr/local/include/gaim/gtkconv.h:
+
+/usr/local/include/gaim/gtkgaim.h:
+
+/usr/local/include/gaim/gtkplugin.h:

Added: qrc/trunk/gaym-extras/src/.libs/libgaym-extras.lai
===================================================================
--- qrc/trunk/gaym-extras/src/.libs/libgaym-extras.lai	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/src/.libs/libgaym-extras.lai	2005-07-30 21:32:57 UTC (rev 256)
@@ -0,0 +1,35 @@
+# libgaym-extras.la - a libtool library file
+# Generated by ltmain.sh - GNU libtool 1.5.18 (1.1220.2.246 2005/05/16 10:00:18)
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# The name that we can dlopen(3).
+dlname='libgaym-extras.so'
+
+# Names of this library.
+library_names='libgaym-extras.so libgaym-extras.so libgaym-extras.so'
+
+# The name of the static archive.
+old_library=''
+
+# Libraries that this one depends upon.
+dependency_libs=' /usr/lib/libgtk-x11-2.0.la /usr/lib/libgdk-x11-2.0.la /usr/lib/libatk-1.0.la /usr/lib/libgdk_pixbuf-2.0.la /usr/lib/libpangoxft-1.0.la /usr/lib/libpangox-1.0.la /usr/lib/libpango-1.0.la -lm /usr/lib/libgobject-2.0.la /usr/lib/libgmodule-2.0.la -ldl /usr/lib/libglib-2.0.la'
+
+# Version information for libgaym-extras.
+current=0
+age=0
+revision=0
+
+# Is this an already installed library?
+installed=yes
+
+# Should we warn about portability when linking against -modules?
+shouldnotlink=yes
+
+# Files to dlopen/dlpreopen
+dlopen=''
+dlpreopen=''
+
+# Directory that this library needs to be installed in:
+libdir='/usr/local/lib/gaim'

Added: qrc/trunk/gaym-extras/src/.libs/libgaym-extras.so
===================================================================
(Binary files differ)


Property changes on: qrc/trunk/gaym-extras/src/.libs/libgaym-extras.so
___________________________________________________________________
Name: svn:executable
   + *
Name: svn:mime-type
   + application/octet-stream

Added: qrc/trunk/gaym-extras/src/Makefile
===================================================================
--- qrc/trunk/gaym-extras/src/Makefile	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/src/Makefile	2005-07-30 21:32:57 UTC (rev 256)
@@ -0,0 +1,505 @@
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# gaym-extras/src/Makefile.  Generated from Makefile.in by configure.
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+
+
+srcdir = .
+top_srcdir = ../..
+
+pkgdatadir = $(datadir)/qrc
+pkglibdir = $(libdir)/qrc
+pkgincludedir = $(includedir)/qrc
+top_builddir = ../..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = /bin/install -c
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = i686-pc-linux-gnu
+host_triplet = i686-pc-linux-gnu
+target_triplet = i686-pc-linux-gnu
+subdir = gaym-extras/src
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(pkgdir)"
+pkgLTLIBRARIES_INSTALL = $(INSTALL)
+LTLIBRARIES = $(pkg_LTLIBRARIES)
+libgaym_extras_la_LIBADD =
+am__objects_1 = gaym-extras.lo chatsort.lo bio-popups.lo chaticon.lo
+am_libgaym_extras_la_OBJECTS = $(am__objects_1)
+libgaym_extras_la_OBJECTS = $(am_libgaym_extras_la_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libgaym_extras_la_SOURCES)
+DIST_SOURCES = $(libgaym_extras_la_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = ${SHELL} /home/jason/packages/qrc-dev/missing --run aclocal-1.9
+AMDEP_FALSE = #
+AMDEP_TRUE = 
+AMTAR = ${SHELL} /home/jason/packages/qrc-dev/missing --run tar
+AR = ar
+AS = as
+AUTOCONF = ${SHELL} /home/jason/packages/qrc-dev/missing --run autoconf
+AUTOHEADER = ${SHELL} /home/jason/packages/qrc-dev/missing --run autoheader
+AUTOMAKE = ${SHELL} /home/jason/packages/qrc-dev/missing --run automake-1.9
+AWK = gawk
+CC = gcc
+CCDEPMODE = depmode=gcc3
+CFLAGS = -g -O2 -Wall -g3
+COND_BOT_CHALLENGER_FALSE = #
+COND_BOT_CHALLENGER_TRUE = 
+COND_GAYM_EXTRAS_FALSE = #
+COND_GAYM_EXTRAS_TRUE = 
+COND_GAYM_FALSE = #
+COND_GAYM_TRUE = 
+CPP = gcc -E
+CPPFLAGS = 
+CXX = g++
+CXXCPP = g++ -E
+CXXDEPMODE = depmode=gcc3
+CXXFLAGS = -g -O2
+CYGPATH_W = echo
+DEFS = -DHAVE_CONFIG_H
+DEPDIR = .deps
+DLLTOOL = dlltool
+ECHO = echo
+ECHO_C = 
+ECHO_N = -n
+ECHO_T = 
+EGREP = grep -E
+EXEEXT = 
+F77 = g77
+FFLAGS = -g -O2
+GAIM_CFLAGS = -I/usr/local/include/gaim -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include  
+GAIM_DATADIR = /usr/local/share
+GAIM_LIBDIR = /usr/local/lib
+GAIM_LIBS = -lglib-2.0  
+GTK_CFLAGS = -DXTHREADS -D_REENTRANT -DXUSE_MTSAFE_API -I/usr/include/gtk-2.0 -I/usr/lib/gtk-2.0/include -I/usr/include/atk-1.0 -I/usr/include/pango-1.0 -I/usr/include/freetype2 -I/usr/include/freetype2/config -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include  
+GTK_LIBS = -lgtk-x11-2.0 -lgdk-x11-2.0 -latk-1.0 -lgdk_pixbuf-2.0 -lm -lpangoxft-1.0 -lpangox-1.0 -lpango-1.0 -lgobject-2.0 -lgmodule-2.0 -ldl -lglib-2.0  
+INSTALL_DATA = ${INSTALL} -m 644
+INSTALL_PROGRAM = ${INSTALL}
+INSTALL_SCRIPT = ${INSTALL}
+INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
+LDFLAGS = 
+LIBOBJS = 
+LIBS = 
+LIBTOOL = $(SHELL) $(top_builddir)/libtool --silent
+LN_S = ln -s
+LTLIBOBJS = 
+MAKEINFO = ${SHELL} /home/jason/packages/qrc-dev/missing --run makeinfo
+OBJDUMP = objdump
+OBJEXT = o
+PACKAGE = qrc
+PACKAGE_BUGREPORT = gaymplugin at yahoogroups.com
+PACKAGE_NAME = qrc
+PACKAGE_STRING = qrc 0.34.1+svn
+PACKAGE_TARNAME = qrc
+PACKAGE_VERSION = 0.34.1+svn
+PATH_SEPARATOR = :
+PKG_CONFIG = /usr/bin/pkg-config
+RANLIB = ranlib
+REQUIRED_GAIM = gaim >= 1.2 gaim < 2.0
+REQUIRED_GTK = gtk+-2.0
+REQUIRED_PKG_CONFIG = 0.15.0
+SET_MAKE = 
+SHELL = /bin/sh
+STRIP = strip
+VERSION = 0.34.1+svn
+ac_ct_AR = ar
+ac_ct_AS = 
+ac_ct_CC = gcc
+ac_ct_CXX = g++
+ac_ct_DLLTOOL = 
+ac_ct_F77 = g77
+ac_ct_OBJDUMP = 
+ac_ct_RANLIB = ranlib
+ac_ct_STRIP = strip
+ac_pt_PKG_CONFIG = 
+am__fastdepCC_FALSE = #
+am__fastdepCC_TRUE = 
+am__fastdepCXX_FALSE = #
+am__fastdepCXX_TRUE = 
+am__include = include
+am__leading_dot = .
+am__quote = 
+am__tar = ${AMTAR} chof - "$$tardir"
+am__untar = ${AMTAR} xf -
+bindir = ${exec_prefix}/bin
+build = i686-pc-linux-gnu
+build_alias = 
+build_cpu = i686
+build_os = linux-gnu
+build_vendor = pc
+datadir = ${prefix}/share
+exec_prefix = ${prefix}
+host = i686-pc-linux-gnu
+host_alias = 
+host_cpu = i686
+host_os = linux-gnu
+host_vendor = pc
+includedir = ${prefix}/include
+infodir = ${prefix}/info
+install_sh = /home/jason/packages/qrc-dev/install-sh
+libdir = ${exec_prefix}/lib
+libexecdir = ${exec_prefix}/libexec
+localstatedir = ${prefix}/var
+mandir = ${prefix}/man
+mkdir_p = mkdir -p --
+oldincludedir = /usr/include
+prefix = /usr/local
+program_transform_name = s,x,x,
+sbindir = ${exec_prefix}/sbin
+sharedstatedir = ${prefix}/com
+sysconfdir = ${prefix}/etc
+target = i686-pc-linux-gnu
+target_alias = 
+target_cpu = i686
+target_os = linux-gnu
+target_vendor = pc
+pkgdir = \
+	$(GAIM_LIBDIR)/gaim
+
+GAYMSOURCES = \
+	gaym-extras.c chatsort.c bio-popups.c chaticon.c gaym-extras.h
+
+AM_CFLAGS = \
+	$(st)
+
+libgaym_extras_la_LDFLAGS = \
+	-module \
+	-avoid-version \
+	$(GTK_LIBS) \
+	$(GAIM_LIBS)
+
+pkg_LTLIBRARIES = \
+	libgaym-extras.la
+
+libgaym_extras_la_SOURCES = \
+	$(GAYMSOURCES)
+
+AM_CPPFLAGS = \
+	$(DEBUG_CFLAGS) \
+	$(GTK_CFLAGS) \
+	-DGAIM_DATADIR=\"$(datadir)\" \
+	$(GAIM_CFLAGS)
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  gaym-extras/src/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  gaym-extras/src/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+install-pkgLTLIBRARIES: $(pkg_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	test -z "$(pkgdir)" || $(mkdir_p) "$(DESTDIR)$(pkgdir)"
+	@list='$(pkg_LTLIBRARIES)'; for p in $$list; do \
+	  if test -f $$p; then \
+	    f=$(am__strip_dir) \
+	    echo " $(LIBTOOL) --mode=install $(pkgLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) '$$p' '$(DESTDIR)$(pkgdir)/$$f'"; \
+	    $(LIBTOOL) --mode=install $(pkgLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) "$$p" "$(DESTDIR)$(pkgdir)/$$f"; \
+	  else :; fi; \
+	done
+
+uninstall-pkgLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@set -x; list='$(pkg_LTLIBRARIES)'; for p in $$list; do \
+	  p=$(am__strip_dir) \
+	  echo " $(LIBTOOL) --mode=uninstall rm -f '$(DESTDIR)$(pkgdir)/$$p'"; \
+	  $(LIBTOOL) --mode=uninstall rm -f "$(DESTDIR)$(pkgdir)/$$p"; \
+	done
+
+clean-pkgLTLIBRARIES:
+	-test -z "$(pkg_LTLIBRARIES)" || rm -f $(pkg_LTLIBRARIES)
+	@list='$(pkg_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libgaym-extras.la: $(libgaym_extras_la_OBJECTS) $(libgaym_extras_la_DEPENDENCIES) 
+	$(LINK) -rpath $(pkgdir) $(libgaym_extras_la_LDFLAGS) $(libgaym_extras_la_OBJECTS) $(libgaym_extras_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+include ./$(DEPDIR)/bio-popups.Plo
+include ./$(DEPDIR)/chaticon.Plo
+include ./$(DEPDIR)/chatsort.Plo
+include ./$(DEPDIR)/gaym-extras.Plo
+
+.c.o:
+	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+#	source='$<' object='$@' libtool=no \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(COMPILE) -c $<
+
+.c.obj:
+	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+#	source='$<' object='$@' libtool=no \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+	if $(LTCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Plo"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+#	source='$<' object='$@' libtool=yes \
+#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
+#	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+	for dir in "$(DESTDIR)$(pkgdir)"; do \
+	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-pkgLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-libtool distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-pkgLTLIBRARIES
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-pkgLTLIBRARIES
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-pkgLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-exec \
+	install-exec-am install-info install-info-am install-man \
+	install-pkgLTLIBRARIES install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-info-am \
+	uninstall-pkgLTLIBRARIES
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: qrc/trunk/gaym-extras/src/Makefile.am
===================================================================
--- qrc/trunk/gaym-extras/src/Makefile.am	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/src/Makefile.am	2005-07-30 21:32:57 UTC (rev 256)
@@ -0,0 +1,27 @@
+pkgdir = \
+	$(GAIM_LIBDIR)/gaim
+
+GAYMSOURCES = \
+	gaym-extras.c chatsort.c bio-popups.c chaticon.c gaym-extras.h
+
+AM_CFLAGS = \
+	$(st)
+
+libgaym_extras_la_LDFLAGS = \
+	-module \
+	-avoid-version \
+	$(GTK_LIBS) \
+	$(GAIM_LIBS)
+
+pkg_LTLIBRARIES = \
+	libgaym-extras.la
+
+libgaym_extras_la_SOURCES = \
+	$(GAYMSOURCES)
+
+AM_CPPFLAGS = \
+	$(DEBUG_CFLAGS) \
+	$(GTK_CFLAGS) \
+	-DGAIM_DATADIR=\"$(datadir)\" \
+	$(GAIM_CFLAGS)
+	

Added: qrc/trunk/gaym-extras/src/Makefile.in
===================================================================
--- qrc/trunk/gaym-extras/src/Makefile.in	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/src/Makefile.in	2005-07-30 21:32:57 UTC (rev 256)
@@ -0,0 +1,505 @@
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+ at SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+subdir = gaym-extras/src
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(pkgdir)"
+pkgLTLIBRARIES_INSTALL = $(INSTALL)
+LTLIBRARIES = $(pkg_LTLIBRARIES)
+libgaym_extras_la_LIBADD =
+am__objects_1 = gaym-extras.lo chatsort.lo bio-popups.lo chaticon.lo
+am_libgaym_extras_la_OBJECTS = $(am__objects_1)
+libgaym_extras_la_OBJECTS = $(am_libgaym_extras_la_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libgaym_extras_la_SOURCES)
+DIST_SOURCES = $(libgaym_extras_la_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+COND_BOT_CHALLENGER_FALSE = @COND_BOT_CHALLENGER_FALSE@
+COND_BOT_CHALLENGER_TRUE = @COND_BOT_CHALLENGER_TRUE@
+COND_GAYM_EXTRAS_FALSE = @COND_GAYM_EXTRAS_FALSE@
+COND_GAYM_EXTRAS_TRUE = @COND_GAYM_EXTRAS_TRUE@
+COND_GAYM_FALSE = @COND_GAYM_FALSE@
+COND_GAYM_TRUE = @COND_GAYM_TRUE@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GAIM_CFLAGS = @GAIM_CFLAGS@
+GAIM_DATADIR = @GAIM_DATADIR@
+GAIM_LIBDIR = @GAIM_LIBDIR@
+GAIM_LIBS = @GAIM_LIBS@
+GTK_CFLAGS = @GTK_CFLAGS@
+GTK_LIBS = @GTK_LIBS@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PKG_CONFIG = @PKG_CONFIG@
+RANLIB = @RANLIB@
+REQUIRED_GAIM = @REQUIRED_GAIM@
+REQUIRED_GTK = @REQUIRED_GTK@
+REQUIRED_PKG_CONFIG = @REQUIRED_PKG_CONFIG@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_AS = @ac_ct_AS@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_DLLTOOL = @ac_ct_DLLTOOL@
+ac_ct_F77 = @ac_ct_F77@
+ac_ct_OBJDUMP = @ac_ct_OBJDUMP@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_pt_PKG_CONFIG = @ac_pt_PKG_CONFIG@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+pkgdir = \
+	$(GAIM_LIBDIR)/gaim
+
+GAYMSOURCES = \
+	gaym-extras.c chatsort.c bio-popups.c chaticon.c gaym-extras.h
+
+AM_CFLAGS = \
+	$(st)
+
+libgaym_extras_la_LDFLAGS = \
+	-module \
+	-avoid-version \
+	$(GTK_LIBS) \
+	$(GAIM_LIBS)
+
+pkg_LTLIBRARIES = \
+	libgaym-extras.la
+
+libgaym_extras_la_SOURCES = \
+	$(GAYMSOURCES)
+
+AM_CPPFLAGS = \
+	$(DEBUG_CFLAGS) \
+	$(GTK_CFLAGS) \
+	-DGAIM_DATADIR=\"$(datadir)\" \
+	$(GAIM_CFLAGS)
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  gaym-extras/src/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  gaym-extras/src/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+install-pkgLTLIBRARIES: $(pkg_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	test -z "$(pkgdir)" || $(mkdir_p) "$(DESTDIR)$(pkgdir)"
+	@list='$(pkg_LTLIBRARIES)'; for p in $$list; do \
+	  if test -f $$p; then \
+	    f=$(am__strip_dir) \
+	    echo " $(LIBTOOL) --mode=install $(pkgLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) '$$p' '$(DESTDIR)$(pkgdir)/$$f'"; \
+	    $(LIBTOOL) --mode=install $(pkgLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) "$$p" "$(DESTDIR)$(pkgdir)/$$f"; \
+	  else :; fi; \
+	done
+
+uninstall-pkgLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@set -x; list='$(pkg_LTLIBRARIES)'; for p in $$list; do \
+	  p=$(am__strip_dir) \
+	  echo " $(LIBTOOL) --mode=uninstall rm -f '$(DESTDIR)$(pkgdir)/$$p'"; \
+	  $(LIBTOOL) --mode=uninstall rm -f "$(DESTDIR)$(pkgdir)/$$p"; \
+	done
+
+clean-pkgLTLIBRARIES:
+	-test -z "$(pkg_LTLIBRARIES)" || rm -f $(pkg_LTLIBRARIES)
+	@list='$(pkg_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libgaym-extras.la: $(libgaym_extras_la_OBJECTS) $(libgaym_extras_la_DEPENDENCIES) 
+	$(LINK) -rpath $(pkgdir) $(libgaym_extras_la_LDFLAGS) $(libgaym_extras_la_OBJECTS) $(libgaym_extras_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/bio-popups.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/chaticon.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/chatsort.Plo at am__quote@
+ at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/gaym-extras.Plo at am__quote@
+
+.c.o:
+ at am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+ at am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+ at AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+ at AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+ at am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+ at am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+ at am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+ at AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+ at AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+ at am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+ at am__fastdepCC_TRUE@	if $(LTCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+ at am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Plo"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+ at AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+ at AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+ at am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+distclean-libtool:
+	-rm -f libtool
+uninstall-info-am:
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+	for dir in "$(DESTDIR)$(pkgdir)"; do \
+	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-pkgLTLIBRARIES \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-libtool distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-pkgLTLIBRARIES
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am uninstall-pkgLTLIBRARIES
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-pkgLTLIBRARIES ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-exec \
+	install-exec-am install-info install-info-am install-man \
+	install-pkgLTLIBRARIES install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-info-am \
+	uninstall-pkgLTLIBRARIES
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:

Added: qrc/trunk/gaym-extras/src/bio-popups.c
===================================================================
--- qrc/trunk/gaym-extras/src/bio-popups.c	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/src/bio-popups.c	2005-07-30 21:32:57 UTC (rev 256)
@@ -0,0 +1,453 @@
+#include "gaym-extras.h"
+// Consider combining into one popup hash...
+GHashTable *popup_rects;
+GHashTable *popup_timeouts;
+GHashTable *popups;
+void clean_popup_stuff(GaimConversation * c)
+{
+
+    if (!g_strrstr(gaim_account_get_protocol_id(c->account),"prpl-gaym"))
+	    return;
+    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
+    if (c->type == GAIM_CONV_IM) {
+        g_hash_table_remove(popup_timeouts, gtkconv->tab_label);
+        g_hash_table_remove(popups, gtkconv->tab_label);
+    } else if (c->type == GAIM_CONV_CHAT) {
+        GaimGtkChatPane *gtkchat = gtkconv->u.chat;
+        g_hash_table_remove(popup_timeouts, gtkchat->list);
+        g_hash_table_remove(popup_rects, gtkchat->list);
+        g_hash_table_remove(popups, gtkchat->list);
+    }
+
+}
+
+static void namelist_leave_cb(GtkWidget * tv, GdkEventCrossing * e,
+                              gpointer n)
+{
+    // This prevent clicks from demloishing popups.
+    if (e->mode != GDK_CROSSING_NORMAL)
+        return;
+
+    guint *timeout = g_hash_table_lookup(popup_timeouts, tv);
+    g_hash_table_remove(popups, tv);
+
+    if (*timeout) {
+        g_source_remove(*timeout);
+        *timeout = 0;
+    }
+}
+
+static void namelist_paint_tip(GtkWidget * tipwindow,
+                               GdkEventExpose * event, gpointer data)
+{
+    g_return_if_fail(data);
+	
+    char *tooltiptext= ((struct paint_data *) data)->tooltiptext;
+    GdkPixbuf* pixbuf = ((struct paint_data *)data)->pixbuf;
+    GtkStyle *style=NULL;
+        
+    PangoLayout *layout;
+
+    layout = gtk_widget_create_pango_layout(tipwindow, NULL);
+    pango_layout_set_markup(layout, tooltiptext, strlen(tooltiptext));
+    pango_layout_set_wrap(layout, PANGO_WRAP_WORD);
+    pango_layout_set_width(layout, 300000);
+    style = tipwindow->style;
+
+    gtk_paint_flat_box(style, tipwindow->window, GTK_STATE_NORMAL,
+                       GTK_SHADOW_OUT, NULL, tipwindow, "tooltip", 0, 0,
+                       -1, -1);
+
+#if GTK_CHECK_VERSION(2,2,0)
+    gdk_draw_pixbuf(GDK_DRAWABLE(tipwindow->window), NULL, pixbuf,
+                    0, 0, 4, 4, -1, -1, GDK_RGB_DITHER_NONE, 0, 0);
+#else
+    gdk_pixbuf_render_to_drawable(pixbuf,
+                                  GDK_DRAWABLE(tipwindow->window), NULL, 0,
+                                  0, 4, 4, -1, -1, GDK_RGB_DITHER_NONE, 0,
+                                  0);
+#endif
+
+    gtk_paint_layout(style, tipwindow->window, GTK_STATE_NORMAL, TRUE,
+                     NULL, tipwindow, "tooltip", 65, 4, layout);
+
+    g_object_unref(pixbuf);
+    g_object_unref(layout);
+    g_free(tooltiptext);
+    g_free(data);
+
+    return;
+}
+GdkPixbuf* lookup_cached_thumbnail(GaimAccount* account, const char*fullname) {
+    GDir* gdir=NULL;
+    GError* err=NULL;
+    GdkPixbuf *pixbuf=NULL;
+    const char *filename=NULL;
+    char* dirname=NULL;
+    char* path=NULL;
+    const char* name= gaim_normalize(account, fullname);
+    dirname=g_build_filename(gaim_user_dir(), "icons", "gaym", name, NULL);
+    if(dirname) 
+    {
+	gdir=g_dir_open(dirname, 0 , &err);
+	if(gdir)
+	{
+	    filename=g_dir_read_name(gdir); //don't free filename: owned by glib.
+	    if(filename)
+	    {	
+		path=g_build_filename(dirname,filename,NULL);
+		if(path)
+		    pixbuf=gdk_pixbuf_new_from_file(path, &err);
+		    g_free(path);
+	    }
+	    g_free(gdir);
+	}
+	g_free(dirname);
+    }
+    return pixbuf;
+}
+
+static gboolean tooltip_timeout(struct timeout_cb_data *data)
+{
+    const gchar *name;
+    int scr_w, scr_h, w, h, x, y;
+#if GTK_CHECK_VERSION(2,2,0)
+    int mon_num;
+    GdkScreen *screen = NULL;
+#endif
+    PangoLayout *layout;
+    gboolean tooltip_top = FALSE;
+    char *tooltiptext = NULL;
+    GdkRectangle mon_size;
+    guint *timeout;
+    GtkWidget *tipwindow;
+    GtkWidget *tv = data->tv;
+
+    GaymTooltipType type = data->type;
+    GaimAccount *account = data->account;
+    GaimPluginProtocolInfo *prpl_info= 
+	GAIM_PLUGIN_PROTOCOL_INFO(
+		gaim_find_prpl(gaim_account_get_protocol_id(account)));
+    
+
+    timeout = (guint *) g_hash_table_lookup(popup_timeouts, tv);
+    /* we check to see if we're still supposed to be moving, now that gtk
+       events have happened, and the mouse might not still be in the buddy 
+       list */
+    while (gtk_events_pending())
+        gtk_main_iteration();
+    if (!(*timeout)) {
+        return FALSE;
+    }
+
+    if (type == TOOLTIP_CHAT) {
+        GtkTreePath *path;
+        GtkTreeIter iter;
+        GtkTreeModel *model;
+        GdkRectangle *rect;
+
+        rect = g_hash_table_lookup(popup_rects, tv);
+        if (!gtk_tree_view_get_path_at_pos
+            (GTK_TREE_VIEW(tv), rect->x, rect->y, &path, NULL, NULL, NULL))
+            return FALSE;
+        model = gtk_tree_view_get_model(GTK_TREE_VIEW(tv));
+        gtk_tree_model_get_iter(model, &iter, path);
+        gtk_tree_model_get(model, &iter, CHAT_USERS_NAME_COLUMN, &name,
+                           -1);
+        gtk_tree_path_free(path);
+    } else if (type == TOOLTIP_IM) {
+        name = gtk_label_get_text(GTK_LABEL(tv));
+    } else
+        return FALSE;
+    
+    	
+
+
+    GaimBuddy *gb = g_new0(GaimBuddy, 1);
+    gb->name = g_strdup(name);
+    gb->account = account;
+    tooltiptext = prpl_info->tooltip_text(gb);
+    g_free(gb->name);
+    g_free(gb);
+
+    if (!tooltiptext) 
+        return FALSE;
+
+    
+    g_return_val_if_fail(tooltiptext != NULL, FALSE);
+
+    tipwindow = g_hash_table_lookup(popups, tv);
+    if (tipwindow) {
+        g_hash_table_remove(popups, tv);
+    }
+    tipwindow = gtk_window_new(GTK_WINDOW_POPUP);
+    g_hash_table_insert(popups, tv, tipwindow);
+
+    gtk_widget_set_app_paintable(tipwindow, TRUE);
+    gtk_window_set_resizable(GTK_WINDOW(tipwindow), FALSE);
+    gtk_widget_set_name(tipwindow, "gtk-tooltips");
+
+    struct paint_data *pdata = g_new0(struct paint_data, 1);
+    pdata->tooltiptext = tooltiptext;
+    pdata->pixbuf = lookup_cached_thumbnail(account, name);
+    g_signal_connect(G_OBJECT(tipwindow), "expose_event",
+                     G_CALLBACK(namelist_paint_tip), pdata);
+    gtk_widget_ensure_style(tipwindow);
+    layout = gtk_widget_create_pango_layout(tipwindow, NULL);
+    pango_layout_set_wrap(layout, PANGO_WRAP_WORD);
+    pango_layout_set_width(layout, 300000);
+    pango_layout_set_markup(layout, tooltiptext, strlen(tooltiptext));
+    pango_layout_get_size(layout, &w, &h);
+
+#if GTK_CHECK_VERSION(2,2,0)
+    gdk_display_get_pointer(gdk_display_get_default(), &screen, &x, &y,
+                            NULL);
+    mon_num = gdk_screen_get_monitor_at_point(screen, x, y);
+    gdk_screen_get_monitor_geometry(screen, mon_num, &mon_size);
+
+    scr_w = mon_size.width + mon_size.x;
+    scr_h = mon_size.height + mon_size.y;
+#else
+    scr_w = gdk_screen_width();
+    scr_h = gdk_screen_height();
+    gdk_window_get_pointer(NULL, &x, &y, NULL);
+    mon_size.x = 0;
+    mon_size.y = 0;
+#endif
+
+
+    w = PANGO_PIXELS(w) + 8;
+    h = PANGO_PIXELS(h) + 8;
+
+    /* 57 is the size of a large status icon plus 4 pixels padding on each 
+       side.  I should #define this or something */
+    w = w + gdk_pixbuf_get_width(pdata->pixbuf) + 4;
+    h = MAX(h, gdk_pixbuf_get_height(pdata->pixbuf)+4);
+
+#if GTK_CHECK_VERSION(2,2,0)
+    if (w > mon_size.width)
+        w = mon_size.width - 10;
+
+    if (h > mon_size.height)
+        h = mon_size.height - 10;
+#endif
+
+    // Find the conversation window here....
+    // if (GTK_WIDGET_NO_WINDOW(window))
+    // y+=window->allocation.y;
+
+    x -= ((w >> 1) + 4);
+
+    if ((y + h + 4) > scr_h || tooltip_top)
+        y = y - h - 5;
+    else
+        y = y + 6;
+
+    if (y < mon_size.y)
+        y = mon_size.y;
+
+    if (y != mon_size.y) {
+        if ((x + w) > scr_w)
+            x -= (x + w + 5) - scr_w;
+        else if (x < mon_size.x)
+            x = mon_size.x;
+    } else {
+        x -= (w / 2 + 10);
+        if (x < mon_size.x)
+            x = mon_size.x;
+    }
+
+    g_object_unref(layout);
+    gtk_widget_set_size_request(tipwindow, w, h);
+    gtk_window_move(GTK_WINDOW(tipwindow), x, y);
+    gtk_widget_show(tipwindow);
+
+    return FALSE;
+}
+
+
+static gboolean namelist_motion_cb(GtkWidget * tv, GdkEventMotion * event,
+                                   gpointer account)
+{
+    GtkTreeModel *ls = NULL;
+    GtkTreePath *path = NULL;
+    GtkTreeIter iter;
+    char *name;
+    static int count = 0;
+    gboolean tf;
+    GdkRectangle *rect;
+    guint *timeout;
+    count++;
+    guint delay;
+    rect = g_hash_table_lookup(popup_rects, tv);
+    g_return_val_if_fail(rect != NULL, FALSE);
+
+    timeout = g_hash_table_lookup(popup_timeouts, tv);
+
+    delay = gaim_prefs_get_int("/gaim/gtk/blist/tooltip_delay");
+
+    if (delay == 0)
+        return FALSE;
+
+    if (*timeout) {
+        if ((event->y > rect->y) && ((event->y - rect->height) < rect->y))
+            return FALSE;
+        /* We've left the cell.  Remove the timeout and create a new one
+           below */
+
+        g_hash_table_remove(popups, tv);
+        g_source_remove(*timeout);
+    }
+
+    gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(tv), event->x, event->y,
+                                  &path, NULL, NULL, NULL);
+    if (G_UNLIKELY(path == NULL))
+        return FALSE;
+    struct timeout_cb_data *timeout_data =
+        g_new0(struct timeout_cb_data, 1);
+    timeout_data->tv = tv;
+    timeout_data->account = account;
+    timeout_data->type = TOOLTIP_CHAT;
+    *timeout =
+        g_timeout_add(delay, (GSourceFunc) tooltip_timeout, timeout_data);
+
+    gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, rect);
+
+    ls = gtk_tree_view_get_model(GTK_TREE_VIEW(tv));
+    tf = gtk_tree_model_get_iter(ls, &iter, path);
+    gtk_tree_model_get(ls, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
+    gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, rect);
+
+    return TRUE;
+}
+
+static void tab_leave_cb(GtkWidget * event, GdkEventCrossing * e,
+                         gpointer conv)
+{
+    
+    GaimConversation *c = (GaimConversation *) conv;
+   
+    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
+    // Prevent clicks from demolishing popup.
+    if (e->mode != GDK_CROSSING_NORMAL)
+        return;
+    GtkWidget *tab = gtkconv->tab_label;
+  
+    guint *timeout = g_hash_table_lookup(popup_timeouts, tab);
+    g_hash_table_remove(popups, tab);
+
+
+    if (timeout && *timeout) {
+        g_source_remove(*timeout);
+        *timeout = 0;
+    }
+}
+
+
+static gboolean tab_entry_cb(GtkWidget *event,
+                             GdkEventCrossing * crossing, gpointer conv)
+{
+
+    guint *timeout;
+    guint delay;
+    GaimConversation *c = (GaimConversation *) conv;
+    GaimAccount *account = gaim_conversation_get_account(c); 
+    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
+
+    GtkWidget *tab = gtkconv->tab_label;
+    timeout = g_hash_table_lookup(popup_timeouts, tab);
+
+    delay = gaim_prefs_get_int("/gaim/gtk/blist/tooltip_delay");
+
+    if (delay == 0)
+        return FALSE;
+
+    if (timeout && *timeout)
+        return FALSE;
+
+    // g_hash_table_remove(popups, tab);
+    // g_source_remove(*timeout);
+
+
+
+    struct timeout_cb_data *timeout_data =
+        g_new0(struct timeout_cb_data, 1);
+    timeout_data->tv = tab;
+    timeout_data->account = account;
+    timeout_data->type = TOOLTIP_IM;
+    *timeout =
+        g_timeout_add(delay, (GSourceFunc) tooltip_timeout, timeout_data);
+
+    return TRUE;
+}
+
+void add_chat_popup_stuff(GaimConversation * c)
+{
+
+    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
+    GaimGtkChatPane *gtkchat = gtkconv->u.chat;
+    GaimAccount *account = gaim_conversation_get_account(c);
+
+    g_signal_connect(G_OBJECT(gtkchat->list), "motion-notify-event",
+                     G_CALLBACK(namelist_motion_cb), account);
+    g_signal_connect(G_OBJECT(gtkchat->list), "leave-notify-event",
+                     G_CALLBACK(namelist_leave_cb), NULL);
+
+
+    g_hash_table_insert(popup_rects, gtkchat->list,
+                        g_new0(GdkRectangle, 1));
+    g_hash_table_insert(popup_timeouts, gtkchat->list, g_new0(guint, 1));
+
+
+}
+
+void add_im_popup_stuff(GaimConversation * c)
+{
+    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
+    GtkWidget *event = gtk_event_box_new();
+    GtkWidget *hbox = gtk_hbox_new(FALSE, 6);
+    
+    gtk_widget_ref(gtkconv->icon);
+    gtk_container_remove(GTK_CONTAINER(gtkconv->tabby),
+                         GTK_WIDGET(gtkconv->icon));
+    gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(gtkconv->icon), FALSE, FALSE, 0);
+    gtk_widget_ref(gtkconv->icon);
+    gtk_widget_unref(gtkconv->icon);
+
+    gtk_widget_ref(gtkconv->tab_label);
+    gtk_container_remove(GTK_CONTAINER(gtkconv->tabby),
+                         GTK_WIDGET(gtkconv->tab_label));
+    gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(gtkconv->tab_label), FALSE, FALSE, 0);
+    gtk_widget_unref(gtkconv->tab_label);
+    
+        
+    gtk_widget_add_events(event,
+                          GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK);
+    g_signal_connect(G_OBJECT(event), "enter-notify-event",
+                     G_CALLBACK(tab_entry_cb), c);
+    g_signal_connect(G_OBJECT(event), "leave-notify-event",
+                     G_CALLBACK(tab_leave_cb), c);
+    gtk_box_pack_start(GTK_BOX(gtkconv->tabby), GTK_WIDGET(event), TRUE,
+                       TRUE, 0);
+    gtk_box_reorder_child(GTK_BOX(gtkconv->tabby), GTK_WIDGET(event), 0);
+    gtk_widget_show(GTK_WIDGET(event));
+    gtk_widget_show(GTK_WIDGET(hbox));
+    gtk_event_box_set_visible_window(GTK_EVENT_BOX(event), FALSE);
+    gtk_container_add(GTK_CONTAINER(event),
+                      GTK_WIDGET(hbox));
+    g_hash_table_insert(popup_timeouts, gtkconv->tab_label,
+                        g_new0(guint, 1));
+}
+
+void init_popups()
+{
+    popup_rects =
+        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
+
+    popup_timeouts =
+        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
+
+    popups =
+        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL,
+                              (GDestroyNotify) gtk_widget_destroy);
+}

Added: qrc/trunk/gaym-extras/src/chaticon.c
===================================================================
--- qrc/trunk/gaym-extras/src/chaticon.c	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/src/chaticon.c	2005-07-30 21:32:57 UTC (rev 256)
@@ -0,0 +1,203 @@
+#include "gaym-extras.h"
+GHashTable *icons;
+void get_icon_scale_size(GdkPixbuf * icon, GaimBuddyIconSpec * spec,
+                    int *width, int *height)
+{
+    *width = gdk_pixbuf_get_width(icon);
+    *height = gdk_pixbuf_get_height(icon);
+    gaim_debug_misc("popups","current: w: %i, h: %i\n", *width,*height);
+    /* this should eventually get smarter about preserving the aspect
+       ratio when scaling, but gimmie a break, I just woke up */
+    if (spec && spec->scale_rules & GAIM_ICON_SCALE_DISPLAY) {
+        if (*width < spec->min_width)
+            *width = spec->min_width;
+        else if (*width > spec->max_width)
+            *width = spec->max_width;
+
+        if (*height < spec->min_height)
+            *height = spec->min_height;
+        else if (*height > spec->max_height)
+            *height = spec->max_height;
+    }
+
+    /* and now for some arbitrary sanity checks */
+    if (*width > 100)
+        *width = 100;
+    if (*height > 100)
+        *height = 100;
+    gaim_debug_misc("popups","scaled: w: %i, h: %i\n", *width,*height);
+}
+
+void gaym_update_thumbnail(GaimConversation * conv, GdkPixbuf* pixbuf) 
+{
+    GaimGtkConversation *gtkconv;
+
+    GdkPixbuf *scale;
+    GdkPixmap *pm=NULL;
+    GdkBitmap *bm=NULL;
+    int scale_width=0, 
+	scale_height=0;
+
+
+    GaimAccount *account;
+    GaimPluginProtocolInfo *prpl_info = NULL;
+    g_return_if_fail(conv != NULL);
+    g_return_if_fail(GAIM_IS_GTK_CONVERSATION(conv));
+    g_return_if_fail(gaim_conversation_get_type(conv) == GAIM_CONV_CHAT);
+
+    gtkconv = GAIM_GTK_CONVERSATION(conv);
+
+    GaymChatIcon *icon_data = g_hash_table_lookup(icons, conv);
+
+    if (!icon_data->show_icon)
+        return;
+
+    account = gaim_conversation_get_account(conv);
+    if (account && account->gc)
+        prpl_info = GAIM_PLUGIN_PROTOCOL_INFO(account->gc->prpl);
+
+    if (!gaim_prefs_get_bool
+        ("/gaim/gtk/conversations/im/show_buddy_icons"))
+        return;
+
+    if (gaim_conversation_get_gc(conv) == NULL)
+        return;
+
+
+
+    get_icon_scale_size(pixbuf,
+                        prpl_info ? &prpl_info->icon_spec : NULL,
+                        &scale_width, &scale_height);
+    //double aspect=(double)gdk_pixbuf_get_width(pixbuf)/(double)gdk_pixbuf_get_height(pixbuf); 
+
+    scale =
+        gdk_pixbuf_scale_simple(pixbuf,
+                                scale_width,
+                                scale_height,
+                                GDK_INTERP_BILINEAR);
+
+    gdk_pixbuf_render_pixmap_and_mask(scale, &pm, &bm, 100);
+    g_object_unref(G_OBJECT(scale));
+
+
+    icon_data->event = gtk_event_box_new();
+    gtk_container_add(GTK_CONTAINER(icon_data->frame), icon_data->event);
+    gtk_widget_set_size_request(GTK_WIDGET(icon_data->frame), 57,
+                                77);
+
+    //g_signal_connect(G_OBJECT(icon_data->event), "button-press-event",
+    //G_CALLBACK(icon_menu), conv);
+    gtk_widget_show(icon_data->event);
+    icon_data->icon = gtk_image_new_from_pixmap(pm, bm);
+    gtk_container_add(GTK_CONTAINER(icon_data->event), icon_data->icon);
+    gtk_widget_show(icon_data->icon);
+
+    if(pm)
+        g_object_unref(G_OBJECT(pm));
+
+    if (bm)
+        g_object_unref(G_OBJECT(bm));
+
+
+}
+
+
+static void changed_cb(GtkTreeSelection * selection, gpointer conv)
+{
+
+    g_return_if_fail(selection != NULL);
+    g_return_if_fail(conv != NULL);
+
+    GaimConversation *c = (GaimConversation *) conv;
+
+    GtkTreeIter iter;
+    GtkTreeModel *model=NULL;
+    GdkPixbuf *pixbuf=NULL;
+    gchar *name;
+
+    if (!gtk_tree_selection_get_selected(selection, &model, &iter))
+        return;
+
+    gtk_tree_model_get(model, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
+
+    /* Remove the current icon stuff */
+    GaymChatIcon *icon_data = g_hash_table_lookup(icons, c);
+    if (icon_data->event != NULL)
+        gtk_widget_destroy(icon_data->event);
+    icon_data->event = NULL;
+
+    gtk_widget_grab_focus(GTK_WIDGET(model)->parent);
+
+    pixbuf=lookup_cached_thumbnail(c->account, name);
+ 
+    if(pixbuf)
+	gaym_update_thumbnail(c, pixbuf);
+    
+    g_object_unref(pixbuf);
+    return;
+
+}
+
+void add_chat_icon_stuff(GaimConversation * c)
+{
+
+    GtkTreeModel *ls;
+
+    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
+    GaimGtkChatPane *gtkchat = gtkconv->u.chat;
+    GaimPluginProtocolInfo *prpl_info = NULL;
+    GaimAccount *account = gaim_conversation_get_account(c);
+    GaymChatIcon *icon_data = g_new0(GaymChatIcon, 1);
+
+    if (account && account->gc)
+        prpl_info = GAIM_PLUGIN_PROTOCOL_INFO(account->gc->prpl);
+    GtkTreeSelection *select =
+        gtk_tree_view_get_selection(GTK_TREE_VIEW(gtkchat->list));
+
+    gtk_tree_selection_set_mode(select, GTK_SELECTION_SINGLE);
+
+    ls = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
+
+    GtkBox *hbox = GTK_BOX(gtkconv->lower_hbox);
+
+    g_signal_connect(G_OBJECT(select), "changed", G_CALLBACK(changed_cb),
+                     c);
+
+    icon_data->icon_container_parent = GTK_WIDGET(hbox);
+    icon_data->icon_container = NULL;
+    icon_data->icon = NULL;
+    icon_data->show_icon = TRUE;
+    icon_data->icon_container = gtk_vbox_new(FALSE, 0);
+
+    gtk_widget_set_size_request(GTK_WIDGET(icon_data->icon_container),
+                                57,77);//prpl_info->icon_spec.max_width,
+                                //prpl_info->icon_spec.max_height);
+
+
+    icon_data->frame = gtk_frame_new(NULL);
+    gtk_frame_set_shadow_type(GTK_FRAME(icon_data->frame),
+                              (GTK_SHADOW_IN));
+    gtk_box_pack_start(GTK_BOX(icon_data->icon_container),
+                       icon_data->frame, FALSE, FALSE, 0);
+    gtk_widget_show(icon_data->icon_container);
+    gtk_widget_show(icon_data->frame);
+    gtk_box_pack_end(GTK_BOX(icon_data->icon_container_parent),
+                     icon_data->icon_container, FALSE, FALSE, 0);
+
+    icon_data->event = gtk_event_box_new();
+    gtk_container_add(GTK_CONTAINER(icon_data->frame), icon_data->event);
+
+    // Maybe add menu functionality later.
+    // g_signal_connect(G_OBJECT(icon_data->event), "button-press-event",
+    // G_CALLBACK(icon_menu), conv);
+    gtk_widget_show(icon_data->event);
+    g_hash_table_insert(icons, c, icon_data);
+
+
+}
+
+void init_chat_icons()
+{
+
+    icons = g_hash_table_new(g_direct_hash, g_direct_equal);
+}

Added: qrc/trunk/gaym-extras/src/chatsort.c
===================================================================
--- qrc/trunk/gaym-extras/src/chatsort.c	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/src/chatsort.c	2005-07-30 21:32:57 UTC (rev 256)
@@ -0,0 +1,145 @@
+#include "gaym-extras.h"
+
+static gint
+sort_chat_users_by_entry(GtkTreeModel * model, GtkTreeIter * a,
+                         GtkTreeIter * b, gpointer userdata)
+{
+    GaimConvChatBuddyFlags f1 = 0, f2 = 0;
+    char *user1 = NULL, *user2 = NULL;
+    gint ret = 0;
+
+    gtk_tree_model_get(model, a, CHAT_USERS_NAME_COLUMN, &user1,
+                       CHAT_USERS_FLAGS_COLUMN, &f1, -1);
+    gtk_tree_model_get(model, b, CHAT_USERS_NAME_COLUMN, &user2,
+                       CHAT_USERS_FLAGS_COLUMN, &f2, -1);
+
+    if (user1 == NULL || user2 == NULL) {
+        if (!(user1 == NULL && user2 == NULL))
+            ret = (user1 == NULL) ? -1 : 1;
+    } else if (f1 != f2) {
+        /* sort more important users first */
+        ret = (f1 > f2) ? -1 : 1;
+    } else {
+        ret = g_utf8_collate(user1, user2);
+    }
+
+    g_free(user1);
+    g_free(user2);
+    return ret;
+}
+
+static gint
+sort_chat_users_by_alpha(GtkTreeModel * model, GtkTreeIter * a,
+                         GtkTreeIter * b, gpointer userdata)
+{
+    char *user1 = NULL, *user2 = NULL;
+    gint ret = 0;
+
+    gtk_tree_model_get(model, a, CHAT_USERS_NAME_COLUMN, &user1, -1);
+    gtk_tree_model_get(model, b, CHAT_USERS_NAME_COLUMN, &user2, -1);
+
+    if (user1 == NULL || user2 == NULL) {
+        if (!(user1 == NULL && user2 == NULL))
+            ret = (user1 == NULL) ? -1 : 1;
+    } else {
+        ret = g_utf8_collate(user1, user2);
+    }
+
+    g_free(user1);
+    g_free(user2);
+    return ret;
+}
+
+
+static gint
+sort_chat_users_by_pic(GtkTreeModel * model, GtkTreeIter * a,
+                            GtkTreeIter * b, gpointer userdata)
+{
+    GaimConvChatBuddyFlags f1 = 0, f2 = 0;
+    gint flag_mask = 0x000F;
+    char *user1 = NULL, *user2 = NULL;
+    gint ret = 0;
+
+    gtk_tree_model_get(model, a, CHAT_USERS_NAME_COLUMN, &user1,
+                       CHAT_USERS_FLAGS_COLUMN, &f1, -1);
+    gtk_tree_model_get(model, b, CHAT_USERS_NAME_COLUMN, &user2,
+                       CHAT_USERS_FLAGS_COLUMN, &f2, -1);
+
+    f1 = f1 & flag_mask;
+    f2 = f2 & flag_mask;
+
+    if (user1 == NULL || user2 == NULL) {
+        if (!(user1 == NULL && user2 == NULL))
+            ret = (user1 == NULL) ? -1 : 1;
+    } else if (f1 != f2) {
+        /* sort more important users first */
+        ret = (f1 > f2) ? -1 : 1;
+    } else {
+        ret = g_utf8_collate(user1, user2);
+    }
+
+    g_free(user1);
+    g_free(user2);
+    return ret;
+}
+
+
+static struct gaym_sort_orders
+{
+	const char* icon;
+	void* sort_funcion;
+	const char* tooltip;
+} const order[] =
+    
+{ 
+	{GAYM_STOCK_ENTRY, sort_chat_users_by_entry, _("Current sorting by entry") },
+	{GAYM_STOCK_ALPHA, sort_chat_users_by_alpha, _("Current sorting by alpha") },
+	{GAYM_STOCK_PIC, sort_chat_users_by_pic, _("Current sorting by pic") }
+};
+
+   
+void change_sort_order(GtkWidget * button, void *data)
+{
+   
+    static int current=0;
+    current=(current+1)%G_N_ELEMENTS(order);
+    GaimGtkConversation *gtkconv = (GaimGtkConversation *) data;
+    GaimGtkChatPane *gtkchat = gtkconv->u.chat;
+    GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
+    
+    GtkBox* buttonbox = GTK_BOX(button->parent);
+    gtk_widget_destroy(button);
+    button = GTK_WIDGET(gaim_gtkconv_button_new(order[current].icon, 
+						NULL,//_("E"), 
+						order[current].tooltip, 
+						gtkconv->tooltips, 
+						change_sort_order, 
+						gtkconv));
+    gtk_box_pack_end(buttonbox, button, FALSE, FALSE, 0);
+    gtk_widget_show(button);
+    gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model),
+                                        CHAT_USERS_NAME_COLUMN,
+                                        order[current].sort_funcion, NULL,
+                                        NULL);
+
+
+
+}
+void add_chat_sort_functions(GaimConversation * c)
+{
+
+    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
+
+    GtkBox *iconbox = (GtkBox *) gtkconv->info->parent;
+    //    GtkWidget *button = gtk_button_new_with_label("E");
+    GtkWidget *button = gaim_gtkconv_button_new(GAYM_STOCK_ENTRY, 
+						NULL,//_("E"), 
+						_("Currently sorting by entry"), 
+						gtkconv->tooltips, 
+						change_sort_order, 
+						gtkconv);
+    gtk_box_pack_end(iconbox, button, FALSE, FALSE, 0);
+    gtk_widget_show(button);
+
+
+}

Added: qrc/trunk/gaym-extras/src/gaym-extras.c
===================================================================
--- qrc/trunk/gaym-extras/src/gaym-extras.c	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/src/gaym-extras.c	2005-07-30 21:32:57 UTC (rev 256)
@@ -0,0 +1,141 @@
+/* Show icons in chat room windows */
+
+
+#include "gaym-extras.h"
+// Adds motion handlers to IM tab labels.
+static void redo_im_window(GaimConversation * c)
+{
+    if (!g_strrstr(gaim_account_get_protocol_id(c->account),"prpl-gaym"))
+	    return;
+    if (c && c->type == GAIM_CONV_IM)
+        add_im_popup_stuff(c);
+}
+
+
+static void update_info_cb(GaimAccount * account, char *name)
+{
+    if (!g_strrstr(gaim_account_get_protocol_id(account),"prpl-gaym"))
+	    return;
+    gaim_debug_misc("gaym-extras", "info update\n");
+}
+
+static void redochatwindow(GaimConversation * c)
+{
+    if (!g_strrstr(gaim_account_get_protocol_id(c->account),"prpl-gaym"))
+	    return;
+    add_chat_sort_functions(c);
+    add_chat_popup_stuff(c);
+    add_chat_icon_stuff(c);
+}
+static gchar *
+find_file(const char *dir, const char *base)
+{
+	char *filename;
+
+	if (base == NULL)
+		return NULL;
+
+	if (!strcmp(dir, "gaim"))
+		filename = g_build_filename(GAIM_DATADIR, "pixmaps", "gaim", base, NULL);
+	else
+	{
+		filename = g_build_filename(GAIM_DATADIR, "pixmaps", "gaim", dir,
+									base, NULL);
+	}
+
+	if (!g_file_test(filename, G_FILE_TEST_EXISTS))
+	{
+		g_critical("Unable to load stock pixmap %s\n", filename);
+
+		g_free(filename);
+
+		return NULL;
+	}
+
+	return filename;
+
+}
+void extras_register_stock() {
+    
+    static gboolean stock_is_init=FALSE;
+    GtkIconFactory* icon_factory=NULL;
+    int i;
+    if(stock_is_init)
+	return;
+    stock_is_init=TRUE;
+    icon_factory=gtk_icon_factory_new();
+
+    gtk_icon_factory_add_default(icon_factory);
+
+    for (i=0 ; i < G_N_ELEMENTS(stock_icons); i++)
+    {
+	GdkPixbuf *pixbuf;
+	GtkIconSet *iconset;
+	gchar *filename;
+	filename = find_file(stock_icons[i].dir, stock_icons[i].filename);
+	if (filename==NULL)
+	    continue;
+
+	pixbuf = gdk_pixbuf_new_from_file(filename, NULL);
+	g_free(filename);
+	iconset = gtk_icon_set_new_from_pixbuf(pixbuf);
+	
+	g_object_unref(pixbuf);
+	gtk_icon_factory_add(icon_factory, stock_icons[i].name, iconset);
+	gtk_icon_set_unref(iconset);
+    }
+	
+	
+}
+static gboolean plugin_load(GaimPlugin * plugin)
+{
+    init_chat_icons();
+    init_popups();
+
+    gaim_signal_connect(gaim_conversations_get_handle(), "chat-joined",
+                        plugin, GAIM_CALLBACK(redochatwindow), NULL);
+
+    gaim_signal_connect(gaim_conversations_get_handle(),
+                        "conversation-created", plugin,
+                        GAIM_CALLBACK(redo_im_window), NULL);
+
+    gaim_signal_connect(gaim_accounts_get_handle(), "info-updated", plugin,
+                        GAIM_CALLBACK(update_info_cb), NULL);
+
+    gaim_signal_connect(gaim_conversations_get_handle(),
+                        "deleting-conversation", plugin,
+                        GAIM_CALLBACK(clean_popup_stuff), NULL);
+
+    extras_register_stock();
+    return TRUE;
+}
+
+static GaimPluginInfo info = {
+    GAIM_PLUGIN_MAGIC,
+    GAIM_MAJOR_VERSION,
+    GAIM_MINOR_VERSION,
+    GAIM_PLUGIN_STANDARD,
+    GAIM_GTK_PLUGIN_TYPE,
+    0,
+    NULL,
+    GAIM_PRIORITY_DEFAULT,
+    GAYM_EXTRAS_PLUGIN_ID,
+    N_("Gaym Extras"),
+    VERSION,
+    N_("GUI-related additions for the gaym protocol plugin."),
+    N_("Current functionality provided by this plugin:\n1. Allows namelist sort order in rooms to be changed.\n2. Shows thumbnails for currently selected user in rooms.\n3. Popup displays bio when you hover over a name in the namelist.\n4. Popup shows bio when you hover over an IM tab."),
+    "Jason LeBrun gaym at jasonlebrun.info",
+    GAIM_WEBSITE,
+    plugin_load,
+    NULL,
+    NULL,
+    NULL,
+    NULL,
+    NULL
+};
+
+static void init_plugin(GaimPlugin * plugin)
+{
+}
+
+GAIM_INIT_PLUGIN(history, init_plugin, info)

Added: qrc/trunk/gaym-extras/src/gaym-extras.h
===================================================================
--- qrc/trunk/gaym-extras/src/gaym-extras.h	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/src/gaym-extras.h	2005-07-30 21:32:57 UTC (rev 256)
@@ -0,0 +1,89 @@
+#include "internal.h"
+#include "gtkgaim.h"
+
+#include "conversation.h"
+#include "debug.h"
+#include "prefs.h"
+#include "signals.h"
+#include "util.h"
+#include "version.h"
+#include "buddyicon.h"
+#include "prpl.h"
+
+#include "gtkconv.h"
+#include "gtkplugin.h"
+
+#ifndef GAYM_EXTRAS_H
+#define GAYM_EXTRAS_H
+
+#define GAYM_EXTRAS_PLUGIN_ID "gtk-gaym-extras"
+
+#define GAYM_STOCK_ALPHA "alpha"
+#define GAYM_STOCK_ENTRY "entry"
+#define GAYM_STOCK_PIC "pic"
+
+
+struct fetch_thumbnail_data {
+    const char *who;
+    char *pic_data;
+    gint pic_data_len;
+    gboolean from_file;
+};
+
+struct paint_data {
+    char *tooltiptext;
+    GdkPixbuf* pixbuf;
+};
+
+// Additional UI info for a conversation.
+// We may be able to clean this up, some.
+typedef struct _GaymChatIcon {
+
+    GaimConversation *conv;
+    GtkWidget *icon_container_parent;
+    GtkWidget *icon_container;
+    GtkWidget *frame;
+    GtkWidget *icon;
+    GtkWidget *event;
+    gboolean show_icon;
+
+} GaymChatIcon;
+
+
+typedef enum {
+    TOOLTIP_CHAT,
+    TOOLTIP_IM,
+} GaymTooltipType;
+
+struct timeout_cb_data {
+    GaymTooltipType type;
+    GtkWidget *tv;
+    GaimAccount* account;
+};
+
+
+GdkPixbuf* lookup_cached_thumbnail(GaimAccount* account, const char*fullname);
+void get_icon_scale_size(GdkPixbuf* icon, GaimBuddyIconSpec * spec,int *width, int *height);
+void clean_popup_stuff(GaimConversation * c);
+void add_chat_icon_stuff(GaimConversation *c);
+void add_chat_popup_stuff(GaimConversation *c);
+void add_chat_sort_functions(GaimConversation *c);
+void add_im_popup_stuff(GaimConversation* c);
+void init_chat_icons();
+void init_popups();
+
+
+static struct StockIcon
+{
+	const char *name;
+	const char *dir;
+	const char *filename;
+
+} const stock_icons[] = 
+{
+	    { GAYM_STOCK_ALPHA,	    "gaym",	"alpha.png" },    
+	    { GAYM_STOCK_ENTRY,	    "gaym",	"entry.png" },    
+	    { GAYM_STOCK_PIC,	    "gaym",	"pic.png" }
+};
+
+#endif //GAYM_EXTRAS_H

Added: qrc/trunk/gaym-extras/src/roombrowse.c
===================================================================
--- qrc/trunk/gaym-extras/src/roombrowse.c	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/gaym-extras/src/roombrowse.c	2005-07-30 21:32:57 UTC (rev 256)
@@ -0,0 +1,435 @@
+/* Puts last 4k of log in new conversations a la Everybuddy (and then
+   stolen by Trillian "Pro") */
+
+#include "internal.h"
+#include "gtkgaim.h"
+
+#include "conversation.h"
+#include "debug.h"
+#include "log.h"
+#include "prefs.h"
+#include "signals.h"
+#include "util.h"
+#include "version.h"
+#include "prpl.h"
+
+#include "gtkconv.h"
+#include "gtkimhtml.h"
+#include "gtkplugin.h"
+#include "gtkdialogs.h"
+#include "gtkutils.h"
+#include "gtkblist.h"
+#include "gtkimhtmltoolbar.h"
+#include <gdk/gdkkeysyms.h>
+
+#define CHATSORT_PLUGIN_ID "gtk-chatsort"
+#define CHATSORT_USERS_COLUMNS 4
+#define CHATSORT_USERS_ENTRY_COLUMN 3
+
+/**
+ * Unused variables:
+ *
+ * static GList *browsers = NULL;
+ */
+
+struct RoomBrowseInfo {
+
+    GaimAccount *account;
+    GaimConnection *gc;
+};
+
+static GtkWidget *setup_roombrowse_pane(GaimConversation * conv)
+{
+    GaimGtkConversation *gtkconv;
+    GaimGtkChatPane *gtkchat;
+    GaimConnection *gc;
+    GtkWidget *vpaned, *hpaned;
+    GtkWidget *vbox;
+
+        /**
+	 * Unused variables:
+	 *
+	 * GaimPluginProtocolInfo *prpl_info = NULL;
+	 * GtkWidget *hbox;
+	 * GtkWidget *lbox, *bbox;
+	 * GtkWidget *label;
+	 * GtkWidget *list;
+	 * GtkWidget *button;
+	 * GtkWidget *sw;
+	 * GtkListStore *ls;
+	 * GtkCellRenderer *rend;
+	 * GtkTreeViewColumn *col;
+	 * GList *focus_chain = NULL;
+	 */
+
+    gtkconv = GAIM_GTK_CONVERSATION(conv);
+    gtkchat = gtkconv->u.chat;
+    gc = gaim_conversation_get_gc(conv);
+
+    /* Setup the outer pane. */
+    vpaned = gtk_vpaned_new();
+    gtk_widget_show(vpaned);
+    /* Setup the top part of the pane. */
+    vbox = gtk_vbox_new(FALSE, 6);
+    gtk_paned_pack1(GTK_PANED(vpaned), vbox, TRUE, TRUE);
+    gtk_widget_show(vbox);
+
+    /* Setup the horizontal pane. */
+    hpaned = gtk_hpaned_new();
+    gtk_box_pack_start(GTK_BOX(vbox), hpaned, TRUE, TRUE, 0);
+    gtk_widget_show(hpaned);
+
+    /* Setup the scrolled window to put gtkimhtml in. */
+    gtkconv->sw = gtk_scrolled_window_new(NULL, NULL);
+    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(gtkconv->sw),
+                                   GTK_POLICY_AUTOMATIC,
+                                   GTK_POLICY_ALWAYS);
+    gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(gtkconv->sw),
+                                        GTK_SHADOW_IN);
+    gtk_paned_pack1(GTK_PANED(hpaned), gtkconv->sw, TRUE, TRUE);
+
+    gtk_widget_set_size_request(gtkconv->sw,
+                                gaim_prefs_get_int
+                                ("/gaim/gtk/conversations/chat/default_width"),
+                                gaim_prefs_get_int
+                                ("/gaim/gtk/conversations/chat/default_height"));
+
+    // g_signal_connect(G_OBJECT(gtkconv->sw), "size-allocate",
+    // G_CALLBACK(size_allocate_cb), conv);
+
+    gtk_widget_show(gtkconv->sw);
+
+    return vpaned;
+}
+
+static gint close_conv_cb(GtkWidget * w, gpointer d)
+{
+    GaimConversation *conv = (GaimConversation *) d;
+
+    gaim_conversation_destroy(conv);
+
+    return TRUE;
+}
+
+GdkPixbuf *get_tab_icon(GaimConversation * conv, gboolean small_icon)
+{
+    GaimAccount *account = NULL;
+    const char *name = NULL;
+    GdkPixbuf *status = NULL;
+
+    g_return_val_if_fail(conv != NULL, NULL);
+
+    account = gaim_conversation_get_account(conv);
+    name = gaim_conversation_get_name(conv);
+
+    g_return_val_if_fail(account != NULL, NULL);
+    g_return_val_if_fail(name != NULL, NULL);
+
+
+    if (gaim_conversation_get_type(conv) == GAIM_CONV_IM) {
+        GaimBuddy *b = gaim_find_buddy(account, name);
+        if (b != NULL) {
+            status = gaim_gtk_blist_get_status_icon((GaimBlistNode *) b,
+                                                    (small_icon ?
+                                                     GAIM_STATUS_ICON_SMALL
+                                                     :
+                                                     GAIM_STATUS_ICON_LARGE));
+        }
+    }
+
+    if (!status) {
+        GdkPixbuf *pixbuf;
+        pixbuf = create_prpl_icon(account);
+
+        if (small_icon && pixbuf != NULL) {
+            status = gdk_pixbuf_scale_simple(pixbuf, 15, 15,
+                                             GDK_INTERP_BILINEAR);
+            g_object_unref(pixbuf);
+        } else
+            status = pixbuf;
+    }
+    return status;
+}
+
+/**
+ * Unused function
+ */
+#if 0
+static void update_tab_icon(GaimConversation * conv)
+{
+    GaimGtkConversation *gtkconv;
+    GaimConvWindow *win = gaim_conversation_get_window(conv);
+    GaimAccount *account;
+    const char *name;
+    GdkPixbuf *status = NULL;
+
+    g_return_if_fail(conv != NULL);
+
+    gtkconv = GAIM_GTK_CONVERSATION(conv);
+    name = gaim_conversation_get_name(conv);
+    account = gaim_conversation_get_account(conv);
+
+    status = get_tab_icon(conv, TRUE);
+
+    g_return_if_fail(status != NULL);
+
+    gtk_image_set_from_pixbuf(GTK_IMAGE(gtkconv->icon), status);
+    gtk_image_set_from_pixbuf(GTK_IMAGE(gtkconv->menu_icon), status);
+
+    if (status != NULL)
+        g_object_unref(status);
+
+    if (gaim_conv_window_get_active_conversation(win) == conv &&
+        gtkconv->u.im->anim == NULL) {
+        status = get_tab_icon(conv, FALSE);
+
+        gtk_window_set_icon(GTK_WINDOW(GAIM_GTK_WINDOW(win)->window),
+                            status);
+
+        if (status != NULL)
+            g_object_unref(status);
+    }
+}
+#endif
+
+/* Courtesy of Galeon! */
+static void
+tab_close_button_state_changed_cb(GtkWidget * widget,
+                                  GtkStateType prev_state)
+{
+    if (GTK_WIDGET_STATE(widget) == GTK_STATE_ACTIVE)
+        gtk_widget_set_state(widget, GTK_STATE_NORMAL);
+}
+
+static void
+roombrowse_gtk_add_conversation(GaimConvWindow * win,
+                                GaimConversation * conv)
+{
+    GaimGtkWindow *gtkwin;
+    GaimGtkConversation *gtkconv, *focus_gtkconv;
+    GaimConversation *focus_conv;
+    GtkWidget *pane = NULL;
+    GtkWidget *tab_cont;
+    GtkWidget *tabby, *menu_tabby;
+    GtkWidget *close_image;
+    gboolean new_ui;
+    GaimConversationType conv_type;
+    const char *name;
+
+    name = gaim_conversation_get_name(conv);
+    conv_type = gaim_conversation_get_type(conv);
+    gtkwin = GAIM_GTK_WINDOW(win);
+
+    if (conv->ui_data != NULL) {
+        gtkconv = (GaimGtkConversation *) conv->ui_data;
+
+        tab_cont = gtkconv->tab_cont;
+
+        new_ui = FALSE;
+    } else {
+        gtkconv = g_malloc0(sizeof(GaimGtkConversation));
+        conv->ui_data = gtkconv;
+
+        /* Setup some initial variables. */
+        gtkconv->sg = gtk_size_group_new(GTK_SIZE_GROUP_BOTH);
+        gtkconv->tooltips = gtk_tooltips_new();
+
+        gaim_debug_misc("roombrowse", "setting up pane\n");
+        pane = setup_roombrowse_pane(conv);
+
+        gaim_debug_misc("roombrowse", "set up pane\n");
+
+        if (pane == NULL) {
+            g_free(gtkconv);
+            conv->ui_data = NULL;
+
+            return;
+        }
+
+
+
+        /* Setup the container for the tab. */
+        gtkconv->tab_cont = tab_cont = gtk_vbox_new(FALSE, 6);
+        gtk_container_set_border_width(GTK_CONTAINER(tab_cont), 6);
+        gtk_container_add(GTK_CONTAINER(tab_cont), pane);
+        gtk_widget_show(pane);
+
+        new_ui = TRUE;
+
+        gtkconv->make_sound = FALSE;
+        gtkconv->show_formatting_toolbar = FALSE;
+        gtkconv->show_timestamps = FALSE;
+
+        g_signal_connect_swapped(G_OBJECT(pane), "focus",
+                                 G_CALLBACK(gtk_widget_grab_focus),
+                                 gtkconv->entry);
+    }
+
+    gaim_debug_misc("roombrowse", "Setting up tabs\n");
+    gtkconv->tabby = tabby = gtk_hbox_new(FALSE, 6);
+    gtkconv->menu_tabby = menu_tabby = gtk_hbox_new(FALSE, 6);
+    gtkconv->entry = gtk_imhtml_new(NULL, NULL);
+    gtkconv->toolbar = gtk_imhtmltoolbar_new();
+
+    gaim_debug_misc("roombrowse", "Setting up close button\n");
+    /* Close button. */
+    gtkconv->close = gtk_button_new();
+    gtk_widget_set_size_request(GTK_WIDGET(gtkconv->close), 16, 16);
+    gtk_button_set_relief(GTK_BUTTON(gtkconv->close), GTK_RELIEF_NONE);
+    close_image =
+        gtk_image_new_from_stock(GTK_STOCK_CLOSE, GTK_ICON_SIZE_MENU);
+    gtk_widget_show(close_image);
+    gtk_container_add(GTK_CONTAINER(gtkconv->close), close_image);
+    gtk_tooltips_set_tip(gtkconv->tooltips, gtkconv->close,
+                         _("Close conversation"), NULL);
+
+    g_signal_connect(G_OBJECT(gtkconv->close), "clicked",
+                     G_CALLBACK(close_conv_cb), conv);
+
+    /* 
+     * I love Galeon. They have a fix for that stupid annoying visible
+     * border bug. I love you guys! -- ChipX86
+     */
+    g_signal_connect(G_OBJECT(gtkconv->close), "state_changed",
+                     G_CALLBACK(tab_close_button_state_changed_cb), NULL);
+
+    /* Status icon. */
+    gtkconv->icon = gtk_image_new();
+    gtkconv->menu_icon = gtk_image_new();
+    // update_tab_icon(conv);
+
+    /* Tab label. */
+    gtkconv->tab_label = gtk_label_new(gaim_conversation_get_title(conv));
+    gtkconv->menu_label = gtk_label_new(gaim_conversation_get_title(conv));
+#if 0
+    gtk_misc_set_alignment(GTK_MISC(gtkconv->tab_label), 0.00, 0.5);
+    gtk_misc_set_padding(GTK_MISC(gtkconv->tab_label), 4, 0);
+#endif
+
+    gaim_debug_misc("roombrowse", "Packing\n");
+    /* Pack it all together. */
+    gtk_box_pack_start(GTK_BOX(tabby), gtkconv->icon, FALSE, FALSE, 0);
+    gtk_box_pack_start(GTK_BOX(menu_tabby), gtkconv->menu_icon,
+                       FALSE, FALSE, 0);
+
+    gtk_widget_show_all(gtkconv->icon);
+    gtk_widget_show_all(gtkconv->menu_icon);
+
+    gtk_box_pack_start(GTK_BOX(tabby), gtkconv->tab_label, TRUE, TRUE, 0);
+    gtk_box_pack_start(GTK_BOX(menu_tabby), gtkconv->menu_label, TRUE,
+                       TRUE, 0);
+    gtk_widget_show(gtkconv->tab_label);
+    gtk_widget_show(gtkconv->menu_label);
+    gtk_misc_set_alignment(GTK_MISC(gtkconv->menu_label), 0, 0);
+
+    gtk_box_pack_start(GTK_BOX(tabby), gtkconv->close, FALSE, FALSE, 0);
+    if (gaim_prefs_get_bool("/gaim/gtk/conversations/close_on_tabs"))
+        gtk_widget_show(gtkconv->close);
+
+    gtk_widget_show(tabby);
+    gtk_widget_show(menu_tabby);
+
+    if (gaim_conversation_get_type(conv) == GAIM_CONV_IM)
+        gaim_gtkconv_update_buddy_icon(conv);
+
+    gaim_debug_misc("roombrowse", "Adding to notebook\n");
+    gaim_debug_misc("roombrowse", "gtkwin->notebook=%x\n",
+                    gtkwin->notebook);
+    gaim_debug_misc("roombrowse", "gtkwin=%x\n", gtkwin);
+    gaim_debug_misc("roombrowse", "tabby=%x\n", tabby);
+    gaim_debug_misc("roombrowse", "menu_tabby=%x\n", menu_tabby);
+    gaim_debug_misc("roombrowse", "tab_cont=%x\n", tab_cont);
+
+    /* Add this pane to the conversation's notebook. */
+    int n = gtk_notebook_get_n_pages(GTK_NOTEBOOK(gtkwin->notebook));
+    gaim_debug_misc("roombrowse:", "Notebook has %d pages\n", n);
+    gtk_notebook_append_page_menu(GTK_NOTEBOOK(gtkwin->notebook), tab_cont,
+                                  tabby, menu_tabby);
+    gaim_debug_misc("roombrowse", "Got through append_page_menu\n");
+    gtk_widget_show(tab_cont);
+
+    if (gaim_conv_window_get_conversation_count(win) == 1) {
+        /* Er, bug in notebooks? Switch to the page manually. */
+        gtk_notebook_set_current_page(GTK_NOTEBOOK(gtkwin->notebook), 0);
+
+        gtk_notebook_set_show_tabs(GTK_NOTEBOOK(gtkwin->notebook),
+                                   gaim_prefs_get_bool
+                                   ("/gaim/gtk/conversations/tabs"));
+    } else
+        gtk_notebook_set_show_tabs(GTK_NOTEBOOK(gtkwin->notebook), TRUE);
+    gaim_debug_misc("roombrowse", "FOcus stuff\n");
+    focus_conv = g_list_nth_data(gaim_conv_window_get_conversations(win),
+                                 gtk_notebook_get_current_page(GTK_NOTEBOOK
+                                                               (gtkwin->
+                                                                notebook)));
+    focus_gtkconv = GAIM_GTK_CONVERSATION(focus_conv);
+    gtk_widget_grab_focus(focus_gtkconv->entry);
+
+    if (!new_ui)
+        g_object_unref(gtkconv->tab_cont);
+}
+
+
+static void roombrowse_menu_cb(GaimBlistNode * node, gpointer data)
+{
+    GaimConvWindow *win = gaim_get_first_window_with_type(GAIM_CONV_MISC);
+    GaimConversation *conv = g_new0(GaimConversation, 1);
+
+    GaimAccount *account = ((GaimChat *) node)->account;
+    if (!win)
+        win = gaim_conv_window_new();
+    GaimChat *chat = ((GaimChat *) node);
+    char *room = g_strdup(g_hash_table_lookup(chat->components, "name"));
+
+
+    gaim_debug_misc("roombrowser", "In cb with node=%x, account=%x\n",
+                    node, account);
+    conv = gaim_conversation_new(GAIM_CONV_MISC, account, room);
+
+    gaim_conversation_set_logging(conv, FALSE);
+
+    roombrowse_gtk_add_conversation(conv->window, conv);
+    gaim_conv_window_show(conv->window);
+
+    g_free(room);
+
+}
+static void roombrowse_menu_create(GaimBlistNode * node, GList ** menu)
+{
+
+    char *label, *room;
+
+    struct gaym_conn *gaym;
+    GaimChat *chat = (GaimChat *) node;
+
+    gaim_debug_misc("roombrowse", "In callback\n");
+    if (node->type != GAIM_BLIST_CHAT_NODE)
+        return;
+
+    gaym = chat->account->gc->proto_data;
+
+    room = g_strdup(g_hash_table_lookup(chat->components, "name"));
+    gaim_debug_misc("roombrowse", "Room name: %s\n", room);
+    if (!room)
+        return;
+
+
+    label = g_strdup_printf("Lurk in %s", room);
+    GaimBlistNodeAction *act = gaim_blist_node_action_new(label,
+                                                          roombrowse_menu_cb,
+                                                          chat->account);
+
+    *menu = g_list_append(*menu, act);
+    // g_free(label);
+}
+static gboolean roombrowse_load(GaimPlugin * plugin)
+{
+    gaim_signal_connect(gaim_blist_get_handle(),
+                        "blist-node-extended-menu",
+                        plugin, GAIM_CALLBACK(roombrowse_menu_create),
+                        NULL);
+
+
+    gaim_debug_misc("roombrowse", "Callback registered!\n");
+    return TRUE;
+}

Modified: qrc/trunk/nsis/installer.nsi
===================================================================
--- qrc/trunk/nsis/installer.nsi	2005-07-30 17:36:47 UTC (rev 255)
+++ qrc/trunk/nsis/installer.nsi	2005-07-30 21:32:57 UTC (rev 256)
@@ -9,9 +9,12 @@
 !define QRC_UNINST_EXE     "gaim-qrc-uninst.exe"
 !define GAYM_DLL           "libgaym.dll"
 !define BOT_CHALLENGER_DLL "libbot-challenger.dll"
+!define GAYM_EXTRAS_DLL	   "libgaym-extras.dll"
 !define GAYM_PNG           "gaym.png"
 !define QRC_UNINSTALL_LNK  "Gaim-QRC Uninstall.lnk"
-
+!define	ALPHA_PNG	   "alpha.png"
+!define	ENTRY_PNG	   "entry.png"
+!define	PIC_PNG		    "pic.png"
 !include "MUI.nsh"
 
 ;Do A CRC Check
@@ -30,7 +33,7 @@
 ; Gaim Plugin installer helper stuff
 
 !addincludedir "${GAIM_TOP}\src\win32\nsis"
-!include "gaim-plugin.nsh"
+!include "${GAIM_TOP}\src\win32\nsis\gaim-plugin.nsh"
 
 ; Modern UI Configuration
 !define MUI_HEADERIMAGE
@@ -130,7 +133,11 @@
               ; plugin DLL
               Delete "$R1\plugins\${GAYM_DLL}"
               Delete "$R1\plugins\${BOT_CHALLENGER_DLL}"
+              Delete "$R1\plugins\${GAYM_EXTRAS_DLL}"
               ; pixmaps
+	      Delete "$R1\pixmaps\${ALPHA_PNG}"
+	      Delete "$R1\pixmaps\${ENTRY_PNG}"
+	      Delete "$R1\pixmaps\${PIC_PNG}"
               Delete "$R1\pixmaps\gaim\status\default\${GAYM_PNG}"
               Delete "$R3"
 
@@ -175,11 +182,16 @@
     SetCompress Auto
     SetOverwrite on
     File "..\gaym\src\.libs\${GAYM_DLL}"
+    File "..\gaym-extras\.libs\${GAYM_EXTRAS_DLL}"
     File "..\bot-challenger\.libs\${BOT_CHALLENGER_DLL}"
     
     SetOutPath "$INSTDIR\pixmaps\gaim\status\default"
     File "..\gaym\pixmaps\${GAYM_PNG}"
-    
+    	
+    SetOutPath "$INSTDIR\pixmaps"
+    File "..\gaym-extras\pixmaps\${ALPHA_PNG}"
+    File "..\gaym-extras\pixmaps\${ENTRY_PNG}"
+    File "..\gaym-extras\pixmaps\${PIC_PNG}"
     StrCmp $R0 "NONE" done
     CreateShortCut "$SMPROGRAMS\Gaim\${QRC_UNINSTALL_LNK}" "$INSTDIR\${QRC_UNINST_EXE}"
     WriteUninstaller "$INSTDIR\${QRC_UNINST_EXE}"
@@ -188,7 +200,11 @@
   done:
 SectionEnd
 
-Section Uninstall
+Sec
+   makensis -DQRC_VERSION="0.33.0+svn" -DGAIM_VERSION="1.3.0" \
+   -DGAIM_TOP="/some/path/to/gaim-win32-dev-1.3.0-1/gaim-1.3.0" \
+   nsis/installer.nsi
+tion Uninstall
   Call un.CheckUserInstallRights
   Pop $R0
   StrCmp $R0 "NONE" no_rights
@@ -217,6 +233,9 @@
     Delete "$INSTDIR\plugins\${BOT_CHALLENGER_DLL}"
     ; pixmaps
     Delete "$INSTDIR\pixmaps\gaim\status\default\${GAYM_PNG}"
+    Delete "$INSTDIR\pixmaps\${ALPHA_PNG}"
+    Delete "$INSTDIR\pixmaps\${ENTRY_PNG}"
+    Delete "$INSTDIR\pixmaps\${PIC_PNG}"
     ; uninstaller
     Delete "$INSTDIR\${QRC_UNINST_EXE}"
     ; uninstaller shortcut



From jblebrun at berlios.de  Sat Jul 30 23:59:26 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Sat, 30 Jul 2005 23:59:26 +0200
Subject: [Qrc-svn] r257 - in qrc/trunk: gaym/src gaym-extras/pixmaps gaym-extras/src
Message-ID: <200507302159.j6ULxQuu029856@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-30 23:59:25 +0200 (Sat, 30 Jul 2005)
New Revision: 257

Removed:
   qrc/trunk/gaym-extras/pixmaps/Makefile
   qrc/trunk/gaym-extras/pixmaps/Makefile.in
   qrc/trunk/gaym-extras/src/.chatsort.c.swp
   qrc/trunk/gaym-extras/src/.deps/
   qrc/trunk/gaym-extras/src/.libs/
   qrc/trunk/gaym-extras/src/Makefile
   qrc/trunk/gaym-extras/src/Makefile.in
Modified:
   qrc/trunk/gaym-extras/src/bio-popups.c
   qrc/trunk/gaym/src/gayminfo.c
Log:
Layout fixes, one crash fix, and removal of over-committed files (makefiles and .libs and .deps)


Modified: qrc/trunk/gaym/src/gayminfo.c
===================================================================
--- qrc/trunk/gaym/src/gayminfo.c	2005-07-30 21:32:57 UTC (rev 256)
+++ qrc/trunk/gaym/src/gayminfo.c	2005-07-30 21:59:25 UTC (rev 257)
@@ -239,7 +239,6 @@
 		data->filename=g_strdup(g_strrstr(thumbnail, "/"));
 		gaim_debug_misc("gayminfo","Found filename: %s\n",data->filename);
 		url = g_strdup_printf("%s%s", hashurl, thumbnail);
-		g_free(thumbnail);
 		gaim_url_fetch(url, FALSE, "Mozilla/4.0", FALSE,
 			       gaym_fetch_thumbnail_cb, data);
 		g_free(url);

Deleted: qrc/trunk/gaym-extras/pixmaps/Makefile
===================================================================
--- qrc/trunk/gaym-extras/pixmaps/Makefile	2005-07-30 21:32:57 UTC (rev 256)
+++ qrc/trunk/gaym-extras/pixmaps/Makefile	2005-07-30 21:59:25 UTC (rev 257)
@@ -1,380 +0,0 @@
-# Makefile.in generated by automake 1.9.6 from Makefile.am.
-# gaym-extras/pixmaps/Makefile.  Generated from Makefile.in by configure.
-
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005  Free Software Foundation, Inc.
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-
-
-srcdir = .
-top_srcdir = ../..
-
-pkgdatadir = $(datadir)/qrc
-pkglibdir = $(libdir)/qrc
-pkgincludedir = $(includedir)/qrc
-top_builddir = ../..
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-INSTALL = /bin/install -c
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = i686-pc-linux-gnu
-host_triplet = i686-pc-linux-gnu
-target_triplet = i686-pc-linux-gnu
-subdir = gaym-extras/pixmaps
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-SOURCES =
-DIST_SOURCES =
-am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
-am__vpath_adj = case $$p in \
-    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
-    *) f=$$p;; \
-  esac;
-am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
-am__installdirs = "$(DESTDIR)$(gaymsortpixdir)"
-gaymsortpixDATA_INSTALL = $(INSTALL_DATA)
-DATA = $(gaymsortpix_DATA)
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-ACLOCAL = ${SHELL} /home/jason/packages/qrc-dev/missing --run aclocal-1.9
-AMDEP_FALSE = #
-AMDEP_TRUE = 
-AMTAR = ${SHELL} /home/jason/packages/qrc-dev/missing --run tar
-AR = ar
-AS = as
-AUTOCONF = ${SHELL} /home/jason/packages/qrc-dev/missing --run autoconf
-AUTOHEADER = ${SHELL} /home/jason/packages/qrc-dev/missing --run autoheader
-AUTOMAKE = ${SHELL} /home/jason/packages/qrc-dev/missing --run automake-1.9
-AWK = gawk
-CC = gcc
-CCDEPMODE = depmode=gcc3
-CFLAGS = -g -O2 -Wall -g3
-COND_BOT_CHALLENGER_FALSE = #
-COND_BOT_CHALLENGER_TRUE = 
-COND_GAYM_EXTRAS_FALSE = #
-COND_GAYM_EXTRAS_TRUE = 
-COND_GAYM_FALSE = #
-COND_GAYM_TRUE = 
-CPP = gcc -E
-CPPFLAGS = 
-CXX = g++
-CXXCPP = g++ -E
-CXXDEPMODE = depmode=gcc3
-CXXFLAGS = -g -O2
-CYGPATH_W = echo
-DEFS = -DHAVE_CONFIG_H
-DEPDIR = .deps
-DLLTOOL = dlltool
-ECHO = echo
-ECHO_C = 
-ECHO_N = -n
-ECHO_T = 
-EGREP = grep -E
-EXEEXT = 
-F77 = g77
-FFLAGS = -g -O2
-GAIM_CFLAGS = -I/usr/local/include/gaim -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include  
-GAIM_DATADIR = /usr/local/share
-GAIM_LIBDIR = /usr/local/lib
-GAIM_LIBS = -lglib-2.0  
-GTK_CFLAGS = -DXTHREADS -D_REENTRANT -DXUSE_MTSAFE_API -I/usr/include/gtk-2.0 -I/usr/lib/gtk-2.0/include -I/usr/include/atk-1.0 -I/usr/include/pango-1.0 -I/usr/include/freetype2 -I/usr/include/freetype2/config -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include  
-GTK_LIBS = -lgtk-x11-2.0 -lgdk-x11-2.0 -latk-1.0 -lgdk_pixbuf-2.0 -lm -lpangoxft-1.0 -lpangox-1.0 -lpango-1.0 -lgobject-2.0 -lgmodule-2.0 -ldl -lglib-2.0  
-INSTALL_DATA = ${INSTALL} -m 644
-INSTALL_PROGRAM = ${INSTALL}
-INSTALL_SCRIPT = ${INSTALL}
-INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
-LDFLAGS = 
-LIBOBJS = 
-LIBS = 
-LIBTOOL = $(SHELL) $(top_builddir)/libtool --silent
-LN_S = ln -s
-LTLIBOBJS = 
-MAKEINFO = ${SHELL} /home/jason/packages/qrc-dev/missing --run makeinfo
-OBJDUMP = objdump
-OBJEXT = o
-PACKAGE = qrc
-PACKAGE_BUGREPORT = gaymplugin at yahoogroups.com
-PACKAGE_NAME = qrc
-PACKAGE_STRING = qrc 0.34.1+svn
-PACKAGE_TARNAME = qrc
-PACKAGE_VERSION = 0.34.1+svn
-PATH_SEPARATOR = :
-PKG_CONFIG = /usr/bin/pkg-config
-RANLIB = ranlib
-REQUIRED_GAIM = gaim >= 1.2 gaim < 2.0
-REQUIRED_GTK = gtk+-2.0
-REQUIRED_PKG_CONFIG = 0.15.0
-SET_MAKE = 
-SHELL = /bin/sh
-STRIP = strip
-VERSION = 0.34.1+svn
-ac_ct_AR = ar
-ac_ct_AS = 
-ac_ct_CC = gcc
-ac_ct_CXX = g++
-ac_ct_DLLTOOL = 
-ac_ct_F77 = g77
-ac_ct_OBJDUMP = 
-ac_ct_RANLIB = ranlib
-ac_ct_STRIP = strip
-ac_pt_PKG_CONFIG = 
-am__fastdepCC_FALSE = #
-am__fastdepCC_TRUE = 
-am__fastdepCXX_FALSE = #
-am__fastdepCXX_TRUE = 
-am__include = include
-am__leading_dot = .
-am__quote = 
-am__tar = ${AMTAR} chof - "$$tardir"
-am__untar = ${AMTAR} xf -
-bindir = ${exec_prefix}/bin
-build = i686-pc-linux-gnu
-build_alias = 
-build_cpu = i686
-build_os = linux-gnu
-build_vendor = pc
-datadir = ${prefix}/share
-exec_prefix = ${prefix}
-host = i686-pc-linux-gnu
-host_alias = 
-host_cpu = i686
-host_os = linux-gnu
-host_vendor = pc
-includedir = ${prefix}/include
-infodir = ${prefix}/info
-install_sh = /home/jason/packages/qrc-dev/install-sh
-libdir = ${exec_prefix}/lib
-libexecdir = ${exec_prefix}/libexec
-localstatedir = ${prefix}/var
-mandir = ${prefix}/man
-mkdir_p = mkdir -p --
-oldincludedir = /usr/include
-prefix = /usr/local
-program_transform_name = s,x,x,
-sbindir = ${exec_prefix}/sbin
-sharedstatedir = ${prefix}/com
-sysconfdir = ${prefix}/etc
-target = i686-pc-linux-gnu
-target_alias = 
-target_cpu = i686
-target_os = linux-gnu
-target_vendor = pc
-EXTRA_DIST = \
-	alpha.png \
-	entry.png \
-	pic.png 
-
-gaymsortpixdir = \
-	$(GAIM_DATADIR)/pixmaps/gaim/gaym
-
-gaymsortpix_DATA = \
-	alpha.png\
-	entry.png\
-	pic.png
-
-all: all-am
-
-.SUFFIXES:
-$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
-		&& exit 0; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  gaym-extras/pixmaps/Makefile'; \
-	cd $(top_srcdir) && \
-	  $(AUTOMAKE) --gnu  gaym-extras/pixmaps/Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure:  $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-
-distclean-libtool:
-	-rm -f libtool
-uninstall-info-am:
-install-gaymsortpixDATA: $(gaymsortpix_DATA)
-	@$(NORMAL_INSTALL)
-	test -z "$(gaymsortpixdir)" || $(mkdir_p) "$(DESTDIR)$(gaymsortpixdir)"
-	@list='$(gaymsortpix_DATA)'; for p in $$list; do \
-	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
-	  f=$(am__strip_dir) \
-	  echo " $(gaymsortpixDATA_INSTALL) '$$d$$p' '$(DESTDIR)$(gaymsortpixdir)/$$f'"; \
-	  $(gaymsortpixDATA_INSTALL) "$$d$$p" "$(DESTDIR)$(gaymsortpixdir)/$$f"; \
-	done
-
-uninstall-gaymsortpixDATA:
-	@$(NORMAL_UNINSTALL)
-	@list='$(gaymsortpix_DATA)'; for p in $$list; do \
-	  f=$(am__strip_dir) \
-	  echo " rm -f '$(DESTDIR)$(gaymsortpixdir)/$$f'"; \
-	  rm -f "$(DESTDIR)$(gaymsortpixdir)/$$f"; \
-	done
-tags: TAGS
-TAGS:
-
-ctags: CTAGS
-CTAGS:
-
-
-distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
-	list='$(DISTFILES)'; for file in $$list; do \
-	  case $$file in \
-	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
-	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
-	  esac; \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
-	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
-	    dir="/$$dir"; \
-	    $(mkdir_p) "$(distdir)$$dir"; \
-	  else \
-	    dir=''; \
-	  fi; \
-	  if test -d $$d/$$file; then \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
-	    fi; \
-	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
-	  else \
-	    test -f $(distdir)/$$file \
-	    || cp -p $$d/$$file $(distdir)/$$file \
-	    || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-check: check-am
-all-am: Makefile $(DATA)
-installdirs:
-	for dir in "$(DESTDIR)$(gaymsortpixdir)"; do \
-	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
-	done
-install: install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-am
-
-clean-am: clean-generic clean-libtool mostlyclean-am
-
-distclean: distclean-am
-	-rm -f Makefile
-distclean-am: clean-am distclean-generic distclean-libtool
-
-dvi: dvi-am
-
-dvi-am:
-
-html: html-am
-
-info: info-am
-
-info-am:
-
-install-data-am: install-gaymsortpixDATA
-
-install-exec-am:
-
-install-info: install-info-am
-
-install-man:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-am
-
-mostlyclean-am: mostlyclean-generic mostlyclean-libtool
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am: uninstall-gaymsortpixDATA uninstall-info-am
-
-.PHONY: all all-am check check-am clean clean-generic clean-libtool \
-	distclean distclean-generic distclean-libtool distdir dvi \
-	dvi-am html html-am info info-am install install-am \
-	install-data install-data-am install-exec install-exec-am \
-	install-gaymsortpixDATA install-info install-info-am \
-	install-man install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \
-	ps ps-am uninstall uninstall-am uninstall-gaymsortpixDATA \
-	uninstall-info-am
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:

Deleted: qrc/trunk/gaym-extras/pixmaps/Makefile.in
===================================================================
--- qrc/trunk/gaym-extras/pixmaps/Makefile.in	2005-07-30 21:32:57 UTC (rev 256)
+++ qrc/trunk/gaym-extras/pixmaps/Makefile.in	2005-07-30 21:59:25 UTC (rev 257)
@@ -1,380 +0,0 @@
-# Makefile.in generated by automake 1.9.6 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005  Free Software Foundation, Inc.
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
- at SET_MAKE@
-
-srcdir = @srcdir@
-top_srcdir = @top_srcdir@
-VPATH = @srcdir@
-pkgdatadir = $(datadir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-top_builddir = ../..
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-INSTALL = @INSTALL@
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-target_triplet = @target@
-subdir = gaym-extras/pixmaps
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-SOURCES =
-DIST_SOURCES =
-am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
-am__vpath_adj = case $$p in \
-    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
-    *) f=$$p;; \
-  esac;
-am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
-am__installdirs = "$(DESTDIR)$(gaymsortpixdir)"
-gaymsortpixDATA_INSTALL = $(INSTALL_DATA)
-DATA = $(gaymsortpix_DATA)
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-ACLOCAL = @ACLOCAL@
-AMDEP_FALSE = @AMDEP_FALSE@
-AMDEP_TRUE = @AMDEP_TRUE@
-AMTAR = @AMTAR@
-AR = @AR@
-AS = @AS@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-CC = @CC@
-CCDEPMODE = @CCDEPMODE@
-CFLAGS = @CFLAGS@
-COND_BOT_CHALLENGER_FALSE = @COND_BOT_CHALLENGER_FALSE@
-COND_BOT_CHALLENGER_TRUE = @COND_BOT_CHALLENGER_TRUE@
-COND_GAYM_EXTRAS_FALSE = @COND_GAYM_EXTRAS_FALSE@
-COND_GAYM_EXTRAS_TRUE = @COND_GAYM_EXTRAS_TRUE@
-COND_GAYM_FALSE = @COND_GAYM_FALSE@
-COND_GAYM_TRUE = @COND_GAYM_TRUE@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CXX = @CXX@
-CXXCPP = @CXXCPP@
-CXXDEPMODE = @CXXDEPMODE@
-CXXFLAGS = @CXXFLAGS@
-CYGPATH_W = @CYGPATH_W@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-DLLTOOL = @DLLTOOL@
-ECHO = @ECHO@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGREP = @EGREP@
-EXEEXT = @EXEEXT@
-F77 = @F77@
-FFLAGS = @FFLAGS@
-GAIM_CFLAGS = @GAIM_CFLAGS@
-GAIM_DATADIR = @GAIM_DATADIR@
-GAIM_LIBDIR = @GAIM_LIBDIR@
-GAIM_LIBS = @GAIM_LIBS@
-GTK_CFLAGS = @GTK_CFLAGS@
-GTK_LIBS = @GTK_LIBS@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-LDFLAGS = @LDFLAGS@
-LIBOBJS = @LIBOBJS@
-LIBS = @LIBS@
-LIBTOOL = @LIBTOOL@
-LN_S = @LN_S@
-LTLIBOBJS = @LTLIBOBJS@
-MAKEINFO = @MAKEINFO@
-OBJDUMP = @OBJDUMP@
-OBJEXT = @OBJEXT@
-PACKAGE = @PACKAGE@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-PKG_CONFIG = @PKG_CONFIG@
-RANLIB = @RANLIB@
-REQUIRED_GAIM = @REQUIRED_GAIM@
-REQUIRED_GTK = @REQUIRED_GTK@
-REQUIRED_PKG_CONFIG = @REQUIRED_PKG_CONFIG@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-STRIP = @STRIP@
-VERSION = @VERSION@
-ac_ct_AR = @ac_ct_AR@
-ac_ct_AS = @ac_ct_AS@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_CXX = @ac_ct_CXX@
-ac_ct_DLLTOOL = @ac_ct_DLLTOOL@
-ac_ct_F77 = @ac_ct_F77@
-ac_ct_OBJDUMP = @ac_ct_OBJDUMP@
-ac_ct_RANLIB = @ac_ct_RANLIB@
-ac_ct_STRIP = @ac_ct_STRIP@
-ac_pt_PKG_CONFIG = @ac_pt_PKG_CONFIG@
-am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
-am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
-am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
-am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-datadir = @datadir@
-exec_prefix = @exec_prefix@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-oldincludedir = @oldincludedir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-sysconfdir = @sysconfdir@
-target = @target@
-target_alias = @target_alias@
-target_cpu = @target_cpu@
-target_os = @target_os@
-target_vendor = @target_vendor@
-EXTRA_DIST = \
-	alpha.png \
-	entry.png \
-	pic.png 
-
-gaymsortpixdir = \
-	$(GAIM_DATADIR)/pixmaps/gaim/gaym
-
-gaymsortpix_DATA = \
-	alpha.png\
-	entry.png\
-	pic.png
-
-all: all-am
-
-.SUFFIXES:
-$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
-		&& exit 0; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  gaym-extras/pixmaps/Makefile'; \
-	cd $(top_srcdir) && \
-	  $(AUTOMAKE) --gnu  gaym-extras/pixmaps/Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure:  $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-
-distclean-libtool:
-	-rm -f libtool
-uninstall-info-am:
-install-gaymsortpixDATA: $(gaymsortpix_DATA)
-	@$(NORMAL_INSTALL)
-	test -z "$(gaymsortpixdir)" || $(mkdir_p) "$(DESTDIR)$(gaymsortpixdir)"
-	@list='$(gaymsortpix_DATA)'; for p in $$list; do \
-	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
-	  f=$(am__strip_dir) \
-	  echo " $(gaymsortpixDATA_INSTALL) '$$d$$p' '$(DESTDIR)$(gaymsortpixdir)/$$f'"; \
-	  $(gaymsortpixDATA_INSTALL) "$$d$$p" "$(DESTDIR)$(gaymsortpixdir)/$$f"; \
-	done
-
-uninstall-gaymsortpixDATA:
-	@$(NORMAL_UNINSTALL)
-	@list='$(gaymsortpix_DATA)'; for p in $$list; do \
-	  f=$(am__strip_dir) \
-	  echo " rm -f '$(DESTDIR)$(gaymsortpixdir)/$$f'"; \
-	  rm -f "$(DESTDIR)$(gaymsortpixdir)/$$f"; \
-	done
-tags: TAGS
-TAGS:
-
-ctags: CTAGS
-CTAGS:
-
-
-distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
-	list='$(DISTFILES)'; for file in $$list; do \
-	  case $$file in \
-	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
-	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
-	  esac; \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
-	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
-	    dir="/$$dir"; \
-	    $(mkdir_p) "$(distdir)$$dir"; \
-	  else \
-	    dir=''; \
-	  fi; \
-	  if test -d $$d/$$file; then \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
-	    fi; \
-	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
-	  else \
-	    test -f $(distdir)/$$file \
-	    || cp -p $$d/$$file $(distdir)/$$file \
-	    || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-check: check-am
-all-am: Makefile $(DATA)
-installdirs:
-	for dir in "$(DESTDIR)$(gaymsortpixdir)"; do \
-	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
-	done
-install: install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-am
-
-clean-am: clean-generic clean-libtool mostlyclean-am
-
-distclean: distclean-am
-	-rm -f Makefile
-distclean-am: clean-am distclean-generic distclean-libtool
-
-dvi: dvi-am
-
-dvi-am:
-
-html: html-am
-
-info: info-am
-
-info-am:
-
-install-data-am: install-gaymsortpixDATA
-
-install-exec-am:
-
-install-info: install-info-am
-
-install-man:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-am
-
-mostlyclean-am: mostlyclean-generic mostlyclean-libtool
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am: uninstall-gaymsortpixDATA uninstall-info-am
-
-.PHONY: all all-am check check-am clean clean-generic clean-libtool \
-	distclean distclean-generic distclean-libtool distdir dvi \
-	dvi-am html html-am info info-am install install-am \
-	install-data install-data-am install-exec install-exec-am \
-	install-gaymsortpixDATA install-info install-info-am \
-	install-man install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-generic mostlyclean-libtool pdf pdf-am \
-	ps ps-am uninstall uninstall-am uninstall-gaymsortpixDATA \
-	uninstall-info-am
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:

Deleted: qrc/trunk/gaym-extras/src/.chatsort.c.swp
===================================================================
(Binary files differ)

Deleted: qrc/trunk/gaym-extras/src/Makefile
===================================================================
--- qrc/trunk/gaym-extras/src/Makefile	2005-07-30 21:32:57 UTC (rev 256)
+++ qrc/trunk/gaym-extras/src/Makefile	2005-07-30 21:59:25 UTC (rev 257)
@@ -1,505 +0,0 @@
-# Makefile.in generated by automake 1.9.6 from Makefile.am.
-# gaym-extras/src/Makefile.  Generated from Makefile.in by configure.
-
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005  Free Software Foundation, Inc.
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
-
-
-srcdir = .
-top_srcdir = ../..
-
-pkgdatadir = $(datadir)/qrc
-pkglibdir = $(libdir)/qrc
-pkgincludedir = $(includedir)/qrc
-top_builddir = ../..
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-INSTALL = /bin/install -c
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = i686-pc-linux-gnu
-host_triplet = i686-pc-linux-gnu
-target_triplet = i686-pc-linux-gnu
-subdir = gaym-extras/src
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
-am__vpath_adj = case $$p in \
-    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
-    *) f=$$p;; \
-  esac;
-am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
-am__installdirs = "$(DESTDIR)$(pkgdir)"
-pkgLTLIBRARIES_INSTALL = $(INSTALL)
-LTLIBRARIES = $(pkg_LTLIBRARIES)
-libgaym_extras_la_LIBADD =
-am__objects_1 = gaym-extras.lo chatsort.lo bio-popups.lo chaticon.lo
-am_libgaym_extras_la_OBJECTS = $(am__objects_1)
-libgaym_extras_la_OBJECTS = $(am_libgaym_extras_la_OBJECTS)
-DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
-depcomp = $(SHELL) $(top_srcdir)/depcomp
-am__depfiles_maybe = depfiles
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-LTCOMPILE = $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) \
-	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
-	$(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(LIBTOOL) --tag=CC --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(AM_LDFLAGS) $(LDFLAGS) -o $@
-SOURCES = $(libgaym_extras_la_SOURCES)
-DIST_SOURCES = $(libgaym_extras_la_SOURCES)
-ETAGS = etags
-CTAGS = ctags
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-ACLOCAL = ${SHELL} /home/jason/packages/qrc-dev/missing --run aclocal-1.9
-AMDEP_FALSE = #
-AMDEP_TRUE = 
-AMTAR = ${SHELL} /home/jason/packages/qrc-dev/missing --run tar
-AR = ar
-AS = as
-AUTOCONF = ${SHELL} /home/jason/packages/qrc-dev/missing --run autoconf
-AUTOHEADER = ${SHELL} /home/jason/packages/qrc-dev/missing --run autoheader
-AUTOMAKE = ${SHELL} /home/jason/packages/qrc-dev/missing --run automake-1.9
-AWK = gawk
-CC = gcc
-CCDEPMODE = depmode=gcc3
-CFLAGS = -g -O2 -Wall -g3
-COND_BOT_CHALLENGER_FALSE = #
-COND_BOT_CHALLENGER_TRUE = 
-COND_GAYM_EXTRAS_FALSE = #
-COND_GAYM_EXTRAS_TRUE = 
-COND_GAYM_FALSE = #
-COND_GAYM_TRUE = 
-CPP = gcc -E
-CPPFLAGS = 
-CXX = g++
-CXXCPP = g++ -E
-CXXDEPMODE = depmode=gcc3
-CXXFLAGS = -g -O2
-CYGPATH_W = echo
-DEFS = -DHAVE_CONFIG_H
-DEPDIR = .deps
-DLLTOOL = dlltool
-ECHO = echo
-ECHO_C = 
-ECHO_N = -n
-ECHO_T = 
-EGREP = grep -E
-EXEEXT = 
-F77 = g77
-FFLAGS = -g -O2
-GAIM_CFLAGS = -I/usr/local/include/gaim -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include  
-GAIM_DATADIR = /usr/local/share
-GAIM_LIBDIR = /usr/local/lib
-GAIM_LIBS = -lglib-2.0  
-GTK_CFLAGS = -DXTHREADS -D_REENTRANT -DXUSE_MTSAFE_API -I/usr/include/gtk-2.0 -I/usr/lib/gtk-2.0/include -I/usr/include/atk-1.0 -I/usr/include/pango-1.0 -I/usr/include/freetype2 -I/usr/include/freetype2/config -I/usr/include/glib-2.0 -I/usr/lib/glib-2.0/include  
-GTK_LIBS = -lgtk-x11-2.0 -lgdk-x11-2.0 -latk-1.0 -lgdk_pixbuf-2.0 -lm -lpangoxft-1.0 -lpangox-1.0 -lpango-1.0 -lgobject-2.0 -lgmodule-2.0 -ldl -lglib-2.0  
-INSTALL_DATA = ${INSTALL} -m 644
-INSTALL_PROGRAM = ${INSTALL}
-INSTALL_SCRIPT = ${INSTALL}
-INSTALL_STRIP_PROGRAM = ${SHELL} $(install_sh) -c -s
-LDFLAGS = 
-LIBOBJS = 
-LIBS = 
-LIBTOOL = $(SHELL) $(top_builddir)/libtool --silent
-LN_S = ln -s
-LTLIBOBJS = 
-MAKEINFO = ${SHELL} /home/jason/packages/qrc-dev/missing --run makeinfo
-OBJDUMP = objdump
-OBJEXT = o
-PACKAGE = qrc
-PACKAGE_BUGREPORT = gaymplugin at yahoogroups.com
-PACKAGE_NAME = qrc
-PACKAGE_STRING = qrc 0.34.1+svn
-PACKAGE_TARNAME = qrc
-PACKAGE_VERSION = 0.34.1+svn
-PATH_SEPARATOR = :
-PKG_CONFIG = /usr/bin/pkg-config
-RANLIB = ranlib
-REQUIRED_GAIM = gaim >= 1.2 gaim < 2.0
-REQUIRED_GTK = gtk+-2.0
-REQUIRED_PKG_CONFIG = 0.15.0
-SET_MAKE = 
-SHELL = /bin/sh
-STRIP = strip
-VERSION = 0.34.1+svn
-ac_ct_AR = ar
-ac_ct_AS = 
-ac_ct_CC = gcc
-ac_ct_CXX = g++
-ac_ct_DLLTOOL = 
-ac_ct_F77 = g77
-ac_ct_OBJDUMP = 
-ac_ct_RANLIB = ranlib
-ac_ct_STRIP = strip
-ac_pt_PKG_CONFIG = 
-am__fastdepCC_FALSE = #
-am__fastdepCC_TRUE = 
-am__fastdepCXX_FALSE = #
-am__fastdepCXX_TRUE = 
-am__include = include
-am__leading_dot = .
-am__quote = 
-am__tar = ${AMTAR} chof - "$$tardir"
-am__untar = ${AMTAR} xf -
-bindir = ${exec_prefix}/bin
-build = i686-pc-linux-gnu
-build_alias = 
-build_cpu = i686
-build_os = linux-gnu
-build_vendor = pc
-datadir = ${prefix}/share
-exec_prefix = ${prefix}
-host = i686-pc-linux-gnu
-host_alias = 
-host_cpu = i686
-host_os = linux-gnu
-host_vendor = pc
-includedir = ${prefix}/include
-infodir = ${prefix}/info
-install_sh = /home/jason/packages/qrc-dev/install-sh
-libdir = ${exec_prefix}/lib
-libexecdir = ${exec_prefix}/libexec
-localstatedir = ${prefix}/var
-mandir = ${prefix}/man
-mkdir_p = mkdir -p --
-oldincludedir = /usr/include
-prefix = /usr/local
-program_transform_name = s,x,x,
-sbindir = ${exec_prefix}/sbin
-sharedstatedir = ${prefix}/com
-sysconfdir = ${prefix}/etc
-target = i686-pc-linux-gnu
-target_alias = 
-target_cpu = i686
-target_os = linux-gnu
-target_vendor = pc
-pkgdir = \
-	$(GAIM_LIBDIR)/gaim
-
-GAYMSOURCES = \
-	gaym-extras.c chatsort.c bio-popups.c chaticon.c gaym-extras.h
-
-AM_CFLAGS = \
-	$(st)
-
-libgaym_extras_la_LDFLAGS = \
-	-module \
-	-avoid-version \
-	$(GTK_LIBS) \
-	$(GAIM_LIBS)
-
-pkg_LTLIBRARIES = \
-	libgaym-extras.la
-
-libgaym_extras_la_SOURCES = \
-	$(GAYMSOURCES)
-
-AM_CPPFLAGS = \
-	$(DEBUG_CFLAGS) \
-	$(GTK_CFLAGS) \
-	-DGAIM_DATADIR=\"$(datadir)\" \
-	$(GAIM_CFLAGS)
-
-all: all-am
-
-.SUFFIXES:
-.SUFFIXES: .c .lo .o .obj
-$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
-		&& exit 0; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  gaym-extras/src/Makefile'; \
-	cd $(top_srcdir) && \
-	  $(AUTOMAKE) --gnu  gaym-extras/src/Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure:  $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-install-pkgLTLIBRARIES: $(pkg_LTLIBRARIES)
-	@$(NORMAL_INSTALL)
-	test -z "$(pkgdir)" || $(mkdir_p) "$(DESTDIR)$(pkgdir)"
-	@list='$(pkg_LTLIBRARIES)'; for p in $$list; do \
-	  if test -f $$p; then \
-	    f=$(am__strip_dir) \
-	    echo " $(LIBTOOL) --mode=install $(pkgLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) '$$p' '$(DESTDIR)$(pkgdir)/$$f'"; \
-	    $(LIBTOOL) --mode=install $(pkgLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) "$$p" "$(DESTDIR)$(pkgdir)/$$f"; \
-	  else :; fi; \
-	done
-
-uninstall-pkgLTLIBRARIES:
-	@$(NORMAL_UNINSTALL)
-	@set -x; list='$(pkg_LTLIBRARIES)'; for p in $$list; do \
-	  p=$(am__strip_dir) \
-	  echo " $(LIBTOOL) --mode=uninstall rm -f '$(DESTDIR)$(pkgdir)/$$p'"; \
-	  $(LIBTOOL) --mode=uninstall rm -f "$(DESTDIR)$(pkgdir)/$$p"; \
-	done
-
-clean-pkgLTLIBRARIES:
-	-test -z "$(pkg_LTLIBRARIES)" || rm -f $(pkg_LTLIBRARIES)
-	@list='$(pkg_LTLIBRARIES)'; for p in $$list; do \
-	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
-	  test "$$dir" != "$$p" || dir=.; \
-	  echo "rm -f \"$${dir}/so_locations\""; \
-	  rm -f "$${dir}/so_locations"; \
-	done
-libgaym-extras.la: $(libgaym_extras_la_OBJECTS) $(libgaym_extras_la_DEPENDENCIES) 
-	$(LINK) -rpath $(pkgdir) $(libgaym_extras_la_LDFLAGS) $(libgaym_extras_la_OBJECTS) $(libgaym_extras_la_LIBADD) $(LIBS)
-
-mostlyclean-compile:
-	-rm -f *.$(OBJEXT)
-
-distclean-compile:
-	-rm -f *.tab.c
-
-include ./$(DEPDIR)/bio-popups.Plo
-include ./$(DEPDIR)/chaticon.Plo
-include ./$(DEPDIR)/chatsort.Plo
-include ./$(DEPDIR)/gaym-extras.Plo
-
-.c.o:
-	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
-	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
-#	source='$<' object='$@' libtool=no \
-#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
-#	$(COMPILE) -c $<
-
-.c.obj:
-	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
-	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
-#	source='$<' object='$@' libtool=no \
-#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
-#	$(COMPILE) -c `$(CYGPATH_W) '$<'`
-
-.c.lo:
-	if $(LTCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
-	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Plo"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
-#	source='$<' object='$@' libtool=yes \
-#	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) \
-#	$(LTCOMPILE) -c -o $@ $<
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-
-distclean-libtool:
-	-rm -f libtool
-uninstall-info-am:
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	mkid -fID $$unique
-tags: TAGS
-
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	tags=; \
-	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
-	  test -n "$$unique" || unique=$$empty_fix; \
-	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	    $$tags $$unique; \
-	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	tags=; \
-	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	test -z "$(CTAGS_ARGS)$$tags$$unique" \
-	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
-	     $$tags $$unique
-
-GTAGS:
-	here=`$(am__cd) $(top_builddir) && pwd` \
-	  && cd $(top_srcdir) \
-	  && gtags -i $(GTAGS_ARGS) $$here
-
-distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-
-distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
-	list='$(DISTFILES)'; for file in $$list; do \
-	  case $$file in \
-	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
-	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
-	  esac; \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
-	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
-	    dir="/$$dir"; \
-	    $(mkdir_p) "$(distdir)$$dir"; \
-	  else \
-	    dir=''; \
-	  fi; \
-	  if test -d $$d/$$file; then \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
-	    fi; \
-	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
-	  else \
-	    test -f $(distdir)/$$file \
-	    || cp -p $$d/$$file $(distdir)/$$file \
-	    || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-check: check-am
-all-am: Makefile $(LTLIBRARIES)
-installdirs:
-	for dir in "$(DESTDIR)$(pkgdir)"; do \
-	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
-	done
-install: install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-am
-
-clean-am: clean-generic clean-libtool clean-pkgLTLIBRARIES \
-	mostlyclean-am
-
-distclean: distclean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-libtool distclean-tags
-
-dvi: dvi-am
-
-dvi-am:
-
-html: html-am
-
-info: info-am
-
-info-am:
-
-install-data-am: install-pkgLTLIBRARIES
-
-install-exec-am:
-
-install-info: install-info-am
-
-install-man:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-am
-
-mostlyclean-am: mostlyclean-compile mostlyclean-generic \
-	mostlyclean-libtool
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am: uninstall-info-am uninstall-pkgLTLIBRARIES
-
-.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
-	clean-libtool clean-pkgLTLIBRARIES ctags distclean \
-	distclean-compile distclean-generic distclean-libtool \
-	distclean-tags distdir dvi dvi-am html html-am info info-am \
-	install install-am install-data install-data-am install-exec \
-	install-exec-am install-info install-info-am install-man \
-	install-pkgLTLIBRARIES install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am uninstall-info-am \
-	uninstall-pkgLTLIBRARIES
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:

Deleted: qrc/trunk/gaym-extras/src/Makefile.in
===================================================================
--- qrc/trunk/gaym-extras/src/Makefile.in	2005-07-30 21:32:57 UTC (rev 256)
+++ qrc/trunk/gaym-extras/src/Makefile.in	2005-07-30 21:59:25 UTC (rev 257)
@@ -1,505 +0,0 @@
-# Makefile.in generated by automake 1.9.6 from Makefile.am.
-# @configure_input@
-
-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005  Free Software Foundation, Inc.
-# This Makefile.in is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
-# PARTICULAR PURPOSE.
-
- at SET_MAKE@
-
-srcdir = @srcdir@
-top_srcdir = @top_srcdir@
-VPATH = @srcdir@
-pkgdatadir = $(datadir)/@PACKAGE@
-pkglibdir = $(libdir)/@PACKAGE@
-pkgincludedir = $(includedir)/@PACKAGE@
-top_builddir = ../..
-am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-INSTALL = @INSTALL@
-install_sh_DATA = $(install_sh) -c -m 644
-install_sh_PROGRAM = $(install_sh) -c
-install_sh_SCRIPT = $(install_sh) -c
-INSTALL_HEADER = $(INSTALL_DATA)
-transform = $(program_transform_name)
-NORMAL_INSTALL = :
-PRE_INSTALL = :
-POST_INSTALL = :
-NORMAL_UNINSTALL = :
-PRE_UNINSTALL = :
-POST_UNINSTALL = :
-build_triplet = @build@
-host_triplet = @host@
-target_triplet = @target@
-subdir = gaym-extras/src
-DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
-am__aclocal_m4_deps = $(top_srcdir)/configure.ac
-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
-	$(ACLOCAL_M4)
-mkinstalldirs = $(install_sh) -d
-CONFIG_HEADER = $(top_builddir)/config.h
-CONFIG_CLEAN_FILES =
-am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
-am__vpath_adj = case $$p in \
-    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
-    *) f=$$p;; \
-  esac;
-am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
-am__installdirs = "$(DESTDIR)$(pkgdir)"
-pkgLTLIBRARIES_INSTALL = $(INSTALL)
-LTLIBRARIES = $(pkg_LTLIBRARIES)
-libgaym_extras_la_LIBADD =
-am__objects_1 = gaym-extras.lo chatsort.lo bio-popups.lo chaticon.lo
-am_libgaym_extras_la_OBJECTS = $(am__objects_1)
-libgaym_extras_la_OBJECTS = $(am_libgaym_extras_la_OBJECTS)
-DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
-depcomp = $(SHELL) $(top_srcdir)/depcomp
-am__depfiles_maybe = depfiles
-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
-	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-LTCOMPILE = $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) \
-	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
-	$(AM_CFLAGS) $(CFLAGS)
-CCLD = $(CC)
-LINK = $(LIBTOOL) --tag=CC --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(AM_LDFLAGS) $(LDFLAGS) -o $@
-SOURCES = $(libgaym_extras_la_SOURCES)
-DIST_SOURCES = $(libgaym_extras_la_SOURCES)
-ETAGS = etags
-CTAGS = ctags
-DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
-ACLOCAL = @ACLOCAL@
-AMDEP_FALSE = @AMDEP_FALSE@
-AMDEP_TRUE = @AMDEP_TRUE@
-AMTAR = @AMTAR@
-AR = @AR@
-AS = @AS@
-AUTOCONF = @AUTOCONF@
-AUTOHEADER = @AUTOHEADER@
-AUTOMAKE = @AUTOMAKE@
-AWK = @AWK@
-CC = @CC@
-CCDEPMODE = @CCDEPMODE@
-CFLAGS = @CFLAGS@
-COND_BOT_CHALLENGER_FALSE = @COND_BOT_CHALLENGER_FALSE@
-COND_BOT_CHALLENGER_TRUE = @COND_BOT_CHALLENGER_TRUE@
-COND_GAYM_EXTRAS_FALSE = @COND_GAYM_EXTRAS_FALSE@
-COND_GAYM_EXTRAS_TRUE = @COND_GAYM_EXTRAS_TRUE@
-COND_GAYM_FALSE = @COND_GAYM_FALSE@
-COND_GAYM_TRUE = @COND_GAYM_TRUE@
-CPP = @CPP@
-CPPFLAGS = @CPPFLAGS@
-CXX = @CXX@
-CXXCPP = @CXXCPP@
-CXXDEPMODE = @CXXDEPMODE@
-CXXFLAGS = @CXXFLAGS@
-CYGPATH_W = @CYGPATH_W@
-DEFS = @DEFS@
-DEPDIR = @DEPDIR@
-DLLTOOL = @DLLTOOL@
-ECHO = @ECHO@
-ECHO_C = @ECHO_C@
-ECHO_N = @ECHO_N@
-ECHO_T = @ECHO_T@
-EGREP = @EGREP@
-EXEEXT = @EXEEXT@
-F77 = @F77@
-FFLAGS = @FFLAGS@
-GAIM_CFLAGS = @GAIM_CFLAGS@
-GAIM_DATADIR = @GAIM_DATADIR@
-GAIM_LIBDIR = @GAIM_LIBDIR@
-GAIM_LIBS = @GAIM_LIBS@
-GTK_CFLAGS = @GTK_CFLAGS@
-GTK_LIBS = @GTK_LIBS@
-INSTALL_DATA = @INSTALL_DATA@
-INSTALL_PROGRAM = @INSTALL_PROGRAM@
-INSTALL_SCRIPT = @INSTALL_SCRIPT@
-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
-LDFLAGS = @LDFLAGS@
-LIBOBJS = @LIBOBJS@
-LIBS = @LIBS@
-LIBTOOL = @LIBTOOL@
-LN_S = @LN_S@
-LTLIBOBJS = @LTLIBOBJS@
-MAKEINFO = @MAKEINFO@
-OBJDUMP = @OBJDUMP@
-OBJEXT = @OBJEXT@
-PACKAGE = @PACKAGE@
-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
-PACKAGE_NAME = @PACKAGE_NAME@
-PACKAGE_STRING = @PACKAGE_STRING@
-PACKAGE_TARNAME = @PACKAGE_TARNAME@
-PACKAGE_VERSION = @PACKAGE_VERSION@
-PATH_SEPARATOR = @PATH_SEPARATOR@
-PKG_CONFIG = @PKG_CONFIG@
-RANLIB = @RANLIB@
-REQUIRED_GAIM = @REQUIRED_GAIM@
-REQUIRED_GTK = @REQUIRED_GTK@
-REQUIRED_PKG_CONFIG = @REQUIRED_PKG_CONFIG@
-SET_MAKE = @SET_MAKE@
-SHELL = @SHELL@
-STRIP = @STRIP@
-VERSION = @VERSION@
-ac_ct_AR = @ac_ct_AR@
-ac_ct_AS = @ac_ct_AS@
-ac_ct_CC = @ac_ct_CC@
-ac_ct_CXX = @ac_ct_CXX@
-ac_ct_DLLTOOL = @ac_ct_DLLTOOL@
-ac_ct_F77 = @ac_ct_F77@
-ac_ct_OBJDUMP = @ac_ct_OBJDUMP@
-ac_ct_RANLIB = @ac_ct_RANLIB@
-ac_ct_STRIP = @ac_ct_STRIP@
-ac_pt_PKG_CONFIG = @ac_pt_PKG_CONFIG@
-am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
-am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
-am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
-am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
-am__include = @am__include@
-am__leading_dot = @am__leading_dot@
-am__quote = @am__quote@
-am__tar = @am__tar@
-am__untar = @am__untar@
-bindir = @bindir@
-build = @build@
-build_alias = @build_alias@
-build_cpu = @build_cpu@
-build_os = @build_os@
-build_vendor = @build_vendor@
-datadir = @datadir@
-exec_prefix = @exec_prefix@
-host = @host@
-host_alias = @host_alias@
-host_cpu = @host_cpu@
-host_os = @host_os@
-host_vendor = @host_vendor@
-includedir = @includedir@
-infodir = @infodir@
-install_sh = @install_sh@
-libdir = @libdir@
-libexecdir = @libexecdir@
-localstatedir = @localstatedir@
-mandir = @mandir@
-mkdir_p = @mkdir_p@
-oldincludedir = @oldincludedir@
-prefix = @prefix@
-program_transform_name = @program_transform_name@
-sbindir = @sbindir@
-sharedstatedir = @sharedstatedir@
-sysconfdir = @sysconfdir@
-target = @target@
-target_alias = @target_alias@
-target_cpu = @target_cpu@
-target_os = @target_os@
-target_vendor = @target_vendor@
-pkgdir = \
-	$(GAIM_LIBDIR)/gaim
-
-GAYMSOURCES = \
-	gaym-extras.c chatsort.c bio-popups.c chaticon.c gaym-extras.h
-
-AM_CFLAGS = \
-	$(st)
-
-libgaym_extras_la_LDFLAGS = \
-	-module \
-	-avoid-version \
-	$(GTK_LIBS) \
-	$(GAIM_LIBS)
-
-pkg_LTLIBRARIES = \
-	libgaym-extras.la
-
-libgaym_extras_la_SOURCES = \
-	$(GAYMSOURCES)
-
-AM_CPPFLAGS = \
-	$(DEBUG_CFLAGS) \
-	$(GTK_CFLAGS) \
-	-DGAIM_DATADIR=\"$(datadir)\" \
-	$(GAIM_CFLAGS)
-
-all: all-am
-
-.SUFFIXES:
-.SUFFIXES: .c .lo .o .obj
-$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
-	@for dep in $?; do \
-	  case '$(am__configure_deps)' in \
-	    *$$dep*) \
-	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
-		&& exit 0; \
-	      exit 1;; \
-	  esac; \
-	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  gaym-extras/src/Makefile'; \
-	cd $(top_srcdir) && \
-	  $(AUTOMAKE) --gnu  gaym-extras/src/Makefile
-.PRECIOUS: Makefile
-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
-	@case '$?' in \
-	  *config.status*) \
-	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
-	  *) \
-	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
-	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
-	esac;
-
-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-
-$(top_srcdir)/configure:  $(am__configure_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
-	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
-install-pkgLTLIBRARIES: $(pkg_LTLIBRARIES)
-	@$(NORMAL_INSTALL)
-	test -z "$(pkgdir)" || $(mkdir_p) "$(DESTDIR)$(pkgdir)"
-	@list='$(pkg_LTLIBRARIES)'; for p in $$list; do \
-	  if test -f $$p; then \
-	    f=$(am__strip_dir) \
-	    echo " $(LIBTOOL) --mode=install $(pkgLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) '$$p' '$(DESTDIR)$(pkgdir)/$$f'"; \
-	    $(LIBTOOL) --mode=install $(pkgLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) "$$p" "$(DESTDIR)$(pkgdir)/$$f"; \
-	  else :; fi; \
-	done
-
-uninstall-pkgLTLIBRARIES:
-	@$(NORMAL_UNINSTALL)
-	@set -x; list='$(pkg_LTLIBRARIES)'; for p in $$list; do \
-	  p=$(am__strip_dir) \
-	  echo " $(LIBTOOL) --mode=uninstall rm -f '$(DESTDIR)$(pkgdir)/$$p'"; \
-	  $(LIBTOOL) --mode=uninstall rm -f "$(DESTDIR)$(pkgdir)/$$p"; \
-	done
-
-clean-pkgLTLIBRARIES:
-	-test -z "$(pkg_LTLIBRARIES)" || rm -f $(pkg_LTLIBRARIES)
-	@list='$(pkg_LTLIBRARIES)'; for p in $$list; do \
-	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
-	  test "$$dir" != "$$p" || dir=.; \
-	  echo "rm -f \"$${dir}/so_locations\""; \
-	  rm -f "$${dir}/so_locations"; \
-	done
-libgaym-extras.la: $(libgaym_extras_la_OBJECTS) $(libgaym_extras_la_DEPENDENCIES) 
-	$(LINK) -rpath $(pkgdir) $(libgaym_extras_la_LDFLAGS) $(libgaym_extras_la_OBJECTS) $(libgaym_extras_la_LIBADD) $(LIBS)
-
-mostlyclean-compile:
-	-rm -f *.$(OBJEXT)
-
-distclean-compile:
-	-rm -f *.tab.c
-
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/bio-popups.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/chaticon.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/chatsort.Plo at am__quote@
- at AMDEP_TRUE@@am__include@ @am__quote at ./$(DEPDIR)/gaym-extras.Plo at am__quote@
-
-.c.o:
- at am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
- at am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
- at AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
- at AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- at am__fastdepCC_FALSE@	$(COMPILE) -c $<
-
-.c.obj:
- at am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
- at am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
- at AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
- at AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- at am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
-
-.c.lo:
- at am__fastdepCC_TRUE@	if $(LTCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
- at am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Plo"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
- at AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
- at AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
- at am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
-
-mostlyclean-libtool:
-	-rm -f *.lo
-
-clean-libtool:
-	-rm -rf .libs _libs
-
-distclean-libtool:
-	-rm -f libtool
-uninstall-info-am:
-
-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
-	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	mkid -fID $$unique
-tags: TAGS
-
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	tags=; \
-	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
-	  test -n "$$unique" || unique=$$empty_fix; \
-	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
-	    $$tags $$unique; \
-	fi
-ctags: CTAGS
-CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
-		$(TAGS_FILES) $(LISP)
-	tags=; \
-	here=`pwd`; \
-	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
-	unique=`for i in $$list; do \
-	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
-	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
-	test -z "$(CTAGS_ARGS)$$tags$$unique" \
-	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
-	     $$tags $$unique
-
-GTAGS:
-	here=`$(am__cd) $(top_builddir) && pwd` \
-	  && cd $(top_srcdir) \
-	  && gtags -i $(GTAGS_ARGS) $$here
-
-distclean-tags:
-	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-
-distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
-	list='$(DISTFILES)'; for file in $$list; do \
-	  case $$file in \
-	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
-	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
-	  esac; \
-	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
-	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
-	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
-	    dir="/$$dir"; \
-	    $(mkdir_p) "$(distdir)$$dir"; \
-	  else \
-	    dir=''; \
-	  fi; \
-	  if test -d $$d/$$file; then \
-	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
-	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
-	    fi; \
-	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
-	  else \
-	    test -f $(distdir)/$$file \
-	    || cp -p $$d/$$file $(distdir)/$$file \
-	    || exit 1; \
-	  fi; \
-	done
-check-am: all-am
-check: check-am
-all-am: Makefile $(LTLIBRARIES)
-installdirs:
-	for dir in "$(DESTDIR)$(pkgdir)"; do \
-	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
-	done
-install: install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
-
-install-am: all-am
-	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-
-installcheck: installcheck-am
-install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
-mostlyclean-generic:
-
-clean-generic:
-
-distclean-generic:
-	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
-
-maintainer-clean-generic:
-	@echo "This command is intended for maintainers to use"
-	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-am
-
-clean-am: clean-generic clean-libtool clean-pkgLTLIBRARIES \
-	mostlyclean-am
-
-distclean: distclean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-libtool distclean-tags
-
-dvi: dvi-am
-
-dvi-am:
-
-html: html-am
-
-info: info-am
-
-info-am:
-
-install-data-am: install-pkgLTLIBRARIES
-
-install-exec-am:
-
-install-info: install-info-am
-
-install-man:
-
-installcheck-am:
-
-maintainer-clean: maintainer-clean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
-maintainer-clean-am: distclean-am maintainer-clean-generic
-
-mostlyclean: mostlyclean-am
-
-mostlyclean-am: mostlyclean-compile mostlyclean-generic \
-	mostlyclean-libtool
-
-pdf: pdf-am
-
-pdf-am:
-
-ps: ps-am
-
-ps-am:
-
-uninstall-am: uninstall-info-am uninstall-pkgLTLIBRARIES
-
-.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
-	clean-libtool clean-pkgLTLIBRARIES ctags distclean \
-	distclean-compile distclean-generic distclean-libtool \
-	distclean-tags distdir dvi dvi-am html html-am info info-am \
-	install install-am install-data install-data-am install-exec \
-	install-exec-am install-info install-info-am install-man \
-	install-pkgLTLIBRARIES install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
-	tags uninstall uninstall-am uninstall-info-am \
-	uninstall-pkgLTLIBRARIES
-
-# Tell versions [3.59,3.63) of GNU make to not export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:

Modified: qrc/trunk/gaym-extras/src/bio-popups.c
===================================================================
--- qrc/trunk/gaym-extras/src/bio-popups.c	2005-07-30 21:32:57 UTC (rev 256)
+++ qrc/trunk/gaym-extras/src/bio-popups.c	2005-07-30 21:59:25 UTC (rev 257)
@@ -69,7 +69,7 @@
 #endif
 
     gtk_paint_layout(style, tipwindow->window, GTK_STATE_NORMAL, TRUE,
-                     NULL, tipwindow, "tooltip", 65, 4, layout);
+                     NULL, tipwindow, "tooltip", gdk_pixbuf_get_width(pixbuf)+9, 4, layout);
 
     g_object_unref(pixbuf);
     g_object_unref(layout);
@@ -219,10 +219,11 @@
     w = PANGO_PIXELS(w) + 8;
     h = PANGO_PIXELS(h) + 8;
 
-    /* 57 is the size of a large status icon plus 4 pixels padding on each 
-       side.  I should #define this or something */
+    /* For the width, set it to the text width, plus 13 for 4 pixels on each side and 5 between icon/text.
+     * For height, the greater of the text height and the icon height, plus 8 (4 for each buffer on top and bottom).
+     */
     w = w + gdk_pixbuf_get_width(pdata->pixbuf) + 4;
-    h = MAX(h, gdk_pixbuf_get_height(pdata->pixbuf)+4);
+    h = MAX(h, gdk_pixbuf_get_height(pdata->pixbuf)+8);
 
 #if GTK_CHECK_VERSION(2,2,0)
     if (w > mon_size.width)
@@ -417,7 +418,7 @@
     gtk_widget_ref(gtkconv->tab_label);
     gtk_container_remove(GTK_CONTAINER(gtkconv->tabby),
                          GTK_WIDGET(gtkconv->tab_label));
-    gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(gtkconv->tab_label), FALSE, FALSE, 0);
+    gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(gtkconv->tab_label), TRUE, TRUE, 0);
     gtk_widget_unref(gtkconv->tab_label);
     
         



From jblebrun at berlios.de  Sun Jul 31 00:17:20 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Sun, 31 Jul 2005 00:17:20 +0200
Subject: [Qrc-svn] r258 - in qrc/trunk: . gaym-extras nsis
Message-ID: <200507302217.j6UMHK51031136@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-31 00:17:19 +0200 (Sun, 31 Jul 2005)
New Revision: 258

Modified:
   qrc/trunk/ChangeLog
   qrc/trunk/gaym-extras/Makefile.am
   qrc/trunk/nsis/installer.nsi
Log:
Updated changelog, fixed windows install script, reformatted Makefile.am


Modified: qrc/trunk/ChangeLog
===================================================================
--- qrc/trunk/ChangeLog	2005-07-30 21:59:25 UTC (rev 257)
+++ qrc/trunk/ChangeLog	2005-07-30 22:17:19 UTC (rev 258)
@@ -1,3 +1,14 @@
+0.8-pre:
+	New Features:
+	- Bio displays in chat list as popups over the namelist.
+	- Pvt IM windows display bios as popups over the tab.
+	- Rooms are now sortable by entry order, alpha, or pic type.
+	- Popups have thumbnails in them, as well
+	- Thumbnails are cached locally.
+	
+	Bug Fixes:
+	- Too many to count
+
 0.34.1+svn:
 	New Features:
 	- Bio displays in the buddy list status area

Modified: qrc/trunk/gaym-extras/Makefile.am
===================================================================
--- qrc/trunk/gaym-extras/Makefile.am	2005-07-30 21:59:25 UTC (rev 257)
+++ qrc/trunk/gaym-extras/Makefile.am	2005-07-30 22:17:19 UTC (rev 258)
@@ -1,2 +1,2 @@
 SUBDIRS = src\
-	pixmaps
+	  pixmaps

Modified: qrc/trunk/nsis/installer.nsi
===================================================================
--- qrc/trunk/nsis/installer.nsi	2005-07-30 21:59:25 UTC (rev 257)
+++ qrc/trunk/nsis/installer.nsi	2005-07-30 22:17:19 UTC (rev 258)
@@ -182,7 +182,7 @@
     SetCompress Auto
     SetOverwrite on
     File "..\gaym\src\.libs\${GAYM_DLL}"
-    File "..\gaym-extras\.libs\${GAYM_EXTRAS_DLL}"
+    File "..\gaym-extras\src\.libs\${GAYM_EXTRAS_DLL}"
     File "..\bot-challenger\.libs\${BOT_CHALLENGER_DLL}"
     
     SetOutPath "$INSTDIR\pixmaps\gaim\status\default"
@@ -200,11 +200,7 @@
   done:
 SectionEnd
 
-Sec
-   makensis -DQRC_VERSION="0.33.0+svn" -DGAIM_VERSION="1.3.0" \
-   -DGAIM_TOP="/some/path/to/gaim-win32-dev-1.3.0-1/gaim-1.3.0" \
-   nsis/installer.nsi
-tion Uninstall
+Section Uninstall
   Call un.CheckUserInstallRights
   Pop $R0
   StrCmp $R0 "NONE" no_rights



From jblebrun at berlios.de  Sun Jul 31 00:19:30 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Sun, 31 Jul 2005 00:19:30 +0200
Subject: [Qrc-svn] r259 - in qrc/trunk: . gaym/src gaym-extras/src
Message-ID: <200507302219.j6UMJUpO031266@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-31 00:19:23 +0200 (Sun, 31 Jul 2005)
New Revision: 259

Added:
   qrc/trunk/format
Modified:
   qrc/trunk/gaym-extras/src/bio-popups.c
   qrc/trunk/gaym-extras/src/chaticon.c
   qrc/trunk/gaym-extras/src/chatsort.c
   qrc/trunk/gaym-extras/src/gaym-extras.c
   qrc/trunk/gaym-extras/src/gaym-extras.h
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gayminfo.c
   qrc/trunk/gaym/src/helpers.c
Log:
Reformatted the code with indent.
Added a small script to reformat all code.



Added: qrc/trunk/format
===================================================================
--- qrc/trunk/format	2005-07-30 22:17:19 UTC (rev 258)
+++ qrc/trunk/format	2005-07-30 22:19:23 UTC (rev 259)
@@ -0,0 +1,3 @@
+indent -kr -lc75 -fc1 -fca -nut gaym/src/*.[ch]
+indent -kr -lc75 -fc1 -fca -nut gaym-extras/src/*.[ch]
+indent -kr -lc75 -fc1 -fca -nut bot-challenger/*.[ch]


Property changes on: qrc/trunk/format
___________________________________________________________________
Name: svn:executable
   + *

Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-30 22:17:19 UTC (rev 258)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-30 22:19:23 UTC (rev 259)
@@ -535,7 +535,7 @@
     gaym->confighash = gaym_properties_new(config_text);
     g_return_if_fail(gaym->confighash != NULL);
 
-    //synchronize_deny_list(gc, gaym->confighash);
+    // synchronize_deny_list(gc, gaym->confighash);
 
     return;
 }
@@ -1549,7 +1549,7 @@
     NULL,                                                 /**< unload         */
     NULL,                                                 /**< destroy        */
 
-    NULL,				                   /**< ui_info        */
+    NULL,                                                  /**< ui_info        */
     &prpl_info,                                           /**< extra_info     */
     &prefs_info,
     gaym_actions
@@ -1595,9 +1595,9 @@
                                         GAIM_SUBTYPE_ACCOUNT),
                          gaim_value_new(GAIM_TYPE_POINTER,
                                         GAIM_TYPE_CHAR));
-    
-    
 
+
+
     gaim_prefs_add_none("/plugins/prpl/gaym");
     gaim_prefs_add_int("/plugins/prpl/gaym/chat_room_instances", 4);
     gaim_prefs_add_bool("/plugins/prpl/gaym/show_join", TRUE);

Modified: qrc/trunk/gaym/src/gayminfo.c
===================================================================
--- qrc/trunk/gaym/src/gayminfo.c	2005-07-30 22:17:19 UTC (rev 258)
+++ qrc/trunk/gaym/src/gayminfo.c	2005-07-30 22:19:23 UTC (rev 259)
@@ -120,24 +120,27 @@
     if (!pic_data) {
         return;
     }
-    
+
     if (len && !g_strrstr_len(pic_data, len, "Server Error")) {
-        char *dir = g_build_filename(gaim_user_dir(), "icons", "gaym", d->who, NULL);
+        char *dir =
+            g_build_filename(gaim_user_dir(), "icons", "gaym", d->who,
+                             NULL);
         char *filename = g_strdup(d->filename);
         char *path = g_build_filename(dir, filename, NULL);
-	gaim_debug_misc("gayminfo","dir: %s\n",dir);
-	gaim_debug_misc("gayminfo","filename: %s\n",filename);
-	gaim_debug_misc("gayminfo","path: %s\n",path);
-	if(!g_file_test(dir, G_FILE_TEST_EXISTS))
+        gaim_debug_misc("gayminfo", "dir: %s\n", dir);
+        gaim_debug_misc("gayminfo", "filename: %s\n", filename);
+        gaim_debug_misc("gayminfo", "path: %s\n", path);
+        if (!g_file_test(dir, G_FILE_TEST_EXISTS))
             gaim_build_dir(dir, S_IRUSR | S_IWUSR | S_IXUSR);
-	
-	if(path && !g_file_test(path, G_FILE_TEST_EXISTS)) {
+
+        if (path && !g_file_test(path, G_FILE_TEST_EXISTS)) {
             FILE *file;
             if ((file = g_fopen(path, "wb"))) {
                 fwrite(pic_data, 1, len, file);
                 fclose(file);
             } else {
-                gaim_debug_misc("fetch_thumbnail_cb", "Couldn't write file\n");
+                gaim_debug_misc("fetch_thumbnail_cb",
+                                "Couldn't write file\n");
             }
             g_free(filename);
             g_free(path);
@@ -147,12 +150,12 @@
     if (GAIM_CONNECTION_IS_VALID(d->gc) && len) {
         gaim_signal_emit(gaim_accounts_get_handle(), "info-updated",
                          d->gc, NULL, d->who);
-        if(gaim_find_conversation_with_account(d->who, d->gc->account)) 
-	{
-	   gaim_buddy_icons_set_for_user(gaim_connection_get_account(d->gc),
-                                      d->who, (void *) pic_data, len);
-	}
-	   
+        if (gaim_find_conversation_with_account(d->who, d->gc->account)) {
+            gaim_buddy_icons_set_for_user(gaim_connection_get_account
+                                          (d->gc), d->who,
+                                          (void *) pic_data, len);
+        }
+
     } else {
         gaim_debug_error("gaym", "Fetching buddy icon failed.\n");
     }
@@ -200,51 +203,62 @@
     struct gaym_buddy *ib = g_hash_table_lookup(gaym->buddies, name);
 
     char *normalized = g_strdup(gaim_normalize(gaym->account, name));
-    
+
     if (thumbnail) {
-	gboolean do_fetch=1;
-	GError* err=NULL;
+        gboolean do_fetch = 1;
+        GError *err = NULL;
         if (!ib || gaim_utf8_strcasecmp(thumbnail, ib->thumbnail)) {
-	    char* dirname=g_build_filename(gaim_user_dir(), "icons", "gaym", gaim_normalize(gaym->account,name), NULL);
-	    GDir* gdir=g_dir_open(dirname, 0 , &err);
-	    if(gdir)
-	    {
-	        const char* filename;
-		
-	        while((filename=g_dir_read_name(gdir))) //don't free filename: owned by glib.
-		{
-		    char* thumbnail_base=g_path_get_basename(thumbnail);
-		    gaim_debug_misc("gaym","compared %s and %s\n",thumbnail_base, filename);
-		    if(!gaim_utf8_strcasecmp(thumbnail_base, filename))
-		    {
-			do_fetch=0;
-			break;
-		    }
-		    g_free(thumbnail_base);
-		}	
-	    }
-	    if(do_fetch) {
-		
-		gaim_debug_misc("gaym","********************************************\n");
-		gaim_debug_misc("gaym","*****************FETCH**********************\n");
-		gaim_debug_misc("gaym","********************************************\n");
-		char *hashurl = NULL;
-		hashurl =
-		    g_hash_table_lookup(gaym->confighash,
-					"mini-profile-panel.thumbnail-prefix");
-		g_return_if_fail(hashurl != NULL);
-		data = g_new0(struct gaym_fetch_thumbnail_data, 1);
-		data->gc = gaim_account_get_connection(gaym->account);
-		data->who = g_strdup(gaim_normalize(gaym->account,name));
-		data->filename=g_strdup(g_strrstr(thumbnail, "/"));
-		gaim_debug_misc("gayminfo","Found filename: %s\n",data->filename);
-		url = g_strdup_printf("%s%s", hashurl, thumbnail);
-		gaim_url_fetch(url, FALSE, "Mozilla/4.0", FALSE,
-			       gaym_fetch_thumbnail_cb, data);
-		g_free(url);
-	    }
-    
-	}
+            char *dirname =
+                g_build_filename(gaim_user_dir(), "icons", "gaym",
+                                 gaim_normalize(gaym->account, name),
+                                 NULL);
+            GDir *gdir = g_dir_open(dirname, 0, &err);
+            if (gdir) {
+                const char *filename;
+
+                while ((filename = g_dir_read_name(gdir)))      // don't
+                    // free
+                    // filename: 
+                    // owned
+                    // by
+                    // glib.
+                {
+                    char *thumbnail_base = g_path_get_basename(thumbnail);
+                    gaim_debug_misc("gaym", "compared %s and %s\n",
+                                    thumbnail_base, filename);
+                    if (!gaim_utf8_strcasecmp(thumbnail_base, filename)) {
+                        do_fetch = 0;
+                        break;
+                    }
+                    g_free(thumbnail_base);
+                }
+            }
+            if (do_fetch) {
+
+                gaim_debug_misc("gaym",
+                                "********************************************\n");
+                gaim_debug_misc("gaym",
+                                "*****************FETCH**********************\n");
+                gaim_debug_misc("gaym",
+                                "********************************************\n");
+                char *hashurl = NULL;
+                hashurl =
+                    g_hash_table_lookup(gaym->confighash,
+                                        "mini-profile-panel.thumbnail-prefix");
+                g_return_if_fail(hashurl != NULL);
+                data = g_new0(struct gaym_fetch_thumbnail_data, 1);
+                data->gc = gaim_account_get_connection(gaym->account);
+                data->who = g_strdup(gaim_normalize(gaym->account, name));
+                data->filename = g_strdup(g_strrstr(thumbnail, "/"));
+                gaim_debug_misc("gayminfo", "Found filename: %s\n",
+                                data->filename);
+                url = g_strdup_printf("%s%s", hashurl, thumbnail);
+                gaim_url_fetch(url, FALSE, "Mozilla/4.0", FALSE,
+                               gaym_fetch_thumbnail_cb, data);
+                g_free(url);
+            }
+
+        }
     }
 
     g_free(normalized);

Modified: qrc/trunk/gaym/src/helpers.c
===================================================================
--- qrc/trunk/gaym/src/helpers.c	2005-07-30 22:17:19 UTC (rev 258)
+++ qrc/trunk/gaym/src/helpers.c	2005-07-30 22:19:23 UTC (rev 259)
@@ -205,27 +205,25 @@
 
 void replace_dollar_n(gpointer key, gpointer value, gpointer user_data)
 {
- 
+
     /**
      * replace $[0-9] with %s, so we can use printf style
      * processing with the provided property values
      */
-    gchar* pos=(gchar*)value;
-    while((pos=(strchr(pos, '$'))))
-    {
-	pos++;
-	if(g_ascii_isdigit(*pos))
-	{
-		*pos='s';
-		*(pos-1)='%';
-		
-	}
+    gchar *pos = (gchar *) value;
+    while ((pos = (strchr(pos, '$')))) {
+        pos++;
+        if (g_ascii_isdigit(*pos)) {
+            *pos = 's';
+            *(pos - 1) = '%';
+
+        }
     }
 }
 
 GHashTable *gaym_properties_new(const gchar * str)
 {
-    
+
     gchar *tmpstr = NULL;
     gchar **tmparr = NULL;
     gchar **proparr = NULL;
@@ -242,19 +240,18 @@
     /**
      * strip out continuation character followed by newline 
      */
-    //tmparr = g_strsplit(tmpstr, "\\\n", -1);
-    //g_free(tmpstr);
-    //tmpstr = g_strjoinv(NULL, tmparr);
-    //g_strfreev(tmparr);
+    // tmparr = g_strsplit(tmpstr, "\\\n", -1);
+    // g_free(tmpstr);
+    // tmpstr = g_strjoinv(NULL, tmparr);
+    // g_strfreev(tmparr);
     /**
      * Since the properties get stripped of spaces later,
      * just replace \\\n with <space>\n in-place, for speed.
      * */
-    char* pos=tmpstr;
-    while((pos=g_strrstr(pos, "\\\n")))
-    {
-	*pos=' ';
-	*(pos+1)=' ';
+    char *pos = tmpstr;
+    while ((pos = g_strrstr(pos, "\\\n"))) {
+        *pos = ' ';
+        *(pos + 1) = ' ';
     }
     /**
      * We're getting close.  Now we need an array as follows:
@@ -291,12 +288,12 @@
         proparr = g_strsplit(tmparr[i], "=", 2);
         if (proparr[0] && strlen(g_strstrip(proparr[0])) > 0
             && proparr[1] && strlen(g_strstrip(proparr[1])) > 0) {
-            
-		g_hash_table_insert(props, g_strdup(proparr[0]),
+
+            g_hash_table_insert(props, g_strdup(proparr[0]),
                                 g_strdup(proparr[1]));
-	    
+
         }
-	g_strfreev(proparr);
+        g_strfreev(proparr);
     }
 
     g_strfreev(tmparr);
@@ -460,8 +457,8 @@
 char *build_tooltip_text(struct gaym_buddy *ib)
 {
     char *escaped;
-     GString *tooltip = g_string_new("");
-    g_string_printf(tooltip, "<b><i>%s</i></b>",ib->name);
+    GString *tooltip = g_string_new("");
+    g_string_printf(tooltip, "<b><i>%s</i></b>", ib->name);
 
     g_return_val_if_fail(ib != NULL, NULL);
 
@@ -495,9 +492,8 @@
     if (tooltip->len == 0) {
         g_string_append_printf(tooltip, _(" No info."));
     }
+    // g_string_erase(tooltip, 0, 1);
 
-    //g_string_erase(tooltip, 0, 1);
-
     return g_string_free(tooltip, FALSE);
 }
 

Modified: qrc/trunk/gaym-extras/src/bio-popups.c
===================================================================
--- qrc/trunk/gaym-extras/src/bio-popups.c	2005-07-30 22:17:19 UTC (rev 258)
+++ qrc/trunk/gaym-extras/src/bio-popups.c	2005-07-30 22:19:23 UTC (rev 259)
@@ -6,8 +6,8 @@
 void clean_popup_stuff(GaimConversation * c)
 {
 
-    if (!g_strrstr(gaim_account_get_protocol_id(c->account),"prpl-gaym"))
-	    return;
+    if (!g_strrstr(gaim_account_get_protocol_id(c->account), "prpl-gaym"))
+        return;
     GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
     if (c->type == GAIM_CONV_IM) {
         g_hash_table_remove(popup_timeouts, gtkconv->tab_label);
@@ -41,11 +41,11 @@
                                GdkEventExpose * event, gpointer data)
 {
     g_return_if_fail(data);
-	
-    char *tooltiptext= ((struct paint_data *) data)->tooltiptext;
-    GdkPixbuf* pixbuf = ((struct paint_data *)data)->pixbuf;
-    GtkStyle *style=NULL;
-        
+
+    char *tooltiptext = ((struct paint_data *) data)->tooltiptext;
+    GdkPixbuf *pixbuf = ((struct paint_data *) data)->pixbuf;
+    GtkStyle *style = NULL;
+
     PangoLayout *layout;
 
     layout = gtk_widget_create_pango_layout(tipwindow, NULL);
@@ -69,7 +69,8 @@
 #endif
 
     gtk_paint_layout(style, tipwindow->window, GTK_STATE_NORMAL, TRUE,
-                     NULL, tipwindow, "tooltip", gdk_pixbuf_get_width(pixbuf)+9, 4, layout);
+                     NULL, tipwindow, "tooltip",
+                     gdk_pixbuf_get_width(pixbuf) + 9, 4, layout);
 
     g_object_unref(pixbuf);
     g_object_unref(layout);
@@ -78,31 +79,33 @@
 
     return;
 }
-GdkPixbuf* lookup_cached_thumbnail(GaimAccount* account, const char*fullname) {
-    GDir* gdir=NULL;
-    GError* err=NULL;
-    GdkPixbuf *pixbuf=NULL;
-    const char *filename=NULL;
-    char* dirname=NULL;
-    char* path=NULL;
-    const char* name= gaim_normalize(account, fullname);
-    dirname=g_build_filename(gaim_user_dir(), "icons", "gaym", name, NULL);
-    if(dirname) 
-    {
-	gdir=g_dir_open(dirname, 0 , &err);
-	if(gdir)
-	{
-	    filename=g_dir_read_name(gdir); //don't free filename: owned by glib.
-	    if(filename)
-	    {	
-		path=g_build_filename(dirname,filename,NULL);
-		if(path)
-		    pixbuf=gdk_pixbuf_new_from_file(path, &err);
-		    g_free(path);
-	    }
-	    g_free(gdir);
-	}
-	g_free(dirname);
+
+GdkPixbuf *lookup_cached_thumbnail(GaimAccount * account,
+                                   const char *fullname)
+{
+    GDir *gdir = NULL;
+    GError *err = NULL;
+    GdkPixbuf *pixbuf = NULL;
+    const char *filename = NULL;
+    char *dirname = NULL;
+    char *path = NULL;
+    const char *name = gaim_normalize(account, fullname);
+    dirname =
+        g_build_filename(gaim_user_dir(), "icons", "gaym", name, NULL);
+    if (dirname) {
+        gdir = g_dir_open(dirname, 0, &err);
+        if (gdir) {
+            filename = g_dir_read_name(gdir);   // don't free filename:
+                                                // owned by glib.
+            if (filename) {
+                path = g_build_filename(dirname, filename, NULL);
+                if (path)
+                    pixbuf = gdk_pixbuf_new_from_file(path, &err);
+                g_free(path);
+            }
+            g_free(gdir);
+        }
+        g_free(dirname);
     }
     return pixbuf;
 }
@@ -125,11 +128,11 @@
 
     GaymTooltipType type = data->type;
     GaimAccount *account = data->account;
-    GaimPluginProtocolInfo *prpl_info= 
-	GAIM_PLUGIN_PROTOCOL_INFO(
-		gaim_find_prpl(gaim_account_get_protocol_id(account)));
-    
+    GaimPluginProtocolInfo *prpl_info =
+        GAIM_PLUGIN_PROTOCOL_INFO(gaim_find_prpl
+                                  (gaim_account_get_protocol_id(account)));
 
+
     timeout = (guint *) g_hash_table_lookup(popup_timeouts, tv);
     /* we check to see if we're still supposed to be moving, now that gtk
        events have happened, and the mouse might not still be in the buddy 
@@ -159,10 +162,10 @@
         name = gtk_label_get_text(GTK_LABEL(tv));
     } else
         return FALSE;
-    
-    	
 
 
+
+
     GaimBuddy *gb = g_new0(GaimBuddy, 1);
     gb->name = g_strdup(name);
     gb->account = account;
@@ -170,10 +173,10 @@
     g_free(gb->name);
     g_free(gb);
 
-    if (!tooltiptext) 
+    if (!tooltiptext)
         return FALSE;
 
-    
+
     g_return_val_if_fail(tooltiptext != NULL, FALSE);
 
     tipwindow = g_hash_table_lookup(popups, tv);
@@ -219,11 +222,12 @@
     w = PANGO_PIXELS(w) + 8;
     h = PANGO_PIXELS(h) + 8;
 
-    /* For the width, set it to the text width, plus 13 for 4 pixels on each side and 5 between icon/text.
-     * For height, the greater of the text height and the icon height, plus 8 (4 for each buffer on top and bottom).
-     */
+    /* For the width, set it to the text width, plus 13 for 4 pixels on
+       each side and 5 between icon/text. For height, the greater of the
+       text height and the icon height, plus 8 (4 for each buffer on top
+       and bottom). */
     w = w + gdk_pixbuf_get_width(pdata->pixbuf) + 4;
-    h = MAX(h, gdk_pixbuf_get_height(pdata->pixbuf)+8);
+    h = MAX(h, gdk_pixbuf_get_height(pdata->pixbuf) + 8);
 
 #if GTK_CHECK_VERSION(2,2,0)
     if (w > mon_size.width)
@@ -325,15 +329,15 @@
 static void tab_leave_cb(GtkWidget * event, GdkEventCrossing * e,
                          gpointer conv)
 {
-    
+
     GaimConversation *c = (GaimConversation *) conv;
-   
+
     GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
     // Prevent clicks from demolishing popup.
     if (e->mode != GDK_CROSSING_NORMAL)
         return;
     GtkWidget *tab = gtkconv->tab_label;
-  
+
     guint *timeout = g_hash_table_lookup(popup_timeouts, tab);
     g_hash_table_remove(popups, tab);
 
@@ -345,14 +349,14 @@
 }
 
 
-static gboolean tab_entry_cb(GtkWidget *event,
+static gboolean tab_entry_cb(GtkWidget * event,
                              GdkEventCrossing * crossing, gpointer conv)
 {
 
     guint *timeout;
     guint delay;
     GaimConversation *c = (GaimConversation *) conv;
-    GaimAccount *account = gaim_conversation_get_account(c); 
+    GaimAccount *account = gaim_conversation_get_account(c);
     GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
 
     GtkWidget *tab = gtkconv->tab_label;
@@ -407,21 +411,23 @@
     GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
     GtkWidget *event = gtk_event_box_new();
     GtkWidget *hbox = gtk_hbox_new(FALSE, 6);
-    
+
     gtk_widget_ref(gtkconv->icon);
     gtk_container_remove(GTK_CONTAINER(gtkconv->tabby),
                          GTK_WIDGET(gtkconv->icon));
-    gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(gtkconv->icon), FALSE, FALSE, 0);
+    gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(gtkconv->icon), FALSE,
+                       FALSE, 0);
     gtk_widget_ref(gtkconv->icon);
     gtk_widget_unref(gtkconv->icon);
 
     gtk_widget_ref(gtkconv->tab_label);
     gtk_container_remove(GTK_CONTAINER(gtkconv->tabby),
                          GTK_WIDGET(gtkconv->tab_label));
-    gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(gtkconv->tab_label), TRUE, TRUE, 0);
+    gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(gtkconv->tab_label), TRUE,
+                       TRUE, 0);
     gtk_widget_unref(gtkconv->tab_label);
-    
-        
+
+
     gtk_widget_add_events(event,
                           GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK);
     g_signal_connect(G_OBJECT(event), "enter-notify-event",
@@ -434,8 +440,7 @@
     gtk_widget_show(GTK_WIDGET(event));
     gtk_widget_show(GTK_WIDGET(hbox));
     gtk_event_box_set_visible_window(GTK_EVENT_BOX(event), FALSE);
-    gtk_container_add(GTK_CONTAINER(event),
-                      GTK_WIDGET(hbox));
+    gtk_container_add(GTK_CONTAINER(event), GTK_WIDGET(hbox));
     g_hash_table_insert(popup_timeouts, gtkconv->tab_label,
                         g_new0(guint, 1));
 }

Modified: qrc/trunk/gaym-extras/src/chaticon.c
===================================================================
--- qrc/trunk/gaym-extras/src/chaticon.c	2005-07-30 22:17:19 UTC (rev 258)
+++ qrc/trunk/gaym-extras/src/chaticon.c	2005-07-30 22:19:23 UTC (rev 259)
@@ -1,11 +1,11 @@
 #include "gaym-extras.h"
 GHashTable *icons;
 void get_icon_scale_size(GdkPixbuf * icon, GaimBuddyIconSpec * spec,
-                    int *width, int *height)
+                         int *width, int *height)
 {
     *width = gdk_pixbuf_get_width(icon);
     *height = gdk_pixbuf_get_height(icon);
-    gaim_debug_misc("popups","current: w: %i, h: %i\n", *width,*height);
+    gaim_debug_misc("popups", "current: w: %i, h: %i\n", *width, *height);
     /* this should eventually get smarter about preserving the aspect
        ratio when scaling, but gimmie a break, I just woke up */
     if (spec && spec->scale_rules & GAIM_ICON_SCALE_DISPLAY) {
@@ -25,18 +25,17 @@
         *width = 100;
     if (*height > 100)
         *height = 100;
-    gaim_debug_misc("popups","scaled: w: %i, h: %i\n", *width,*height);
+    gaim_debug_misc("popups", "scaled: w: %i, h: %i\n", *width, *height);
 }
 
-void gaym_update_thumbnail(GaimConversation * conv, GdkPixbuf* pixbuf) 
+void gaym_update_thumbnail(GaimConversation * conv, GdkPixbuf * pixbuf)
 {
     GaimGtkConversation *gtkconv;
 
     GdkPixbuf *scale;
-    GdkPixmap *pm=NULL;
-    GdkBitmap *bm=NULL;
-    int scale_width=0, 
-	scale_height=0;
+    GdkPixmap *pm = NULL;
+    GdkBitmap *bm = NULL;
+    int scale_width = 0, scale_height = 0;
 
 
     GaimAccount *account;
@@ -68,13 +67,14 @@
     get_icon_scale_size(pixbuf,
                         prpl_info ? &prpl_info->icon_spec : NULL,
                         &scale_width, &scale_height);
-    //double aspect=(double)gdk_pixbuf_get_width(pixbuf)/(double)gdk_pixbuf_get_height(pixbuf); 
+    // double
+    // aspect=(double)gdk_pixbuf_get_width(pixbuf)/(double)gdk_pixbuf_get_height(pixbuf); 
+    // 
 
     scale =
         gdk_pixbuf_scale_simple(pixbuf,
                                 scale_width,
-                                scale_height,
-                                GDK_INTERP_BILINEAR);
+                                scale_height, GDK_INTERP_BILINEAR);
 
     gdk_pixbuf_render_pixmap_and_mask(scale, &pm, &bm, 100);
     g_object_unref(G_OBJECT(scale));
@@ -82,17 +82,16 @@
 
     icon_data->event = gtk_event_box_new();
     gtk_container_add(GTK_CONTAINER(icon_data->frame), icon_data->event);
-    gtk_widget_set_size_request(GTK_WIDGET(icon_data->frame), 57,
-                                77);
+    gtk_widget_set_size_request(GTK_WIDGET(icon_data->frame), 57, 77);
 
-    //g_signal_connect(G_OBJECT(icon_data->event), "button-press-event",
-    //G_CALLBACK(icon_menu), conv);
+    // g_signal_connect(G_OBJECT(icon_data->event), "button-press-event",
+    // G_CALLBACK(icon_menu), conv);
     gtk_widget_show(icon_data->event);
     icon_data->icon = gtk_image_new_from_pixmap(pm, bm);
     gtk_container_add(GTK_CONTAINER(icon_data->event), icon_data->icon);
     gtk_widget_show(icon_data->icon);
 
-    if(pm)
+    if (pm)
         g_object_unref(G_OBJECT(pm));
 
     if (bm)
@@ -111,8 +110,8 @@
     GaimConversation *c = (GaimConversation *) conv;
 
     GtkTreeIter iter;
-    GtkTreeModel *model=NULL;
-    GdkPixbuf *pixbuf=NULL;
+    GtkTreeModel *model = NULL;
+    GdkPixbuf *pixbuf = NULL;
     gchar *name;
 
     if (!gtk_tree_selection_get_selected(selection, &model, &iter))
@@ -128,11 +127,11 @@
 
     gtk_widget_grab_focus(GTK_WIDGET(model)->parent);
 
-    pixbuf=lookup_cached_thumbnail(c->account, name);
- 
-    if(pixbuf)
-	gaym_update_thumbnail(c, pixbuf);
-    
+    pixbuf = lookup_cached_thumbnail(c->account, name);
+
+    if (pixbuf)
+        gaym_update_thumbnail(c, pixbuf);
+
     g_object_unref(pixbuf);
     return;
 
@@ -169,9 +168,8 @@
     icon_data->show_icon = TRUE;
     icon_data->icon_container = gtk_vbox_new(FALSE, 0);
 
-    gtk_widget_set_size_request(GTK_WIDGET(icon_data->icon_container),
-                                57,77);//prpl_info->icon_spec.max_width,
-                                //prpl_info->icon_spec.max_height);
+    gtk_widget_set_size_request(GTK_WIDGET(icon_data->icon_container), 57, 77); // prpl_info->icon_spec.max_width,
+    // prpl_info->icon_spec.max_height);
 
 
     icon_data->frame = gtk_frame_new(NULL);

Modified: qrc/trunk/gaym-extras/src/chatsort.c
===================================================================
--- qrc/trunk/gaym-extras/src/chatsort.c	2005-07-30 22:17:19 UTC (rev 258)
+++ qrc/trunk/gaym-extras/src/chatsort.c	2005-07-30 22:19:23 UTC (rev 259)
@@ -53,7 +53,7 @@
 
 static gint
 sort_chat_users_by_pic(GtkTreeModel * model, GtkTreeIter * a,
-                            GtkTreeIter * b, gpointer userdata)
+                       GtkTreeIter * b, gpointer userdata)
 {
     GaimConvChatBuddyFlags f1 = 0, f2 = 0;
     gint flag_mask = 0x000F;
@@ -84,60 +84,62 @@
 }
 
 
-static struct gaym_sort_orders
-{
-	const char* icon;
-	void* sort_funcion;
-	const char* tooltip;
-} const order[] =
-    
-{ 
-	{GAYM_STOCK_ENTRY, sort_chat_users_by_entry, _("Current sorting by entry") },
-	{GAYM_STOCK_ALPHA, sort_chat_users_by_alpha, _("Current sorting by alpha") },
-	{GAYM_STOCK_PIC, sort_chat_users_by_pic, _("Current sorting by pic") }
+static struct gaym_sort_orders {
+    const char *icon;
+    void *sort_funcion;
+    const char *tooltip;
+} const order[] = {
+    {GAYM_STOCK_ENTRY, sort_chat_users_by_entry,
+     _("Current sorting by entry")},
+    {GAYM_STOCK_ALPHA, sort_chat_users_by_alpha,
+     _("Current sorting by alpha")},
+    {GAYM_STOCK_PIC, sort_chat_users_by_pic, _("Current sorting by pic")}
 };
 
-   
+
 void change_sort_order(GtkWidget * button, void *data)
 {
-   
-    static int current=0;
-    current=(current+1)%G_N_ELEMENTS(order);
+
+    static int current = 0;
+    current = (current + 1) % G_N_ELEMENTS(order);
     GaimGtkConversation *gtkconv = (GaimGtkConversation *) data;
     GaimGtkChatPane *gtkchat = gtkconv->u.chat;
-    GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
-    
-    GtkBox* buttonbox = GTK_BOX(button->parent);
+    GtkTreeModel *model =
+        gtk_tree_view_get_model(GTK_TREE_VIEW(gtkchat->list));
+
+    GtkBox *buttonbox = GTK_BOX(button->parent);
     gtk_widget_destroy(button);
-    button = GTK_WIDGET(gaim_gtkconv_button_new(order[current].icon, 
-						NULL,//_("E"), 
-						order[current].tooltip, 
-						gtkconv->tooltips, 
-						change_sort_order, 
-						gtkconv));
+    button = GTK_WIDGET(gaim_gtkconv_button_new(order[current].icon, NULL,      // _("E"), 
+                                                                                // 
+                                                order[current].tooltip,
+                                                gtkconv->tooltips,
+                                                change_sort_order,
+                                                gtkconv));
     gtk_box_pack_end(buttonbox, button, FALSE, FALSE, 0);
     gtk_widget_show(button);
     gtk_tree_sortable_set_sort_func(GTK_TREE_SORTABLE(model),
-                                        CHAT_USERS_NAME_COLUMN,
-                                        order[current].sort_funcion, NULL,
-                                        NULL);
+                                    CHAT_USERS_NAME_COLUMN,
+                                    order[current].sort_funcion, NULL,
+                                    NULL);
 
 
 
 }
+
 void add_chat_sort_functions(GaimConversation * c)
 {
 
     GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
 
     GtkBox *iconbox = (GtkBox *) gtkconv->info->parent;
-    //    GtkWidget *button = gtk_button_new_with_label("E");
-    GtkWidget *button = gaim_gtkconv_button_new(GAYM_STOCK_ENTRY, 
-						NULL,//_("E"), 
-						_("Currently sorting by entry"), 
-						gtkconv->tooltips, 
-						change_sort_order, 
-						gtkconv);
+    // GtkWidget *button = gtk_button_new_with_label("E");
+    GtkWidget *button = gaim_gtkconv_button_new(GAYM_STOCK_ENTRY,
+                                                NULL,   // _("E"), 
+                                                _
+                                                ("Currently sorting by entry"),
+                                                gtkconv->tooltips,
+                                                change_sort_order,
+                                                gtkconv);
     gtk_box_pack_end(iconbox, button, FALSE, FALSE, 0);
     gtk_widget_show(button);
 

Modified: qrc/trunk/gaym-extras/src/gaym-extras.c
===================================================================
--- qrc/trunk/gaym-extras/src/gaym-extras.c	2005-07-30 22:17:19 UTC (rev 258)
+++ qrc/trunk/gaym-extras/src/gaym-extras.c	2005-07-30 22:19:23 UTC (rev 259)
@@ -5,8 +5,8 @@
 // Adds motion handlers to IM tab labels.
 static void redo_im_window(GaimConversation * c)
 {
-    if (!g_strrstr(gaim_account_get_protocol_id(c->account),"prpl-gaym"))
-	    return;
+    if (!g_strrstr(gaim_account_get_protocol_id(c->account), "prpl-gaym"))
+        return;
     if (c && c->type == GAIM_CONV_IM)
         add_im_popup_stuff(c);
 }
@@ -14,78 +14,77 @@
 
 static void update_info_cb(GaimAccount * account, char *name)
 {
-    if (!g_strrstr(gaim_account_get_protocol_id(account),"prpl-gaym"))
-	    return;
+    if (!g_strrstr(gaim_account_get_protocol_id(account), "prpl-gaym"))
+        return;
     gaim_debug_misc("gaym-extras", "info update\n");
 }
 
 static void redochatwindow(GaimConversation * c)
 {
-    if (!g_strrstr(gaim_account_get_protocol_id(c->account),"prpl-gaym"))
-	    return;
+    if (!g_strrstr(gaim_account_get_protocol_id(c->account), "prpl-gaym"))
+        return;
     add_chat_sort_functions(c);
     add_chat_popup_stuff(c);
     add_chat_icon_stuff(c);
 }
-static gchar *
-find_file(const char *dir, const char *base)
+static gchar *find_file(const char *dir, const char *base)
 {
-	char *filename;
+    char *filename;
 
-	if (base == NULL)
-		return NULL;
+    if (base == NULL)
+        return NULL;
 
-	if (!strcmp(dir, "gaim"))
-		filename = g_build_filename(GAIM_DATADIR, "pixmaps", "gaim", base, NULL);
-	else
-	{
-		filename = g_build_filename(GAIM_DATADIR, "pixmaps", "gaim", dir,
-									base, NULL);
-	}
+    if (!strcmp(dir, "gaim"))
+        filename =
+            g_build_filename(GAIM_DATADIR, "pixmaps", "gaim", base, NULL);
+    else {
+        filename = g_build_filename(GAIM_DATADIR, "pixmaps", "gaim", dir,
+                                    base, NULL);
+    }
 
-	if (!g_file_test(filename, G_FILE_TEST_EXISTS))
-	{
-		g_critical("Unable to load stock pixmap %s\n", filename);
+    if (!g_file_test(filename, G_FILE_TEST_EXISTS)) {
+        g_critical("Unable to load stock pixmap %s\n", filename);
 
-		g_free(filename);
+        g_free(filename);
 
-		return NULL;
-	}
+        return NULL;
+    }
 
-	return filename;
+    return filename;
 
 }
-void extras_register_stock() {
-    
-    static gboolean stock_is_init=FALSE;
-    GtkIconFactory* icon_factory=NULL;
+
+void extras_register_stock()
+{
+
+    static gboolean stock_is_init = FALSE;
+    GtkIconFactory *icon_factory = NULL;
     int i;
-    if(stock_is_init)
-	return;
-    stock_is_init=TRUE;
-    icon_factory=gtk_icon_factory_new();
+    if (stock_is_init)
+        return;
+    stock_is_init = TRUE;
+    icon_factory = gtk_icon_factory_new();
 
     gtk_icon_factory_add_default(icon_factory);
 
-    for (i=0 ; i < G_N_ELEMENTS(stock_icons); i++)
-    {
-	GdkPixbuf *pixbuf;
-	GtkIconSet *iconset;
-	gchar *filename;
-	filename = find_file(stock_icons[i].dir, stock_icons[i].filename);
-	if (filename==NULL)
-	    continue;
+    for (i = 0; i < G_N_ELEMENTS(stock_icons); i++) {
+        GdkPixbuf *pixbuf;
+        GtkIconSet *iconset;
+        gchar *filename;
+        filename = find_file(stock_icons[i].dir, stock_icons[i].filename);
+        if (filename == NULL)
+            continue;
 
-	pixbuf = gdk_pixbuf_new_from_file(filename, NULL);
-	g_free(filename);
-	iconset = gtk_icon_set_new_from_pixbuf(pixbuf);
-	
-	g_object_unref(pixbuf);
-	gtk_icon_factory_add(icon_factory, stock_icons[i].name, iconset);
-	gtk_icon_set_unref(iconset);
+        pixbuf = gdk_pixbuf_new_from_file(filename, NULL);
+        g_free(filename);
+        iconset = gtk_icon_set_new_from_pixbuf(pixbuf);
+
+        g_object_unref(pixbuf);
+        gtk_icon_factory_add(icon_factory, stock_icons[i].name, iconset);
+        gtk_icon_set_unref(iconset);
     }
-	
-	
+
+
 }
 static gboolean plugin_load(GaimPlugin * plugin)
 {

Modified: qrc/trunk/gaym-extras/src/gaym-extras.h
===================================================================
--- qrc/trunk/gaym-extras/src/gaym-extras.h	2005-07-30 22:17:19 UTC (rev 258)
+++ qrc/trunk/gaym-extras/src/gaym-extras.h	2005-07-30 22:19:23 UTC (rev 259)
@@ -32,7 +32,7 @@
 
 struct paint_data {
     char *tooltiptext;
-    GdkPixbuf* pixbuf;
+    GdkPixbuf *pixbuf;
 };
 
 // Additional UI info for a conversation.
@@ -58,32 +58,32 @@
 struct timeout_cb_data {
     GaymTooltipType type;
     GtkWidget *tv;
-    GaimAccount* account;
+    GaimAccount *account;
 };
 
 
-GdkPixbuf* lookup_cached_thumbnail(GaimAccount* account, const char*fullname);
-void get_icon_scale_size(GdkPixbuf* icon, GaimBuddyIconSpec * spec,int *width, int *height);
+GdkPixbuf *lookup_cached_thumbnail(GaimAccount * account,
+                                   const char *fullname);
+void get_icon_scale_size(GdkPixbuf * icon, GaimBuddyIconSpec * spec,
+                         int *width, int *height);
 void clean_popup_stuff(GaimConversation * c);
-void add_chat_icon_stuff(GaimConversation *c);
-void add_chat_popup_stuff(GaimConversation *c);
-void add_chat_sort_functions(GaimConversation *c);
-void add_im_popup_stuff(GaimConversation* c);
+void add_chat_icon_stuff(GaimConversation * c);
+void add_chat_popup_stuff(GaimConversation * c);
+void add_chat_sort_functions(GaimConversation * c);
+void add_im_popup_stuff(GaimConversation * c);
 void init_chat_icons();
 void init_popups();
 
 
-static struct StockIcon
-{
-	const char *name;
-	const char *dir;
-	const char *filename;
+static struct StockIcon {
+    const char *name;
+    const char *dir;
+    const char *filename;
 
-} const stock_icons[] = 
-{
-	    { GAYM_STOCK_ALPHA,	    "gaym",	"alpha.png" },    
-	    { GAYM_STOCK_ENTRY,	    "gaym",	"entry.png" },    
-	    { GAYM_STOCK_PIC,	    "gaym",	"pic.png" }
+} const stock_icons[] = {
+    {GAYM_STOCK_ALPHA, "gaym", "alpha.png"},
+    {GAYM_STOCK_ENTRY, "gaym", "entry.png"},
+    {GAYM_STOCK_PIC, "gaym", "pic.png"}
 };
 
-#endif //GAYM_EXTRAS_H
+#endif                          // GAYM_EXTRAS_H



From jblebrun at berlios.de  Sun Jul 31 05:29:08 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Sun, 31 Jul 2005 05:29:08 +0200
Subject: [Qrc-svn] r260 - in qrc/trunk: gaym/src gaym-extras/src nsis
Message-ID: <200507310329.j6V3T8hJ017314@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-31 05:29:02 +0200 (Sun, 31 Jul 2005)
New Revision: 260

Modified:
   qrc/trunk/gaym-extras/src/bio-popups.c
   qrc/trunk/gaym-extras/src/gaym-extras.c
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gayminfo.c
   qrc/trunk/gaym/src/helpers.c
   qrc/trunk/gaym/src/msgs.c
   qrc/trunk/nsis/installer.nsi
Log:
More random cleanup and bugfix. Sorry for the onslaught of commit emails ;-)

helpers.c: 
*Return "no info" instead of null as tooltip for non-existent person. 

gayminfo.c:
*ADDED A g_dir_close! D'oh!

msgs.c:
*Make the "no such person" message appear in the window, if a conversation is open, instead of annoying popup notification. 
*Don't use buddy icon system at all, since we have our own caching system.

gaym.c:
*Normalize some hash table lookups
*return no info found for tooltip

gaym-extras.c:
*defines to make sure win32 looks for icons in the right place. Might be the wrong way to do it.
*add a prefs frame

bio-popups.c:
*added a dir_close! d'oh!
*make popups get destroyed on right click, since this was causing crash.

installer.nsI:
*add icons in right place



Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-31 03:29:02 UTC (rev 260)
@@ -236,13 +236,12 @@
     }
 
     struct gaym_buddy *ib =
-        g_hash_table_lookup(gaym->channel_members, buddy->name);
-
-    if (!ib)
-        ib = g_hash_table_lookup(gaym->buddies, buddy->name);
-
+        g_hash_table_lookup(gaym->channel_members, gaim_normalize(gaym->account,buddy->name)); 
+    if(!ib)
+         ib=g_hash_table_lookup(gaym->buddies, gaim_normalize(gaym->account,buddy->name));
+    
     if (!ib) {
-        return NULL;
+        return g_strdup("No info found.");
     }
 
     return build_tooltip_text(ib);
@@ -812,11 +811,11 @@
     if (!channel_member) {
         GaymBuddy *channel_member = g_new0(GaymBuddy, 1);
         channel_member->ref_count = 1;
-        g_hash_table_insert(gaym->channel_members, g_strdup(name),
+        g_hash_table_insert(gaym->channel_members, g_strdup(gaim_normalize(gaym->account,name)),
                             channel_member);
         gaim_debug_misc("gaym", "Creating channel_members entry for %s\n",
                         name);
-        return g_hash_table_lookup(gaym->channel_members, name);
+        return g_hash_table_lookup(gaym->channel_members, gaim_normalize(gaym->account, name));
     } else {
         gaim_debug_misc("gaym",
                         "Adding reference to channel_members entry for %s\n",
@@ -833,7 +832,7 @@
 
     GaymBuddy *channel_member;
     channel_member =
-        (GaymBuddy *) g_hash_table_lookup(gaym->channel_members, name);
+        (GaymBuddy *) g_hash_table_lookup(gaym->channel_members, gaim_normalize(gaym->account,name));
     if (!channel_member)
         return FALSE;
     else {
@@ -847,7 +846,7 @@
         if (channel_member->ref_count == 0) {
             gaim_debug_misc("gaym", "Removing %s from channel_members\n",
                             name);
-            return g_hash_table_remove(gaym->channel_members, name);
+            return g_hash_table_remove(gaym->channel_members, gaim_normalize(gaym->account, name));
         }
         return FALSE;
     }

Modified: qrc/trunk/gaym/src/gayminfo.c
===================================================================
--- qrc/trunk/gaym/src/gayminfo.c	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/trunk/gaym/src/gayminfo.c	2005-07-31 03:29:02 UTC (rev 260)
@@ -151,9 +151,9 @@
         gaim_signal_emit(gaim_accounts_get_handle(), "info-updated",
                          d->gc, NULL, d->who);
         if (gaim_find_conversation_with_account(d->who, d->gc->account)) {
-            gaim_buddy_icons_set_for_user(gaim_connection_get_account
-                                          (d->gc), d->who,
-                                          (void *) pic_data, len);
+            //gaim_buddy_icons_set_for_user(gaim_connection_get_account
+            //                              (d->gc), d->who,
+            //                              (void *) pic_data, len);
         }
 
     } else {
@@ -232,6 +232,7 @@
                     }
                     g_free(thumbnail_base);
                 }
+		g_dir_close(gdir);
             }
             if (do_fetch) {
 

Modified: qrc/trunk/gaym/src/helpers.c
===================================================================
--- qrc/trunk/gaym/src/helpers.c	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/trunk/gaym/src/helpers.c	2005-07-31 03:29:02 UTC (rev 260)
@@ -456,8 +456,11 @@
 
 char *build_tooltip_text(struct gaym_buddy *ib)
 {
+    if(!ib->name)
+	return g_strdup("No info found.");
     char *escaped;
     GString *tooltip = g_string_new("");
+    
     g_string_printf(tooltip, "<b><i>%s</i></b>", ib->name);
 
     g_return_val_if_fail(ib != NULL, NULL);

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-31 03:29:02 UTC (rev 260)
@@ -244,7 +244,7 @@
     if (!gaym || !args || !args[1]) {
         return;
     }
-
+    
     gcom_nick_to_gaym(args[1]);
 
     gaym_buddy_status(gaym, args[1], TRUE, args[5]);
@@ -255,8 +255,8 @@
 
     // Update, but then release the reference. It was already opened
     // during conversation-created.
-    gaym_update_channel_member(gaym, args[1], args[5]);
-    gaym_unreference_channel_member(gaym, args[1]);
+    gaym_update_channel_member(gaym, normalized, args[5]);
+    gaym_unreference_channel_member(gaym, normalized);
     gaim_signal_emit(gaim_accounts_get_handle(), "info-updated",
                      gaym->account, args[1]);
 
@@ -539,11 +539,32 @@
                           const char *from, char **args)
 {
     GaimConnection *gc = gaim_account_get_connection(gaym->account);
+    GaimConversation *convo;
 
+    convo = gaim_find_conversation_with_account(args[1], gaym->account);
+    if (convo) {
+        if (gaim_conversation_get_type(convo) == GAIM_CONV_CHAT) {
+            /* does this happen? */
+            gaim_conv_chat_write(GAIM_CONV_CHAT(convo), args[1],
+                                 _("no such channel"),
+                                 GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
+                                 time(NULL));
+        } else {
+            gaim_conv_im_write(GAIM_CONV_IM(convo), args[1],
+                               _("User is not logged in"),
+                               GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
+                               time(NULL));
+        }
+    } else {
+        if ((gc = gaim_account_get_connection(gaym->account)) == NULL)
+            return;
+        gaim_notify_error(gc, NULL, _("Not logged in: "), args[1]);
+    }
+
     if (gc == NULL || args == NULL || args[1] == NULL)
         return;
-
-    gaim_notify_error(gc, NULL, _("Not logged in:"), args[1]);
+    
+    
 }
 
 void gaym_msg_nonick(struct gaym_conn *gaym, const char *name,

Modified: qrc/trunk/gaym-extras/src/bio-popups.c
===================================================================
--- qrc/trunk/gaym-extras/src/bio-popups.c	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/trunk/gaym-extras/src/bio-popups.c	2005-07-31 03:29:02 UTC (rev 260)
@@ -25,7 +25,7 @@
                               gpointer n)
 {
     // This prevent clicks from demloishing popups.
-    if (e->mode != GDK_CROSSING_NORMAL)
+    if (e->mode != GDK_CROSSING_NORMAL && (e->state & GDK_BUTTON1_MASK))
         return;
 
     guint *timeout = g_hash_table_lookup(popup_timeouts, tv);
@@ -103,7 +103,7 @@
                     pixbuf = gdk_pixbuf_new_from_file(path, &err);
                 g_free(path);
             }
-            g_free(gdir);
+            g_dir_close(gdir);
         }
         g_free(dirname);
     }
@@ -334,7 +334,7 @@
 
     GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
     // Prevent clicks from demolishing popup.
-    if (e->mode != GDK_CROSSING_NORMAL)
+    if (e->mode != GDK_CROSSING_NORMAL && (e->state & GDK_BUTTON1_MASK))
         return;
     GtkWidget *tab = gtkconv->tab_label;
 

Modified: qrc/trunk/gaym-extras/src/gaym-extras.c
===================================================================
--- qrc/trunk/gaym-extras/src/gaym-extras.c	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/trunk/gaym-extras/src/gaym-extras.c	2005-07-31 03:29:02 UTC (rev 260)
@@ -1,7 +1,12 @@
 /* Show icons in chat room windows */
 
-
+//Messy.
 #include "gaym-extras.h"
+#ifdef _WIN32
+#include "win32/win32dep.h"
+#else
+#define DATADIR GAIM_DATADIR
+#endif
 // Adds motion handlers to IM tab labels.
 static void redo_im_window(GaimConversation * c)
 {
@@ -36,9 +41,9 @@
 
     if (!strcmp(dir, "gaim"))
         filename =
-            g_build_filename(GAIM_DATADIR, "pixmaps", "gaim", base, NULL);
+            g_build_filename(DATADIR, "pixmaps", "gaim", base, NULL);
     else {
-        filename = g_build_filename(GAIM_DATADIR, "pixmaps", "gaim", dir,
+        filename = g_build_filename(DATADIR, "pixmaps", "gaim", dir,
                                     base, NULL);
     }
 
@@ -105,10 +110,31 @@
                         "deleting-conversation", plugin,
                         GAIM_CALLBACK(clean_popup_stuff), NULL);
 
+    gaim_prefs_add_none("/plugins/gaym-extras");
+    gaim_prefs_add_none("/plugins/gaym-extras/silly");
+
     extras_register_stock();
+    
     return TRUE;
 }
 
+static GaimPluginPrefFrame *get_plugin_pref_frame(GaimPlugin * plugin)
+{
+    GaimPluginPrefFrame *frame;
+    GaimPluginPref *ppref;
+
+    frame = gaim_plugin_pref_frame_new();
+
+    ppref =
+        gaim_plugin_pref_new_with_name_and_label("/plugins/gaym-extras/silly",_("Do you really want to turn any of this off? ;-)"));
+    gaim_plugin_pref_frame_add(frame, ppref);
+
+      return frame;
+}
+static GaimPluginUiInfo prefs_info = {
+    get_plugin_pref_frame
+};
+
 static GaimPluginInfo info = {
     GAIM_PLUGIN_MAGIC,
     GAIM_MAJOR_VERSION,
@@ -129,7 +155,7 @@
     NULL,
     NULL,
     NULL,
-    NULL,
+    &prefs_info,
     NULL
 };
 

Modified: qrc/trunk/nsis/installer.nsi
===================================================================
--- qrc/trunk/nsis/installer.nsi	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/trunk/nsis/installer.nsi	2005-07-31 03:29:02 UTC (rev 260)
@@ -135,9 +135,9 @@
               Delete "$R1\plugins\${BOT_CHALLENGER_DLL}"
               Delete "$R1\plugins\${GAYM_EXTRAS_DLL}"
               ; pixmaps
-	      Delete "$R1\pixmaps\${ALPHA_PNG}"
-	      Delete "$R1\pixmaps\${ENTRY_PNG}"
-	      Delete "$R1\pixmaps\${PIC_PNG}"
+	      Delete "$R1\pixmaps\gaim\gaym\${ALPHA_PNG}"
+	      Delete "$R1\pixmaps\gaim\gaym\${ENTRY_PNG}"
+	      Delete "$R1\pixmaps\gaim\gaym\${PIC_PNG}"
               Delete "$R1\pixmaps\gaim\status\default\${GAYM_PNG}"
               Delete "$R3"
 
@@ -188,7 +188,7 @@
     SetOutPath "$INSTDIR\pixmaps\gaim\status\default"
     File "..\gaym\pixmaps\${GAYM_PNG}"
     	
-    SetOutPath "$INSTDIR\pixmaps"
+    SetOutPath "$INSTDIR\pixmaps\gaim\gaym"
     File "..\gaym-extras\pixmaps\${ALPHA_PNG}"
     File "..\gaym-extras\pixmaps\${ENTRY_PNG}"
     File "..\gaym-extras\pixmaps\${PIC_PNG}"
@@ -229,9 +229,9 @@
     Delete "$INSTDIR\plugins\${BOT_CHALLENGER_DLL}"
     ; pixmaps
     Delete "$INSTDIR\pixmaps\gaim\status\default\${GAYM_PNG}"
-    Delete "$INSTDIR\pixmaps\${ALPHA_PNG}"
-    Delete "$INSTDIR\pixmaps\${ENTRY_PNG}"
-    Delete "$INSTDIR\pixmaps\${PIC_PNG}"
+    Delete "$INSTDIR\pixmaps\gaim\gaym\${ALPHA_PNG}"
+    Delete "$INSTDIR\pixmaps\gaim\gaym\${ENTRY_PNG}"
+    Delete "$INSTDIR\pixmaps\gaim\gaym\${PIC_PNG}"
     ; uninstaller
     Delete "$INSTDIR\${QRC_UNINST_EXE}"
     ; uninstaller shortcut



From jblebrun at berlios.de  Sun Jul 31 07:33:12 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Sun, 31 Jul 2005 07:33:12 +0200
Subject: [Qrc-svn] r261 - qrc/trunk/gaym/src
Message-ID: <200507310533.j6V5XCKx031263@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-31 07:32:56 +0200 (Sun, 31 Jul 2005)
New Revision: 261

Modified:
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gaym.h
   qrc/trunk/gaym/src/gayminfo.c
   qrc/trunk/gaym/src/gayminfo.h
   qrc/trunk/gaym/src/helpers.c
Log:
Add an invisible token to the end of gaym users biolines.
Misc cleanup


Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-31 03:29:02 UTC (rev 260)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-31 05:32:56 UTC (rev 261)
@@ -300,7 +300,7 @@
     }
 
     bioline =
-        g_strdup_printf("%s#%s\001%s",
+        g_strdup_printf("%s#%s\xC2\xA0 \xC2\xA0\001%s",
                         gaym->thumbnail ? gaym->thumbnail : "",
                         gc->away ? gc->away : (gaym->bio ? gaym->bio : ""),
                         gaym->server_stats ? gaym->server_stats : "");
@@ -596,7 +596,7 @@
 
         login_name =
             gaym_nick_to_gcom_strdup(gaim_connection_get_display_name(gc));
-        bioline = g_strdup_printf("%s#%s\001%s",
+        bioline = g_strdup_printf("%s#%s\xC2\xA0 \xC2\xA0\001%s",
                                   gaym->thumbnail,
                                   user_bioline ? user_bioline : "",
                                   gaym->server_stats ? gaym->

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-31 03:29:02 UTC (rev 260)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-31 05:32:56 UTC (rev 261)
@@ -112,7 +112,6 @@
     gboolean hasFormData;
 
 } GaimUrlSession;
-
 typedef struct gaym_buddy GaymBuddy;
 struct gaym_buddy {
     char *name;                 /* gaym formatted nick */
@@ -124,15 +123,17 @@
     char *sex;                  /* sex string */
     char *age;                  /* age string */
     char *location;             /* location string */
+    gboolean gaymuser;		/* gaym detected */
 };
-
-gboolean gaym_unreference_channel_member(struct gaym_conn *gaym,
-                                         gchar * name);
 GaymBuddy *gaym_get_channel_member_info(struct gaym_conn *gaym,
                                         const gchar * name);
 
 GaymBuddy *gaym_get_channel_member_reference(struct gaym_conn
                                              *gaym, const char *name);
+
+gboolean gaym_unreference_channel_member(struct gaym_conn *gaym,
+                                         gchar * name);
+
 typedef int (*IRCCmdCallback) (struct gaym_conn * gaym, const char *cmd,
                                const char *target, const char **args);
 

Modified: qrc/trunk/gaym/src/gayminfo.c
===================================================================
--- qrc/trunk/gaym/src/gayminfo.c	2005-07-31 03:29:02 UTC (rev 260)
+++ qrc/trunk/gaym/src/gayminfo.c	2005-07-31 05:32:56 UTC (rev 261)
@@ -26,6 +26,14 @@
 #include "util.h"
 #include "debug.h"
 
+//#define GAYM_TOKEN 1
+
+#ifdef GAYM_TOKEN
+gboolean gaym_stats_find_gaym_token(const char* info) {
+    gaim_debug_misc("token","checking for token in %s\n",info);
+    return (gboolean)g_strrstr(info, "\xC2\xA0 \xC2\xA0");
+}
+#endif
 char *gaym_thumbnail_strdup(const char *info)
 {
     char *start = strchr(info, ':');
@@ -45,13 +53,19 @@
 {
     char *start = strchr(info, '#');
     char *end = 0;
-    if (start) {
+    if (start && *start) {
         start++;
         end = strchr(start, 0x01);
         if (!end)
             end = strchr(start, 0);
     }
-
+#ifdef GAYM_TOKEN
+    gaim_debug_misc("gaym","end: %x, end-1: %x, end-5: %x\n",end,*(end-1),*(end-5));
+    if(end-5 >= start)
+	if(!strncmp((end-5),"\xC2\xA0 \xC2\xA0",5))
+	    end-=5;
+#endif
+    gaim_debug_misc("gaym","end %x, start %x\n",end,start);
     if ((end) && (start < end)) {
         return g_strdup_printf("%.*s", end - start, start);
     } else {
@@ -107,6 +121,9 @@
         }
         cm->name = g_strdup(nick);
         cm->bio = gaym_bio_strdup(info);
+#ifdef GAYM_TOKEN
+	cm->gaymuser = gaym_stats_find_gaym_token(info);
+#endif
         cm->thumbnail = gaym_thumbnail_strdup(info);
 
     }
@@ -172,12 +189,16 @@
     char *stats = NULL;
     char *url = NULL;
     struct gaym_fetch_thumbnail_data *data;
+    gboolean gaymuser=FALSE;
 
     if (!gaym || !gaym->account || !gaym->buddies || !name) {
         return;
     }
 
     if (info) {
+#ifdef GAYM_TOKEN
+	gaymuser = gaym_stats_find_gaym_token(info);
+#endif
         bio = gaym_bio_strdup(info);
         if (bio) {
             bio = g_strstrip(bio);
@@ -192,6 +213,8 @@
         if (stats) {
             stats = g_strstrip(stats);
         }
+
+	
     }
 
     GaimConnection *gc = gaim_account_get_connection(gaym->account);
@@ -216,12 +239,7 @@
             if (gdir) {
                 const char *filename;
 
-                while ((filename = g_dir_read_name(gdir)))      // don't
-                    // free
-                    // filename: 
-                    // owned
-                    // by
-                    // glib.
+                while ((filename = g_dir_read_name(gdir)))      /* don't  free  filename:  owned  by glib.*/
                 {
                     char *thumbnail_base = g_path_get_basename(thumbnail);
                     gaim_debug_misc("gaym", "compared %s and %s\n",
@@ -298,6 +316,7 @@
             g_strfreev(s);
             g_free(stats);
         }
+	ib->gaymuser = gaymuser;
         GaimBuddy *buddy = gaim_find_buddy(gaym->account, name);
         if (buddy) {
             serv_got_update(gc, buddy->name, online, 0, 0, 0, 0);

Modified: qrc/trunk/gaym/src/gayminfo.h
===================================================================
--- qrc/trunk/gaym/src/gayminfo.h	2005-07-31 03:29:02 UTC (rev 260)
+++ qrc/trunk/gaym/src/gayminfo.h	2005-07-31 05:32:56 UTC (rev 261)
@@ -41,6 +41,7 @@
     // const char *pic_data;
     // gint pic_data_len;
 };
+
 void gaym_fetch_thumbnail_cb(void *user_data, const char *pic_data,
                              size_t len);
 /**
@@ -67,6 +68,10 @@
  */
 char *gaym_bio_strdup(const char *info);
 
+
+
+gboolean gaym_stats_find_gaym_token(const char* info);
+
 /**
  * Extract the stats string from the extra IRC info about the user.
  * The returned string should be freed when no longer needed.

Modified: qrc/trunk/gaym/src/helpers.c
===================================================================
--- qrc/trunk/gaym/src/helpers.c	2005-07-31 03:29:02 UTC (rev 260)
+++ qrc/trunk/gaym/src/helpers.c	2005-07-31 05:32:56 UTC (rev 261)
@@ -249,9 +249,9 @@
      * just replace \\\n with <space>\n in-place, for speed.
      * */
     char *pos = tmpstr;
-    while ((pos = g_strrstr(pos, "\\\n"))) {
+    while ((pos = strstr(pos, "\\\n"))) {
         *pos = ' ';
-        *(pos + 1) = ' ';
+        *(++pos) = ' ';
     }
     /**
      * We're getting close.  Now we need an array as follows:
@@ -288,7 +288,7 @@
         proparr = g_strsplit(tmparr[i], "=", 2);
         if (proparr[0] && strlen(g_strstrip(proparr[0])) > 0
             && proparr[1] && strlen(g_strstrip(proparr[1])) > 0) {
-
+	    gaim_debug_misc("properties","Inserted %s=%s\n",proparr[0],proparr[1]);
             g_hash_table_insert(props, g_strdup(proparr[0]),
                                 g_strdup(proparr[1]));
 
@@ -492,6 +492,9 @@
         g_free(escaped);
     }
 
+    if (ib->gaymuser) {
+	g_string_append(tooltip, _("\n<i>Gaym user.</i>"));
+    }
     if (tooltip->len == 0) {
         g_string_append_printf(tooltip, _(" No info."));
     }



From jblebrun at berlios.de  Sun Jul 31 09:45:35 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Sun, 31 Jul 2005 09:45:35 +0200
Subject: [Qrc-svn] r262 - in qrc/trunk: gaym/src gaym-extras/src
Message-ID: <200507310745.j6V7jZSR020066@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-31 09:45:24 +0200 (Sun, 31 Jul 2005)
New Revision: 262

Modified:
   qrc/trunk/gaym-extras/src/roombrowse.c
   qrc/trunk/gaym/src/gaym.c
   qrc/trunk/gaym/src/gaym.h
   qrc/trunk/gaym/src/msgs.c
Log:
Hammer system fixed.
I need people to run in debug mode to verify one corner case:
I want to make sure that if you cancel, but the last pending join was actually 
successful, it should just do a part right away.

There will be an obvious debug message when this case occurs. Normally, you will see
HAMMER CANCELLED ON FULL MESSAGE

the case I want to verify will say
JOINED, BUT HAMMER CANCELLED: ABORT!!!!




Modified: qrc/trunk/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-31 05:32:56 UTC (rev 261)
+++ qrc/trunk/gaym/src/gaym.c	2005-07-31 07:45:24 UTC (rev 262)
@@ -493,6 +493,8 @@
     gaym->msgs = g_hash_table_new(g_str_hash, g_str_equal);
     gaym_msg_table_build(gaym);
     gaym->roomlist_filter = NULL;
+
+    gaym->hammers = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, (GDestroyNotify)hammer_cb_data_destroy);
     /**
      * The last parameter needs to be NULL here, since the same
      * field is added for both the key and the value (and if we
@@ -641,6 +643,11 @@
 
     }
 }
+
+void kill_hammer(gpointer* room, struct hammer_cb_data* data, gpointer *null) {
+    hammer_cb_data_destroy(data);
+}
+
 static void gaym_close(GaimConnection * gc)
 {
     struct gaym_conn *gaym = gc->proto_data;
@@ -696,9 +703,7 @@
 
     g_hash_table_destroy(gaym->confighash);
 
-    if (gaym->hammer_cancel_dialog)
-        gaim_request_close(GAIM_REQUEST_ACTION,
-                           gaym->hammer_cancel_dialog);
+    g_hash_table_foreach(gaym->hammers, (GHFunc)kill_hammer, NULL);
 
     g_free(gaym->server);
     g_free(gaym);

Modified: qrc/trunk/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-31 05:32:56 UTC (rev 261)
+++ qrc/trunk/gaym/src/gaym.h	2005-07-31 07:45:24 UTC (rev 262)
@@ -94,9 +94,7 @@
     GHashTable *confighash;
     GHashTable *entry_order;
 
-    char *persist_room;
-    gboolean cancelling_persist;
-    void *hammer_cancel_dialog;
+    GHashTable *hammers;
 
 };
 
@@ -134,6 +132,14 @@
 gboolean gaym_unreference_channel_member(struct gaym_conn *gaym,
                                          gchar * name);
 
+struct hammer_cb_data {
+   struct gaym_conn* gaym;
+   char* room;
+   void* cancel_dialog;
+} hammer_cb_data;
+
+void hammer_cb_data_destroy(struct hammer_cb_data *hdata);
+
 typedef int (*IRCCmdCallback) (struct gaym_conn * gaym, const char *cmd,
                                const char *target, const char **args);
 

Modified: qrc/trunk/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-31 05:32:56 UTC (rev 261)
+++ qrc/trunk/gaym/src/msgs.c	2005-07-31 07:45:24 UTC (rev 262)
@@ -694,6 +694,7 @@
 void gaym_msg_join(struct gaym_conn *gaym, const char *name,
                    const char *from, char **args)
 {
+    gaim_debug_misc("join","got join for %s\n",args[0]);
     GaimConnection *gc = gaim_account_get_connection(gaym->account);
     g_return_if_fail(gc != NULL);
 
@@ -708,6 +709,18 @@
     gcom_nick_to_gaym(nick);
     if (!gaim_utf8_strcasecmp(nick, gaim_connection_get_display_name(gc))) {
         /* We are joining a channel for the first time */
+
+	gpointer data, unused;
+	gboolean hammering=g_hash_table_lookup_extended
+	    (gaym->hammers,args[1],&unused, &data);
+	//There was a hammer, but it is cancelled. Leave!
+	if(hammering && !data) { //hammer was cancelled.
+	    gaim_debug_misc("gaym","JOINED, BUT HAMMER CANCELLED: ABORT!!!!\n");
+	    g_hash_table_remove(gaym->hammers, args[0]);
+	    gaym_cmd_part(gaym, NULL, NULL, (const char**)args);
+	    return;
+	}
+#if 0
         if (gaym->persist_room && !strcmp(gaym->persist_room, args[0])) {
             g_free(gaym->persist_room);
             gaym->persist_room = NULL;
@@ -715,7 +728,8 @@
                                gaym->hammer_cancel_dialog);
 
         }
-
+#endif
+	g_hash_table_remove(gaym->hammers, args[0]);
         serv_got_joined_chat(gc, id++, args[0]);
 
         gint *entry = g_new(gint, 1);
@@ -1145,37 +1159,56 @@
 void gaym_msg_who(struct gaym_conn *gaym, const char *name,
                   const char *from, char **args)
 {
+    //Use the who msgs cross-referenced with the NAMES list to figure out who is who. Resolve conflicts.
+    
 }
 
 void hammer_stop_cb(gpointer data)
 {
+    struct hammer_cb_data* hdata = (struct hammer_cb_data *) data;
 
-    struct gaym_conn *gaym = (struct gaym_conn *) data;
+    gaim_debug_misc("gaym","hammer stopped, dialog is %x\n",hdata->cancel_dialog);
+    //This destroys the hammer data!
+    gaim_debug_misc("gaym", "Cancelling hammer: %s\n",hdata->room);
+    //I'm not sure if the dialog data is freed. 
+    //For now, I assume not. 
+    //hdata->cancel_dialog=0;
+    //The old key gets freed, so strdup it again
+    g_hash_table_replace(hdata->gaym->hammers, g_strdup(hdata->room), NULL); 
+}
 
-    gaym->cancelling_persist = TRUE;
-    gaim_debug_misc("gaym", "Cancelling persist: %s\n",
-                    gaym->persist_room);
+void hammer_cb_data_destroy(struct hammer_cb_data *hdata) {
+    if(!hdata)
+	return;
+    if(hdata->cancel_dialog)
+	gaim_request_close(GAIM_REQUEST_ACTION, hdata->cancel_dialog);
+    if(hdata->room)
+	g_free(hdata->room);
+    g_free(hdata);
 }
 
-void hammer_cb(gpointer data)
+void hammer_cb_no(gpointer data) {
+    hammer_cb_data_destroy(data);
+}
+
+void hammer_cb_yes(gpointer data)
 {
-
-    struct gaym_conn *gaym = (struct gaym_conn *) data;
-    const char *args[1];
+    struct hammer_cb_data *hdata = (struct hammer_cb_data *) data;
+    char* room=g_strdup(hdata->room);
+    const char *args[1]={room};
+    
     char *msg;
-    gaim_debug_misc("gaym", "Persisting room %s\n", gaym->persist_room);
-    args[0] = gaym->persist_room;
-    gaym->cancelling_persist = FALSE;
-    msg = g_strdup_printf("Hammering into room %s", gaym->persist_room);
-    gaym->hammer_cancel_dialog =
-        gaim_request_action(gaym->account->gc, _("Cancel Hammer"), msg,
-                            NULL, 0, gaym, 1, ("Cancel"), hammer_stop_cb);
-
-    gaym_cmd_join(gaym, NULL, NULL, args);
+    msg = g_strdup_printf("Hammering into room %s", hdata->room);
+    hdata->cancel_dialog =
+        gaim_request_action(hdata->gaym->account->gc, _("Cancel Hammer"), msg,
+                            NULL, 0, hdata, 1, ("Cancel"), hammer_stop_cb);
+    g_hash_table_insert(hdata->gaym->hammers, g_strdup(hdata->room), hdata);
+    gaym_cmd_join(hdata->gaym, NULL, NULL, args);
     if (msg)
         g_free(msg);
+    if (room)
+	g_free(room);
 }
-
 void gaym_msg_chanfull(struct gaym_conn *gaym, const char *name,
                        const char *from, char **args)
 {
@@ -1188,27 +1221,33 @@
 
     joinargs[0] = args[1];
 
-    if (gaym->persist_room && !strcmp(gaym->persist_room, args[1]))
-        if (gaym->cancelling_persist) {
-            if (gaym->persist_room) {
-                g_free(gaym->persist_room);
-                gaym->persist_room = NULL;
-            }
-            gaym->cancelling_persist = FALSE;
-        } else {
-            gaim_debug_misc("gaym", "trying again\n");
-            gaym_cmd_join(gaym, NULL, NULL, joinargs);
-    } else {
+    gpointer unused=NULL;
+    gpointer data=NULL;
+    gboolean hammering=g_hash_table_lookup_extended
+	(gaym->hammers,args[1],&unused, &data);
 
-        gaym->persist_room = g_strdup(args[1]);
+    if(hammering && data) {
+        //Add delay here?
+	gaym_cmd_join(gaym, NULL, NULL, joinargs);
+    }
+    else if(hammering && !data) { //hammer was cancelled.
+	    gaim_debug_misc("gaym","HAMMER CANCELLED ON FULL MESSAGE\n");
+	g_hash_table_remove(gaym->hammers, args[1]);
+    }
+    else {
         buf =
             g_strdup_printf("%s is full. Do you want to keep trying?",
                             args[1]);
+	struct hammer_cb_data* hdata = g_new0(struct hammer_cb_data, 1);
+	hdata->gaym=gaym;
+	hdata->room=g_strdup(args[1]);
+	hdata->cancel_dialog=NULL;
         gaim_request_yes_no(gc, _("Room Full"), _("Room Full"), buf, 0,
-                            gaym, hammer_cb, NULL);
+                            hdata, hammer_cb_yes, hammer_cb_no);
 
         g_free(buf);
     }
+	
 }
 
 void gaym_msg_create_pay_only(struct gaym_conn *gaym, const char *name,

Modified: qrc/trunk/gaym-extras/src/roombrowse.c
===================================================================
--- qrc/trunk/gaym-extras/src/roombrowse.c	2005-07-31 05:32:56 UTC (rev 261)
+++ qrc/trunk/gaym-extras/src/roombrowse.c	2005-07-31 07:45:24 UTC (rev 262)
@@ -422,7 +422,7 @@
     *menu = g_list_append(*menu, act);
     // g_free(label);
 }
-static gboolean roombrowse_load(GaimPlugin * plugin)
+static gboolean roombrowse_init()
 {
     gaim_signal_connect(gaim_blist_get_handle(),
                         "blist-node-extended-menu",



From jblebrun at berlios.de  Sun Jul 31 21:07:09 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Sun, 31 Jul 2005 21:07:09 +0200
Subject: [Qrc-svn] r263 - in qrc/branches: . buddy_icon_hack/gaym/src buddy_icon_hack/gaym-extras/src buddy_icon_hack/nsis
Message-ID: <200507311907.j6VJ79Zp022739@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-31 21:07:03 +0200 (Sun, 31 Jul 2005)
New Revision: 263

Added:
   qrc/branches/buddy_icon_hack/
   qrc/branches/buddy_icon_hack/gaym-extras/src/bio-popups.c
   qrc/branches/buddy_icon_hack/gaym-extras/src/gaym-extras.c
   qrc/branches/buddy_icon_hack/gaym-extras/src/roombrowse.c
   qrc/branches/buddy_icon_hack/gaym/src/gaym.c
   qrc/branches/buddy_icon_hack/gaym/src/gaym.h
   qrc/branches/buddy_icon_hack/gaym/src/gayminfo.c
   qrc/branches/buddy_icon_hack/gaym/src/gayminfo.h
   qrc/branches/buddy_icon_hack/gaym/src/helpers.c
   qrc/branches/buddy_icon_hack/gaym/src/msgs.c
   qrc/branches/buddy_icon_hack/nsis/installer.nsi
Removed:
   qrc/branches/buddy_icon_hack/gaym-extras/src/bio-popups.c
   qrc/branches/buddy_icon_hack/gaym-extras/src/gaym-extras.c
   qrc/branches/buddy_icon_hack/gaym-extras/src/roombrowse.c
   qrc/branches/buddy_icon_hack/gaym/src/gaym.c
   qrc/branches/buddy_icon_hack/gaym/src/gaym.h
   qrc/branches/buddy_icon_hack/gaym/src/gayminfo.c
   qrc/branches/buddy_icon_hack/gaym/src/gayminfo.h
   qrc/branches/buddy_icon_hack/gaym/src/helpers.c
   qrc/branches/buddy_icon_hack/gaym/src/msgs.c
   qrc/branches/buddy_icon_hack/nsis/installer.nsi
Log:
Trying out a system that only uses the gaim buddy icon system for popup thumbnails.
It's a hack, because of the way gaim manages buddy icons. In order for it to work for rooms, 
we need to create either a dummy conversation, or a dummy buddy list entry, otherwise, 
when you instantiate a buddy icon, it will be immediately destroyed.

This is because, the only API hook for creating a buddy icon calls create, and then calls update. 
If update does not find a conversation or blist node for the user, the icon is destroyed. You
can not call anything lower level than this function, because it's all static below that.

I'm going to experiment with transient conversations and buddy list entries. 



Copied: qrc/branches/buddy_icon_hack (from rev 259, qrc/trunk)

Deleted: qrc/branches/buddy_icon_hack/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/branches/buddy_icon_hack/gaym/src/gaym.c	2005-07-31 19:07:03 UTC (rev 263)
@@ -1,1632 +0,0 @@
-/**
- * @file gaym.c
- *
- * gaim
- *
- * Copyright (C) 2003, Robbert Haarman <gaim at inglorion.net>
- * Copyright (C) 2003, Ethan Blanton <eblanton at cs.purdue.edu>
- * Copyright (C) 2000-2003, Rob Flynn <rob at tgflinux.com>
- * Copyright (C) 1998-1999, Mark Spencer <markster at marko.net>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "internal.h"
-#include "accountopt.h"
-#include "blist.h"
-#include "conversation.h"
-#include "debug.h"
-#include "notify.h"
-#include "prpl.h"
-#include "plugin.h"
-#include "util.h"
-#include "version.h"
-#include "request.h"
-#include "privacy.h"
-#include "signals.h"
-
-#include "helpers.h"
-#include "gayminfo.h"
-#include "gaympriv.h"
-#include "botfilter.h"
-#include "gaym.h"
-
-static const char *gaym_blist_icon(GaimAccount * a, GaimBuddy * b);
-static void gaym_blist_emblems(GaimBuddy * b, char **se, char **sw,
-                               char **nw, char **ne);
-static GList *gaym_away_states(GaimConnection * gc);
-static GList *gaym_actions(GaimPlugin * plugin, gpointer context);
-/* static GList *gaym_chat_info(GaimConnection *gc); */
-static void gaym_login(GaimAccount * account);
-static void gaym_login_cb(gpointer data, gint source,
-                          GaimInputCondition cond);
-static void gaym_close(GaimConnection * gc);
-static int gaym_im_send(GaimConnection * gc, const char *who,
-                        const char *what, GaimConvImFlags flags);
-static int gaym_chat_send(GaimConnection * gc, int id, const char *what);
-static void gaym_chat_join(GaimConnection * gc, GHashTable * data);
-static void gaym_input_cb(gpointer data, gint source,
-                          GaimInputCondition cond);
-
-static guint gaym_nick_hash(const char *nick);
-static gboolean gaym_nick_equal(const char *nick1, const char *nick2);
-static void gaym_buddy_free(struct gaym_buddy *ib);
-static void gaym_channel_member_free(GaymBuddy * cm);
-
-static void gaym_buddy_append(char *name, struct gaym_buddy *ib,
-                              BListWhois * blist_whois);
-static void gaym_buddy_clear_done(char *name, struct gaym_buddy *ib,
-                                  gpointer nothing);
-
-static GaimPlugin *_gaym_plugin = NULL;
-
-static const char *status_chars = "@+%&";
-
-int gaym_send(struct gaym_conn *gaym, const char *buf)
-{
-    int ret;
-
-    if (gaym->fd < 0)
-        return -1;
-
-    /* gaim_debug(GAIM_DEBUG_MISC, "gaym", "sent: %s", buf); */
-    if ((ret = write(gaym->fd, buf, strlen(buf))) < 0)
-        gaim_connection_error(gaim_account_get_connection(gaym->account),
-                              _("Server has disconnected"));
-
-    return ret;
-}
-
-gboolean gaym_blist_timeout(struct gaym_conn * gaym)
-{
-    /**
-     * There are 510 characters available for an IRC command (512 if
-     * you count CR-LF).  "WHOIS " takes up 6 characters.  Assuming
-     * you need allow an extra character for the NULL when using
-     * g_string_sized_new(), we need to allocate (510-6)+1=505 here.
-     */
-    BListWhois *blist_whois = g_new0(BListWhois, 1);
-    blist_whois->count = 0;
-    blist_whois->string = g_string_sized_new(505);
-
-    char *list, *buf;
-
-    g_hash_table_foreach(gaym->buddies, (GHFunc) gaym_buddy_append,
-                         (gpointer) blist_whois);
-
-    list = g_string_free(blist_whois->string, FALSE);
-    if (!list || !strlen(list)) {
-        g_hash_table_foreach(gaym->buddies, (GHFunc) gaym_buddy_clear_done,
-                             NULL);
-        gaim_timeout_remove(gaym->timer);
-        gaym->timer =
-            gaim_timeout_add(BLIST_UPDATE_PERIOD,
-                             (GSourceFunc) gaym_blist_timeout,
-                             (gpointer) gaym);
-        g_free(list);
-        g_free(blist_whois);
-
-        return TRUE;
-    }
-    gaym->blist_updating = TRUE;
-    buf = gaym_format(gaym, "vn", "WHOIS", list);
-    gaym_send(gaym, buf);
-    gaim_timeout_remove(gaym->timer);
-    gaym->timer =
-        gaim_timeout_add(BLIST_CHUNK_INTERVAL,
-                         (GSourceFunc) gaym_blist_timeout,
-                         (gpointer) gaym);
-
-    g_free(buf);
-    g_free(list);
-    g_free(blist_whois);
-
-    return TRUE;
-}
-
-static void gaym_buddy_clear_done(char *name, struct gaym_buddy *ib,
-                                  gpointer nothing)
-{
-    ib->done = FALSE;
-}
-
-static void gaym_buddy_append(char *name, struct gaym_buddy *ib,
-                              BListWhois * blist_whois)
-{
-    char *converted_name = NULL;
-    converted_name = gaym_nick_to_gcom_strdup(name);
-
-    /**
-     * There are 510 characters available for an IRC command (512 if
-     * you count CR-LF).  "WHOIS " takes up 6 characters.  This means
-     * we have up to 504 characters available for comma separated
-     * converted_names
-     */
-    if (ib->done == FALSE && blist_whois->count < 10
-        && (strlen(converted_name) + blist_whois->string->len + 1) <=
-        504) {
-        blist_whois->count++;
-        ib->done = TRUE;
-        if (blist_whois->string->len == 0) {
-            g_string_append_printf(blist_whois->string, "%s",
-                                   converted_name);
-        } else {
-            g_string_append_printf(blist_whois->string, ",%s",
-                                   converted_name);
-        }
-    }
-
-    g_free(converted_name);
-    return;
-}
-
-static void gaym_whois_one(struct gaym_conn *gaym, struct gaym_buddy *ib)
-{
-    char *buf;
-    char *nick;
-    nick = gaym_nick_to_gcom_strdup(ib->name);
-    buf = gaym_format(gaym, "vn", "WHOIS", nick);
-    gaym_send(gaym, buf);
-    g_free(nick);
-    g_free(buf);
-}
-
-static const char *gaym_blist_icon(GaimAccount * a, GaimBuddy * b)
-{
-    return "gaym";
-}
-
-static void gaym_blist_emblems(GaimBuddy * b, char **se, char **sw,
-                               char **nw, char **ne)
-{
-    if (b->present == GAIM_BUDDY_OFFLINE)
-        *se = "offline";
-}
-
-static char *gaym_status_text(GaimBuddy * buddy)
-{
-    char *status;
-
-    struct gaym_conn *gaym =
-        (struct gaym_conn *) buddy->account->gc->proto_data;
-
-    if (!gaym) {
-        return g_strdup(_("Offline"));
-    }
-
-    struct gaym_buddy *ib =
-        g_hash_table_lookup(gaym->buddies, buddy->name);
-
-    if (!ib) {
-        return g_strdup(_("Offline"));
-    }
-
-    if (!ib->online) {
-        return g_strdup(_("Offline"));
-    }
-
-    if (!ib->bio) {
-        return NULL;
-    }
-
-    status = g_markup_escape_text(ib->bio, strlen(ib->bio));
-
-    return status;
-}
-
-static char *gaym_tooltip_text(GaimBuddy * buddy)
-{
-    struct gaym_conn *gaym =
-        (struct gaym_conn *) buddy->account->gc->proto_data;
-
-    if (!gaym) {
-        return NULL;
-    }
-
-    struct gaym_buddy *ib =
-        g_hash_table_lookup(gaym->channel_members, buddy->name);
-
-    if (!ib)
-        ib = g_hash_table_lookup(gaym->buddies, buddy->name);
-
-    if (!ib) {
-        return NULL;
-    }
-
-    return build_tooltip_text(ib);
-}
-
-static GList *gaym_away_states(GaimConnection * gc)
-{
-    return g_list_prepend(NULL, (gpointer) GAIM_AWAY_CUSTOM);
-}
-
-static void gaym_set_info(GaimConnection * gc, const char *info)
-{
-    struct gaym_conn *gaym = gc->proto_data;
-    GaimAccount *account = gaim_connection_get_account(gc);
-    char *hostname = "none";
-    char *buf, *bioline;
-    int i = 0;
-
-    char *tmpinfo = NULL;
-    if (info) {
-        tmpinfo = g_strdup(info);
-        for (i = 0; i < strlen(tmpinfo); i++) {
-            if (tmpinfo[i] == '\n') {
-                tmpinfo[i] = ' ';
-            }
-        }
-        tmpinfo = g_strstrip(tmpinfo);
-    }
-
-    if (gc->away && !tmpinfo) {
-        /**
-         * don't change any bio settings, since this is just
-         * setting an away message
-         */
-    } else {
-        if (gaym->bio) {
-            g_free(gaym->bio);
-        }
-        if (tmpinfo && strlen(tmpinfo) > 0) {
-            gaim_debug_misc("gaym", "option1, info=%x\n", tmpinfo);
-            /* java client allows MAX_BIO_LEN characters */
-            gaym->bio = g_strndup(tmpinfo, MAX_BIO_LEN);
-        } else if (gaym->server_bioline
-                   && strlen(gaym->server_bioline) > 0) {
-            gaim_debug_misc("gaym", "option2\n");
-            gaym->bio = gaym_bio_strdup(gaym->server_bioline);
-        } else {
-            gaim_debug_misc("gaym", "option3\n");
-            gaym->bio = g_strdup("Gaim User");
-        }
-        gaim_account_set_user_info(account, gaym->bio);
-        gaim_account_set_string(account, "bioline", gaym->bio);
-        gaim_debug_info("gaym", "INFO=%x BIO=%x\n", tmpinfo, gaym->bio);
-        gaim_debug_misc("gaym", "In login_cb, gc->account=%x\n",
-                        gc->account);
-    }
-
-    bioline =
-        g_strdup_printf("%s#%s\001%s",
-                        gaym->thumbnail ? gaym->thumbnail : "",
-                        gc->away ? gc->away : (gaym->bio ? gaym->bio : ""),
-                        gaym->server_stats ? gaym->server_stats : "");
-
-    buf = gaym_format(gaym, "vvvv:", "USER",
-                      gaim_account_get_username(account),
-                      hostname, gaym->server, bioline);
-
-    gaim_debug_misc("gaym", "BIO=%x\n", bioline);
-
-    if (gaym_send(gaym, buf) < 0) {
-        gaim_connection_error(gc, "Error registering with server");
-    }
-
-    if (tmpinfo) {
-        g_free(tmpinfo);
-    }
-    g_free(bioline);
-    g_free(buf);
-
-    return;
-}
-
-static void gaym_show_set_info(GaimPluginAction * action)
-{
-    GaimConnection *gc = (GaimConnection *) action->context;
-    gaim_account_request_change_user_info(gaim_connection_get_account(gc));
-}
-
-static GList *gaym_actions(GaimPlugin * plugin, gpointer context)
-{
-    GList *list = NULL;
-    GaimPluginAction *act = NULL;
-
-    act = gaim_plugin_action_new(_("Change Bio"), gaym_show_set_info);
-    list = g_list_prepend(list, act);
-
-    return list;
-}
-
-static void gaym_blist_join_chat_cb(GaimBlistNode * node, gpointer data)
-{
-    const char *args[1];
-
-    GaimChat *chat = (GaimChat *) node;
-    struct gaym_conn *gaym = chat->account->gc->proto_data;
-    args[0] = data;
-
-    g_return_if_fail(args[0] != NULL);
-    g_return_if_fail(gaym != NULL);
-
-    gaym_cmd_join(gaym, "join", NULL, args);
-}
-
-static GList *gaym_blist_node_menu(GaimBlistNode * node)
-{
-    GList *m = NULL;
-    GaimBlistNodeAction *act = NULL;
-    int i = 0;
-
-    if (node->type != GAIM_BLIST_CHAT_NODE) {
-        return m;
-    }
-
-    GaimChat *chat = (GaimChat *) node;
-    char *channel = g_hash_table_lookup(chat->components, "channel");
-
-    if (!channel) {
-        return m;
-    }
-
-    if (!g_str_has_suffix(channel, "=*")) {
-        return m;
-    }
-
-    char *label = NULL;
-    char *instance = NULL;
-
-    int max = gaim_prefs_get_int("/plugins/prpl/gaym/chat_room_instances");
-
-    for (i = max; i > 0; i--) {
-        label = g_strdup_printf(_("Join Room %d"), i);
-        instance =
-            g_strdup_printf("%.*s%d", strlen(channel) - 1, channel, i);
-        act =
-            gaim_blist_node_action_new(label, gaym_blist_join_chat_cb,
-                                       instance);
-        m = g_list_prepend(m, act);
-    }
-    return m;
-}
-
-static GList *gaym_chat_join_info(GaimConnection * gc)
-{
-    GList *m = NULL;
-    struct proto_chat_entry *pce;
-
-    pce = g_new0(struct proto_chat_entry, 1);
-    pce->label = _("_Room:");
-    pce->identifier = "channel";
-    m = g_list_prepend(m, pce);
-
-    return m;
-}
-
-GHashTable *gaym_chat_info_defaults(GaimConnection * gc,
-                                    const char *chat_name)
-{
-    GHashTable *defaults;
-
-    defaults =
-        g_hash_table_new_full(g_str_hash, g_str_equal, NULL, g_free);
-
-    if (chat_name != NULL)
-        g_hash_table_insert(defaults, "channel", g_strdup(chat_name));
-
-    return defaults;
-}
-
-static void gaym_login_with_chat_key(GaimAccount * account)
-{
-    GaimConnection *gc;
-    struct gaym_conn *gaym;
-    char *buf;
-    const char *username = gaim_account_get_username(account);
-    int err;
-
-    gc = gaim_account_get_connection(account);
-    gaym = gc->proto_data;
-
-    buf = g_strdup_printf(_("Signon: %s"), username);
-    gaim_connection_update_progress(gc, buf, 5, 6);
-    g_free(buf);
-    gaim_debug_misc("gaym", "Trying login to %s\n", gaym->server);
-    err = gaim_proxy_connect(account, gaym->server,
-                             gaim_account_get_int(account, "port",
-                                                  IRC_DEFAULT_PORT),
-                             gaym_login_cb, gc);
-    if (err || !account->gc) {
-        gaim_connection_error(gc, _("Couldn't create socket"));
-        gaim_debug_misc("gaym", "err: %d, account->gc: %x\n", err,
-                        account->gc);
-        return;
-    }
-
-}
-
-static void gaym_login(GaimAccount * account)
-{
-    GaimConnection *gc;
-    struct gaym_conn *gaym;
-    char *buf;
-    const char *username = gaim_account_get_username(account);
-
-    gc = gaim_account_get_connection(account);
-    gc->flags |= GAIM_CONNECTION_NO_NEWLINES | GAIM_CONNECTION_AUTO_RESP;
-
-    if (strpbrk(username, " \t\v\r\n") != NULL) {
-        gaim_connection_error(gc,
-                              _("IRC nicks may not contain whitespace"));
-        return;
-    }
-
-    gc->proto_data = gaym = g_new0(struct gaym_conn, 1);
-    gaym->account = account;
-
-
-    /**
-     * gaim_connection_set_display_name(gc, userparts[0]);
-     */
-    gaim_connection_set_display_name(gc, username);
-    gaym->server =
-        g_strdup(gaim_account_get_string
-                 (account, "server", "www.gay.com"));
-    /**
-     * gaym->server = "www.gay.com";
-     */
-    gaym->buddies =
-        g_hash_table_new_full((GHashFunc) gaym_nick_hash,
-                              (GEqualFunc) gaym_nick_equal, NULL,
-                              (GDestroyNotify) gaym_buddy_free);
-
-    gaym->channel_members =
-        g_hash_table_new_full((GHashFunc) gaym_nick_hash,
-                              (GEqualFunc) gaym_nick_equal, NULL,
-                              (GDestroyNotify) gaym_channel_member_free);
-
-    gaym->cmds = g_hash_table_new(g_str_hash, g_str_equal);
-    gaym_cmd_table_build(gaym);
-    gaym->msgs = g_hash_table_new(g_str_hash, g_str_equal);
-    gaym_msg_table_build(gaym);
-    gaym->roomlist_filter = NULL;
-    /**
-     * The last parameter needs to be NULL here, since the same
-     * field is added for both the key and the value (and if we
-     * free it twice, thats bad and causes crashing!).
-     */
-    gaym->info_window_needed =
-        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
-
-    gaym->entry_order =
-        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
-
-    /**
-     * This is similar to gaym->info_window_needed, except this is
-     * for thumbails inside the IM conversation window if the
-     * person is not already on the buddy list
-     */
-
-    buf = g_strdup_printf(_("Signon: %s"), username);
-    gaim_connection_update_progress(gc, buf, 1, 6);
-    g_free(buf);
-
-
-    /**
-     * Making a change to try cached password first.
-     * gaym_try_cached_password(account, gaym_login_with_chat_key);
-     */
-    gaym_get_chat_key_from_weblogin(account, gaym_login_with_chat_key);
-}
-
-
-static void gaym_get_configtxt_cb(gpointer proto_data,
-                                  const gchar * config_text, size_t len)
-{
-    struct gaym_conn *gaym = (struct gaym_conn *) proto_data;
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-
-    g_return_if_fail(config_text != NULL);
-
-    gaym->confighash = gaym_properties_new(config_text);
-    g_return_if_fail(gaym->confighash != NULL);
-
-    // synchronize_deny_list(gc, gaym->confighash);
-
-    return;
-}
-static void gaym_login_cb(gpointer data, gint source,
-                          GaimInputCondition cond)
-{
-    GaimConnection *gc = data;
-    struct gaym_conn *gaym = gc->proto_data;
-    char hostname[256];
-    char *buf;
-    const char *username;
-    const char *user_bioline = NULL;
-    char *bioline;
-    char *login_name;
-
-    if (GAIM_CONNECTION_IS_VALID(gc)) {
-
-
-        GList *connections = gaim_connections_get_all();
-
-        if (source < 0) {
-            gaim_connection_error(gc, _("Couldn't connect to host"));
-            return;
-        }
-
-        if (!g_list_find(connections, gc)) {
-            close(source);
-            return;
-        }
-
-        gaym->fd = source;
-        gaim_debug_misc("gaym", "In login_cb with chat_key=%s\n",
-                        gaym->chat_key);
-        if (gaym->chat_key) {
-
-            buf = gaym_format(gaym, "vv", "PASS", gaym->chat_key);
-            if (gaym_send(gaym, buf) < 0) {
-                gaim_connection_error(gc, "Error sending password");
-                return;
-            }
-            g_free(buf);
-        } else {
-            gaim_connection_error(gc,
-                                  _
-                                  ("Password wasn't recorded. Report bug."));
-            return;
-        }
-        gethostname(hostname, sizeof(hostname));
-        hostname[sizeof(hostname) - 1] = '\0';
-        username = gaim_account_get_string(gaym->account, "username", "");
-        user_bioline =
-            g_strdup(gaim_account_get_string
-                     (gaym->account, "bioline", ""));
-        gaim_debug_info("gaym", "USER BIOLINE=%x\n", user_bioline);
-        gaim_account_set_user_info(gc->account, user_bioline);
-        gaim_debug_misc("gaym",
-                        "In login_cb, user_bioline: %x, gc->account=%x\n",
-                        user_bioline, gc->account);
-
-        login_name =
-            gaym_nick_to_gcom_strdup(gaim_connection_get_display_name(gc));
-        bioline = g_strdup_printf("%s#%s\001%s",
-                                  gaym->thumbnail,
-                                  user_bioline ? user_bioline : "",
-                                  gaym->server_stats ? gaym->
-                                  server_stats : "");
-
-        buf = gaym_format(gaym, "vn", "NICK", login_name);
-        gaim_debug_misc("gaym", "Command: %s\n", buf);
-
-        if (gaym_send(gaym, buf) < 0) {
-            gaim_connection_error(gc, "Error sending nickname");
-            return;
-        }
-        g_free(buf);
-        buf =
-            gaym_format(gaym, "vvvv:", "USER", login_name, hostname,
-                        gaym->server, bioline);
-
-        gaim_debug_misc("gaym", "Command: %s\n", buf);
-        if (gaym_send(gaym, buf) < 0) {
-            gaim_connection_error(gc, "Error registering with server");
-            return;
-        }
-        g_free(login_name);
-        g_free(buf);
-
-        const char *server = gaim_account_get_string(gc->account, "server",
-                                                     IRC_DEFAULT_SERVER);
-        char *url =
-            g_strdup_printf
-            ("http://%s/messenger/config.txt?%s", server, gaym->chat_key);
-
-        char *user_agent = "Mozilla/4.0";
-
-        get_spamlist_from_web();
-        gaim_url_fetch(url, FALSE, user_agent, FALSE,
-                       gaym_get_configtxt_cb, gaym);
-
-        g_free(url);
-        gc->inpa =
-            gaim_input_add(gaym->fd, GAIM_INPUT_READ, gaym_input_cb, gc);
-
-
-    }
-}
-static void gaym_close(GaimConnection * gc)
-{
-    struct gaym_conn *gaym = gc->proto_data;
-
-    gaim_debug_misc("gaym", "gaym close function has been called\n");
-    if (gaym == NULL)
-        return;
-
-    gaym_cmd_quit(gaym, "quit", NULL, NULL);
-
-    if (gc->inpa)
-        gaim_input_remove(gc->inpa);
-
-    g_free(gaym->inbuf);
-    gaim_debug_misc("gaym", "closing fd %i\n", gaym->fd);
-    close(gaym->fd);
-
-    if (gaym->timer)
-        gaim_timeout_remove(gaym->timer);
-
-    if (gaym->thumbnail)
-        g_free(gaym->thumbnail);
-
-    if (gaym->chat_key)
-        g_free(gaym->chat_key);
-
-    if (gaym->server_bioline)
-        g_free(gaym->server_bioline);
-
-    if (gaym->server_stats)
-        g_free(gaym->server_stats);
-
-    if (gaym->roomlist_filter)
-        g_free(gaym->roomlist_filter);
-
-    if (gaym->bio)
-        g_free(gaym->bio);
-
-    g_hash_table_destroy(gaym->cmds);
-    g_hash_table_destroy(gaym->msgs);
-    g_hash_table_destroy(gaym->info_window_needed);
-    g_hash_table_destroy(gaym->entry_order);
-    if (gaym->motd)
-        g_string_free(gaym->motd, TRUE);
-
-    if (gaym->names)
-        g_string_free(gaym->names, TRUE);
-
-    if (gaym->nameconv)
-        g_free(gaym->nameconv);
-    if (gaym->subroom)
-        g_free(gaym->subroom);
-
-    g_hash_table_destroy(gaym->confighash);
-
-    if (gaym->hammer_cancel_dialog)
-        gaim_request_close(GAIM_REQUEST_ACTION,
-                           gaym->hammer_cancel_dialog);
-
-    g_free(gaym->server);
-    g_free(gaym);
-}
-
-static int gaym_im_send(GaimConnection * gc, const char *who,
-                        const char *what, GaimConvImFlags flags)
-{
-    struct gaym_conn *gaym = gc->proto_data;
-    const char *args[2];
-    char *automsg = NULL;
-    char *stripped_msg = NULL;
-    if (strchr(status_chars, *who) != NULL) {
-        args[0] = who + 1;
-    } else {
-        args[0] = who;
-    }
-    if (flags & GAIM_CONV_IM_AUTO_RESP) {
-        stripped_msg = gaim_markup_strip_html(what);
-        automsg = g_strdup_printf("<AUTO-REPLY> %s", stripped_msg);
-        g_free(stripped_msg);
-        args[1] = automsg;
-
-    } else {
-        args[1] = what;
-    }
-    gaym_cmd_privmsg(gaym, "msg", NULL, args);
-    if (automsg) {
-        g_free(automsg);
-    }
-    return 1;
-}
-
-static void gaym_get_info(GaimConnection * gc, const char *who)
-{
-    struct gaym_conn *gaym = gc->proto_data;
-    const char *args[1];
-    args[0] = who;
-
-    char *normalized = g_strdup(gaim_normalize(gc->account, who));
-    /**
-     * We are adding the same char* to both the key and the value.
-     * If this changes, we need to change the corresponding
-     * g_hash_table_new_full() so that things are properly cleaned
-     * up during the remove/destroy phase.
-     */
-    g_hash_table_insert(gaym->info_window_needed, normalized, normalized);
-    gaym_cmd_whois(gaym, "whois", NULL, args);
-}
-
-static void gaym_set_away(GaimConnection * gc, const char *state,
-                          const char *msg)
-{
-    char *bio = NULL;
-    char *tmpmsg = NULL;
-    int i = 0;
-    struct gaym_conn *gaym = gc->proto_data;
-
-    if (gc->away) {
-        g_free(gc->away);
-        gc->away = NULL;
-    }
-
-    /**
-     * In addition to setting the away message, set the Bio to the
-     * away message; if the away message is NULL, then set the Bio
-     * to the original bio.
-     */
-
-    if (msg) {
-        tmpmsg = g_strdup(msg);
-        for (i = 0; i < strlen(tmpmsg); i++) {
-            if (tmpmsg[i] == '\n') {
-                tmpmsg[i] = ' ';
-            }
-        }
-        tmpmsg = g_strstrip(tmpmsg);
-
-        gc->away = g_strndup(tmpmsg, MAX_BIO_LEN);
-        gaym_set_info(gc, NULL);
-        g_free(tmpmsg);
-    } else {
-        if (gaym && gaym->bio) {
-            bio = g_strdup(gaym->bio);
-            gaym_set_info(gc, bio);
-            g_free(bio);
-        } else {
-            gaym_set_info(gc, NULL);
-        }
-    }
-
-    /**
-     *  The following would be great, and gay.com's server supports
-     *  it, but gay.com's clients don't see the result.  So even though
-     *  we can see the result, we won't bother.
-     *
-     * args[0] = msg;
-     * gaym_cmd_away(gaym, "away", NULL, args);
-     */
-}
-
-GaymBuddy *gaym_get_channel_member_reference(struct gaym_conn
-                                             *gaym, const gchar * name)
-{
-
-    GaymBuddy *channel_member =
-        (GaymBuddy *) g_hash_table_lookup(gaym->channel_members,
-                                          name);
-
-    if (!channel_member) {
-        GaymBuddy *channel_member = g_new0(GaymBuddy, 1);
-        channel_member->ref_count = 1;
-        g_hash_table_insert(gaym->channel_members, g_strdup(name),
-                            channel_member);
-        gaim_debug_misc("gaym", "Creating channel_members entry for %s\n",
-                        name);
-        return g_hash_table_lookup(gaym->channel_members, name);
-    } else {
-        gaim_debug_misc("gaym",
-                        "Adding reference to channel_members entry for %s\n",
-                        name);
-        (channel_member->ref_count)++;
-        return channel_member;
-    }
-
-}
-
-gboolean gaym_unreference_channel_member(struct gaym_conn * gaym,
-                                         gchar * name)
-{
-
-    GaymBuddy *channel_member;
-    channel_member =
-        (GaymBuddy *) g_hash_table_lookup(gaym->channel_members, name);
-    if (!channel_member)
-        return FALSE;
-    else {
-
-        if (channel_member->ref_count <= 0)
-            gaim_debug_error("gaym",
-                             "****Reference counting error with channel members struct.\n");
-
-        channel_member->ref_count--;
-
-        if (channel_member->ref_count == 0) {
-            gaim_debug_misc("gaym", "Removing %s from channel_members\n",
-                            name);
-            return g_hash_table_remove(gaym->channel_members, name);
-        }
-        return FALSE;
-    }
-}
-
-static void gaym_add_buddy(GaimConnection * gc, GaimBuddy * buddy,
-                           GaimGroup * group)
-{
-    if (buddy->name) {
-        buddy->name = g_strstrip(buddy->name);
-    }
-    if (buddy->alias) {
-        buddy->alias = g_strstrip(buddy->alias);
-    }
-    if (buddy->server_alias) {
-        buddy->server_alias = g_strstrip(buddy->server_alias);
-    }
-    struct gaym_conn *gaym = (struct gaym_conn *) gc->proto_data;
-    struct gaym_buddy *ib = g_new0(struct gaym_buddy, 1);
-    ib->name = g_strdup(buddy->name);
-    ib->done = FALSE;
-    ib->online = FALSE;
-    ib->bio = NULL;
-    ib->thumbnail = NULL;
-    ib->sex = NULL;
-    ib->age = NULL;
-    ib->location = NULL;
-    g_hash_table_replace(gaym->buddies, ib->name, ib);
-    gaim_debug_misc("gaym", "Add buddy: %s\n", buddy->name);
-    /**
-     * if the timer isn't set, this is during signon, so we don't want to
-     * flood ourself off with WHOIS's, so we don't, but after that we want
-     * to know when someone's online asap
-     */
-    if (gaym->timer)
-        gaym_whois_one(gaym, ib);
-}
-
-static void gaym_remove_buddy(GaimConnection * gc, GaimBuddy * buddy,
-                              GaimGroup * group)
-{
-    struct gaym_conn *gaym = (struct gaym_conn *) gc->proto_data;
-
-    /**
-     * Only remove buddy->name from gaym->buddies if it doesn't
-     * exist in any other group on the buddy list.  This allows us
-     * to manage the buddy once, even though it might exist in
-     * several groups within the buddy list.
-     *
-     * To add to confusion, the buddy being deleted is not yet deleted,
-     * so we look for less than two identical buddies, and if so, then
-     * remove the buddy from gaym->buddies.
-     */
-
-    GSList *buddies = gaim_find_buddies(gaym->account, buddy->name);
-    guint length = g_slist_length(buddies);
-
-    if (length < 2) {
-        g_hash_table_remove(gaym->buddies, buddy->name);
-    }
-
-    g_slist_free(buddies);
-}
-
-static void gaym_input_cb(gpointer data, gint source,
-                          GaimInputCondition cond)
-{
-    GaimConnection *gc = data;
-    struct gaym_conn *gaym = gc->proto_data;
-    char *cur, *end;
-    int len;
-
-    if (gaym->inbuflen < gaym->inbufused + IRC_INITIAL_BUFSIZE) {
-        gaym->inbuflen += IRC_INITIAL_BUFSIZE;
-        gaym->inbuf = g_realloc(gaym->inbuf, gaym->inbuflen);
-    }
-
-    if ((len =
-         read(gaym->fd, gaym->inbuf + gaym->inbufused,
-              IRC_INITIAL_BUFSIZE - 1)) < 0) {
-        gaim_connection_error(gc, _("Read error"));
-        return;
-    } else if (len == 0) {
-        gaim_connection_error(gc, _("Server has disconnected"));
-        return;
-    }
-
-    gaym->inbufused += len;
-    gaym->inbuf[gaym->inbufused] = '\0';
-
-    cur = gaym->inbuf;
-    while (cur < gaym->inbuf + gaym->inbufused &&
-           ((end = strstr(cur, "\r\n")) || (end = strstr(cur, "\n")))) {
-        int step = (*end == '\r' ? 2 : 1);
-        *end = '\0';
-        gaym_parse_msg(gaym, cur);
-        cur = end + step;
-    }
-    if (cur != gaym->inbuf + gaym->inbufused) { /* leftover */
-        gaym->inbufused -= (cur - gaym->inbuf);
-        memmove(gaym->inbuf, cur, gaym->inbufused);
-    } else {
-        gaym->inbufused = 0;
-    }
-}
-
-static void gaym_add_permit(GaimConnection * gc, const char *name)
-{
-    if (!gaym_nick_check(name)) {
-        gaim_privacy_permit_remove(gc->account, name, TRUE);
-        gaim_notify_error(gc, _("Invalid User Name"), name,
-                          _("Invalid user name not added."));
-    } else {
-        gaym_privacy_change(gc, name);
-    }
-}
-
-static void gaym_add_deny(GaimConnection * gc, const char *name)
-{
-    if (!gaym_nick_check(name)) {
-        gaim_privacy_deny_remove(gc->account, name, TRUE);
-        gaim_notify_error(gc, _("Invalid User Name"), name,
-                          _("Invalid user name not added."));
-        return;
-    }
-    gaym_server_store_deny(gc, name, TRUE);
-    gaym_privacy_change(gc, name);
-}
-
-static void gaym_rem_permit(GaimConnection * gc, const char *name)
-{
-    gaym_privacy_change(gc, name);
-}
-
-static void gaym_rem_deny(GaimConnection * gc, const char *name)
-{
-    gaym_server_store_deny(gc, name, FALSE);
-    gaym_privacy_change(gc, name);
-}
-
-static void gaym_set_permit_deny(GaimConnection * gc)
-{
-    gaym_privacy_change(gc, NULL);
-}
-
-static void gaym_warn(GaimConnection * gc, const char *who,
-                      gboolean anonymous)
-{
-    void *handle = NULL;
-    struct gaym_conn *gaym = gc->proto_data;
-    char *buf =
-        g_strdup_printf
-        ("http://%s/members/report/form.html?area=chat&room=&report=%s",
-         gaym->server, who);
-    gaim_notify_uri(handle, buf);
-    g_free(buf);
-}
-
-static void gaym_chat_join(GaimConnection * gc, GHashTable * data)
-{
-    struct gaym_conn *gaym = gc->proto_data;
-    const char *args[1];
-    char *alias = NULL;
-
-    GaimChat *c = NULL;
-
-    /**
-     * need a copy, because data gets
-     * destroyed in roomlist.c
-     */
-    GHashTable *chatinfo = NULL;
-
-    args[0] = g_hash_table_lookup(data, "channel");
-
-    if (args[0]) {
-        alias = g_hash_table_lookup(data, "description");
-        c = gaim_blist_find_chat(gaim_connection_get_account(gc), args[0]);
-        if (!c) {
-            chatinfo = g_hash_table_new(g_str_hash, g_str_equal);
-
-            g_hash_table_replace(chatinfo, "channel", g_strdup(args[0]));
-
-            c = gaim_chat_new(gaim_connection_get_account(gc),
-                              alias, chatinfo);
-
-            gaim_blist_add_chat(c, NULL, NULL);
-        }
-    }
-
-    if (!args[0] || *args[0] != '#') {
-        /**
-         * Trigger a room search in config.txt....
-         */
-        return;
-    }
-
-    gaym_cmd_join(gaym, "join", NULL, args);
-}
-
-static char *gaym_get_chat_name(GHashTable * data)
-{
-    return g_strdup(g_hash_table_lookup(data, "channel"));
-}
-
-static void gaym_chat_invite(GaimConnection * gc, int id,
-                             const char *message, const char *name)
-{
-    struct gaym_conn *gaym = gc->proto_data;
-    GaimConversation *convo = gaim_find_chat(gc, id);
-    const char *args[2];
-
-    if (!convo) {
-        gaim_debug(GAIM_DEBUG_ERROR, "gaym",
-                   "Got chat invite request for bogus chat\n");
-        return;
-    }
-    args[0] = name;
-    args[1] = gaim_conversation_get_name(convo);
-    gaym_cmd_invite(gaym, "invite", gaim_conversation_get_name(convo),
-                    args);
-}
-
-static void gaym_chat_leave(GaimConnection * gc, int id)
-{
-    struct gaym_conn *gaym = gc->proto_data;
-    GaimConversation *convo = gaim_find_chat(gc, id);
-    const char *args[2];
-
-    if (!convo)
-        return;
-
-    args[0] = gaim_conversation_get_name(convo);
-    args[1] = NULL;
-    gaym_cmd_part(gaym, "part", gaim_conversation_get_name(convo), args);
-    serv_got_chat_left(gc, id);
-}
-
-static int gaym_chat_send(GaimConnection * gc, int id, const char *what)
-{
-    struct gaym_conn *gaym = gc->proto_data;
-    GaimConversation *convo = gaim_find_chat(gc, id);
-    const char *args[2];
-    char *tmp;
-
-    if (!convo) {
-        gaim_debug(GAIM_DEBUG_ERROR, "gaym",
-                   "chat send on nonexistent chat\n");
-        return -EINVAL;
-    }
-#if 0
-    if (*what == '/') {
-        return gaym_parse_cmd(gaym, convo->name, what + 1);
-    }
-#endif
-    args[0] = convo->name;
-    args[1] = what;
-
-    gaym_cmd_privmsg(gaym, "msg", NULL, args);
-
-    tmp = gaim_escape_html(what);
-    serv_got_chat_in(gc, id, gaim_connection_get_display_name(gc), 0, tmp,
-                     time(NULL));
-    g_free(tmp);
-    return 0;
-}
-
-static guint gaym_nick_hash(const char *nick)
-{
-    char *lc = NULL;
-    guint bucket;
-
-    if (!nick)
-        return 0;
-    lc = g_utf8_strdown(nick, -1);
-    bucket = g_str_hash(lc);
-    g_free(lc);
-
-    return bucket;
-}
-
-static gboolean gaym_nick_equal(const char *nick1, const char *nick2)
-{
-    return (gaim_utf8_strcasecmp(nick1, nick2) == 0);
-}
-
-static void gaym_channel_member_free(GaymBuddy * cm)
-{
-    g_free(cm->name);
-    g_free(cm->bio);
-    g_free(cm->thumbnail);
-    g_free(cm->sex);
-    g_free(cm->age);
-    g_free(cm->location);
-    g_free(cm);
-}
-
-static void gaym_buddy_free(struct gaym_buddy *ib)
-{
-    g_free(ib->name);
-    g_free(ib->bio);
-    g_free(ib->thumbnail);
-    g_free(ib->sex);
-    g_free(ib->age);
-    g_free(ib->location);
-    g_free(ib);
-}
-
-static GaimChat *gaym_find_blist_chat(GaimAccount * account,
-                                      const char *name)
-{
-    char *chat_name;
-    GaimChat *chat;
-    GaimPlugin *prpl;
-    GaimPluginProtocolInfo *prpl_info = NULL;
-    struct proto_chat_entry *pce;
-    GaimBlistNode *node, *group;
-    GList *parts;
-
-    GaimBuddyList *gaimbuddylist = gaim_get_blist();
-
-    g_return_val_if_fail(gaimbuddylist != NULL, NULL);
-    g_return_val_if_fail((name != NULL) && (*name != '\0'), NULL);
-
-    if (!gaim_account_is_connected(account))
-        return NULL;
-
-    prpl = gaim_find_prpl(gaim_account_get_protocol_id(account));
-    prpl_info = GAIM_PLUGIN_PROTOCOL_INFO(prpl);
-
-    for (group = gaimbuddylist->root; group != NULL; group = group->next) {
-        for (node = group->child; node != NULL; node = node->next) {
-            if (GAIM_BLIST_NODE_IS_CHAT(node)) {
-
-                chat = (GaimChat *) node;
-
-                if (account != chat->account)
-                    continue;
-
-                parts =
-                    prpl_info->
-                    chat_info(gaim_account_get_connection(chat->account));
-
-                pce = parts->data;
-                chat_name = g_hash_table_lookup(chat->components,
-                                                pce->identifier);
-
-                if (chat->account == account && chat_name != NULL &&
-                    name != NULL
-                    && g_pattern_match_simple(chat_name, name)) {
-
-                    return chat;
-                }
-            }
-        }
-    }
-
-    return NULL;
-}
-
-static GaimRoomlist *gaym_roomlist_get_list(GaimConnection * gc)
-{
-    struct gaym_conn *gaym;
-    GList *fields = NULL;
-    GaimRoomlistField *f;
-    char *buf;
-
-    gaym = gc->proto_data;
-
-    if (gaym->roomlist) {
-        gaim_roomlist_unref(gaym->roomlist);
-    }
-
-    gaym->roomlist = gaim_roomlist_new(gaim_connection_get_account(gc));
-
-    f = gaim_roomlist_field_new(GAIM_ROOMLIST_FIELD_STRING, _("Channel"),
-                                "channel", FALSE);
-    fields = g_list_prepend(fields, f);
-
-    f = gaim_roomlist_field_new(GAIM_ROOMLIST_FIELD_STRING, "",
-                                "description", TRUE);
-    fields = g_list_prepend(fields, f);
-
-    gaim_roomlist_set_fields(gaym->roomlist, fields);
-
-    /**
-     * Member created rooms are retrieved through the IRC protocol
-     * and after the last response is recieved from that request
-     * the static rooms are added
-     */
-
-    buf = gaym_format(gaym, "v", "LIST #_*");
-    gaym_send(gaym, buf);
-    g_free(buf);
-
-    return gaym->roomlist;
-}
-
-static void gaym_roomlist_cancel(struct _GaimRoomlist *list)
-{
-    GaimConnection *gc = gaim_account_get_connection(list->account);
-    struct gaym_conn *gaym;
-
-    if (gc == NULL)
-        return;
-
-    gaym = gc->proto_data;
-
-    gaim_roomlist_set_in_progress(list, FALSE);
-
-    if (gaym->roomlist == list) {
-        g_list_free(g_list_nth_data(list->rooms, 0));
-        gaym->roomlist = NULL;
-        gaim_roomlist_unref(list);
-    }
-
-    if (gaym->roomlist_filter) {
-        g_free(gaym->roomlist_filter);
-        gaym->roomlist_filter = NULL;
-    }
-}
-
-void gaym_roomlist_expand_category(struct _GaimRoomlist *list,
-                                   struct _GaimRoomlistRoom *category)
-{
-    GaimRoomlistRoom *room = NULL;
-    gchar *altname = NULL;
-    gchar *altchan = NULL;
-    int i = 0;
-
-    if (category->type & GAIM_ROOMLIST_ROOMTYPE_ROOM
-        && !category->expanded_once) {
-
-        category->expanded_once = TRUE;
-
-        int max =
-            gaim_prefs_get_int("/plugins/prpl/gaym/chat_room_instances");
-
-        gchar *name = category->fields->data;
-        gchar *chan = category->fields->next->data;
-
-        for (i = 1; i <= max; i++) {
-            altname = g_strdup_printf("%.*s%d", strlen(name) - 1, name, i);
-            altchan = g_strdup_printf("%.*s%d", strlen(chan) - 1, chan, i);
-
-            room =
-                gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_ROOM,
-                                       altname, category);
-
-            gaim_roomlist_room_add_field(list, room, altname);
-            gaim_roomlist_room_add_field(list, room, altchan);
-            gaim_roomlist_room_add(list, room);
-            g_free(altname);
-            g_free(altchan);
-        }
-    }
-    gaim_roomlist_set_in_progress(list, FALSE);
-}
-
-static GaimPluginProtocolInfo prpl_info = {
-    0,                          /* options */
-    NULL,                       /* user_splits */
-    NULL,                       /* protocol_options */
-    {"jpg", 57, 77, 57, 77},    /* icon_spec */
-    gaym_blist_icon,            /* list_icon */
-    gaym_blist_emblems,         /* list_emblems */
-    gaym_status_text,           /* status_text */
-    gaym_tooltip_text,          /* tooltip_text */
-    gaym_away_states,           /* away_states */
-    gaym_blist_node_menu,       /* blist_node_menu */
-    gaym_chat_join_info,        /* chat_info */
-    gaym_chat_info_defaults,    /* chat_info_defaults */
-    gaym_login,                 /* login */
-    gaym_close,                 /* close */
-    gaym_im_send,               /* send_im */
-    gaym_set_info,              /* set_info */
-    NULL,                       /* send_typing */
-    gaym_get_info,              /* get_info */
-    gaym_set_away,              /* set_away */
-    NULL,                       /* set_idle */
-    NULL,                       /* change_passwd */
-    gaym_add_buddy,             /* add_buddy */
-    NULL,                       /* add_buddies */
-    gaym_remove_buddy,          /* remove_buddy */
-    NULL,                       /* remove_buddies */
-    gaym_add_permit,            /* add_permit */
-    gaym_add_deny,              /* add_deny */
-    gaym_rem_permit,            /* rem_permit */
-    gaym_rem_deny,              /* rem_deny */
-    gaym_set_permit_deny,       /* set_permit_deny */
-    gaym_warn,                  /* warn */
-    gaym_chat_join,             /* join_chat */
-    NULL,                       /* reject_chat */
-    gaym_get_chat_name,         /* get_chat_name */
-    gaym_chat_invite,           /* chat_invite */
-    gaym_chat_leave,            /* chat_leave */
-    NULL,                       /* chat_whisper */
-    gaym_chat_send,             /* chat_send */
-    NULL,                       /* keepalive */
-    NULL,                       /* register_user */
-    NULL,                       /* get_cb_info */
-    NULL,                       /* get_cb_away */
-    NULL,                       /* alias_buddy */
-    NULL,                       /* group_buddy */
-    NULL,                       /* rename_group */
-    NULL,                       /* buddy_free */
-    NULL,                       /* convo_closed */
-    NULL,                       /* normalize */
-    NULL,                       /* set_buddy_icon */
-    NULL,                       /* remove_group */
-    NULL,                       /* get_cb_real_name */
-    NULL,                       /* set_chat_topic */
-    gaym_find_blist_chat,       /* find_blist_chat */
-    gaym_roomlist_get_list,     /* roomlist_get_list */
-    gaym_roomlist_cancel,       /* roomlist_cancel */
-    gaym_roomlist_expand_category,      /* roomlist_expand_category */
-    NULL,                       /* can_receive_file */
-    gaym_dccsend_send_file      /* send_file */
-};
-
-void deref_one_user(gpointer * user, gpointer * data)
-{
-
-    struct gaym_conn *gaym = (struct gaym_conn *) data;
-    GaimConvChatBuddy *cb = (GaimConvChatBuddy *) user;
-    gaim_debug_misc("gaym", "Removing %s in %x from list\n",
-                    (char *) cb->name, cb);
-
-    gaim_debug_misc("    ", "Succes was: %i\n",
-                    gaym_unreference_channel_member(gaym, cb->name));
-
-}
-static void gaym_clean_channel_members(GaimConversation * conv)
-{
-
-    g_return_if_fail(conv != NULL);
-
-    if (conv->type == GAIM_CONV_CHAT) {
-        GaimConvChat *chat = gaim_conversation_get_chat_data(conv);
-        GaimConnection *gc = gaim_conversation_get_gc(conv);
-        g_return_if_fail(gc != NULL);
-        struct gaym_conn *gaym = gc->proto_data;
-        GList *users = gaim_conv_chat_get_users(chat);
-        gaim_debug_misc("gaym", "got userlist %x length %i\n", users,
-                        g_list_length(users));
-        g_list_foreach(users, (GFunc) deref_one_user, gaym);
-    } else if (conv->type == GAIM_CONV_IM) {
-        gaim_debug_misc("gaym", "removing reference to %s\n", conv->name);
-        GaimConnection *gc = gaim_conversation_get_gc(conv);
-        g_return_if_fail(gc != NULL);
-        struct gaym_conn *gaym = gc->proto_data;
-        gaym_unreference_channel_member(gaym, conv->name);
-    }
-}
-static void gaym_get_photo_info(GaimConversation * conv)
-{
-    char *buf;
-    char *name;
-    gaim_debug_misc("gaym", "Got conversation-created signal\n");
-    if (strncmp(conv->account->protocol_id, "prpl-gaym", 9) == 0
-        && gaim_conversation_get_type(conv) == GAIM_CONV_IM) {
-
-        /**
-         * First check to see if we already have the photo via
-         * the buddy list process.
-         */
-
-        struct gaym_conn *gaym;
-
-        GaimConnection *gc = gaim_conversation_get_gc(conv);
-        gaym = (struct gaym_conn *) gc->proto_data;
-
-        if (!gaym) {
-            return;
-        }
-
-        struct gaym_buddy *ib =
-            g_hash_table_lookup(gaym->buddies, conv->name);
-
-        if (ib) {
-            return;
-        }
-
-        /**
-         * Since this person isn't in our buddy list, go ahead
-         * with the WHOIS to get the photo for the IM thumbnail
-         */
-
-
-        name = gaym_nick_to_gcom_strdup(conv->name);
-        buf = gaym_format(gaym, "vn", "WHOIS", name);
-        gaim_debug_misc("gaym", "Conversation triggered command: %s\n",
-                        buf);
-        gaym_send(gaym, buf);
-        gaym_get_channel_member_reference(gaym, name);
-        g_free(name);
-        g_free(buf);
-        // Opens a reference in channel_members.
-
-    }
-}
-
-static GaimPluginPrefFrame *get_plugin_pref_frame(GaimPlugin * plugin)
-{
-    GaimPluginPrefFrame *frame;
-    GaimPluginPref *ppref;
-
-    frame = gaim_plugin_pref_frame_new();
-
-    ppref = gaim_plugin_pref_new_with_label(_("Chat Rooms"));
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_name_and_label
-        ("/plugins/prpl/gaym/show_join", _("Show entrance announcement"));
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_name_and_label
-        ("/plugins/prpl/gaym/show_bio_with_join",
-         _("Show member bio with entrance announcement"));
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_name_and_label
-        ("/plugins/prpl/gaym/show_part", _("Show exit announcement"));
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_name_and_label
-        ("/plugins/prpl/gaym/chat_room_instances",
-         _("Number of chat room instances to display"));
-    gaim_plugin_pref_set_bounds(ppref, 0, 9);
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_label(_
-                                        ("Bio-Based Chat Room Activity Filtering"));
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_name_and_label
-        ("/plugins/prpl/gaym/botfilter_enable", _("Enable"));
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_name_and_label
-        ("/plugins/prpl/gaym/botfilter_ignore_null",
-         _("Ignore if bio is blank"));
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_name_and_label
-        ("/plugins/prpl/gaym/botfilter_patterns",
-         _
-         ("Ignore if bio contains these patterns\n\t? = match any single character\n\t* = match zero, one, or more"));
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_name_and_label
-        ("/plugins/prpl/gaym/botfilter_sep",
-         _("Above patterns are separated by"));
-    gaim_plugin_pref_set_max_length(ppref, 1);
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_name_and_label
-        ("/plugins/prpl/gaym/botfilter_url",
-         _
-         ("URL for GayBoi's spam database\n\tblank to disable\n\tchanges affect next login\n\tdefault is "
-          GAYBOI_SPAM_URL));
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    return frame;
-}
-
-static GaimPluginUiInfo prefs_info = {
-    get_plugin_pref_frame
-};
-
-static GaimPluginInfo info = {
-    GAIM_PLUGIN_MAGIC,
-    GAIM_MAJOR_VERSION,
-    GAIM_MINOR_VERSION,
-    GAIM_PLUGIN_PROTOCOL,                                 /**< type           */
-    NULL,                                                 /**< ui_requirement */
-    0,                                                    /**< flags          */
-    NULL,                                                 /**< dependencies   */
-    GAIM_PRIORITY_DEFAULT,                                /**< priority       */
-
-    "prpl-gaym",                                          /**< id             */
-    "GayM",                                               /**< name           */
-    VERSION,                                              /**< version        */
-    N_("GayM Protocol Plugin"),                           /**  summary        */
-    N_("Gay.com Messaging based on IRC"),                 /**  description    */
-    NULL,                                                 /**< author         */
-    "http://qrc.berlios.de/",                             /**< homepage       */
-
-    NULL,                                                 /**< load           */
-    NULL,                                                 /**< unload         */
-    NULL,                                                 /**< destroy        */
-
-    NULL,                                                  /**< ui_info        */
-    &prpl_info,                                           /**< extra_info     */
-    &prefs_info,
-    gaym_actions
-};
-
-static void _init_plugin(GaimPlugin * plugin)
-{
-
-    GaimAccountOption *option;
-
-    option = gaim_account_option_string_new(_("Bio Line"), "bioline", "");
-    prpl_info.protocol_options =
-        g_list_prepend(prpl_info.protocol_options, option);
-
-    option =
-        gaim_account_option_int_new(_("Port"), "port", IRC_DEFAULT_PORT);
-    prpl_info.protocol_options =
-        g_list_prepend(prpl_info.protocol_options, option);
-
-    option =
-        gaim_account_option_string_new(_("Server"), "server",
-                                       IRC_DEFAULT_SERVER);
-    prpl_info.protocol_options =
-        g_list_prepend(prpl_info.protocol_options, option);
-
-    /**
-     * We have to pull thumbnails, since they aren't pushed like with
-     * other protocols.
-     */
-    gaim_signal_connect(gaim_conversations_get_handle(),
-                        "conversation-created", plugin,
-                        GAIM_CALLBACK(gaym_get_photo_info), NULL);
-
-
-    gaim_signal_connect(gaim_conversations_get_handle(),
-                        "deleting-conversation", plugin,
-                        GAIM_CALLBACK(gaym_clean_channel_members), NULL);
-
-    gaim_signal_register(gaim_accounts_get_handle(),
-                         "info-updated",
-                         gaim_marshal_VOID__POINTER_POINTER, NULL, 2,
-                         gaim_value_new(GAIM_TYPE_SUBTYPE,
-                                        GAIM_SUBTYPE_ACCOUNT),
-                         gaim_value_new(GAIM_TYPE_POINTER,
-                                        GAIM_TYPE_CHAR));
-
-
-
-    gaim_prefs_add_none("/plugins/prpl/gaym");
-    gaim_prefs_add_int("/plugins/prpl/gaym/chat_room_instances", 4);
-    gaim_prefs_add_bool("/plugins/prpl/gaym/show_join", TRUE);
-    gaim_prefs_add_bool("/plugins/prpl/gaym/show_part", TRUE);
-    gaim_prefs_add_bool("/plugins/prpl/gaym/show_bio_with_join", TRUE);
-
-    gaim_prefs_add_bool("/plugins/prpl/gaym/botfilter_enable", FALSE);
-    gaim_prefs_add_bool("/plugins/prpl/gaym/botfilter_ignore_null", FALSE);
-    gaim_prefs_add_string("/plugins/prpl/gaym/botfilter_sep", "|");
-    gaim_prefs_add_string("/plugins/prpl/gaym/botfilter_patterns",
-                          "NULL|MODE * -i|*dantcamboy*|*Free preview*|*epowerchat*|*Live gay sex cam show*|*camboiz*");
-    gaim_prefs_add_string("/plugins/prpl/gaym/botfilter_url",
-                          GAYBOI_SPAM_URL);
-
-    gaim_prefs_connect_callback("/plugins/prpl/gaym/botfilter_url",
-                                botfilter_url_changed_cb, NULL);
-
-    gaim_prefs_add_string("/plugins/prpl/gaym/botfilter_url_result", "");
-    gaim_prefs_add_int("/plugins/prpl/gaym/botfilter_url_last_check", 0);
-
-    _gaym_plugin = plugin;
-
-    gaym_register_commands();
-}
-
-GAIM_INIT_PLUGIN(gaym, _init_plugin, info);
-
-
-
-/**
- * vim:tabstop=4:shiftwidth=4:expandtab:
- */

Copied: qrc/branches/buddy_icon_hack/gaym/src/gaym.c (from rev 262, qrc/trunk/gaym/src/gaym.c)
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-31 07:45:24 UTC (rev 262)
+++ qrc/branches/buddy_icon_hack/gaym/src/gaym.c	2005-07-31 19:07:03 UTC (rev 263)
@@ -0,0 +1,1639 @@
+/**
+ * @file gaym.c
+ *
+ * gaim
+ *
+ * Copyright (C) 2003, Robbert Haarman <gaim at inglorion.net>
+ * Copyright (C) 2003, Ethan Blanton <eblanton at cs.purdue.edu>
+ * Copyright (C) 2000-2003, Rob Flynn <rob at tgflinux.com>
+ * Copyright (C) 1998-1999, Mark Spencer <markster at marko.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "internal.h"
+#include "accountopt.h"
+#include "blist.h"
+#include "conversation.h"
+#include "debug.h"
+#include "notify.h"
+#include "prpl.h"
+#include "plugin.h"
+#include "util.h"
+#include "version.h"
+#include "request.h"
+#include "privacy.h"
+#include "signals.h"
+
+#include "helpers.h"
+#include "gayminfo.h"
+#include "gaympriv.h"
+#include "botfilter.h"
+#include "gaym.h"
+
+static const char *gaym_blist_icon(GaimAccount * a, GaimBuddy * b);
+static void gaym_blist_emblems(GaimBuddy * b, char **se, char **sw,
+                               char **nw, char **ne);
+static GList *gaym_away_states(GaimConnection * gc);
+static GList *gaym_actions(GaimPlugin * plugin, gpointer context);
+/* static GList *gaym_chat_info(GaimConnection *gc); */
+static void gaym_login(GaimAccount * account);
+static void gaym_login_cb(gpointer data, gint source,
+                          GaimInputCondition cond);
+static void gaym_close(GaimConnection * gc);
+static int gaym_im_send(GaimConnection * gc, const char *who,
+                        const char *what, GaimConvImFlags flags);
+static int gaym_chat_send(GaimConnection * gc, int id, const char *what);
+static void gaym_chat_join(GaimConnection * gc, GHashTable * data);
+static void gaym_input_cb(gpointer data, gint source,
+                          GaimInputCondition cond);
+
+static guint gaym_nick_hash(const char *nick);
+static gboolean gaym_nick_equal(const char *nick1, const char *nick2);
+static void gaym_buddy_free(struct gaym_buddy *ib);
+static void gaym_channel_member_free(GaymBuddy * cm);
+
+static void gaym_buddy_append(char *name, struct gaym_buddy *ib,
+                              BListWhois * blist_whois);
+static void gaym_buddy_clear_done(char *name, struct gaym_buddy *ib,
+                                  gpointer nothing);
+
+static GaimPlugin *_gaym_plugin = NULL;
+
+static const char *status_chars = "@+%&";
+
+int gaym_send(struct gaym_conn *gaym, const char *buf)
+{
+    int ret;
+
+    if (gaym->fd < 0)
+        return -1;
+
+    /* gaim_debug(GAIM_DEBUG_MISC, "gaym", "sent: %s", buf); */
+    if ((ret = write(gaym->fd, buf, strlen(buf))) < 0)
+        gaim_connection_error(gaim_account_get_connection(gaym->account),
+                              _("Server has disconnected"));
+
+    return ret;
+}
+
+gboolean gaym_blist_timeout(struct gaym_conn * gaym)
+{
+    /**
+     * There are 510 characters available for an IRC command (512 if
+     * you count CR-LF).  "WHOIS " takes up 6 characters.  Assuming
+     * you need allow an extra character for the NULL when using
+     * g_string_sized_new(), we need to allocate (510-6)+1=505 here.
+     */
+    BListWhois *blist_whois = g_new0(BListWhois, 1);
+    blist_whois->count = 0;
+    blist_whois->string = g_string_sized_new(505);
+
+    char *list, *buf;
+
+    g_hash_table_foreach(gaym->buddies, (GHFunc) gaym_buddy_append,
+                         (gpointer) blist_whois);
+
+    list = g_string_free(blist_whois->string, FALSE);
+    if (!list || !strlen(list)) {
+        g_hash_table_foreach(gaym->buddies, (GHFunc) gaym_buddy_clear_done,
+                             NULL);
+        gaim_timeout_remove(gaym->timer);
+        gaym->timer =
+            gaim_timeout_add(BLIST_UPDATE_PERIOD,
+                             (GSourceFunc) gaym_blist_timeout,
+                             (gpointer) gaym);
+        g_free(list);
+        g_free(blist_whois);
+
+        return TRUE;
+    }
+    gaym->blist_updating = TRUE;
+    buf = gaym_format(gaym, "vn", "WHOIS", list);
+    gaym_send(gaym, buf);
+    gaim_timeout_remove(gaym->timer);
+    gaym->timer =
+        gaim_timeout_add(BLIST_CHUNK_INTERVAL,
+                         (GSourceFunc) gaym_blist_timeout,
+                         (gpointer) gaym);
+
+    g_free(buf);
+    g_free(list);
+    g_free(blist_whois);
+
+    return TRUE;
+}
+
+static void gaym_buddy_clear_done(char *name, struct gaym_buddy *ib,
+                                  gpointer nothing)
+{
+    ib->done = FALSE;
+}
+
+static void gaym_buddy_append(char *name, struct gaym_buddy *ib,
+                              BListWhois * blist_whois)
+{
+    char *converted_name = NULL;
+    converted_name = gaym_nick_to_gcom_strdup(name);
+
+    /**
+     * There are 510 characters available for an IRC command (512 if
+     * you count CR-LF).  "WHOIS " takes up 6 characters.  This means
+     * we have up to 504 characters available for comma separated
+     * converted_names
+     */
+    if (ib->done == FALSE && blist_whois->count < 10
+        && (strlen(converted_name) + blist_whois->string->len + 1) <=
+        504) {
+        blist_whois->count++;
+        ib->done = TRUE;
+        if (blist_whois->string->len == 0) {
+            g_string_append_printf(blist_whois->string, "%s",
+                                   converted_name);
+        } else {
+            g_string_append_printf(blist_whois->string, ",%s",
+                                   converted_name);
+        }
+    }
+
+    g_free(converted_name);
+    return;
+}
+
+static void gaym_whois_one(struct gaym_conn *gaym, struct gaym_buddy *ib)
+{
+    char *buf;
+    char *nick;
+    nick = gaym_nick_to_gcom_strdup(ib->name);
+    buf = gaym_format(gaym, "vn", "WHOIS", nick);
+    gaym_send(gaym, buf);
+    g_free(nick);
+    g_free(buf);
+}
+
+static const char *gaym_blist_icon(GaimAccount * a, GaimBuddy * b)
+{
+    return "gaym";
+}
+
+static void gaym_blist_emblems(GaimBuddy * b, char **se, char **sw,
+                               char **nw, char **ne)
+{
+    if (b->present == GAIM_BUDDY_OFFLINE)
+        *se = "offline";
+}
+
+static char *gaym_status_text(GaimBuddy * buddy)
+{
+    char *status;
+
+    struct gaym_conn *gaym =
+        (struct gaym_conn *) buddy->account->gc->proto_data;
+
+    if (!gaym) {
+        return g_strdup(_("Offline"));
+    }
+
+    struct gaym_buddy *ib =
+        g_hash_table_lookup(gaym->buddies, buddy->name);
+
+    if (!ib) {
+        return g_strdup(_("Offline"));
+    }
+
+    if (!ib->online) {
+        return g_strdup(_("Offline"));
+    }
+
+    if (!ib->bio) {
+        return NULL;
+    }
+
+    status = g_markup_escape_text(ib->bio, strlen(ib->bio));
+
+    return status;
+}
+
+static char *gaym_tooltip_text(GaimBuddy * buddy)
+{
+    struct gaym_conn *gaym =
+        (struct gaym_conn *) buddy->account->gc->proto_data;
+
+    if (!gaym) {
+        return NULL;
+    }
+
+    struct gaym_buddy *ib =
+        g_hash_table_lookup(gaym->channel_members, gaim_normalize(gaym->account,buddy->name)); 
+    if(!ib)
+         ib=g_hash_table_lookup(gaym->buddies, gaim_normalize(gaym->account,buddy->name));
+    
+    if (!ib) {
+        return g_strdup("No info found.");
+    }
+
+    return build_tooltip_text(ib);
+}
+
+static GList *gaym_away_states(GaimConnection * gc)
+{
+    return g_list_prepend(NULL, (gpointer) GAIM_AWAY_CUSTOM);
+}
+
+static void gaym_set_info(GaimConnection * gc, const char *info)
+{
+    struct gaym_conn *gaym = gc->proto_data;
+    GaimAccount *account = gaim_connection_get_account(gc);
+    char *hostname = "none";
+    char *buf, *bioline;
+    int i = 0;
+
+    char *tmpinfo = NULL;
+    if (info) {
+        tmpinfo = g_strdup(info);
+        for (i = 0; i < strlen(tmpinfo); i++) {
+            if (tmpinfo[i] == '\n') {
+                tmpinfo[i] = ' ';
+            }
+        }
+        tmpinfo = g_strstrip(tmpinfo);
+    }
+
+    if (gc->away && !tmpinfo) {
+        /**
+         * don't change any bio settings, since this is just
+         * setting an away message
+         */
+    } else {
+        if (gaym->bio) {
+            g_free(gaym->bio);
+        }
+        if (tmpinfo && strlen(tmpinfo) > 0) {
+            gaim_debug_misc("gaym", "option1, info=%x\n", tmpinfo);
+            /* java client allows MAX_BIO_LEN characters */
+            gaym->bio = g_strndup(tmpinfo, MAX_BIO_LEN);
+        } else if (gaym->server_bioline
+                   && strlen(gaym->server_bioline) > 0) {
+            gaim_debug_misc("gaym", "option2\n");
+            gaym->bio = gaym_bio_strdup(gaym->server_bioline);
+        } else {
+            gaim_debug_misc("gaym", "option3\n");
+            gaym->bio = g_strdup("Gaim User");
+        }
+        gaim_account_set_user_info(account, gaym->bio);
+        gaim_account_set_string(account, "bioline", gaym->bio);
+        gaim_debug_info("gaym", "INFO=%x BIO=%x\n", tmpinfo, gaym->bio);
+        gaim_debug_misc("gaym", "In login_cb, gc->account=%x\n",
+                        gc->account);
+    }
+
+    bioline =
+        g_strdup_printf("%s#%s\xC2\xA0 \xC2\xA0\001%s",
+                        gaym->thumbnail ? gaym->thumbnail : "",
+                        gc->away ? gc->away : (gaym->bio ? gaym->bio : ""),
+                        gaym->server_stats ? gaym->server_stats : "");
+
+    buf = gaym_format(gaym, "vvvv:", "USER",
+                      gaim_account_get_username(account),
+                      hostname, gaym->server, bioline);
+
+    gaim_debug_misc("gaym", "BIO=%x\n", bioline);
+
+    if (gaym_send(gaym, buf) < 0) {
+        gaim_connection_error(gc, "Error registering with server");
+    }
+
+    if (tmpinfo) {
+        g_free(tmpinfo);
+    }
+    g_free(bioline);
+    g_free(buf);
+
+    return;
+}
+
+static void gaym_show_set_info(GaimPluginAction * action)
+{
+    GaimConnection *gc = (GaimConnection *) action->context;
+    gaim_account_request_change_user_info(gaim_connection_get_account(gc));
+}
+
+static GList *gaym_actions(GaimPlugin * plugin, gpointer context)
+{
+    GList *list = NULL;
+    GaimPluginAction *act = NULL;
+
+    act = gaim_plugin_action_new(_("Change Bio"), gaym_show_set_info);
+    list = g_list_prepend(list, act);
+
+    return list;
+}
+
+static void gaym_blist_join_chat_cb(GaimBlistNode * node, gpointer data)
+{
+    const char *args[1];
+
+    GaimChat *chat = (GaimChat *) node;
+    g_free(chat->alias);
+    chat->alias = g_strdup("A new alias.");
+    struct gaym_conn *gaym = chat->account->gc->proto_data;
+    args[0] = data;
+
+    g_return_if_fail(args[0] != NULL);
+    g_return_if_fail(gaym != NULL);
+
+    
+    gaym_cmd_join(gaym, "join", NULL, args);
+}
+
+static GList *gaym_blist_node_menu(GaimBlistNode * node)
+{
+    GList *m = NULL;
+    GaimBlistNodeAction *act = NULL;
+    int i = 0;
+
+    if (node->type != GAIM_BLIST_CHAT_NODE) {
+        return m;
+    }
+
+    GaimChat *chat = (GaimChat *) node;
+    char *channel = g_hash_table_lookup(chat->components, "channel");
+
+    if (!channel) {
+        return m;
+    }
+
+    if (!g_str_has_suffix(channel, "=*")) {
+        return m;
+    }
+
+    char *label = NULL;
+    char *instance = NULL;
+
+    int max = gaim_prefs_get_int("/plugins/prpl/gaym/chat_room_instances");
+
+    for (i = max; i > 0; i--) {
+        label = g_strdup_printf(_("Join Room %d"), i);
+        instance =
+            g_strdup_printf("%.*s%d", strlen(channel) - 1, channel, i);
+        act =
+            gaim_blist_node_action_new(label, gaym_blist_join_chat_cb,
+                                       instance);
+        m = g_list_prepend(m, act);
+    }
+    return m;
+}
+
+static GList *gaym_chat_join_info(GaimConnection * gc)
+{
+    GList *m = NULL;
+    struct proto_chat_entry *pce;
+
+    pce = g_new0(struct proto_chat_entry, 1);
+    pce->label = _("_Room:");
+    pce->identifier = "channel";
+    m = g_list_prepend(m, pce);
+
+    return m;
+}
+
+GHashTable *gaym_chat_info_defaults(GaimConnection * gc,
+                                    const char *chat_name)
+{
+    GHashTable *defaults;
+
+    defaults =
+        g_hash_table_new_full(g_str_hash, g_str_equal, NULL, g_free);
+
+    if (chat_name != NULL)
+        g_hash_table_insert(defaults, "channel", g_strdup(chat_name));
+
+    return defaults;
+}
+
+static void gaym_login_with_chat_key(GaimAccount * account)
+{
+    GaimConnection *gc;
+    struct gaym_conn *gaym;
+    char *buf;
+    const char *username = gaim_account_get_username(account);
+    int err;
+
+    gc = gaim_account_get_connection(account);
+    gaym = gc->proto_data;
+
+    buf = g_strdup_printf(_("Signon: %s"), username);
+    gaim_connection_update_progress(gc, buf, 5, 6);
+    g_free(buf);
+    gaim_debug_misc("gaym", "Trying login to %s\n", gaym->server);
+    err = gaim_proxy_connect(account, gaym->server,
+                             gaim_account_get_int(account, "port",
+                                                  IRC_DEFAULT_PORT),
+                             gaym_login_cb, gc);
+    if (err || !account->gc) {
+        gaim_connection_error(gc, _("Couldn't create socket"));
+        gaim_debug_misc("gaym", "err: %d, account->gc: %x\n", err,
+                        account->gc);
+        return;
+    }
+
+}
+
+static void gaym_login(GaimAccount * account)
+{
+    GaimConnection *gc;
+    struct gaym_conn *gaym;
+    char *buf;
+    const char *username = gaim_account_get_username(account);
+
+    gc = gaim_account_get_connection(account);
+    gc->flags |= GAIM_CONNECTION_NO_NEWLINES | GAIM_CONNECTION_AUTO_RESP;
+
+    if (strpbrk(username, " \t\v\r\n") != NULL) {
+        gaim_connection_error(gc,
+                              _("IRC nicks may not contain whitespace"));
+        return;
+    }
+
+    gc->proto_data = gaym = g_new0(struct gaym_conn, 1);
+    gaym->account = account;
+
+
+    /**
+     * gaim_connection_set_display_name(gc, userparts[0]);
+     */
+    gaim_connection_set_display_name(gc, username);
+    gaym->server =
+        g_strdup(gaim_account_get_string
+                 (account, "server", "www.gay.com"));
+    /**
+     * gaym->server = "www.gay.com";
+     */
+    gaym->buddies =
+        g_hash_table_new_full((GHashFunc) gaym_nick_hash,
+                              (GEqualFunc) gaym_nick_equal, NULL,
+                              (GDestroyNotify) gaym_buddy_free);
+
+    gaym->channel_members =
+        g_hash_table_new_full((GHashFunc) gaym_nick_hash,
+                              (GEqualFunc) gaym_nick_equal, NULL,
+                              (GDestroyNotify) gaym_channel_member_free);
+
+    gaym->cmds = g_hash_table_new(g_str_hash, g_str_equal);
+    gaym_cmd_table_build(gaym);
+    gaym->msgs = g_hash_table_new(g_str_hash, g_str_equal);
+    gaym_msg_table_build(gaym);
+    gaym->roomlist_filter = NULL;
+
+    gaym->hammers = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, (GDestroyNotify)hammer_cb_data_destroy);
+    /**
+     * The last parameter needs to be NULL here, since the same
+     * field is added for both the key and the value (and if we
+     * free it twice, thats bad and causes crashing!).
+     */
+    gaym->info_window_needed =
+        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
+
+    gaym->entry_order =
+        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
+
+    /**
+     * This is similar to gaym->info_window_needed, except this is
+     * for thumbails inside the IM conversation window if the
+     * person is not already on the buddy list
+     */
+
+    buf = g_strdup_printf(_("Signon: %s"), username);
+    gaim_connection_update_progress(gc, buf, 1, 6);
+    g_free(buf);
+
+
+    /**
+     * Making a change to try cached password first.
+     * gaym_try_cached_password(account, gaym_login_with_chat_key);
+     */
+    gaym_get_chat_key_from_weblogin(account, gaym_login_with_chat_key);
+}
+
+
+static void gaym_get_configtxt_cb(gpointer proto_data,
+                                  const gchar * config_text, size_t len)
+{
+    struct gaym_conn *gaym = (struct gaym_conn *) proto_data;
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+
+    g_return_if_fail(config_text != NULL);
+
+    gaym->confighash = gaym_properties_new(config_text);
+    g_return_if_fail(gaym->confighash != NULL);
+
+    // synchronize_deny_list(gc, gaym->confighash);
+
+    return;
+}
+static void gaym_login_cb(gpointer data, gint source,
+                          GaimInputCondition cond)
+{
+    GaimConnection *gc = data;
+    struct gaym_conn *gaym = gc->proto_data;
+    char hostname[256];
+    char *buf;
+    const char *username;
+    const char *user_bioline = NULL;
+    char *bioline;
+    char *login_name;
+
+    if (GAIM_CONNECTION_IS_VALID(gc)) {
+
+
+        GList *connections = gaim_connections_get_all();
+
+        if (source < 0) {
+            gaim_connection_error(gc, _("Couldn't connect to host"));
+            return;
+        }
+
+        if (!g_list_find(connections, gc)) {
+            close(source);
+            return;
+        }
+
+        gaym->fd = source;
+        gaim_debug_misc("gaym", "In login_cb with chat_key=%s\n",
+                        gaym->chat_key);
+        if (gaym->chat_key) {
+
+            buf = gaym_format(gaym, "vv", "PASS", gaym->chat_key);
+            if (gaym_send(gaym, buf) < 0) {
+                gaim_connection_error(gc, "Error sending password");
+                return;
+            }
+            g_free(buf);
+        } else {
+            gaim_connection_error(gc,
+                                  _
+                                  ("Password wasn't recorded. Report bug."));
+            return;
+        }
+        gethostname(hostname, sizeof(hostname));
+        hostname[sizeof(hostname) - 1] = '\0';
+        username = gaim_account_get_string(gaym->account, "username", "");
+        user_bioline =
+            g_strdup(gaim_account_get_string
+                     (gaym->account, "bioline", ""));
+        gaim_debug_info("gaym", "USER BIOLINE=%x\n", user_bioline);
+        gaim_account_set_user_info(gc->account, user_bioline);
+        gaim_debug_misc("gaym",
+                        "In login_cb, user_bioline: %x, gc->account=%x\n",
+                        user_bioline, gc->account);
+
+        login_name =
+            gaym_nick_to_gcom_strdup(gaim_connection_get_display_name(gc));
+        bioline = g_strdup_printf("%s#%s\xC2\xA0 \xC2\xA0\001%s",
+                                  gaym->thumbnail,
+                                  user_bioline ? user_bioline : "",
+                                  gaym->server_stats ? gaym->
+                                  server_stats : "");
+
+        buf = gaym_format(gaym, "vn", "NICK", login_name);
+        gaim_debug_misc("gaym", "Command: %s\n", buf);
+
+        if (gaym_send(gaym, buf) < 0) {
+            gaim_connection_error(gc, "Error sending nickname");
+            return;
+        }
+        g_free(buf);
+        buf =
+            gaym_format(gaym, "vvvv:", "USER", login_name, hostname,
+                        gaym->server, bioline);
+
+        gaim_debug_misc("gaym", "Command: %s\n", buf);
+        if (gaym_send(gaym, buf) < 0) {
+            gaim_connection_error(gc, "Error registering with server");
+            return;
+        }
+        g_free(login_name);
+        g_free(buf);
+
+        const char *server = gaim_account_get_string(gc->account, "server",
+                                                     IRC_DEFAULT_SERVER);
+        char *url =
+            g_strdup_printf
+            ("http://%s/messenger/config.txt?%s", server, gaym->chat_key);
+
+        char *user_agent = "Mozilla/4.0";
+
+        get_spamlist_from_web();
+        gaim_url_fetch(url, FALSE, user_agent, FALSE,
+                       gaym_get_configtxt_cb, gaym);
+
+        g_free(url);
+        gc->inpa =
+            gaim_input_add(gaym->fd, GAIM_INPUT_READ, gaym_input_cb, gc);
+
+
+    }
+}
+
+void kill_hammer(gpointer* room, struct hammer_cb_data* data, gpointer *null) {
+    hammer_cb_data_destroy(data);
+}
+
+static void gaym_close(GaimConnection * gc)
+{
+    struct gaym_conn *gaym = gc->proto_data;
+
+    gaim_debug_misc("gaym", "gaym close function has been called\n");
+    if (gaym == NULL)
+        return;
+
+    gaym_cmd_quit(gaym, "quit", NULL, NULL);
+
+    if (gc->inpa)
+        gaim_input_remove(gc->inpa);
+
+    g_free(gaym->inbuf);
+    gaim_debug_misc("gaym", "closing fd %i\n", gaym->fd);
+    close(gaym->fd);
+
+    if (gaym->timer)
+        gaim_timeout_remove(gaym->timer);
+
+    if (gaym->thumbnail)
+        g_free(gaym->thumbnail);
+
+    if (gaym->chat_key)
+        g_free(gaym->chat_key);
+
+    if (gaym->server_bioline)
+        g_free(gaym->server_bioline);
+
+    if (gaym->server_stats)
+        g_free(gaym->server_stats);
+
+    if (gaym->roomlist_filter)
+        g_free(gaym->roomlist_filter);
+
+    if (gaym->bio)
+        g_free(gaym->bio);
+
+    g_hash_table_destroy(gaym->cmds);
+    g_hash_table_destroy(gaym->msgs);
+    g_hash_table_destroy(gaym->info_window_needed);
+    g_hash_table_destroy(gaym->entry_order);
+    if (gaym->motd)
+        g_string_free(gaym->motd, TRUE);
+
+    if (gaym->names)
+        g_string_free(gaym->names, TRUE);
+
+    if (gaym->nameconv)
+        g_free(gaym->nameconv);
+    if (gaym->subroom)
+        g_free(gaym->subroom);
+
+    g_hash_table_destroy(gaym->confighash);
+
+    g_hash_table_foreach(gaym->hammers, (GHFunc)kill_hammer, NULL);
+
+    g_free(gaym->server);
+    g_free(gaym);
+}
+
+static int gaym_im_send(GaimConnection * gc, const char *who,
+                        const char *what, GaimConvImFlags flags)
+{
+    struct gaym_conn *gaym = gc->proto_data;
+    const char *args[2];
+    char *automsg = NULL;
+    char *stripped_msg = NULL;
+    if (strchr(status_chars, *who) != NULL) {
+        args[0] = who + 1;
+    } else {
+        args[0] = who;
+    }
+    if (flags & GAIM_CONV_IM_AUTO_RESP) {
+        stripped_msg = gaim_markup_strip_html(what);
+        automsg = g_strdup_printf("<AUTO-REPLY> %s", stripped_msg);
+        g_free(stripped_msg);
+        args[1] = automsg;
+
+    } else {
+        args[1] = what;
+    }
+    gaym_cmd_privmsg(gaym, "msg", NULL, args);
+    if (automsg) {
+        g_free(automsg);
+    }
+    return 1;
+}
+
+static void gaym_get_info(GaimConnection * gc, const char *who)
+{
+    struct gaym_conn *gaym = gc->proto_data;
+    const char *args[1];
+    args[0] = who;
+
+    char *normalized = g_strdup(gaim_normalize(gc->account, who));
+    /**
+     * We are adding the same char* to both the key and the value.
+     * If this changes, we need to change the corresponding
+     * g_hash_table_new_full() so that things are properly cleaned
+     * up during the remove/destroy phase.
+     */
+    g_hash_table_insert(gaym->info_window_needed, normalized, normalized);
+    gaym_cmd_whois(gaym, "whois", NULL, args);
+}
+
+static void gaym_set_away(GaimConnection * gc, const char *state,
+                          const char *msg)
+{
+    char *bio = NULL;
+    char *tmpmsg = NULL;
+    int i = 0;
+    struct gaym_conn *gaym = gc->proto_data;
+
+    if (gc->away) {
+        g_free(gc->away);
+        gc->away = NULL;
+    }
+
+    /**
+     * In addition to setting the away message, set the Bio to the
+     * away message; if the away message is NULL, then set the Bio
+     * to the original bio.
+     */
+
+    if (msg) {
+        tmpmsg = g_strdup(msg);
+        for (i = 0; i < strlen(tmpmsg); i++) {
+            if (tmpmsg[i] == '\n') {
+                tmpmsg[i] = ' ';
+            }
+        }
+        tmpmsg = g_strstrip(tmpmsg);
+
+        gc->away = g_strndup(tmpmsg, MAX_BIO_LEN);
+        gaym_set_info(gc, NULL);
+        g_free(tmpmsg);
+    } else {
+        if (gaym && gaym->bio) {
+            bio = g_strdup(gaym->bio);
+            gaym_set_info(gc, bio);
+            g_free(bio);
+        } else {
+            gaym_set_info(gc, NULL);
+        }
+    }
+
+    /**
+     *  The following would be great, and gay.com's server supports
+     *  it, but gay.com's clients don't see the result.  So even though
+     *  we can see the result, we won't bother.
+     *
+     * args[0] = msg;
+     * gaym_cmd_away(gaym, "away", NULL, args);
+     */
+}
+
+GaymBuddy *gaym_get_channel_member_reference(struct gaym_conn
+                                             *gaym, const gchar * name)
+{
+
+    GaymBuddy *channel_member =
+        (GaymBuddy *) g_hash_table_lookup(gaym->channel_members,
+                                          name);
+
+    if (!channel_member) {
+        GaymBuddy *channel_member = g_new0(GaymBuddy, 1);
+        channel_member->ref_count = 1;
+        g_hash_table_insert(gaym->channel_members, g_strdup(gaim_normalize(gaym->account,name)),
+                            channel_member);
+        gaim_debug_misc("gaym", "Creating channel_members entry for %s\n",
+                        name);
+        return g_hash_table_lookup(gaym->channel_members, gaim_normalize(gaym->account, name));
+    } else {
+        gaim_debug_misc("gaym",
+                        "Adding reference to channel_members entry for %s\n",
+                        name);
+        (channel_member->ref_count)++;
+        return channel_member;
+    }
+
+}
+
+gboolean gaym_unreference_channel_member(struct gaym_conn * gaym,
+                                         gchar * name)
+{
+
+    GaymBuddy *channel_member;
+    channel_member =
+        (GaymBuddy *) g_hash_table_lookup(gaym->channel_members, gaim_normalize(gaym->account,name));
+    if (!channel_member)
+        return FALSE;
+    else {
+
+        if (channel_member->ref_count <= 0)
+            gaim_debug_error("gaym",
+                             "****Reference counting error with channel members struct.\n");
+
+        channel_member->ref_count--;
+
+        if (channel_member->ref_count == 0) {
+            gaim_debug_misc("gaym", "Removing %s from channel_members\n",
+                            name);
+            return g_hash_table_remove(gaym->channel_members, gaim_normalize(gaym->account, name));
+        }
+        return FALSE;
+    }
+}
+
+static void gaym_add_buddy(GaimConnection * gc, GaimBuddy * buddy,
+                           GaimGroup * group)
+{
+    if (buddy->name) {
+        buddy->name = g_strstrip(buddy->name);
+    }
+    if (buddy->alias) {
+        buddy->alias = g_strstrip(buddy->alias);
+    }
+    if (buddy->server_alias) {
+        buddy->server_alias = g_strstrip(buddy->server_alias);
+    }
+    struct gaym_conn *gaym = (struct gaym_conn *) gc->proto_data;
+    struct gaym_buddy *ib = g_new0(struct gaym_buddy, 1);
+    ib->name = g_strdup(buddy->name);
+    ib->done = FALSE;
+    ib->online = FALSE;
+    ib->bio = NULL;
+    ib->thumbnail = NULL;
+    ib->sex = NULL;
+    ib->age = NULL;
+    ib->location = NULL;
+    g_hash_table_replace(gaym->buddies, ib->name, ib);
+    gaim_debug_misc("gaym", "Add buddy: %s\n", buddy->name);
+    /**
+     * if the timer isn't set, this is during signon, so we don't want to
+     * flood ourself off with WHOIS's, so we don't, but after that we want
+     * to know when someone's online asap
+     */
+    if (gaym->timer)
+        gaym_whois_one(gaym, ib);
+}
+
+static void gaym_remove_buddy(GaimConnection * gc, GaimBuddy * buddy,
+                              GaimGroup * group)
+{
+    struct gaym_conn *gaym = (struct gaym_conn *) gc->proto_data;
+
+    /**
+     * Only remove buddy->name from gaym->buddies if it doesn't
+     * exist in any other group on the buddy list.  This allows us
+     * to manage the buddy once, even though it might exist in
+     * several groups within the buddy list.
+     *
+     * To add to confusion, the buddy being deleted is not yet deleted,
+     * so we look for less than two identical buddies, and if so, then
+     * remove the buddy from gaym->buddies.
+     */
+
+    GSList *buddies = gaim_find_buddies(gaym->account, buddy->name);
+    guint length = g_slist_length(buddies);
+
+    if (length < 2) {
+        g_hash_table_remove(gaym->buddies, buddy->name);
+    }
+
+    g_slist_free(buddies);
+}
+
+static void gaym_input_cb(gpointer data, gint source,
+                          GaimInputCondition cond)
+{
+    GaimConnection *gc = data;
+    struct gaym_conn *gaym = gc->proto_data;
+    char *cur, *end;
+    int len;
+
+    if (gaym->inbuflen < gaym->inbufused + IRC_INITIAL_BUFSIZE) {
+        gaym->inbuflen += IRC_INITIAL_BUFSIZE;
+        gaym->inbuf = g_realloc(gaym->inbuf, gaym->inbuflen);
+    }
+
+    if ((len =
+         read(gaym->fd, gaym->inbuf + gaym->inbufused,
+              IRC_INITIAL_BUFSIZE - 1)) < 0) {
+        gaim_connection_error(gc, _("Read error"));
+        return;
+    } else if (len == 0) {
+        gaim_connection_error(gc, _("Server has disconnected"));
+        return;
+    }
+
+    gaym->inbufused += len;
+    gaym->inbuf[gaym->inbufused] = '\0';
+
+    cur = gaym->inbuf;
+    while (cur < gaym->inbuf + gaym->inbufused &&
+           ((end = strstr(cur, "\r\n")) || (end = strstr(cur, "\n")))) {
+        int step = (*end == '\r' ? 2 : 1);
+        *end = '\0';
+        gaym_parse_msg(gaym, cur);
+        cur = end + step;
+    }
+    if (cur != gaym->inbuf + gaym->inbufused) { /* leftover */
+        gaym->inbufused -= (cur - gaym->inbuf);
+        memmove(gaym->inbuf, cur, gaym->inbufused);
+    } else {
+        gaym->inbufused = 0;
+    }
+}
+
+static void gaym_add_permit(GaimConnection * gc, const char *name)
+{
+    if (!gaym_nick_check(name)) {
+        gaim_privacy_permit_remove(gc->account, name, TRUE);
+        gaim_notify_error(gc, _("Invalid User Name"), name,
+                          _("Invalid user name not added."));
+    } else {
+        gaym_privacy_change(gc, name);
+    }
+}
+
+static void gaym_add_deny(GaimConnection * gc, const char *name)
+{
+    if (!gaym_nick_check(name)) {
+        gaim_privacy_deny_remove(gc->account, name, TRUE);
+        gaim_notify_error(gc, _("Invalid User Name"), name,
+                          _("Invalid user name not added."));
+        return;
+    }
+    gaym_server_store_deny(gc, name, TRUE);
+    gaym_privacy_change(gc, name);
+}
+
+static void gaym_rem_permit(GaimConnection * gc, const char *name)
+{
+    gaym_privacy_change(gc, name);
+}
+
+static void gaym_rem_deny(GaimConnection * gc, const char *name)
+{
+    gaym_server_store_deny(gc, name, FALSE);
+    gaym_privacy_change(gc, name);
+}
+
+static void gaym_set_permit_deny(GaimConnection * gc)
+{
+    gaym_privacy_change(gc, NULL);
+}
+
+static void gaym_warn(GaimConnection * gc, const char *who,
+                      gboolean anonymous)
+{
+    void *handle = NULL;
+    struct gaym_conn *gaym = gc->proto_data;
+    char *buf =
+        g_strdup_printf
+        ("http://%s/members/report/form.html?area=chat&room=&report=%s",
+         gaym->server, who);
+    gaim_notify_uri(handle, buf);
+    g_free(buf);
+}
+
+static void gaym_chat_join(GaimConnection * gc, GHashTable * data)
+{
+    struct gaym_conn *gaym = gc->proto_data;
+    const char *args[1];
+    char *alias = NULL;
+
+    GaimChat *c = NULL;
+
+    /**
+     * need a copy, because data gets
+     * destroyed in roomlist.c
+     */
+    GHashTable *chatinfo = NULL;
+
+    args[0] = g_hash_table_lookup(data, "channel");
+
+    if (args[0]) {
+        alias = g_hash_table_lookup(data, "description");
+        c = gaim_blist_find_chat(gaim_connection_get_account(gc), args[0]);
+        if (!c) {
+            chatinfo = g_hash_table_new(g_str_hash, g_str_equal);
+
+            g_hash_table_replace(chatinfo, "channel", g_strdup(args[0]));
+
+            c = gaim_chat_new(gaim_connection_get_account(gc),
+                              alias, chatinfo);
+
+            gaim_blist_add_chat(c, NULL, NULL);
+        }
+    }
+
+    if (!args[0] || *args[0] != '#') {
+        /**
+         * Trigger a room search in config.txt....
+         */
+        return;
+    }
+
+    gaym_cmd_join(gaym, "join", NULL, args);
+}
+
+static char *gaym_get_chat_name(GHashTable * data)
+{
+    return g_strdup(g_hash_table_lookup(data, "channel"));
+}
+
+static void gaym_chat_invite(GaimConnection * gc, int id,
+                             const char *message, const char *name)
+{
+    struct gaym_conn *gaym = gc->proto_data;
+    GaimConversation *convo = gaim_find_chat(gc, id);
+    const char *args[2];
+
+    if (!convo) {
+        gaim_debug(GAIM_DEBUG_ERROR, "gaym",
+                   "Got chat invite request for bogus chat\n");
+        return;
+    }
+    args[0] = name;
+    args[1] = gaim_conversation_get_name(convo);
+    gaym_cmd_invite(gaym, "invite", gaim_conversation_get_name(convo),
+                    args);
+}
+
+static void gaym_chat_leave(GaimConnection * gc, int id)
+{
+    struct gaym_conn *gaym = gc->proto_data;
+    GaimConversation *convo = gaim_find_chat(gc, id);
+    const char *args[2];
+
+    if (!convo)
+        return;
+
+    args[0] = gaim_conversation_get_name(convo);
+    args[1] = NULL;
+    gaym_cmd_part(gaym, "part", gaim_conversation_get_name(convo), args);
+    serv_got_chat_left(gc, id);
+}
+
+static int gaym_chat_send(GaimConnection * gc, int id, const char *what)
+{
+    struct gaym_conn *gaym = gc->proto_data;
+    GaimConversation *convo = gaim_find_chat(gc, id);
+    const char *args[2];
+    char *tmp;
+
+    if (!convo) {
+        gaim_debug(GAIM_DEBUG_ERROR, "gaym",
+                   "chat send on nonexistent chat\n");
+        return -EINVAL;
+    }
+#if 0
+    if (*what == '/') {
+        return gaym_parse_cmd(gaym, convo->name, what + 1);
+    }
+#endif
+    args[0] = convo->name;
+    args[1] = what;
+
+    gaym_cmd_privmsg(gaym, "msg", NULL, args);
+
+    tmp = gaim_escape_html(what);
+    serv_got_chat_in(gc, id, gaim_connection_get_display_name(gc), 0, tmp,
+                     time(NULL));
+    g_free(tmp);
+    return 0;
+}
+
+static guint gaym_nick_hash(const char *nick)
+{
+    char *lc = NULL;
+    guint bucket;
+
+    if (!nick)
+        return 0;
+    lc = g_utf8_strdown(nick, -1);
+    bucket = g_str_hash(lc);
+    g_free(lc);
+
+    return bucket;
+}
+
+static gboolean gaym_nick_equal(const char *nick1, const char *nick2)
+{
+    return (gaim_utf8_strcasecmp(nick1, nick2) == 0);
+}
+
+static void gaym_channel_member_free(GaymBuddy * cm)
+{
+    g_free(cm->name);
+    g_free(cm->bio);
+    g_free(cm->thumbnail);
+    g_free(cm->sex);
+    g_free(cm->age);
+    g_free(cm->location);
+    g_free(cm);
+}
+
+static void gaym_buddy_free(struct gaym_buddy *ib)
+{
+    g_free(ib->name);
+    g_free(ib->bio);
+    g_free(ib->thumbnail);
+    g_free(ib->sex);
+    g_free(ib->age);
+    g_free(ib->location);
+    g_free(ib);
+}
+
+static GaimChat *gaym_find_blist_chat(GaimAccount * account,
+                                      const char *name)
+{
+    char *chat_name;
+    GaimChat *chat;
+    GaimPlugin *prpl;
+    GaimPluginProtocolInfo *prpl_info = NULL;
+    struct proto_chat_entry *pce;
+    GaimBlistNode *node, *group;
+    GList *parts;
+
+    GaimBuddyList *gaimbuddylist = gaim_get_blist();
+
+    g_return_val_if_fail(gaimbuddylist != NULL, NULL);
+    g_return_val_if_fail((name != NULL) && (*name != '\0'), NULL);
+
+    if (!gaim_account_is_connected(account))
+        return NULL;
+
+    prpl = gaim_find_prpl(gaim_account_get_protocol_id(account));
+    prpl_info = GAIM_PLUGIN_PROTOCOL_INFO(prpl);
+
+    for (group = gaimbuddylist->root; group != NULL; group = group->next) {
+        for (node = group->child; node != NULL; node = node->next) {
+            if (GAIM_BLIST_NODE_IS_CHAT(node)) {
+
+                chat = (GaimChat *) node;
+
+                if (account != chat->account)
+                    continue;
+
+                parts =
+                    prpl_info->
+                    chat_info(gaim_account_get_connection(chat->account));
+
+                pce = parts->data;
+                chat_name = g_hash_table_lookup(chat->components,
+                                                pce->identifier);
+
+                if (chat->account == account && chat_name != NULL &&
+                    name != NULL
+                    && g_pattern_match_simple(chat_name, name)) {
+
+                    return chat;
+                }
+            }
+        }
+    }
+
+    return NULL;
+}
+
+static GaimRoomlist *gaym_roomlist_get_list(GaimConnection * gc)
+{
+    struct gaym_conn *gaym;
+    GList *fields = NULL;
+    GaimRoomlistField *f;
+    char *buf;
+
+    gaym = gc->proto_data;
+
+    if (gaym->roomlist) {
+        gaim_roomlist_unref(gaym->roomlist);
+    }
+
+    gaym->roomlist = gaim_roomlist_new(gaim_connection_get_account(gc));
+
+    f = gaim_roomlist_field_new(GAIM_ROOMLIST_FIELD_STRING, _("Channel"),
+                                "channel", FALSE);
+    fields = g_list_prepend(fields, f);
+
+    f = gaim_roomlist_field_new(GAIM_ROOMLIST_FIELD_STRING, "",
+                                "description", TRUE);
+    fields = g_list_prepend(fields, f);
+
+    gaim_roomlist_set_fields(gaym->roomlist, fields);
+
+    /**
+     * Member created rooms are retrieved through the IRC protocol
+     * and after the last response is recieved from that request
+     * the static rooms are added
+     */
+
+    buf = gaym_format(gaym, "v", "LIST #_*");
+    gaym_send(gaym, buf);
+    g_free(buf);
+
+    return gaym->roomlist;
+}
+
+static void gaym_roomlist_cancel(struct _GaimRoomlist *list)
+{
+    GaimConnection *gc = gaim_account_get_connection(list->account);
+    struct gaym_conn *gaym;
+
+    if (gc == NULL)
+        return;
+
+    gaym = gc->proto_data;
+
+    gaim_roomlist_set_in_progress(list, FALSE);
+
+    if (gaym->roomlist == list) {
+        g_list_free(g_list_nth_data(list->rooms, 0));
+        gaym->roomlist = NULL;
+        gaim_roomlist_unref(list);
+    }
+
+    if (gaym->roomlist_filter) {
+        g_free(gaym->roomlist_filter);
+        gaym->roomlist_filter = NULL;
+    }
+}
+
+void gaym_roomlist_expand_category(struct _GaimRoomlist *list,
+                                   struct _GaimRoomlistRoom *category)
+{
+    GaimRoomlistRoom *room = NULL;
+    gchar *altname = NULL;
+    gchar *altchan = NULL;
+    int i = 0;
+
+    if (category->type & GAIM_ROOMLIST_ROOMTYPE_ROOM
+        && !category->expanded_once) {
+
+        category->expanded_once = TRUE;
+
+        int max =
+            gaim_prefs_get_int("/plugins/prpl/gaym/chat_room_instances");
+
+        gchar *name = category->fields->data;
+        gchar *chan = category->fields->next->data;
+
+        for (i = 1; i <= max; i++) {
+            altname = g_strdup_printf("%.*s%d", strlen(name) - 1, name, i);
+            altchan = g_strdup_printf("%.*s%d", strlen(chan) - 1, chan, i);
+
+            room =
+                gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_ROOM,
+                                       altname, category);
+
+            gaim_roomlist_room_add_field(list, room, altname);
+            gaim_roomlist_room_add_field(list, room, altchan);
+            gaim_roomlist_room_add(list, room);
+            g_free(altname);
+            g_free(altchan);
+        }
+    }
+    gaim_roomlist_set_in_progress(list, FALSE);
+}
+
+static GaimPluginProtocolInfo prpl_info = {
+    0,                          /* options */
+    NULL,                       /* user_splits */
+    NULL,                       /* protocol_options */
+    {"jpg", 57, 77, 57, 77},    /* icon_spec */
+    gaym_blist_icon,            /* list_icon */
+    gaym_blist_emblems,         /* list_emblems */
+    gaym_status_text,           /* status_text */
+    gaym_tooltip_text,          /* tooltip_text */
+    gaym_away_states,           /* away_states */
+    gaym_blist_node_menu,       /* blist_node_menu */
+    gaym_chat_join_info,        /* chat_info */
+    gaym_chat_info_defaults,    /* chat_info_defaults */
+    gaym_login,                 /* login */
+    gaym_close,                 /* close */
+    gaym_im_send,               /* send_im */
+    gaym_set_info,              /* set_info */
+    NULL,                       /* send_typing */
+    gaym_get_info,              /* get_info */
+    gaym_set_away,              /* set_away */
+    NULL,                       /* set_idle */
+    NULL,                       /* change_passwd */
+    gaym_add_buddy,             /* add_buddy */
+    NULL,                       /* add_buddies */
+    gaym_remove_buddy,          /* remove_buddy */
+    NULL,                       /* remove_buddies */
+    gaym_add_permit,            /* add_permit */
+    gaym_add_deny,              /* add_deny */
+    gaym_rem_permit,            /* rem_permit */
+    gaym_rem_deny,              /* rem_deny */
+    gaym_set_permit_deny,       /* set_permit_deny */
+    gaym_warn,                  /* warn */
+    gaym_chat_join,             /* join_chat */
+    NULL,                       /* reject_chat */
+    gaym_get_chat_name,         /* get_chat_name */
+    gaym_chat_invite,           /* chat_invite */
+    gaym_chat_leave,            /* chat_leave */
+    NULL,                       /* chat_whisper */
+    gaym_chat_send,             /* chat_send */
+    NULL,                       /* keepalive */
+    NULL,                       /* register_user */
+    NULL,                       /* get_cb_info */
+    NULL,                       /* get_cb_away */
+    NULL,                       /* alias_buddy */
+    NULL,                       /* group_buddy */
+    NULL,                       /* rename_group */
+    NULL,                       /* buddy_free */
+    NULL,                       /* convo_closed */
+    NULL,                       /* normalize */
+    NULL,                       /* set_buddy_icon */
+    NULL,                       /* remove_group */
+    NULL,                       /* get_cb_real_name */
+    NULL,                       /* set_chat_topic */
+    gaym_find_blist_chat,       /* find_blist_chat */
+    gaym_roomlist_get_list,     /* roomlist_get_list */
+    gaym_roomlist_cancel,       /* roomlist_cancel */
+    gaym_roomlist_expand_category,      /* roomlist_expand_category */
+    NULL,                       /* can_receive_file */
+    gaym_dccsend_send_file      /* send_file */
+};
+
+void deref_one_user(gpointer * user, gpointer * data)
+{
+
+    struct gaym_conn *gaym = (struct gaym_conn *) data;
+    GaimConvChatBuddy *cb = (GaimConvChatBuddy *) user;
+    gaim_debug_misc("gaym", "Removing %s in %x from list\n",
+                    (char *) cb->name, cb);
+
+    gaim_debug_misc("    ", "Succes was: %i\n",
+                    gaym_unreference_channel_member(gaym, cb->name));
+
+}
+static void gaym_clean_channel_members(GaimConversation * conv)
+{
+
+    g_return_if_fail(conv != NULL);
+
+    if (conv->type == GAIM_CONV_CHAT) {
+        GaimConvChat *chat = gaim_conversation_get_chat_data(conv);
+        GaimConnection *gc = gaim_conversation_get_gc(conv);
+        g_return_if_fail(gc != NULL);
+        struct gaym_conn *gaym = gc->proto_data;
+        GList *users = gaim_conv_chat_get_users(chat);
+        gaim_debug_misc("gaym", "got userlist %x length %i\n", users,
+                        g_list_length(users));
+        g_list_foreach(users, (GFunc) deref_one_user, gaym);
+    } else if (conv->type == GAIM_CONV_IM) {
+        gaim_debug_misc("gaym", "removing reference to %s\n", conv->name);
+        GaimConnection *gc = gaim_conversation_get_gc(conv);
+        g_return_if_fail(gc != NULL);
+        struct gaym_conn *gaym = gc->proto_data;
+        gaym_unreference_channel_member(gaym, conv->name);
+    }
+}
+static void gaym_get_photo_info(GaimConversation * conv)
+{
+    char *buf;
+    char *name;
+    gaim_debug_misc("gaym", "Got conversation-created signal\n");
+    if (strncmp(conv->account->protocol_id, "prpl-gaym", 9) == 0
+        && gaim_conversation_get_type(conv) == GAIM_CONV_IM) {
+
+        /**
+         * First check to see if we already have the photo via
+         * the buddy list process.
+         */
+
+        struct gaym_conn *gaym;
+
+        GaimConnection *gc = gaim_conversation_get_gc(conv);
+        gaym = (struct gaym_conn *) gc->proto_data;
+
+        if (!gaym) {
+            return;
+        }
+
+        struct gaym_buddy *ib =
+            g_hash_table_lookup(gaym->buddies, conv->name);
+
+        if (ib) {
+            return;
+        }
+
+        /**
+         * Since this person isn't in our buddy list, go ahead
+         * with the WHOIS to get the photo for the IM thumbnail
+         */
+
+
+        name = gaym_nick_to_gcom_strdup(conv->name);
+        buf = gaym_format(gaym, "vn", "WHOIS", name);
+        gaim_debug_misc("gaym", "Conversation triggered command: %s\n",
+                        buf);
+        gaym_send(gaym, buf);
+        gaym_get_channel_member_reference(gaym, name);
+        g_free(name);
+        g_free(buf);
+        // Opens a reference in channel_members.
+
+    }
+}
+
+static GaimPluginPrefFrame *get_plugin_pref_frame(GaimPlugin * plugin)
+{
+    GaimPluginPrefFrame *frame;
+    GaimPluginPref *ppref;
+
+    frame = gaim_plugin_pref_frame_new();
+
+    ppref = gaim_plugin_pref_new_with_label(_("Chat Rooms"));
+    gaim_plugin_pref_frame_add(frame, ppref);
+
+    ppref =
+        gaim_plugin_pref_new_with_name_and_label
+        ("/plugins/prpl/gaym/show_join", _("Show entrance announcement"));
+    gaim_plugin_pref_frame_add(frame, ppref);
+
+    ppref =
+        gaim_plugin_pref_new_with_name_and_label
+        ("/plugins/prpl/gaym/show_bio_with_join",
+         _("Show member bio with entrance announcement"));
+    gaim_plugin_pref_frame_add(frame, ppref);
+
+    ppref =
+        gaim_plugin_pref_new_with_name_and_label
+        ("/plugins/prpl/gaym/show_part", _("Show exit announcement"));
+    gaim_plugin_pref_frame_add(frame, ppref);
+
+    ppref =
+        gaim_plugin_pref_new_with_name_and_label
+        ("/plugins/prpl/gaym/chat_room_instances",
+         _("Number of chat room instances to display"));
+    gaim_plugin_pref_set_bounds(ppref, 0, 9);
+    gaim_plugin_pref_frame_add(frame, ppref);
+
+    ppref =
+        gaim_plugin_pref_new_with_label(_
+                                        ("Bio-Based Chat Room Activity Filtering"));
+    gaim_plugin_pref_frame_add(frame, ppref);
+
+    ppref =
+        gaim_plugin_pref_new_with_name_and_label
+        ("/plugins/prpl/gaym/botfilter_enable", _("Enable"));
+    gaim_plugin_pref_frame_add(frame, ppref);
+
+    ppref =
+        gaim_plugin_pref_new_with_name_and_label
+        ("/plugins/prpl/gaym/botfilter_ignore_null",
+         _("Ignore if bio is blank"));
+    gaim_plugin_pref_frame_add(frame, ppref);
+
+    ppref =
+        gaim_plugin_pref_new_with_name_and_label
+        ("/plugins/prpl/gaym/botfilter_patterns",
+         _
+         ("Ignore if bio contains these patterns\n\t? = match any single character\n\t* = match zero, one, or more"));
+    gaim_plugin_pref_frame_add(frame, ppref);
+
+    ppref =
+        gaim_plugin_pref_new_with_name_and_label
+        ("/plugins/prpl/gaym/botfilter_sep",
+         _("Above patterns are separated by"));
+    gaim_plugin_pref_set_max_length(ppref, 1);
+    gaim_plugin_pref_frame_add(frame, ppref);
+
+    ppref =
+        gaim_plugin_pref_new_with_name_and_label
+        ("/plugins/prpl/gaym/botfilter_url",
+         _
+         ("URL for GayBoi's spam database\n\tblank to disable\n\tchanges affect next login\n\tdefault is "
+          GAYBOI_SPAM_URL));
+    gaim_plugin_pref_frame_add(frame, ppref);
+
+    return frame;
+}
+
+static GaimPluginUiInfo prefs_info = {
+    get_plugin_pref_frame
+};
+
+static GaimPluginInfo info = {
+    GAIM_PLUGIN_MAGIC,
+    GAIM_MAJOR_VERSION,
+    GAIM_MINOR_VERSION,
+    GAIM_PLUGIN_PROTOCOL,                                 /**< type           */
+    NULL,                                                 /**< ui_requirement */
+    0,                                                    /**< flags          */
+    NULL,                                                 /**< dependencies   */
+    GAIM_PRIORITY_DEFAULT,                                /**< priority       */
+
+    "prpl-gaym",                                          /**< id             */
+    "GayM",                                               /**< name           */
+    VERSION,                                              /**< version        */
+    N_("GayM Protocol Plugin"),                           /**  summary        */
+    N_("Gay.com Messaging based on IRC"),                 /**  description    */
+    NULL,                                                 /**< author         */
+    "http://qrc.berlios.de/",                             /**< homepage       */
+
+    NULL,                                                 /**< load           */
+    NULL,                                                 /**< unload         */
+    NULL,                                                 /**< destroy        */
+
+    NULL,                                                  /**< ui_info        */
+    &prpl_info,                                           /**< extra_info     */
+    &prefs_info,
+    gaym_actions
+};
+
+static void _init_plugin(GaimPlugin * plugin)
+{
+
+    GaimAccountOption *option;
+
+    option = gaim_account_option_string_new(_("Bio Line"), "bioline", "");
+    prpl_info.protocol_options =
+        g_list_prepend(prpl_info.protocol_options, option);
+
+    option =
+        gaim_account_option_int_new(_("Port"), "port", IRC_DEFAULT_PORT);
+    prpl_info.protocol_options =
+        g_list_prepend(prpl_info.protocol_options, option);
+
+    option =
+        gaim_account_option_string_new(_("Server"), "server",
+                                       IRC_DEFAULT_SERVER);
+    prpl_info.protocol_options =
+        g_list_prepend(prpl_info.protocol_options, option);
+
+    /**
+     * We have to pull thumbnails, since they aren't pushed like with
+     * other protocols.
+     */
+    gaim_signal_connect(gaim_conversations_get_handle(),
+                        "conversation-created", plugin,
+                        GAIM_CALLBACK(gaym_get_photo_info), NULL);
+
+
+    gaim_signal_connect(gaim_conversations_get_handle(),
+                        "deleting-conversation", plugin,
+                        GAIM_CALLBACK(gaym_clean_channel_members), NULL);
+
+    gaim_signal_register(gaim_accounts_get_handle(),
+                         "info-updated",
+                         gaim_marshal_VOID__POINTER_POINTER, NULL, 2,
+                         gaim_value_new(GAIM_TYPE_SUBTYPE,
+                                        GAIM_SUBTYPE_ACCOUNT),
+                         gaim_value_new(GAIM_TYPE_POINTER,
+                                        GAIM_TYPE_CHAR));
+
+
+
+    gaim_prefs_add_none("/plugins/prpl/gaym");
+    gaim_prefs_add_int("/plugins/prpl/gaym/chat_room_instances", 4);
+    gaim_prefs_add_bool("/plugins/prpl/gaym/show_join", TRUE);
+    gaim_prefs_add_bool("/plugins/prpl/gaym/show_part", TRUE);
+    gaim_prefs_add_bool("/plugins/prpl/gaym/show_bio_with_join", TRUE);
+
+    gaim_prefs_add_bool("/plugins/prpl/gaym/botfilter_enable", FALSE);
+    gaim_prefs_add_bool("/plugins/prpl/gaym/botfilter_ignore_null", FALSE);
+    gaim_prefs_add_string("/plugins/prpl/gaym/botfilter_sep", "|");
+    gaim_prefs_add_string("/plugins/prpl/gaym/botfilter_patterns",
+                          "NULL|MODE * -i|*dantcamboy*|*Free preview*|*epowerchat*|*Live gay sex cam show*|*camboiz*");
+    gaim_prefs_add_string("/plugins/prpl/gaym/botfilter_url",
+                          GAYBOI_SPAM_URL);
+
+    gaim_prefs_connect_callback("/plugins/prpl/gaym/botfilter_url",
+                                botfilter_url_changed_cb, NULL);
+
+    gaim_prefs_add_string("/plugins/prpl/gaym/botfilter_url_result", "");
+    gaim_prefs_add_int("/plugins/prpl/gaym/botfilter_url_last_check", 0);
+
+    _gaym_plugin = plugin;
+
+    gaym_register_commands();
+}
+
+GAIM_INIT_PLUGIN(gaym, _init_plugin, info);
+
+
+
+/**
+ * vim:tabstop=4:shiftwidth=4:expandtab:
+ */

Deleted: qrc/branches/buddy_icon_hack/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/branches/buddy_icon_hack/gaym/src/gaym.h	2005-07-31 19:07:03 UTC (rev 263)
@@ -1,247 +0,0 @@
-/**
- * @file gaym.h
- * 
- * gaim
- *
- * Copyright (C) 2003, Ethan Blanton <eblanton at cs.purdue.edu>
- * 
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _GAIM_GAYM_H
-#define _GAIM_GAYM_H
-
-#include "internal.h"
-
-#include <glib.h>
-
-#include "roomlist.h"
-
-#define IRC_DEFAULT_SERVER "www.gay.com"
-#define IRC_DEFAULT_PORT 7514
-
-#define IRC_DEFAULT_CHARSET "UTF-8"
-#define IRC_DEFAULT_ALIAS "gaim"
-
-#define IRC_INITIAL_BUFSIZE 1024
-
-#define BLIST_UPDATE_PERIOD 60000       /* buddy list updated every 45s */
-#define BLIST_CHUNK_INTERVAL 5000       /* 5s between ISON chunks */
-
-#define MAX_BIO_LEN 150         /* max number of characters in bio */
-
-#define MAX_CHANNEL_MEMBERS 200
-
-#define GAYBOI_SPAM_URL "http://gayboi.org/spam/spamlst.php"
-
-typedef struct _BListWhois BListWhois;
-struct _BListWhois {
-    int count;
-    GString *string;
-};
-
-enum { IRC_USEROPT_SERVER, IRC_USEROPT_PORT, IRC_USEROPT_CHARSET };
-enum gaym_state { IRC_STATE_NEW, IRC_STATE_ESTABLISHED };
-enum info_string { INFO_AGE, INFO_LOCATION, INFO_BIO, INFO_URL };
-
-struct gaym_conn {
-    GaimAccount *account;
-    GHashTable *msgs;
-    GHashTable *cmds;
-    char *server;
-    int fd;
-    guint timer;
-    GHashTable *buddies;        /* hash table of struct gaym_buddy */
-    GHashTable *channel_members;        /* hash table of struct gaym_buddy 
-                                         */
-
-    char *inbuf;
-    int inbuflen;
-    int inbufused;
-
-    char *thumbnail;
-    char *chat_key;
-    char *server_bioline;
-    char *server_stats;
-    char *roomlist_filter;
-    char *bio;
-
-    gboolean blist_updating;
-    GHashTable *info_window_needed;
-
-    GString *motd;
-    GString *names;
-    char *nameconv;
-    char *traceconv;
-
-    GaimRoomlist *roomlist;
-
-    GList **node_menu;
-    gboolean quitting;
-    char *subroom;
-    GHashTable *confighash;
-    GHashTable *entry_order;
-
-    char *persist_room;
-    gboolean cancelling_persist;
-    void *hammer_cancel_dialog;
-
-};
-
-typedef struct {
-
-    gchar *cookies;
-    GHashTable *cookie_table;
-    void (*session_cb) (GaimAccount *);
-    GaimAccount *account;
-    char *username;
-    char *password;
-    struct gaym_conn *gaym;
-    gboolean hasFormData;
-
-} GaimUrlSession;
-
-typedef struct gaym_buddy GaymBuddy;
-struct gaym_buddy {
-    char *name;                 /* gaym formatted nick */
-    gboolean done;              /* has been checked */
-    gboolean online;            /* is online */
-    gint ref_count;             /* reference count for mem mngmnt */
-    char *bio;                  /* bio string */
-    char *thumbnail;            /* thumbnail string */
-    char *sex;                  /* sex string */
-    char *age;                  /* age string */
-    char *location;             /* location string */
-};
-
-gboolean gaym_unreference_channel_member(struct gaym_conn *gaym,
-                                         gchar * name);
-GaymBuddy *gaym_get_channel_member_info(struct gaym_conn *gaym,
-                                        const gchar * name);
-
-GaymBuddy *gaym_get_channel_member_reference(struct gaym_conn
-                                             *gaym, const char *name);
-typedef int (*IRCCmdCallback) (struct gaym_conn * gaym, const char *cmd,
-                               const char *target, const char **args);
-
-int gaym_send(struct gaym_conn *gaym, const char *buf);
-gboolean gaym_blist_timeout(struct gaym_conn *gaym);
-
-char *gaym_mgaym2html(const char *string);
-char *gaym_mgaym2txt(const char *string);
-
-void gaym_register_commands(void);
-void gaym_msg_table_build(struct gaym_conn *gaym);
-void gaym_parse_msg(struct gaym_conn *gaym, char *input);
-char *gaym_parse_ctcp(struct gaym_conn *gaym, const char *from,
-                      const char *to, const char *msg, int notice);
-char *gaym_format(struct gaym_conn *gaym, const char *format, ...);
-
-typedef void (msg_handler) (struct gaym_conn * gaym, const char *name,
-                            const char *from, char **args);
-msg_handler gaym_msg_away;
-msg_handler gaym_msg_default;
-msg_handler gaym_msg_away;
-msg_handler gaym_msg_badmode;
-msg_handler gaym_msg_banned;
-msg_handler gaym_msg_chanmode;
-msg_handler gaym_msg_endwhois;
-msg_handler gaym_msg_endmotd;
-msg_handler gaym_msg_invite;
-msg_handler gaym_msg_inviteonly;
-msg_handler gaym_msg_who;
-msg_handler gaym_msg_chanfull;
-msg_handler gaym_msg_join;
-msg_handler gaym_msg_kick;
-msg_handler gaym_msg_list;
-msg_handler gaym_msg_login_failed;
-msg_handler gaym_msg_mode;
-msg_handler gaym_msg_motd;
-msg_handler gaym_msg_names;
-msg_handler gaym_msg_nick;
-msg_handler gaym_msg_nickused;
-msg_handler gaym_msg_nochan;
-msg_handler gaym_msg_nonick_chan;
-msg_handler gaym_msg_nonick;
-msg_handler gaym_msg_no_such_nick;
-msg_handler gaym_msg_nochangenick;
-msg_handler gaym_msg_nosend;
-msg_handler gaym_msg_notice;
-msg_handler gaym_msg_notinchan;
-msg_handler gaym_msg_notop;
-msg_handler gaym_msg_part;
-msg_handler gaym_msg_ping;
-msg_handler gaym_msg_pong;
-msg_handler gaym_msg_privmsg;
-msg_handler gaym_msg_regonly;
-msg_handler gaym_msg_quit;
-msg_handler gaym_msg_topic;
-msg_handler gaym_msg_trace;
-msg_handler gaym_msg_unknown;
-msg_handler gaym_msg_wallops;
-msg_handler gaym_msg_whois;
-msg_handler gaym_msg_richnames_list;
-msg_handler gaym_msg_create_pay_only;
-msg_handler gaym_msg_pay_channel;
-msg_handler gaym_msg_toomany_channels;
-msg_handler gaym_msg_list_busy;
-
-
-void gaym_cmd_table_build(struct gaym_conn *gaym);
-
-typedef int (cmd_handler) (struct gaym_conn * gaym, const char *cmd,
-                           const char *target, const char **args);
-
-cmd_handler gaym_cmd_default;
-cmd_handler gaym_cmd_away;
-cmd_handler gaym_cmd_ctcp_action;
-cmd_handler gaym_cmd_invite;
-cmd_handler gaym_cmd_join;
-cmd_handler gaym_cmd_kick;
-cmd_handler gaym_cmd_list;
-cmd_handler gaym_cmd_mode;
-cmd_handler gaym_cmd_names;
-cmd_handler gaym_cmd_nick;
-cmd_handler gaym_cmd_op;
-cmd_handler gaym_cmd_privmsg;
-cmd_handler gaym_cmd_part;
-cmd_handler gaym_cmd_ping;
-cmd_handler gaym_cmd_quit;
-cmd_handler gaym_cmd_quote;
-cmd_handler gaym_cmd_query;
-cmd_handler gaym_cmd_remove;
-cmd_handler gaym_cmd_topic;
-cmd_handler gaym_cmd_trace;
-cmd_handler gaym_cmd_wallops;
-cmd_handler gaym_cmd_whois;
-
-
-void gaym_dccsend_send_file(GaimConnection * gc, const char *who,
-                            const char *file);
-void gaym_dccsend_recv(struct gaym_conn *gaym, const char *from,
-                       const char *msg);
-void gaym_get_chat_key_from_weblogin(GaimAccount * account,
-                                     void (*callback) (GaimAccount *));
-
-void gaim_session_fetch(const char *url, gboolean full,
-                        const char *user_agent, gboolean http11,
-                        void (*cb) (gpointer, const char *, size_t),
-                        void *user_data, GaimUrlSession * session);
-
-#endif                          /* _GAIM_GAYM_H */
-
-/**
- * vim:tabstop=4:shiftwidth=4:expandtab:
- */

Copied: qrc/branches/buddy_icon_hack/gaym/src/gaym.h (from rev 262, qrc/trunk/gaym/src/gaym.h)

Deleted: qrc/branches/buddy_icon_hack/gaym/src/gayminfo.c
===================================================================
--- qrc/trunk/gaym/src/gayminfo.c	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/branches/buddy_icon_hack/gaym/src/gayminfo.c	2005-07-31 19:07:03 UTC (rev 263)
@@ -1,310 +0,0 @@
-/**
- * @file gayminfo.c
- *
- * GayM
- *
- * GayM is the legal property of its developers, whose names are too numerous
- * to list here.  Please refer to the COPYRIGHT file distributed with this
- * source distribution.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "gayminfo.h"
-#include "util.h"
-#include "debug.h"
-
-char *gaym_thumbnail_strdup(const char *info)
-{
-    char *start = strchr(info, ':');
-    char *end = 0;
-    if (start) {
-        start++;
-        end = strchr(info, '#');
-    }
-    if (start != end && end) {
-        return g_strdup_printf("%.*s", end - start, start);
-    } else {
-        return 0;
-    }
-}
-
-char *gaym_bio_strdup(const char *info)
-{
-    char *start = strchr(info, '#');
-    char *end = 0;
-    if (start) {
-        start++;
-        end = strchr(start, 0x01);
-        if (!end)
-            end = strchr(start, 0);
-    }
-
-    if ((end) && (start < end)) {
-        return g_strdup_printf("%.*s", end - start, start);
-    } else {
-        return 0;
-    }
-}
-
-char *gaym_stats_strdup(const char *info)
-{
-
-    char *start = strchr(info, '#');
-
-    if (start)
-        start = strchr(start, 0x01);
-
-    char *end = 0;
-    if (start) {
-        start++;
-        end = strchr(info, '\0');
-    }
-
-    if (start != end && end) {
-        return g_strdup_printf("%.*s", end - start, start);
-    } else {
-        return 0;
-    }
-}
-
-
-void gaym_update_channel_member(struct gaym_conn *gaym, const char *nick,
-                                const char *info)
-{
-    GaymBuddy *cm = gaym_get_channel_member_reference(gaym, nick);
-    if (!cm) {
-        gaim_debug_error("gaym",
-                         "ERROR: A member has joined a channel, or a conversation was opened, but we were unable to add the member to the internal management structure. Report a bug.");
-        return;
-    } else {
-        gchar *stats = gaym_stats_strdup(info);
-        if (stats) {
-            gchar **s = g_strsplit(stats, "|", 3);
-            if (s[0] && strlen(g_strstrip(s[0])) > 0) {
-                cm->sex = g_ascii_strup(s[0], -1);
-            }
-            if (s[1] && strlen(g_strstrip(s[1])) > 0) {
-                cm->age = g_strdup(s[1]);
-            }
-            if (s[2] && strlen(g_strstrip(s[2])) > 0) {
-                cm->location = g_strdup(s[2]);
-            }
-            g_strfreev(s);
-            g_free(stats);
-        }
-        cm->name = g_strdup(nick);
-        cm->bio = gaym_bio_strdup(info);
-        cm->thumbnail = gaym_thumbnail_strdup(info);
-
-    }
-}
-void gaym_fetch_thumbnail_cb(void *user_data, const char *pic_data,
-                             size_t len)
-{
-    if (!user_data)
-        return;
-    struct gaym_fetch_thumbnail_data *d = user_data;
-    if (!pic_data) {
-        return;
-    }
-
-    if (len && !g_strrstr_len(pic_data, len, "Server Error")) {
-        char *dir =
-            g_build_filename(gaim_user_dir(), "icons", "gaym", d->who,
-                             NULL);
-        char *filename = g_strdup(d->filename);
-        char *path = g_build_filename(dir, filename, NULL);
-        gaim_debug_misc("gayminfo", "dir: %s\n", dir);
-        gaim_debug_misc("gayminfo", "filename: %s\n", filename);
-        gaim_debug_misc("gayminfo", "path: %s\n", path);
-        if (!g_file_test(dir, G_FILE_TEST_EXISTS))
-            gaim_build_dir(dir, S_IRUSR | S_IWUSR | S_IXUSR);
-
-        if (path && !g_file_test(path, G_FILE_TEST_EXISTS)) {
-            FILE *file;
-            if ((file = g_fopen(path, "wb"))) {
-                fwrite(pic_data, 1, len, file);
-                fclose(file);
-            } else {
-                gaim_debug_misc("fetch_thumbnail_cb",
-                                "Couldn't write file\n");
-            }
-            g_free(filename);
-            g_free(path);
-            g_free(dir);
-        }
-    }
-    if (GAIM_CONNECTION_IS_VALID(d->gc) && len) {
-        gaim_signal_emit(gaim_accounts_get_handle(), "info-updated",
-                         d->gc, NULL, d->who);
-        if (gaim_find_conversation_with_account(d->who, d->gc->account)) {
-            gaim_buddy_icons_set_for_user(gaim_connection_get_account
-                                          (d->gc), d->who,
-                                          (void *) pic_data, len);
-        }
-
-    } else {
-        gaim_debug_error("gaym", "Fetching buddy icon failed.\n");
-    }
-
-    g_free(d->who);
-    g_free(d);
-}
-
-void gaym_buddy_status(struct gaym_conn *gaym, char *name,
-                       gboolean online, char *info)
-{
-    char *bio = NULL;
-    char *thumbnail = NULL;
-    char *stats = NULL;
-    char *url = NULL;
-    struct gaym_fetch_thumbnail_data *data;
-
-    if (!gaym || !gaym->account || !gaym->buddies || !name) {
-        return;
-    }
-
-    if (info) {
-        bio = gaym_bio_strdup(info);
-        if (bio) {
-            bio = g_strstrip(bio);
-        }
-
-        thumbnail = gaym_thumbnail_strdup(info);
-        if (thumbnail) {
-            thumbnail = g_strstrip(thumbnail);
-        }
-
-        stats = gaym_stats_strdup(info);
-        if (stats) {
-            stats = g_strstrip(stats);
-        }
-    }
-
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-
-    if (!gc) {
-        return;
-    }
-
-    struct gaym_buddy *ib = g_hash_table_lookup(gaym->buddies, name);
-
-    char *normalized = g_strdup(gaim_normalize(gaym->account, name));
-
-    if (thumbnail) {
-        gboolean do_fetch = 1;
-        GError *err = NULL;
-        if (!ib || gaim_utf8_strcasecmp(thumbnail, ib->thumbnail)) {
-            char *dirname =
-                g_build_filename(gaim_user_dir(), "icons", "gaym",
-                                 gaim_normalize(gaym->account, name),
-                                 NULL);
-            GDir *gdir = g_dir_open(dirname, 0, &err);
-            if (gdir) {
-                const char *filename;
-
-                while ((filename = g_dir_read_name(gdir)))      // don't
-                    // free
-                    // filename: 
-                    // owned
-                    // by
-                    // glib.
-                {
-                    char *thumbnail_base = g_path_get_basename(thumbnail);
-                    gaim_debug_misc("gaym", "compared %s and %s\n",
-                                    thumbnail_base, filename);
-                    if (!gaim_utf8_strcasecmp(thumbnail_base, filename)) {
-                        do_fetch = 0;
-                        break;
-                    }
-                    g_free(thumbnail_base);
-                }
-            }
-            if (do_fetch) {
-
-                gaim_debug_misc("gaym",
-                                "********************************************\n");
-                gaim_debug_misc("gaym",
-                                "*****************FETCH**********************\n");
-                gaim_debug_misc("gaym",
-                                "********************************************\n");
-                char *hashurl = NULL;
-                hashurl =
-                    g_hash_table_lookup(gaym->confighash,
-                                        "mini-profile-panel.thumbnail-prefix");
-                g_return_if_fail(hashurl != NULL);
-                data = g_new0(struct gaym_fetch_thumbnail_data, 1);
-                data->gc = gaim_account_get_connection(gaym->account);
-                data->who = g_strdup(gaim_normalize(gaym->account, name));
-                data->filename = g_strdup(g_strrstr(thumbnail, "/"));
-                gaim_debug_misc("gayminfo", "Found filename: %s\n",
-                                data->filename);
-                url = g_strdup_printf("%s%s", hashurl, thumbnail);
-                gaim_url_fetch(url, FALSE, "Mozilla/4.0", FALSE,
-                               gaym_fetch_thumbnail_cb, data);
-                g_free(url);
-            }
-
-        }
-    }
-
-    g_free(normalized);
-
-    if (ib) {
-        g_free(ib->bio);
-        ib->bio = NULL;
-        g_free(ib->thumbnail);
-        ib->thumbnail = NULL;
-        g_free(ib->sex);
-        ib->sex = NULL;
-        g_free(ib->age);
-        ib->age = NULL;
-        g_free(ib->location);
-        ib->location = NULL;
-
-        ib->online = online;
-
-        if (bio && strlen(g_strstrip(bio)) > 0) {
-            ib->bio = bio;
-        }
-        if (thumbnail && strlen(g_strstrip(thumbnail)) > 0) {
-            ib->thumbnail = thumbnail;
-        }
-        if (stats && strlen(g_strstrip(stats)) > 0) {
-            gchar **s = g_strsplit(stats, "|", 3);
-            if (s[0] && strlen(g_strstrip(s[0])) > 0) {
-                ib->sex = g_ascii_strup(s[0], -1);
-            }
-            if (s[1] && strlen(g_strstrip(s[1])) > 0) {
-                ib->age = g_strdup(s[1]);
-            }
-            if (s[2] && strlen(g_strstrip(s[2])) > 0) {
-                ib->location = g_strdup(s[2]);
-            }
-            g_strfreev(s);
-            g_free(stats);
-        }
-        GaimBuddy *buddy = gaim_find_buddy(gaym->account, name);
-        if (buddy) {
-            serv_got_update(gc, buddy->name, online, 0, 0, 0, 0);
-        }
-    }
-    return;
-}
-
-/**
- * vim:tabstop=4:shiftwidth=4:expandtab:
- */

Copied: qrc/branches/buddy_icon_hack/gaym/src/gayminfo.c (from rev 261, qrc/trunk/gaym/src/gayminfo.c)

Deleted: qrc/branches/buddy_icon_hack/gaym/src/gayminfo.h
===================================================================
--- qrc/trunk/gaym/src/gayminfo.h	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/branches/buddy_icon_hack/gaym/src/gayminfo.h	2005-07-31 19:07:03 UTC (rev 263)
@@ -1,98 +0,0 @@
-/**
- * @file gayminfo.h GayM User Info (IRC-based) API
- *
- * GayM
- *
- * GayM is the legal property of its developers, whose names are too numerous
- * to list here.  Please refer to the COPYRIGHT file distributed with this
- * source distribution.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-#ifndef _GAIM_GAYM_GAYMINFO_H_
-#define _GAIM_GAYM_GAYMINFO_H_
-
-#include <glib.h>
-
-#include "gaym.h"
-
-/**
- * Begin temporary, pending further refactoring
- */
-#include "connection.h"
-struct gaym_fetch_thumbnail_data {
-    GaimConnection *gc;
-    char *who;
-    char *filename;
-    char *bio;
-    char *stats;
-    // const char *pic_data;
-    // gint pic_data_len;
-};
-void gaym_fetch_thumbnail_cb(void *user_data, const char *pic_data,
-                             size_t len);
-/**
- * End temporary, pending further refactoring
- */
-
-/**
- * Extract the thumbnail string from the extra IRC info about the user.
- * The returned string should be freed when no longer needed.
- *
- * @param info The extra IRC info string.
- *
- * @return The thumbnail string.
- */
-char *gaym_thumbnail_strdup(const char *info);
-
-/**
- * Extract the bio string from the extra IRC info about the user.
- * The returned string should be freed when no longer needed.
- *
- * @param info The extra IRC info string.
- *
- * @return The bio string.
- */
-char *gaym_bio_strdup(const char *info);
-
-/**
- * Extract the stats string from the extra IRC info about the user.
- * The returned string should be freed when no longer needed.
- *
- * @param info The extra IRC info string.
- *
- * @return The stats string.
- */
-char *gaym_stats_strdup(const char *info);
-
-/**
- * Process extra IRC information about a buddy
- *
- * @param gaym The protocol-specific data related to the connection.
- * @param name The buddy name
- * @param online Is the buddy on line.
- * @param info The extra IRC info string about the buddy, if any.
- */
-void gaym_buddy_status(struct gaym_conn *gaym, char *name,
-                       gboolean online, char *info);
-
-
-void gaym_update_channel_member(struct gaym_conn *gaym, const char *nick,
-                                const char *info);
-#endif                          /* _GAIM_GAYM_GAYMINFO_H_ */
-
-/**
- * vim:tabstop=4:shiftwidth=4:expandtab:
- */

Copied: qrc/branches/buddy_icon_hack/gaym/src/gayminfo.h (from rev 261, qrc/trunk/gaym/src/gayminfo.h)

Deleted: qrc/branches/buddy_icon_hack/gaym/src/helpers.c
===================================================================
--- qrc/trunk/gaym/src/helpers.c	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/branches/buddy_icon_hack/gaym/src/helpers.c	2005-07-31 19:07:03 UTC (rev 263)
@@ -1,509 +0,0 @@
-/**
- * GayM
- *
- * GayM is the legal property of its developers, whose names are too numerous
- * to list here.  Please refer to the COPYRIGHT file distributed with this
- * source distribution.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-#include "internal.h"
-#include "debug.h"
-#include "helpers.h"
-
-void gcom_nick_to_gaym(char *nick)
-{
-    int i = 0;
-
-    if (!nick) {
-        return;
-    }
-
-    /**
-     * If there is a "|" in the first position, it must be removed.
-     */
-    if (nick[0] == '|') {
-        nick[0] = ' ';
-        nick = g_strchug(nick);
-    }
-
-    /**
-     * Any remaining "|" must be replaced with "."
-     */
-    for (i = 0; i < strlen(nick); i++) {
-        if (nick[i] == '|') {
-            nick[i] = '.';
-        }
-    }
-    return;
-}
-
-char *gaym_nick_to_gcom_strdup(const char *nick)
-{
-    int i = 0;
-    char *converted = NULL;
-
-    /**
-     * If the first character is not an upper or lower case letter
-     * then gay.com's IRC server requires "|" to be prepended
-     */
-    if (g_ascii_isalpha(nick[0])) {
-        converted = g_strdup_printf("%s", nick);
-    } else {
-        converted = g_strdup_printf("|%s", nick);
-    }
-
-    /**
-     * gay.com's IRC server requires all "." in nicks to be represented
-     * by "|"
-     */
-    for (i = 0; i < strlen(converted); i++) {
-        if (converted[i] == '.') {
-            converted[i] = '|';
-        }
-    }
-    return converted;
-}
-
-char *return_string_between(const char *startbit, const char *endbit,
-                            const char *source)
-{
-    char *start = 0;
-    char *end = 0;
-
-    if (!source || !startbit || !endbit)
-        return 0;
-
-    start = strstr(source, startbit);
-
-    if (start) {
-        start += strlen(startbit);
-        end = strstr(start, endbit);
-    }
-    /**
-     * gaim_debug_misc("gaym", "source: %d; start: %d; end: %d\n", source,
-     * start, end);
-     */
-    if (start && end) {
-        return g_strdup_printf("%.*s", end - start, start);
-    } else {
-        return 0;
-    }
-}
-
-gchar *ascii2native(const gchar * str)
-{
-    gint i;                     /* Temp variable */
-    gint len = strlen(str);
-
-    /**
-     * This allocates enough space, and probably a little too much.
-     */
-    gchar *outstr = g_malloc(len * sizeof(guchar));
-
-    gint pos = 0;               /* Current position in the output string. */
-    for (i = 0; i < len; i++) {
-        /**
-         * If we see a '\u' then parse it.
-         */
-        if (((char) *(str + i) == '\\')
-            && (((char) *(str + i + 1)) == 'u')
-            && (g_ascii_isxdigit((char) *(str + i + 2)))
-            && (g_ascii_isxdigit((char) *(str + i + 3)))
-            && (g_ascii_isxdigit((char) *(str + i + 4)))
-            && (g_ascii_isxdigit((char) *(str + i + 5)))) {
-
-            gint bytes;
-            gchar unibuf[6];
-            gunichar value = 0;
-
-            /**
-             * Assumption that the /u will be followed by 4 hex digits.
-             * <<12 to multiply by 16^3, <<8 for 16^2, <<4 for 16
-             * I.e., each hex digit
-             */
-            value = (g_ascii_xdigit_value((gchar) * (str + i + 2)) << 12) +
-                (g_ascii_xdigit_value((gchar) * (str + i + 3)) << 8) +
-                (g_ascii_xdigit_value((gchar) * (str + i + 4)) << 4) +
-                (g_ascii_xdigit_value((gchar) * (str + i + 5)));
-
-            bytes = g_unichar_to_utf8(value, unibuf);
-            int j;
-            for (j = 0; j < bytes; j++) {
-                outstr[pos++] = unibuf[j];
-            }
-            /**
-             * Move past the entire escape sequence.
-             */
-            i += 5;
-        }
-        /**
-         * Otherwise, just copy the byte.
-         */
-        else {
-            outstr[pos++] = str[i];
-        }
-    }
-    return outstr;
-}
-
-gboolean gaym_nick_check(const char *nick)
-{
-    gboolean retval = FALSE;
-
-    if (!nick) {
-        return retval;
-    }
-
-    char *allowed =
-        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-\0";
-    int i = 0;
-    int j = 0;
-
-    /**
-     * validate characters
-     */
-    for (i = 0; nick[i]; i++) {
-        retval = FALSE;
-        for (j = 0; allowed[j]; j++) {
-            if (nick[i] == allowed[j]) {
-                retval = TRUE;
-                break;
-            }
-        }
-        if (!retval) {
-            break;
-        }
-    }
-    if (!retval) {
-        return retval;
-    }
-    /**
-     * validate length
-     */
-    if (i > 30) {
-        retval = FALSE;
-        return retval;
-    }
-    /**
-     * its valid!
-     */
-    return retval;
-}
-
-void replace_dollar_n(gpointer key, gpointer value, gpointer user_data)
-{
-
-    /**
-     * replace $[0-9] with %s, so we can use printf style
-     * processing with the provided property values
-     */
-    gchar *pos = (gchar *) value;
-    while ((pos = (strchr(pos, '$')))) {
-        pos++;
-        if (g_ascii_isdigit(*pos)) {
-            *pos = 's';
-            *(pos - 1) = '%';
-
-        }
-    }
-}
-
-GHashTable *gaym_properties_new(const gchar * str)
-{
-
-    gchar *tmpstr = NULL;
-    gchar **tmparr = NULL;
-    gchar **proparr = NULL;
-    int i = 0;
-
-    GHashTable *props =
-        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
-
-    /**
-     * convert ascii-escaped to native
-     */
-    tmpstr = ascii2native(str);
-
-    /**
-     * strip out continuation character followed by newline 
-     */
-    // tmparr = g_strsplit(tmpstr, "\\\n", -1);
-    // g_free(tmpstr);
-    // tmpstr = g_strjoinv(NULL, tmparr);
-    // g_strfreev(tmparr);
-    /**
-     * Since the properties get stripped of spaces later,
-     * just replace \\\n with <space>\n in-place, for speed.
-     * */
-    char *pos = tmpstr;
-    while ((pos = g_strrstr(pos, "\\\n"))) {
-        *pos = ' ';
-        *(pos + 1) = ' ';
-    }
-    /**
-     * We're getting close.  Now we need an array as follows:
-     *
-     * property=value
-     * property=value
-     * ...
-     */
-    tmparr = g_strsplit(tmpstr, "\n", -1);
-
-    for (i = 0; tmparr[i] != NULL; i++) {
-        /**
-         * do nothing if this is a blank line
-         */
-        if (strlen(g_strstrip(tmparr[i])) == 0) {
-            continue;
-        }
-        /**
-         * do nothing if this is a comment line
-         */
-        if (tmparr[i][0] == '#') {
-            continue;
-        }
-        /**
-         * this must be a property=value string, so we make
-         * it into a 2-element array:
-         *
-         * property
-         * value
-         *
-         * but we won't store it in our hash table unless both
-         * have real values after stripping whitespace
-         */
-        proparr = g_strsplit(tmparr[i], "=", 2);
-        if (proparr[0] && strlen(g_strstrip(proparr[0])) > 0
-            && proparr[1] && strlen(g_strstrip(proparr[1])) > 0) {
-
-            g_hash_table_insert(props, g_strdup(proparr[0]),
-                                g_strdup(proparr[1]));
-
-        }
-        g_strfreev(proparr);
-    }
-
-    g_strfreev(tmparr);
-
-    g_hash_table_foreach(props, replace_dollar_n, NULL);
-
-    return props;
-}
-
-int roomlist_level_strip(char *description)
-{
-    int val = 0;
-    int i = 0;
-
-    if (!description) {
-        return val;
-    }
-
-    for (i = 0; i < strlen(description); i++) {
-        if (description[i] == '+') {
-            description[i] = ' ';
-        } else {
-            break;
-        }
-        val++;
-    }
-
-    description = g_strchug(description);
-
-    return val;
-}
-
-GaimRoomlistRoom *find_parent(int level, int old_level,
-                              GaimRoomlistRoom * last_room)
-{
-    GaimRoomlistRoom *parent = NULL;
-    int i = 0;
-
-    if (level == 0) {
-        /* do nothing */
-    } else if (level == old_level) {
-        parent = last_room->parent;
-    } else if (level > old_level) {
-        parent = last_room;
-    } else if (level < old_level) {
-        parent = last_room;
-        for (i = old_level - level; i >= 0; i--) {
-            parent = parent->parent;
-        }
-    }
-    return parent;
-}
-
-void build_roomlist_from_config(GaimRoomlist * roomlist,
-                                GHashTable * confighash, gchar * pattern)
-{
-    gchar **roominst = NULL;
-    gchar *altname = NULL;
-    gchar *normalized = NULL;
-    gchar *lowercase = NULL;
-    gchar *found = NULL;
-    int level = 0;
-    int old_level = 0;
-    int i = 0;
-    GaimRoomlistRoom *room = NULL;
-    GaimRoomlistRoom *parent = NULL;
-
-    g_return_if_fail(roomlist != NULL);
-    g_return_if_fail(confighash != NULL);
-
-    int max = gaim_prefs_get_int("/plugins/prpl/gaym/chat_room_instances");
-
-    gchar *roomstr = g_hash_table_lookup(confighash, "roomlist");
-    g_return_if_fail(roomstr != NULL);
-
-    gchar **roomarr = g_strsplit(roomstr, "|", -1);
-
-    /**
-     * We need to skip the first instance, because they start
-     * with a "|", which we've just split by, leaving a blank
-     * at the beginning of the list
-     */
-    for (i = 1; roomarr[i] != NULL; i++) {
-        if (roomarr[i][0] == '#') {
-            /**
-             * This is an actual room string, break it into its
-             * component parts, determine the level and the parent,
-             * and add this as both a room and a category
-             */
-            if (pattern != NULL) {
-                lowercase = g_utf8_strdown(roomarr[i], -1);
-                normalized =
-                    g_utf8_normalize(lowercase, -1, G_NORMALIZE_ALL);
-                found = g_strstr_len(normalized, -1, pattern);
-                g_free(normalized);
-                g_free(lowercase);
-            }
-            if (found != NULL || pattern == NULL) {
-                found = NULL;
-                roominst = g_strsplit(roomarr[i], " ", 2);
-                level = roomlist_level_strip(roominst[1]);
-                parent = find_parent(level, old_level, room);
-                altname = g_strdup_printf("%s:*", roominst[1]);
-                if (max == 0) {
-                    room =
-                        gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_ROOM,
-                                               altname, parent);
-                } else {
-                    room =
-                        gaim_roomlist_room_new
-                        (GAIM_ROOMLIST_ROOMTYPE_CATEGORY |
-                         GAIM_ROOMLIST_ROOMTYPE_ROOM, altname, parent);
-                }
-                gaim_roomlist_room_add_field(roomlist, room, altname);
-                gaim_roomlist_room_add_field(roomlist, room, roominst[0]);
-                gaim_roomlist_room_add(roomlist, room);
-                g_free(altname);
-                g_strfreev(roominst);
-                old_level = level;
-            }
-        } else if (pattern == NULL) {
-            /**
-             * This is a plain category, determine the level and
-             * the parent and add it.
-             */
-            level = roomlist_level_strip(roomarr[i]);
-            parent = find_parent(level, old_level, room);
-            room =
-                gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_CATEGORY,
-                                       roomarr[i], parent);
-            gaim_roomlist_room_add(roomlist, room);
-        }
-        old_level = level;
-    }
-    g_strfreev(roomarr);
-    gaim_roomlist_set_in_progress(roomlist, FALSE);
-}
-
-GaimConvChatBuddyFlags chat_pecking_order(const char *extra)
-{
-    GaimConvChatBuddyFlags flags = GAIM_CBFLAGS_NONE;
-    if (extra[0] == '1' && extra[1] == '8') {
-        /* profile and g-rated photo */
-        flags = GAIM_CBFLAGS_FOUNDER;
-    } else if (extra[0] == '1' && extra[1] == '9') {
-        /* profile and x-rated photo */
-        flags = GAIM_CBFLAGS_OP;
-    } else if (extra[0] == '8') {
-        /* profile but no photo */
-        flags = GAIM_CBFLAGS_HALFOP;
-    } else if (extra[0] == '0') {
-        /* no profile and no photo */
-        flags = GAIM_CBFLAGS_NONE;
-    } else {
-        /* unknown */
-        flags = GAIM_CBFLAGS_VOICE;
-    }
-    return flags;
-}
-
-char *build_tooltip_text(struct gaym_buddy *ib)
-{
-    char *escaped;
-    GString *tooltip = g_string_new("");
-    g_string_printf(tooltip, "<b><i>%s</i></b>", ib->name);
-
-    g_return_val_if_fail(ib != NULL, NULL);
-
-    if (ib->sex) {
-        escaped = g_markup_escape_text(ib->sex, strlen(ib->sex));
-        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"), _("Sex"),
-                               escaped);
-        g_free(escaped);
-    }
-
-    if (ib->age) {
-        escaped = g_markup_escape_text(ib->age, strlen(ib->age));
-        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"), _("Age"),
-                               escaped);
-        g_free(escaped);
-    }
-    if (ib->location) {
-        escaped = g_markup_escape_text(ib->location, strlen(ib->location));
-        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"),
-                               _("Location"), escaped);
-        g_free(escaped);
-    }
-
-    if (ib->bio) {
-        escaped = g_markup_escape_text(ib->bio, strlen(ib->bio));
-        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"), _("Bio"),
-                               escaped);
-        g_free(escaped);
-    }
-
-    if (tooltip->len == 0) {
-        g_string_append_printf(tooltip, _(" No info."));
-    }
-    // g_string_erase(tooltip, 0, 1);
-
-    return g_string_free(tooltip, FALSE);
-}
-
-GaimConvChatBuddyFlags include_chat_entry_order(GaimConvChatBuddyFlags
-                                                flags, gint entry)
-{
-
-    return (flags | (entry << 4));
-}
-
-/**
- * vim:tabstop=4:shiftwidth=4:expandtab:
- */

Copied: qrc/branches/buddy_icon_hack/gaym/src/helpers.c (from rev 261, qrc/trunk/gaym/src/helpers.c)

Deleted: qrc/branches/buddy_icon_hack/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/branches/buddy_icon_hack/gaym/src/msgs.c	2005-07-31 19:07:03 UTC (rev 263)
@@ -1,1331 +0,0 @@
-/**
- * @file msgs.c
- *
- * GayM
- *
- * GayM is the legal property of its developers, whose names are too numerous
- * to list here.  Please refer to the COPYRIGHT file distributed with this
- * source distribution.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "internal.h"
-#include "conversation.h"
-#include "blist.h"
-#include "notify.h"
-#include "util.h"
-#include "debug.h"
-#include "imgstore.h"
-#include "request.h"
-#include "privacy.h"
-#include "prefs.h"
-
-#include "botfilter.h"
-#include "gaym.h"
-#include "gayminfo.h"
-#include "gaympriv.h"
-#include "helpers.h"
-
-static char *gaym_mask_nick(const char *mask)
-{
-    char *end, *buf;
-
-    end = strchr(mask, '!');
-    if (!end)
-        buf = g_strdup(mask);
-    else
-        buf = g_strndup(mask, end - mask);
-
-    return buf;
-}
-
-static void gaym_chat_remove_buddy(GaimConversation * convo, char *data[2])
-{
-    /**
-     * FIXME: is *message ever used ???
-     */
-    char *message = g_strdup_printf("quit: %s", data[1]);
-
-    if (gaim_conv_chat_find_user(GAIM_CONV_CHAT(convo), data[0]))
-        gaim_conv_chat_remove_user(GAIM_CONV_CHAT(convo), data[0], NULL);
-
-    g_free(message);
-}
-
-void gaym_msg_default(struct gaym_conn *gaym, const char *name,
-                      const char *from, char **args)
-{
-    gaim_debug(GAIM_DEBUG_INFO, "gaym", "Unrecognized message: %s\n",
-               args[0]);
-}
-
-void gaym_msg_away(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-
-    if (!args || !args[1] || !gc) {
-        return;
-    }
-
-    gcom_nick_to_gaym(args[1]);
-    serv_got_im(gc, args[1], args[2], GAIM_CONV_IM_AUTO_RESP, time(NULL));
-}
-
-static void gaym_fetch_photo_cb(void *user_data, const char *info_data,
-                                size_t len)
-{
-    if (!info_data || !user_data) {
-        return;
-    }
-
-    struct gaym_fetch_thumbnail_data *d = user_data;
-
-    char *info, *t;
-
-    struct gaym_conn *gaym = d->gc->proto_data;
-
-    char *hashurl =
-        g_hash_table_lookup(gaym->confighash, "view-profile-url");
-    g_return_if_fail(hashurl != NULL);
-
-    int id = gaim_imgstore_add(info_data, len, NULL);
-    if (d->stats && d->bio)
-        info =
-            g_strdup_printf
-            ("<b>Stats:</b> %s<br><b>Bio:</b> %s<br><img id=%d><br><a href='%s%s'>Full Profile</a>",
-             d->stats, d->bio, id, hashurl, d->who);
-    else if (d->stats)
-        info =
-            g_strdup_printf
-            ("<b>Stats:</b> %s<br><img id=%d><br><a href='%s%s'>Full Profile</a>",
-             d->stats, id, hashurl, d->who);
-    else if (d->bio)
-        info =
-            g_strdup_printf
-            ("<b>Bio:</b> %s<br><img id=%d><br><a href='%s%s'>Full Profile</a>",
-             d->bio, id, hashurl, d->who);
-    else
-        info =
-            g_strdup_printf
-            ("No Info Found<br><img id=%d><br><a href='%s%s'>Full Profile</a>",
-             id, hashurl, d->who);
-
-    gaim_notify_userinfo(d->gc, d->who,
-                         t = g_strdup_printf("Gay.com - %s", d->who),
-                         d->who, NULL, info, NULL, NULL);
-    g_free(t);
-
-    if (d) {
-        if (d->who)
-            g_free(d->who);
-        if (d->bio)
-            g_free(d->bio);
-        if (d->stats)
-            g_free(d->stats);
-        g_free(d);
-    }
-    gaim_imgstore_unref(id);
-}
-
-static void gaym_fetch_info_cb(void *user_data, const char *info_data,
-                               size_t len)
-{
-    struct gaym_fetch_thumbnail_data *d = user_data;
-    char *picpath;
-    char *picurl;
-    char *info, *t;
-    char *match = "pictures.0.url=";
-
-    struct gaym_conn *gaym = d->gc->proto_data;
-
-    char *hashurl =
-        g_hash_table_lookup(gaym->confighash, "view-profile-url");
-    g_return_if_fail(hashurl != NULL);
-
-    if (d->stats && d->bio)
-        info =
-            g_strdup_printf
-            ("<b>Stats:</b> %s<br><b>Bio:</b> %s<br><a href='%s%s'>Full Profile</a>",
-             d->stats, d->bio, hashurl, d->who);
-    else if (d->stats)
-        info =
-            g_strdup_printf
-            ("<b>Stats:</b> %s<br><a href='%s%s'>Full Profile</a>",
-             d->stats, hashurl, d->who);
-    else if (d->bio)
-        info =
-            g_strdup_printf
-            ("<b>Bio:</b> %s<br><a href='%s%s'>Full Profile</a>",
-             d->bio, hashurl, d->who);
-    else
-        info =
-            g_strdup_printf
-            ("No Info Found<br><a href='%s%s'>Full Profile</a>",
-             hashurl, d->who);
-
-    picpath = return_string_between(match, "\n", info_data);
-    if (!picpath || strlen(picpath) == 0) {
-        gaim_notify_userinfo(d->gc, d->who,
-                             t = g_strdup_printf("Gay.com - %s", d->who),
-                             d->who, NULL, info, NULL, NULL);
-        g_free(t);
-        return;
-    }
-
-    picurl = g_strdup_printf("http://www.gay.com%s", picpath);
-    if (picurl) {
-        gaim_url_fetch(picurl, FALSE, "Mozilla/4.0 (compatible; MSIE 5.0)",
-                       FALSE, gaym_fetch_photo_cb, user_data);
-        return;
-    }
-}
-
-void gaym_msg_no_such_nick(struct gaym_conn *gaym, const char *name,
-                           const char *from, char **args)
-{
-    /**
-     * name = 701
-     * from = irc.server.name
-     * args[1] = the nick that wasn't found
-     */
-
-    if (!gaym || !args || !args[1]) {
-        return;
-    }
-
-    gcom_nick_to_gaym(args[1]);
-
-    gaym_buddy_status(gaym, args[1], FALSE, NULL);
-
-    char *normalized = g_strdup(gaim_normalize(gaym->account, args[1]));
-
-    if (g_hash_table_lookup(gaym->info_window_needed, normalized)) {
-        g_hash_table_remove(gaym->info_window_needed, normalized);
-
-        char *hashurl =
-            g_hash_table_lookup(gaym->confighash, "view-profile-url");
-        g_return_if_fail(hashurl != NULL);
-
-        char *buf;
-        buf =
-            g_strdup_printf
-            ("That user is not logged on. Check <a href='%s%s'>here</a> to see if that user has a profile.",
-             hashurl, args[1]);
-        gaim_notify_userinfo(gaim_account_get_connection(gaym->account),
-                             NULL, NULL, "No such user", NULL, buf, NULL,
-                             NULL);
-    }
-    g_free(normalized);
-}
-
-void gaym_msg_whois(struct gaym_conn *gaym, const char *name,
-                    const char *from, char **args)
-{
-    /**
-     * name = 311
-     * from = irc.server.name
-     * args[1] = the nick that we have information about
-     */
-
-    if (!gaym || !args || !args[1]) {
-        return;
-    }
-
-    gcom_nick_to_gaym(args[1]);
-
-    gaym_buddy_status(gaym, args[1], TRUE, args[5]);
-
-    char *normalized = g_strdup(gaim_normalize(gaym->account, args[1]));
-
-    struct gaym_fetch_thumbnail_data *data;
-
-    // Update, but then release the reference. It was already opened
-    // during conversation-created.
-    gaym_update_channel_member(gaym, args[1], args[5]);
-    gaym_unreference_channel_member(gaym, args[1]);
-    gaim_signal_emit(gaim_accounts_get_handle(), "info-updated",
-                     gaym->account, args[1]);
-
-    if (g_hash_table_lookup(gaym->info_window_needed, normalized)) {
-
-        data = g_new0(struct gaym_fetch_thumbnail_data, 1);
-        data->gc = gaim_account_get_connection(gaym->account);
-        data->who = g_strdup(args[1]);
-        data->bio = gaym_bio_strdup(args[5]);
-        data->stats = gaym_stats_strdup(args[5]);
-        g_hash_table_remove(gaym->info_window_needed, normalized);
-        char *hashurl = g_hash_table_lookup(gaym->confighash,
-                                            "ohm.profile-url");
-        g_return_if_fail(hashurl != NULL);
-
-        char *infourl = g_strdup_printf("%s?pw=%s&name=%s", hashurl,
-                                        gaym->chat_key, args[1]);
-        if (infourl) {
-            gaim_url_fetch(infourl, FALSE,
-                           "Mozilla/4.0 (compatible; MSIE 5.0)", FALSE,
-                           gaym_fetch_info_cb, data);
-            g_free(infourl);
-        }
-    }
-    g_free(normalized);
-}
-
-void gaym_msg_login_failed(struct gaym_conn *gaym, const char *name,
-                           const char *from, char **args)
-{
-
-
-
-    gaym_cmd_quit(gaym, "quit", NULL, NULL);
-
-    // if (gc->inpa)
-    // gaim_input_remove(gc->inpa);
-
-    // g_free(gaym->inbuf);
-    // gaim_debug_misc("gaym", "Login failed. closing fd %i\n", gaym->fd);
-    // close(gaym->fd);
-    // gaim_debug_misc("gaym", "Get chatkey from weblogin\n");
-    // gaym_get_hash_from_weblogin(gaym->account,
-    // gaym_login_with_chat_key);
-
-}
-
-void gaym_msg_list(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args)
-{
-    /**
-     * If you free anything here related to the roomlist
-     * be sure you test what happens when the roomlist reference
-     * count goes to zero! Because it may crash gaim.
-     */
-    if (!gaym->roomlist) {
-        return;
-    }
-    /**
-     * Begin result of member created room list
-     */
-    if (!strcmp(name, "321") && gaym->roomlist_filter == NULL) {
-        GaimRoomlistRoom *room;
-        room = gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_CATEGORY,
-                                      _("Member Created"), NULL);
-        gaim_roomlist_room_add(gaym->roomlist, room);
-        gaim_roomlist_set_in_progress(gaym->roomlist, TRUE);
-        return;
-    }
-
-    /**
-     * The list of member created rooms
-     */
-    if (!strcmp(name, "322")) {
-        GaimRoomlistRoom *room;
-        char *field_start = NULL;
-        char *field_end = NULL;
-        size_t field_len = 0;
-        int i = 0;
-
-        if (!args[1]) {
-            return;
-        }
-
-        /**
-         * strip leading "#_" and trailing "=1"
-         */
-        field_start = strchr(args[1], '_');
-        field_end = strrchr(args[1], '=');
-
-        if (!field_start || !field_end) {
-            gaim_debug_error("gaym",
-                             "Member created room list parsing error");
-            return;
-        }
-        field_start++;
-        field_end = field_end + 2;
-
-        field_len = field_end - field_start;
-
-        char *field_name = g_strndup(field_start, field_len);
-
-        /**
-         * replace all remaining "_" with " "
-         */
-        for (i = 0; field_name[i] != '\0'; i++) {
-            if (field_name[i] == '_') {
-                field_name[i] = ' ';
-            }
-        }
-        /**
-         * replace '=' with ':'
-         */
-        field_name[i - 2] = ':';
-
-        gchar *lowercase = g_utf8_strdown(field_name, -1);
-        gchar *normalized =
-            g_utf8_normalize(lowercase, -1, G_NORMALIZE_ALL);
-        g_free(lowercase);
-        if (gaym->roomlist_filter == NULL ||
-            g_strstr_len(normalized, -1, gaym->roomlist_filter) != NULL) {
-
-            room = gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_ROOM,
-                                          field_name,
-                                          g_list_nth_data(gaym->roomlist->
-                                                          rooms, 0));
-            gaim_roomlist_room_add_field(gaym->roomlist, room, field_name);
-            gaim_roomlist_room_add_field(gaym->roomlist, room, args[1]);
-            gaim_roomlist_room_add(gaym->roomlist, room);
-        }
-        g_free(normalized);
-        g_free(field_name);
-    }
-
-    /**
-     * End result of member created room list
-     * This is our trigger to add the static rooms
-     */
-    if (!strcmp(name, "323")) {
-        build_roomlist_from_config(gaym->roomlist, gaym->confighash,
-                                   gaym->roomlist_filter);
-        if (gaym->roomlist_filter) {
-            g_free(gaym->roomlist_filter);
-            gaym->roomlist_filter = NULL;
-        }
-        return;
-    }
-}
-
-void gaym_msg_unknown(struct gaym_conn *gaym, const char *name,
-                      const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *buf;
-
-    if (!args || !args[1] || !gc)
-        return;
-
-    buf = g_strdup_printf(_("Unknown message '%s'"), args[1]);
-    gaim_notify_error(gc, _("Unknown message"), buf,
-                      _
-                      ("Gaim has sent a message the IRC server did not understand."));
-    g_free(buf);
-}
-
-void gaym_msg_names(struct gaym_conn *gaym, const char *name,
-                    const char *from, char **args)
-{
-    char *names, *cur, *end, *tmp, *msg;
-    GaimConversation *convo;
-
-    if (!strcmp(name, "366")) {
-        convo =
-            gaim_find_conversation_with_account(gaym->nameconv ? gaym->
-                                                nameconv : args[1],
-                                                gaym->account);
-        if (!convo) {
-            gaim_debug(GAIM_DEBUG_ERROR, "gaym",
-                       "Got a NAMES list for %s, which doesn't exist\n",
-                       args[2]);
-            g_string_free(gaym->names, TRUE);
-            gaym->names = NULL;
-            g_free(gaym->nameconv);
-            gaym->nameconv = NULL;
-            return;
-        }
-
-        names = cur = g_string_free(gaym->names, FALSE);
-        gaym->names = NULL;
-        if (gaym->nameconv) {
-            msg =
-                g_strdup_printf(_("Users on %s: %s"),
-                                args[1] ? args[1] : "",
-                                names ? names : "");
-            if (gaim_conversation_get_type(convo) == GAIM_CONV_CHAT)
-                gaim_conv_chat_write(GAIM_CONV_CHAT(convo), "", msg,
-                                     GAIM_MESSAGE_SYSTEM |
-                                     GAIM_MESSAGE_NO_LOG, time(NULL));
-            else
-                gaim_conv_im_write(GAIM_CONV_IM(convo), "", msg,
-                                   GAIM_MESSAGE_SYSTEM |
-                                   GAIM_MESSAGE_NO_LOG, time(NULL));
-            g_free(msg);
-            g_free(gaym->nameconv);
-            gaym->nameconv = NULL;
-        } else {
-            GList *users = NULL;
-
-            while (*cur) {
-                end = strchr(cur, ' ');
-                tmp = g_strndup(cur, end - cur);
-                gcom_nick_to_gaym(tmp);
-                users = g_list_prepend(users, tmp);
-                cur = end;
-                if (*cur)
-                    cur++;
-            }
-            users = g_list_reverse(users);
-
-            if (users != NULL) {
-                GList *l;
-
-                gaim_conv_chat_add_users(GAIM_CONV_CHAT(convo), users,
-                                         NULL);
-
-                for (l = users; l != NULL; l = l->next)
-                    g_free(l->data);
-
-                g_list_free(users);
-            }
-        }
-        g_free(names);
-    } else {
-        if (!gaym->names)
-            gaym->names = g_string_new("");
-
-        gaym->names = g_string_append(gaym->names, args[3]);
-    }
-}
-
-/**
- * Change this to WELCOME
- */
-
-void gaym_msg_endmotd(struct gaym_conn *gaym, const char *name,
-                      const char *from, char **args)
-{
-    GaimConnection *gc;
-
-    gaim_debug_misc("gaym", "Got motd\n");
-
-    gc = gaim_account_get_connection(gaym->account);
-    if (!gc) {
-        gaim_debug_misc("gaym", "!gc ???\n");
-        return;
-    }
-    gaim_connection_set_state(gc, GAIM_CONNECTED);
-    serv_finish_login(gc);
-
-    gaym_blist_timeout(gaym);
-    if (!gaym->timer)
-        gaym->timer =
-            gaim_timeout_add(BLIST_UPDATE_PERIOD,
-                             (GSourceFunc) gaym_blist_timeout,
-                             (gpointer) gaym);
-}
-
-void gaym_msg_nochan(struct gaym_conn *gaym, const char *name,
-                     const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-
-    if (gc == NULL || args == NULL || args[1] == NULL)
-        return;
-
-    gaim_notify_error(gc, NULL, _("No such channel"), args[1]);
-}
-
-void gaym_msg_nonick_chan(struct gaym_conn *gaym, const char *name,
-                          const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-
-    if (gc == NULL || args == NULL || args[1] == NULL)
-        return;
-
-    gaim_notify_error(gc, NULL, _("Not logged in:"), args[1]);
-}
-
-void gaym_msg_nonick(struct gaym_conn *gaym, const char *name,
-                     const char *from, char **args)
-{
-    GaimConnection *gc;
-    GaimConversation *convo;
-
-    convo = gaim_find_conversation_with_account(args[1], gaym->account);
-    if (convo) {
-        if (gaim_conversation_get_type(convo) == GAIM_CONV_CHAT) {
-            /* does this happen? */
-            gaim_conv_chat_write(GAIM_CONV_CHAT(convo), args[1],
-                                 _("no such channel"),
-                                 GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
-                                 time(NULL));
-        } else {
-            gaim_conv_im_write(GAIM_CONV_IM(convo), args[1],
-                               _("User is not logged in"),
-                               GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
-                               time(NULL));
-        }
-    } else {
-        if ((gc = gaim_account_get_connection(gaym->account)) == NULL)
-            return;
-        gaim_notify_error(gc, NULL, _("No such nick or channel"), args[1]);
-    }
-}
-
-void gaym_msg_nosend(struct gaym_conn *gaym, const char *name,
-                     const char *from, char **args)
-{
-    GaimConnection *gc;
-    GaimConversation *convo;
-
-    convo = gaim_find_conversation_with_account(args[1], gaym->account);
-    if (convo) {
-        gaim_conv_chat_write(GAIM_CONV_CHAT(convo), args[1], args[2],
-                             GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
-                             time(NULL));
-    } else {
-        if ((gc = gaim_account_get_connection(gaym->account)) == NULL)
-            return;
-        gaim_notify_error(gc, NULL, _("Could not send"), args[2]);
-    }
-}
-
-/**
- * Is this used?
- */
-void gaym_msg_notinchan(struct gaym_conn *gaym, const char *name,
-                        const char *from, char **args)
-{
-    GaimConversation *convo =
-        gaim_find_conversation_with_account(args[1], gaym->account);
-
-    gaim_debug(GAIM_DEBUG_INFO, "gaym",
-               "We're apparently not in %s, but tried to use it\n",
-               args[1]);
-    if (convo) {
-        /* g_slist_remove(gaym->gc->buddy_chats, convo);
-           gaim_conversation_set_account(convo, NULL); */
-        gaim_conv_chat_write(GAIM_CONV_CHAT(convo), args[1], args[2],
-                             GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
-                             time(NULL));
-    }
-}
-
-/**
- * Invite WORKS in gay.com!
- */
-void gaym_msg_invite(struct gaym_conn *gaym, const char *name,
-                     const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *nick = gaym_mask_nick(from);
-    GHashTable *components =
-        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
-
-    if (!args || !args[1] || !gc) {
-        g_free(nick);
-        g_hash_table_destroy(components);
-        return;
-    }
-
-    if (!gaym_privacy_check(gc, nick)) {
-        g_free(nick);
-        g_hash_table_destroy(components);
-        return;
-    }
-
-    g_hash_table_insert(components, strdup("channel"), strdup(args[1]));
-    gcom_nick_to_gaym(nick);
-    serv_got_chat_invite(gc, args[1], nick, NULL, components);
-
-    g_free(nick);
-}
-
-void gaym_msg_inviteonly(struct gaym_conn *gaym, const char *name,
-                         const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *buf;
-
-    if (!args || !args[1] || !gc)
-        return;
-
-    buf =
-        g_strdup_printf(_("Joining %s requires an invitation."), args[1]);
-    gaim_notify_error(gc, _("Invitation only"), _("Invitation only"), buf);
-    g_free(buf);
-}
-
-void gaym_msg_trace(struct gaym_conn *gaym, const char *name,
-                    const char *from, char **args)
-{
-    GaimConversation *conv =
-        gaim_find_conversation_with_account(gaym->traceconv ? gaym->
-                                            traceconv : args[1],
-                                            gaym->account);
-    gaim_conversation_write(conv, "TRACE", args[3],
-                            GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
-                            time(NULL));
-
-}
-
-void gaym_msg_join(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    g_return_if_fail(gc != NULL);
-
-    char *nick = gaym_mask_nick(from);
-
-    GaimConversation *convo;
-    GaimConvChatBuddyFlags flags = GAIM_CBFLAGS_NONE;
-    char *bio = NULL;
-    char *bio_markedup = NULL;
-    static int id = 1;
-
-    gcom_nick_to_gaym(nick);
-    if (!gaim_utf8_strcasecmp(nick, gaim_connection_get_display_name(gc))) {
-        /* We are joining a channel for the first time */
-        if (gaym->persist_room && !strcmp(gaym->persist_room, args[0])) {
-            g_free(gaym->persist_room);
-            gaym->persist_room = NULL;
-            gaim_request_close(GAIM_REQUEST_ACTION,
-                               gaym->hammer_cancel_dialog);
-
-        }
-
-        serv_got_joined_chat(gc, id++, args[0]);
-
-        gint *entry = g_new(gint, 1);
-        *entry = MAX_CHANNEL_MEMBERS;
-        g_hash_table_insert(gaym->entry_order, g_strdup(args[0]), entry);
-
-        g_free(nick);
-        return;
-    }
-
-    convo = gaim_find_conversation_with_account(args[0], gaym->account);
-    if (convo == NULL) {
-        gaim_debug(GAIM_DEBUG_ERROR, "gaym", "JOIN for %s failed\n",
-                   args[0]);
-        g_free(nick);
-        return;
-    }
-
-    gint *entry = g_hash_table_lookup(gaym->entry_order, args[0]);
-    g_return_if_fail(entry != NULL);
-
-    gaym_buddy_status(gaym, nick, TRUE, args[1]);
-
-
-    gboolean gaym_botfilter_permit =
-        gaym_botfilter_check(gc, nick, bio, FALSE);
-
-    bio = gaym_bio_strdup(args[1]);
-    if (bio) {
-        bio_markedup = gaim_markup_linkify(bio);
-        g_free(bio);
-    }
-
-    if (*entry <= MAX_CHANNEL_MEMBERS) {
-        *entry = MAX_CHANNEL_MEMBERS + 1;
-    }
-
-    flags = chat_pecking_order(args[1]);
-    flags = include_chat_entry_order(flags, (*entry)++);
-
-    gboolean gaym_privacy_permit = gaym_privacy_check(gc, nick);
-    gboolean show_join =
-        gaim_prefs_get_bool("/plugins/prpl/gaym/show_join");
-
-    if (gaim_prefs_get_bool("/plugins/prpl/gaym/show_bio_with_join")) {
-        gaim_conv_chat_add_user(GAIM_CONV_CHAT(convo), nick, bio_markedup,
-                                flags, (gaym_privacy_permit
-                                        && gaym_botfilter_permit
-                                        && show_join));
-    } else {
-        gaim_conv_chat_add_user(GAIM_CONV_CHAT(convo), nick, NULL,
-                                flags, (gaym_privacy_permit
-                                        && gaym_botfilter_permit
-                                        && show_join));
-    }
-
-    /**
-     * Make the ignore.png icon appear next to the nick.
-     */
-    GaimConversationUiOps *ops = gaim_conversation_get_ui_ops(convo);
-    if (gaym_privacy_permit && gaym_botfilter_permit) {
-        gaim_conv_chat_unignore(GAIM_CONV_CHAT(convo), nick);
-    } else {
-        gaim_conv_chat_ignore(GAIM_CONV_CHAT(convo), nick);
-    }
-    ops->chat_update_user((convo), nick);
-
-    gaym_update_channel_member(gaym, nick, args[1]);
-    g_free(bio_markedup);
-    g_free(nick);
-}
-
-void gaym_msg_mode(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args)
-{
-    GaimConversation *convo;
-    char *nick = gaym_mask_nick(from), *buf;
-
-    if (*args[0] == '#' || *args[0] == '&') {   /* Channel */
-        convo =
-            gaim_find_conversation_with_account(args[0], gaym->account);
-        if (!convo) {
-            gaim_debug(GAIM_DEBUG_ERROR, "gaym",
-                       "MODE received for %s, which we are not in\n",
-                       args[0]);
-            g_free(nick);
-            return;
-        }
-        buf =
-            g_strdup_printf(_("mode (%s %s) by %s"), args[1],
-                            args[2] ? args[2] : "", nick);
-        gaim_conv_chat_write(GAIM_CONV_CHAT(convo), args[0], buf,
-                             GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
-                             time(NULL));
-        g_free(buf);
-        if (args[2]) {
-            GaimConvChatBuddyFlags newflag, flags;
-            char *mcur, *cur, *end, *user;
-            gboolean add = FALSE;
-            mcur = args[1];
-            cur = args[2];
-            while (*cur && *mcur) {
-                if ((*mcur == '+') || (*mcur == '-')) {
-                    add = (*mcur == '+') ? TRUE : FALSE;
-                    mcur++;
-                    continue;
-                }
-                end = strchr(cur, ' ');
-                if (!end)
-                    end = cur + strlen(cur);
-                user = g_strndup(cur, end - cur);
-                flags =
-                    gaim_conv_chat_user_get_flags(GAIM_CONV_CHAT(convo),
-                                                  user);
-                newflag = GAIM_CBFLAGS_NONE;
-                if (*mcur == 'o')
-                    newflag = GAIM_CBFLAGS_OP;
-                else if (*mcur == 'h')
-                    newflag = GAIM_CBFLAGS_HALFOP;
-                else if (*mcur == 'v')
-                    newflag = GAIM_CBFLAGS_VOICE;
-                if (newflag) {
-                    if (add)
-                        flags |= newflag;
-                    else
-                        flags &= ~newflag;
-                    gaim_conv_chat_user_set_flags(GAIM_CONV_CHAT(convo),
-                                                  user, flags);
-                }
-                g_free(user);
-                cur = end;
-                if (*cur)
-                    cur++;
-                if (*mcur)
-                    mcur++;
-            }
-        }
-    } else {                    /* User */
-    }
-    g_free(nick);
-}
-
-void gaym_msg_nick(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args)
-{
-    GSList *chats;
-
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *nick = gaym_mask_nick(from);
-
-    if (!gc) {
-        g_free(nick);
-        return;
-    }
-
-    chats = gc->buddy_chats;
-
-    if (!gaim_utf8_strcasecmp(nick, gaim_connection_get_display_name(gc))) {
-        gaim_connection_set_display_name(gc, args[0]);
-    }
-
-    while (chats) {
-        GaimConvChat *chat = GAIM_CONV_CHAT(chats->data);
-        /* This is ugly ... */
-        if (gaim_conv_chat_find_user(chat, nick))
-            gaim_conv_chat_rename_user(chat, nick, args[0]);
-        chats = chats->next;
-    }
-    g_free(nick);
-}
-
-void gaym_msg_notice(struct gaym_conn *gaym, const char *name,
-                     const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-
-    if (!gc) {
-        return;
-    }
-
-    char *newargs[2];
-
-    newargs[0] = " notice ";    /* The spaces are magic, leave 'em in! */
-    newargs[1] = args[1];
-    gaym_msg_privmsg(gaym, name, from, newargs);
-}
-
-void gaym_msg_part(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args)
-{
-    GaimConversation *convo;
-    char *msg;
-
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *nick = gaym_mask_nick(from);
-
-    if (!args || !args[0] || !gc || !nick) {
-        g_free(nick);
-        return;
-    }
-
-    convo = gaim_find_conversation_with_account(args[0], gaym->account);
-    gboolean show_part =
-        gaim_prefs_get_bool("/plugins/prpl/gaym/show_part");
-
-    gcom_nick_to_gaym(nick);
-    if (!gaim_utf8_strcasecmp(nick, gaim_connection_get_display_name(gc))) {
-
-        g_hash_table_remove(gaym->entry_order, args[0]);
-        msg = g_strdup_printf(_("You have parted the channel"));
-
-        gaim_conv_chat_write(GAIM_CONV_CHAT(convo), args[0], msg,
-                             GAIM_MESSAGE_SYSTEM, time(NULL));
-        g_free(msg);
-        serv_got_chat_left(gc,
-                           gaim_conv_chat_get_id(GAIM_CONV_CHAT(convo)));
-    } else {
-        if (!gaim_conv_chat_is_user_ignored(GAIM_CONV_CHAT(convo), nick)
-            && show_part) {
-            gaim_conv_chat_remove_user(GAIM_CONV_CHAT(convo), nick, NULL);
-        } else {
-            GaimConversationUiOps *ops =
-                gaim_conversation_get_ui_ops(convo);
-            if (ops != NULL && ops->chat_remove_user != NULL) {
-                ops->chat_remove_user(convo, nick);
-            }
-            GaimConvChatBuddy *cb =
-                gaim_conv_chat_cb_find(GAIM_CONV_CHAT(convo), nick);
-            if (cb) {
-                gaim_conv_chat_set_users(GAIM_CONV_CHAT(convo),
-                                         g_list_remove
-                                         (gaim_conv_chat_get_users
-                                          (GAIM_CONV_CHAT(convo)), cb));
-                gaim_conv_chat_cb_destroy(cb);
-                if (!gaym_unreference_channel_member(gaym, nick))
-                    gaim_debug_error("gaym",
-                                     "channel_members reference counting bug.\n");
-            }
-        }
-    }
-
-    g_free(nick);
-}
-
-void gaym_msg_ping(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args)
-{
-    char *buf;
-    if (!args || !args[0])
-        return;
-
-    buf = gaym_format(gaym, "v:", "PONG", args[0]);
-    gaym_send(gaym, buf);
-    g_free(buf);
-}
-
-void gaym_msg_pong(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args)
-{
-    GaimConversation *convo;
-    GaimConnection *gc;
-    char **parts, *msg;
-    time_t oldstamp;
-
-    if (!args || !args[1])
-        return;
-
-    parts = g_strsplit(args[1], " ", 2);
-
-    if (!parts[0] || !parts[1]) {
-        g_strfreev(parts);
-        return;
-    }
-
-    if (sscanf(parts[1], "%lu", &oldstamp) != 1) {
-        msg = g_strdup(_("Error: invalid PONG from server"));
-    } else {
-        msg =
-            g_strdup_printf(_("PING reply -- Lag: %lu seconds"),
-                            time(NULL) - oldstamp);
-    }
-
-    convo = gaim_find_conversation_with_account(parts[0], gaym->account);
-    g_strfreev(parts);
-    if (convo) {
-        if (gaim_conversation_get_type(convo) == GAIM_CONV_CHAT)
-            gaim_conv_chat_write(GAIM_CONV_CHAT(convo), "PONG", msg,
-                                 GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
-                                 time(NULL));
-        else
-            gaim_conv_im_write(GAIM_CONV_IM(convo), "PONG", msg,
-                               GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
-                               time(NULL));
-    } else {
-        gc = gaim_account_get_connection(gaym->account);
-        if (!gc) {
-            g_free(msg);
-            return;
-        }
-        gaim_notify_info(gc, NULL, "PONG", msg);
-    }
-    g_free(msg);
-}
-
-void gaym_msg_privmsg(struct gaym_conn *gaym, const char *name,
-                      const char *from, char **args)
-{
-    GaimConversation *convo;
-    char *tmp, *msg;
-    int notice = 0;
-
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *nick = gaym_mask_nick(from);
-
-    if (!args || !args[0] || !args[1] || !gc) {
-        g_free(nick);
-        return;
-    }
-
-    /**
-     * Only nicks (sender/receiver) should use gcom_nick_to_gaym().
-     *
-     * Channels (which begin with either "#" or "&") should not be
-     * converted.
-     *
-     * Messages should also not be converted.
-     *
-     * CHAT ROOM:
-     * nick = the sender
-     * args[0] = the receiving channel
-     * args[1] = the message
-     *
-     * INSTANT MESSAGE:
-     * nick = the sender
-     * args[0] = the receiver (me)
-     * args[1] = the message
-     *
-     * NOTICE:
-     * nick = the sender
-     * args[0] = " notice "
-     * args[1] = the message
-     */
-    gcom_nick_to_gaym(nick);
-    if (args[0][0] != '#' && args[0][0] != '&') {
-        gcom_nick_to_gaym(args[0]);
-    }
-
-    convo = gaim_find_conversation_with_account(args[0], gaym->account);
-
-    notice = !strcmp(args[0], " notice ");
-    tmp = gaym_parse_ctcp(gaym, nick, args[0], args[1], notice);
-
-    if (!tmp) {
-        g_free(nick);
-        return;
-    }
-
-    if (!gaym_privacy_check(gc, nick)) {
-        g_free(nick);
-        return;
-    }
-
-    msg = gaim_escape_html(tmp);
-
-    g_free(tmp);
-
-    if (notice) {
-        tmp = g_strdup_printf("(notice) %s", msg);
-        g_free(msg);
-        msg = tmp;
-    }
-
-    if (!gaim_utf8_strcasecmp
-        (args[0], gaim_connection_get_display_name(gc))) {
-        serv_got_im(gc, nick, msg, 0, time(NULL));
-    } else if (notice) {
-        serv_got_im(gc, nick, msg, 0, time(NULL));
-    } else if (convo) {
-
-        serv_got_chat_in(gc, gaim_conv_chat_get_id(GAIM_CONV_CHAT(convo)),
-                         nick, 0, msg, time(NULL));
-    } else {
-        gaim_debug(GAIM_DEBUG_ERROR, "gaym",
-                   "Got a PRIVMSG on %s, which does not exist\n", args[0]);
-    }
-
-    g_free(msg);
-    g_free(nick);
-}
-
-void gaym_msg_regonly(struct gaym_conn *gaym, const char *name,
-                      const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *msg;
-
-    if (!args || !args[1] || !args[2] || !gc)
-        return;
-
-    msg = g_strdup_printf(_("Cannot join %s:"), args[1]);
-    gaim_notify_error(gc, _("Cannot join channel"), msg, args[2]);
-    g_free(msg);
-}
-
-/* I don't think gay.com ever sends this message */
-void gaym_msg_quit(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *data[2];
-
-    if (!args || !args[0] || !gc)
-        return;
-
-    data[0] = gaym_mask_nick(from);
-    data[1] = args[0];
-    /* XXX this should have an API, I shouldn't grab this directly */
-    g_slist_foreach(gc->buddy_chats, (GFunc) gaym_chat_remove_buddy, data);
-
-    gaym_buddy_status(gaym, data[0], FALSE, NULL);
-
-    g_free(data[0]);
-
-    return;
-}
-
-void gaym_msg_who(struct gaym_conn *gaym, const char *name,
-                  const char *from, char **args)
-{
-}
-
-void hammer_stop_cb(gpointer data)
-{
-
-    struct gaym_conn *gaym = (struct gaym_conn *) data;
-
-    gaym->cancelling_persist = TRUE;
-    gaim_debug_misc("gaym", "Cancelling persist: %s\n",
-                    gaym->persist_room);
-}
-
-void hammer_cb(gpointer data)
-{
-
-    struct gaym_conn *gaym = (struct gaym_conn *) data;
-    const char *args[1];
-    char *msg;
-    gaim_debug_misc("gaym", "Persisting room %s\n", gaym->persist_room);
-    args[0] = gaym->persist_room;
-    gaym->cancelling_persist = FALSE;
-    msg = g_strdup_printf("Hammering into room %s", gaym->persist_room);
-    gaym->hammer_cancel_dialog =
-        gaim_request_action(gaym->account->gc, _("Cancel Hammer"), msg,
-                            NULL, 0, gaym, 1, ("Cancel"), hammer_stop_cb);
-
-    gaym_cmd_join(gaym, NULL, NULL, args);
-    if (msg)
-        g_free(msg);
-}
-
-void gaym_msg_chanfull(struct gaym_conn *gaym, const char *name,
-                       const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *buf;
-    const char *joinargs[1];
-
-    if (!args || !args[1] || !gc)
-        return;
-
-    joinargs[0] = args[1];
-
-    if (gaym->persist_room && !strcmp(gaym->persist_room, args[1]))
-        if (gaym->cancelling_persist) {
-            if (gaym->persist_room) {
-                g_free(gaym->persist_room);
-                gaym->persist_room = NULL;
-            }
-            gaym->cancelling_persist = FALSE;
-        } else {
-            gaim_debug_misc("gaym", "trying again\n");
-            gaym_cmd_join(gaym, NULL, NULL, joinargs);
-    } else {
-
-        gaym->persist_room = g_strdup(args[1]);
-        buf =
-            g_strdup_printf("%s is full. Do you want to keep trying?",
-                            args[1]);
-        gaim_request_yes_no(gc, _("Room Full"), _("Room Full"), buf, 0,
-                            gaym, hammer_cb, NULL);
-
-        g_free(buf);
-    }
-}
-
-void gaym_msg_create_pay_only(struct gaym_conn *gaym, const char *name,
-                              const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *buf;
-    if (!args || !args[1] || !gc) {
-        return;
-    }
-    buf = g_strdup_printf(_("%s"), args[2]);
-    gaim_notify_error(gc, _("Pay Only"), _("Pay Only"), buf);
-    /**
-     * FIXME
-     * by now the chatroom is already in the buddy list...need
-     * to remove it or something
-     */
-    g_free(buf);
-}
-
-void gaym_msg_pay_channel(struct gaym_conn *gaym, const char *name,
-                          const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *buf;
-
-    if (!args || !args[1] || !gc)
-        return;
-
-    buf =
-        g_strdup_printf(_("The channel %s is for paying members only."),
-                        args[1]);
-    gaim_notify_error(gc, _("Pay Only"), _("Pay Only"), buf);
-    g_free(buf);
-}
-
-void gaym_msg_toomany_channels(struct gaym_conn *gaym, const char *name,
-                               const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *buf;
-
-    if (!args || !args[1] || !gc)
-        return;
-
-    buf =
-        g_strdup_printf(_
-                        ("You have joined too many channels the maximum is (2). You cannot join channel %s. Part another channel first ."),
-                        args[1]);
-    gaim_notify_error(gc, _("Maximum ChannelsReached"),
-                      _("Maximum ChannelsReached"), buf);
-    g_free(buf);
-}
-
-void gaym_msg_list_busy(struct gaym_conn *gaym, const char *name,
-                        const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *buf;
-    if (!args || !args[1] || !gc) {
-        return;
-    }
-    buf = g_strdup_printf(_("%s"), args[1]);
-    gaim_notify_error(gc, _("Server Busy"), _("Server Busy"), buf);
-    // if (gaym->roomlist) {
-    // gaim_roomlist_cancel_get_list(gaym->roomlist);
-    // }
-    g_free(buf);
-    /**
-     * Can't get member created rooms right now.
-     * This is our trigger to add the static rooms
-     */
-    build_roomlist_from_config(gaym->roomlist, gaym->confighash,
-                               gaym->roomlist_filter);
-    if (gaym->roomlist_filter) {
-        g_free(gaym->roomlist_filter);
-        gaym->roomlist_filter = NULL;
-    }
-    return;
-
-}
-
-void gaym_msg_richnames_list(struct gaym_conn *gaym, const char *name,
-                             const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    GaimConversation *convo;
-    GaimConvChatBuddyFlags flags = GAIM_CBFLAGS_NONE;
-    char *channel = args[1];
-    char *nick = args[2];
-    char *extra = args[4];
-
-    if (!gc) {
-        return;
-    }
-
-    gcom_nick_to_gaym(nick);
-    gaim_debug(GAIM_DEBUG_INFO, "gaym",
-               "gaym_msg_richnames_list() Channel: %s Nick: %s Extra: %s\n",
-               channel, nick, extra);
-
-    convo = gaim_find_conversation_with_account(channel, gaym->account);
-
-    char *bio = gaym_bio_strdup(extra);
-    gboolean gaym_botfilter_permit =
-        gaym_botfilter_check(gc, nick, bio, FALSE);
-    g_free(bio);
-
-    gaym_buddy_status(gaym, nick, TRUE, extra);
-
-    if (convo == NULL) {
-        gaim_debug(GAIM_DEBUG_ERROR, "gaym", "690 for %s failed\n",
-                   args[1]);
-        return;
-    }
-
-    gint *entry = g_hash_table_lookup(gaym->entry_order, channel);
-    g_return_if_fail(entry != NULL);
-
-    flags = chat_pecking_order(extra);
-    flags = include_chat_entry_order(flags, (*entry)--);
-
-    gaim_conv_chat_add_user(GAIM_CONV_CHAT(convo), nick, NULL, flags,
-                            FALSE);
-
-    /**
-     * Make the ignore.png icon appear next to the nick.
-     */
-    GaimConversationUiOps *ops = gaim_conversation_get_ui_ops(convo);
-    if (gaym_privacy_check(gc, nick) && gaym_botfilter_permit) {
-        gaim_conv_chat_unignore(GAIM_CONV_CHAT(convo), nick);
-    } else {
-        gaim_conv_chat_ignore(GAIM_CONV_CHAT(convo), nick);
-    }
-    ops->chat_update_user((convo), nick);
-    gaym_update_channel_member(gaym, nick, extra);
-}
-
-/**
- * vim:tabstop=4:shiftwidth=4:expandtab:
- */

Copied: qrc/branches/buddy_icon_hack/gaym/src/msgs.c (from rev 262, qrc/trunk/gaym/src/msgs.c)
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-31 07:45:24 UTC (rev 262)
+++ qrc/branches/buddy_icon_hack/gaym/src/msgs.c	2005-07-31 19:07:03 UTC (rev 263)
@@ -0,0 +1,1394 @@
+/**
+ * @file msgs.c
+ *
+ * GayM
+ *
+ * GayM is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "internal.h"
+#include "conversation.h"
+#include "blist.h"
+#include "notify.h"
+#include "util.h"
+#include "debug.h"
+#include "imgstore.h"
+#include "request.h"
+#include "privacy.h"
+#include "prefs.h"
+
+#include "botfilter.h"
+#include "gaym.h"
+#include "gayminfo.h"
+#include "gaympriv.h"
+#include "helpers.h"
+
+static char *gaym_mask_nick(const char *mask)
+{
+    char *end, *buf;
+
+    end = strchr(mask, '!');
+    if (!end)
+        buf = g_strdup(mask);
+    else
+        buf = g_strndup(mask, end - mask);
+
+    return buf;
+}
+
+static void gaym_chat_remove_buddy(GaimConversation * convo, char *data[2])
+{
+    /**
+     * FIXME: is *message ever used ???
+     */
+    char *message = g_strdup_printf("quit: %s", data[1]);
+
+    if (gaim_conv_chat_find_user(GAIM_CONV_CHAT(convo), data[0]))
+        gaim_conv_chat_remove_user(GAIM_CONV_CHAT(convo), data[0], NULL);
+
+    g_free(message);
+}
+
+void gaym_msg_default(struct gaym_conn *gaym, const char *name,
+                      const char *from, char **args)
+{
+    gaim_debug(GAIM_DEBUG_INFO, "gaym", "Unrecognized message: %s\n",
+               args[0]);
+}
+
+void gaym_msg_away(struct gaym_conn *gaym, const char *name,
+                   const char *from, char **args)
+{
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+
+    if (!args || !args[1] || !gc) {
+        return;
+    }
+
+    gcom_nick_to_gaym(args[1]);
+    serv_got_im(gc, args[1], args[2], GAIM_CONV_IM_AUTO_RESP, time(NULL));
+}
+
+static void gaym_fetch_photo_cb(void *user_data, const char *info_data,
+                                size_t len)
+{
+    if (!info_data || !user_data) {
+        return;
+    }
+
+    struct gaym_fetch_thumbnail_data *d = user_data;
+
+    char *info, *t;
+
+    struct gaym_conn *gaym = d->gc->proto_data;
+
+    char *hashurl =
+        g_hash_table_lookup(gaym->confighash, "view-profile-url");
+    g_return_if_fail(hashurl != NULL);
+
+    int id = gaim_imgstore_add(info_data, len, NULL);
+    if (d->stats && d->bio)
+        info =
+            g_strdup_printf
+            ("<b>Stats:</b> %s<br><b>Bio:</b> %s<br><img id=%d><br><a href='%s%s'>Full Profile</a>",
+             d->stats, d->bio, id, hashurl, d->who);
+    else if (d->stats)
+        info =
+            g_strdup_printf
+            ("<b>Stats:</b> %s<br><img id=%d><br><a href='%s%s'>Full Profile</a>",
+             d->stats, id, hashurl, d->who);
+    else if (d->bio)
+        info =
+            g_strdup_printf
+            ("<b>Bio:</b> %s<br><img id=%d><br><a href='%s%s'>Full Profile</a>",
+             d->bio, id, hashurl, d->who);
+    else
+        info =
+            g_strdup_printf
+            ("No Info Found<br><img id=%d><br><a href='%s%s'>Full Profile</a>",
+             id, hashurl, d->who);
+
+    gaim_notify_userinfo(d->gc, d->who,
+                         t = g_strdup_printf("Gay.com - %s", d->who),
+                         d->who, NULL, info, NULL, NULL);
+    g_free(t);
+
+    if (d) {
+        if (d->who)
+            g_free(d->who);
+        if (d->bio)
+            g_free(d->bio);
+        if (d->stats)
+            g_free(d->stats);
+        g_free(d);
+    }
+    gaim_imgstore_unref(id);
+}
+
+static void gaym_fetch_info_cb(void *user_data, const char *info_data,
+                               size_t len)
+{
+    struct gaym_fetch_thumbnail_data *d = user_data;
+    char *picpath;
+    char *picurl;
+    char *info, *t;
+    char *match = "pictures.0.url=";
+
+    struct gaym_conn *gaym = d->gc->proto_data;
+
+    char *hashurl =
+        g_hash_table_lookup(gaym->confighash, "view-profile-url");
+    g_return_if_fail(hashurl != NULL);
+
+    if (d->stats && d->bio)
+        info =
+            g_strdup_printf
+            ("<b>Stats:</b> %s<br><b>Bio:</b> %s<br><a href='%s%s'>Full Profile</a>",
+             d->stats, d->bio, hashurl, d->who);
+    else if (d->stats)
+        info =
+            g_strdup_printf
+            ("<b>Stats:</b> %s<br><a href='%s%s'>Full Profile</a>",
+             d->stats, hashurl, d->who);
+    else if (d->bio)
+        info =
+            g_strdup_printf
+            ("<b>Bio:</b> %s<br><a href='%s%s'>Full Profile</a>",
+             d->bio, hashurl, d->who);
+    else
+        info =
+            g_strdup_printf
+            ("No Info Found<br><a href='%s%s'>Full Profile</a>",
+             hashurl, d->who);
+
+    picpath = return_string_between(match, "\n", info_data);
+    if (!picpath || strlen(picpath) == 0) {
+        gaim_notify_userinfo(d->gc, d->who,
+                             t = g_strdup_printf("Gay.com - %s", d->who),
+                             d->who, NULL, info, NULL, NULL);
+        g_free(t);
+        return;
+    }
+
+    picurl = g_strdup_printf("http://www.gay.com%s", picpath);
+    if (picurl) {
+        gaim_url_fetch(picurl, FALSE, "Mozilla/4.0 (compatible; MSIE 5.0)",
+                       FALSE, gaym_fetch_photo_cb, user_data);
+        return;
+    }
+}
+
+void gaym_msg_no_such_nick(struct gaym_conn *gaym, const char *name,
+                           const char *from, char **args)
+{
+    /**
+     * name = 701
+     * from = irc.server.name
+     * args[1] = the nick that wasn't found
+     */
+
+    if (!gaym || !args || !args[1]) {
+        return;
+    }
+
+    gcom_nick_to_gaym(args[1]);
+
+    gaym_buddy_status(gaym, args[1], FALSE, NULL);
+
+    char *normalized = g_strdup(gaim_normalize(gaym->account, args[1]));
+
+    if (g_hash_table_lookup(gaym->info_window_needed, normalized)) {
+        g_hash_table_remove(gaym->info_window_needed, normalized);
+
+        char *hashurl =
+            g_hash_table_lookup(gaym->confighash, "view-profile-url");
+        g_return_if_fail(hashurl != NULL);
+
+        char *buf;
+        buf =
+            g_strdup_printf
+            ("That user is not logged on. Check <a href='%s%s'>here</a> to see if that user has a profile.",
+             hashurl, args[1]);
+        gaim_notify_userinfo(gaim_account_get_connection(gaym->account),
+                             NULL, NULL, "No such user", NULL, buf, NULL,
+                             NULL);
+    }
+    g_free(normalized);
+}
+
+void gaym_msg_whois(struct gaym_conn *gaym, const char *name,
+                    const char *from, char **args)
+{
+    /**
+     * name = 311
+     * from = irc.server.name
+     * args[1] = the nick that we have information about
+     */
+
+    if (!gaym || !args || !args[1]) {
+        return;
+    }
+    
+    gcom_nick_to_gaym(args[1]);
+
+    gaym_buddy_status(gaym, args[1], TRUE, args[5]);
+
+    char *normalized = g_strdup(gaim_normalize(gaym->account, args[1]));
+
+    struct gaym_fetch_thumbnail_data *data;
+
+    // Update, but then release the reference. It was already opened
+    // during conversation-created.
+    gaym_update_channel_member(gaym, normalized, args[5]);
+    gaym_unreference_channel_member(gaym, normalized);
+    gaim_signal_emit(gaim_accounts_get_handle(), "info-updated",
+                     gaym->account, args[1]);
+
+    if (g_hash_table_lookup(gaym->info_window_needed, normalized)) {
+
+        data = g_new0(struct gaym_fetch_thumbnail_data, 1);
+        data->gc = gaim_account_get_connection(gaym->account);
+        data->who = g_strdup(args[1]);
+        data->bio = gaym_bio_strdup(args[5]);
+        data->stats = gaym_stats_strdup(args[5]);
+        g_hash_table_remove(gaym->info_window_needed, normalized);
+        char *hashurl = g_hash_table_lookup(gaym->confighash,
+                                            "ohm.profile-url");
+        g_return_if_fail(hashurl != NULL);
+
+        char *infourl = g_strdup_printf("%s?pw=%s&name=%s", hashurl,
+                                        gaym->chat_key, args[1]);
+        if (infourl) {
+            gaim_url_fetch(infourl, FALSE,
+                           "Mozilla/4.0 (compatible; MSIE 5.0)", FALSE,
+                           gaym_fetch_info_cb, data);
+            g_free(infourl);
+        }
+    }
+    g_free(normalized);
+}
+
+void gaym_msg_login_failed(struct gaym_conn *gaym, const char *name,
+                           const char *from, char **args)
+{
+
+
+
+    gaym_cmd_quit(gaym, "quit", NULL, NULL);
+
+    // if (gc->inpa)
+    // gaim_input_remove(gc->inpa);
+
+    // g_free(gaym->inbuf);
+    // gaim_debug_misc("gaym", "Login failed. closing fd %i\n", gaym->fd);
+    // close(gaym->fd);
+    // gaim_debug_misc("gaym", "Get chatkey from weblogin\n");
+    // gaym_get_hash_from_weblogin(gaym->account,
+    // gaym_login_with_chat_key);
+
+}
+
+void gaym_msg_list(struct gaym_conn *gaym, const char *name,
+                   const char *from, char **args)
+{
+    /**
+     * If you free anything here related to the roomlist
+     * be sure you test what happens when the roomlist reference
+     * count goes to zero! Because it may crash gaim.
+     */
+    if (!gaym->roomlist) {
+        return;
+    }
+    /**
+     * Begin result of member created room list
+     */
+    if (!strcmp(name, "321") && gaym->roomlist_filter == NULL) {
+        GaimRoomlistRoom *room;
+        room = gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_CATEGORY,
+                                      _("Member Created"), NULL);
+        gaim_roomlist_room_add(gaym->roomlist, room);
+        gaim_roomlist_set_in_progress(gaym->roomlist, TRUE);
+        return;
+    }
+
+    /**
+     * The list of member created rooms
+     */
+    if (!strcmp(name, "322")) {
+        GaimRoomlistRoom *room;
+        char *field_start = NULL;
+        char *field_end = NULL;
+        size_t field_len = 0;
+        int i = 0;
+
+        if (!args[1]) {
+            return;
+        }
+
+        /**
+         * strip leading "#_" and trailing "=1"
+         */
+        field_start = strchr(args[1], '_');
+        field_end = strrchr(args[1], '=');
+
+        if (!field_start || !field_end) {
+            gaim_debug_error("gaym",
+                             "Member created room list parsing error");
+            return;
+        }
+        field_start++;
+        field_end = field_end + 2;
+
+        field_len = field_end - field_start;
+
+        char *field_name = g_strndup(field_start, field_len);
+
+        /**
+         * replace all remaining "_" with " "
+         */
+        for (i = 0; field_name[i] != '\0'; i++) {
+            if (field_name[i] == '_') {
+                field_name[i] = ' ';
+            }
+        }
+        /**
+         * replace '=' with ':'
+         */
+        field_name[i - 2] = ':';
+
+        gchar *lowercase = g_utf8_strdown(field_name, -1);
+        gchar *normalized =
+            g_utf8_normalize(lowercase, -1, G_NORMALIZE_ALL);
+        g_free(lowercase);
+        if (gaym->roomlist_filter == NULL ||
+            g_strstr_len(normalized, -1, gaym->roomlist_filter) != NULL) {
+
+            room = gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_ROOM,
+                                          field_name,
+                                          g_list_nth_data(gaym->roomlist->
+                                                          rooms, 0));
+            gaim_roomlist_room_add_field(gaym->roomlist, room, field_name);
+            gaim_roomlist_room_add_field(gaym->roomlist, room, args[1]);
+            gaim_roomlist_room_add(gaym->roomlist, room);
+        }
+        g_free(normalized);
+        g_free(field_name);
+    }
+
+    /**
+     * End result of member created room list
+     * This is our trigger to add the static rooms
+     */
+    if (!strcmp(name, "323")) {
+        build_roomlist_from_config(gaym->roomlist, gaym->confighash,
+                                   gaym->roomlist_filter);
+        if (gaym->roomlist_filter) {
+            g_free(gaym->roomlist_filter);
+            gaym->roomlist_filter = NULL;
+        }
+        return;
+    }
+}
+
+void gaym_msg_unknown(struct gaym_conn *gaym, const char *name,
+                      const char *from, char **args)
+{
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+    char *buf;
+
+    if (!args || !args[1] || !gc)
+        return;
+
+    buf = g_strdup_printf(_("Unknown message '%s'"), args[1]);
+    gaim_notify_error(gc, _("Unknown message"), buf,
+                      _
+                      ("Gaim has sent a message the IRC server did not understand."));
+    g_free(buf);
+}
+
+void gaym_msg_names(struct gaym_conn *gaym, const char *name,
+                    const char *from, char **args)
+{
+    char *names, *cur, *end, *tmp, *msg;
+    GaimConversation *convo;
+
+    if (!strcmp(name, "366")) {
+        convo =
+            gaim_find_conversation_with_account(gaym->nameconv ? gaym->
+                                                nameconv : args[1],
+                                                gaym->account);
+        if (!convo) {
+            gaim_debug(GAIM_DEBUG_ERROR, "gaym",
+                       "Got a NAMES list for %s, which doesn't exist\n",
+                       args[2]);
+            g_string_free(gaym->names, TRUE);
+            gaym->names = NULL;
+            g_free(gaym->nameconv);
+            gaym->nameconv = NULL;
+            return;
+        }
+
+        names = cur = g_string_free(gaym->names, FALSE);
+        gaym->names = NULL;
+        if (gaym->nameconv) {
+            msg =
+                g_strdup_printf(_("Users on %s: %s"),
+                                args[1] ? args[1] : "",
+                                names ? names : "");
+            if (gaim_conversation_get_type(convo) == GAIM_CONV_CHAT)
+                gaim_conv_chat_write(GAIM_CONV_CHAT(convo), "", msg,
+                                     GAIM_MESSAGE_SYSTEM |
+                                     GAIM_MESSAGE_NO_LOG, time(NULL));
+            else
+                gaim_conv_im_write(GAIM_CONV_IM(convo), "", msg,
+                                   GAIM_MESSAGE_SYSTEM |
+                                   GAIM_MESSAGE_NO_LOG, time(NULL));
+            g_free(msg);
+            g_free(gaym->nameconv);
+            gaym->nameconv = NULL;
+        } else {
+            GList *users = NULL;
+
+            while (*cur) {
+                end = strchr(cur, ' ');
+                tmp = g_strndup(cur, end - cur);
+                gcom_nick_to_gaym(tmp);
+                users = g_list_prepend(users, tmp);
+                cur = end;
+                if (*cur)
+                    cur++;
+            }
+            users = g_list_reverse(users);
+
+            if (users != NULL) {
+                GList *l;
+
+                gaim_conv_chat_add_users(GAIM_CONV_CHAT(convo), users,
+                                         NULL);
+
+                for (l = users; l != NULL; l = l->next)
+                    g_free(l->data);
+
+                g_list_free(users);
+            }
+        }
+        g_free(names);
+    } else {
+        if (!gaym->names)
+            gaym->names = g_string_new("");
+
+        gaym->names = g_string_append(gaym->names, args[3]);
+    }
+}
+
+/**
+ * Change this to WELCOME
+ */
+
+void gaym_msg_endmotd(struct gaym_conn *gaym, const char *name,
+                      const char *from, char **args)
+{
+    GaimConnection *gc;
+
+    gaim_debug_misc("gaym", "Got motd\n");
+
+    gc = gaim_account_get_connection(gaym->account);
+    if (!gc) {
+        gaim_debug_misc("gaym", "!gc ???\n");
+        return;
+    }
+    gaim_connection_set_state(gc, GAIM_CONNECTED);
+    serv_finish_login(gc);
+
+    gaym_blist_timeout(gaym);
+    if (!gaym->timer)
+        gaym->timer =
+            gaim_timeout_add(BLIST_UPDATE_PERIOD,
+                             (GSourceFunc) gaym_blist_timeout,
+                             (gpointer) gaym);
+}
+
+void gaym_msg_nochan(struct gaym_conn *gaym, const char *name,
+                     const char *from, char **args)
+{
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+
+    if (gc == NULL || args == NULL || args[1] == NULL)
+        return;
+
+    gaim_notify_error(gc, NULL, _("No such channel"), args[1]);
+}
+
+void gaym_msg_nonick_chan(struct gaym_conn *gaym, const char *name,
+                          const char *from, char **args)
+{
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+    GaimConversation *convo;
+
+    convo = gaim_find_conversation_with_account(args[1], gaym->account);
+    if (convo) {
+        if (gaim_conversation_get_type(convo) == GAIM_CONV_CHAT) {
+            /* does this happen? */
+            gaim_conv_chat_write(GAIM_CONV_CHAT(convo), args[1],
+                                 _("no such channel"),
+                                 GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
+                                 time(NULL));
+        } else {
+            gaim_conv_im_write(GAIM_CONV_IM(convo), args[1],
+                               _("User is not logged in"),
+                               GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
+                               time(NULL));
+        }
+    } else {
+        if ((gc = gaim_account_get_connection(gaym->account)) == NULL)
+            return;
+        gaim_notify_error(gc, NULL, _("Not logged in: "), args[1]);
+    }
+
+    if (gc == NULL || args == NULL || args[1] == NULL)
+        return;
+    
+    
+}
+
+void gaym_msg_nonick(struct gaym_conn *gaym, const char *name,
+                     const char *from, char **args)
+{
+    GaimConnection *gc;
+    GaimConversation *convo;
+
+    convo = gaim_find_conversation_with_account(args[1], gaym->account);
+    if (convo) {
+        if (gaim_conversation_get_type(convo) == GAIM_CONV_CHAT) {
+            /* does this happen? */
+            gaim_conv_chat_write(GAIM_CONV_CHAT(convo), args[1],
+                                 _("no such channel"),
+                                 GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
+                                 time(NULL));
+        } else {
+            gaim_conv_im_write(GAIM_CONV_IM(convo), args[1],
+                               _("User is not logged in"),
+                               GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
+                               time(NULL));
+        }
+    } else {
+        if ((gc = gaim_account_get_connection(gaym->account)) == NULL)
+            return;
+        gaim_notify_error(gc, NULL, _("No such nick or channel"), args[1]);
+    }
+}
+
+void gaym_msg_nosend(struct gaym_conn *gaym, const char *name,
+                     const char *from, char **args)
+{
+    GaimConnection *gc;
+    GaimConversation *convo;
+
+    convo = gaim_find_conversation_with_account(args[1], gaym->account);
+    if (convo) {
+        gaim_conv_chat_write(GAIM_CONV_CHAT(convo), args[1], args[2],
+                             GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
+                             time(NULL));
+    } else {
+        if ((gc = gaim_account_get_connection(gaym->account)) == NULL)
+            return;
+        gaim_notify_error(gc, NULL, _("Could not send"), args[2]);
+    }
+}
+
+/**
+ * Is this used?
+ */
+void gaym_msg_notinchan(struct gaym_conn *gaym, const char *name,
+                        const char *from, char **args)
+{
+    GaimConversation *convo =
+        gaim_find_conversation_with_account(args[1], gaym->account);
+
+    gaim_debug(GAIM_DEBUG_INFO, "gaym",
+               "We're apparently not in %s, but tried to use it\n",
+               args[1]);
+    if (convo) {
+        /* g_slist_remove(gaym->gc->buddy_chats, convo);
+           gaim_conversation_set_account(convo, NULL); */
+        gaim_conv_chat_write(GAIM_CONV_CHAT(convo), args[1], args[2],
+                             GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
+                             time(NULL));
+    }
+}
+
+/**
+ * Invite WORKS in gay.com!
+ */
+void gaym_msg_invite(struct gaym_conn *gaym, const char *name,
+                     const char *from, char **args)
+{
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+    char *nick = gaym_mask_nick(from);
+    GHashTable *components =
+        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
+
+    if (!args || !args[1] || !gc) {
+        g_free(nick);
+        g_hash_table_destroy(components);
+        return;
+    }
+
+    if (!gaym_privacy_check(gc, nick)) {
+        g_free(nick);
+        g_hash_table_destroy(components);
+        return;
+    }
+
+    g_hash_table_insert(components, strdup("channel"), strdup(args[1]));
+    gcom_nick_to_gaym(nick);
+    serv_got_chat_invite(gc, args[1], nick, NULL, components);
+
+    g_free(nick);
+}
+
+void gaym_msg_inviteonly(struct gaym_conn *gaym, const char *name,
+                         const char *from, char **args)
+{
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+    char *buf;
+
+    if (!args || !args[1] || !gc)
+        return;
+
+    buf =
+        g_strdup_printf(_("Joining %s requires an invitation."), args[1]);
+    gaim_notify_error(gc, _("Invitation only"), _("Invitation only"), buf);
+    g_free(buf);
+}
+
+void gaym_msg_trace(struct gaym_conn *gaym, const char *name,
+                    const char *from, char **args)
+{
+    GaimConversation *conv =
+        gaim_find_conversation_with_account(gaym->traceconv ? gaym->
+                                            traceconv : args[1],
+                                            gaym->account);
+    gaim_conversation_write(conv, "TRACE", args[3],
+                            GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
+                            time(NULL));
+
+}
+
+void gaym_msg_join(struct gaym_conn *gaym, const char *name,
+                   const char *from, char **args)
+{
+    GaimBuddy* buddy=gaim_buddy_new(gaym->account, "TESTBUDDY", "TBALIAS");
+    gaim_blist_add_buddy(buddy, NULL, NULL, NULL);
+    gaim_debug_misc("testbuddy","buddy: %x,find buddy: %x\n",buddy, gaim_find_buddy(gaym->account, "TESTBUDDY"));
+    
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+    g_return_if_fail(gc != NULL);
+
+    char *nick = gaym_mask_nick(from);
+
+    GaimConversation *convo;
+    GaimConvChatBuddyFlags flags = GAIM_CBFLAGS_NONE;
+    char *bio = NULL;
+    char *bio_markedup = NULL;
+    static int id = 1;
+
+    gcom_nick_to_gaym(nick);
+    if (!gaim_utf8_strcasecmp(nick, gaim_connection_get_display_name(gc))) {
+        /* We are joining a channel for the first time */
+
+	gpointer data, unused;
+	gboolean hammering=g_hash_table_lookup_extended
+	    (gaym->hammers,args[1],&unused, &data);
+	//There was a hammer, but it is cancelled. Leave!
+	if(hammering && !data) { //hammer was cancelled.
+	    gaim_debug_misc("gaym","JOINED, BUT HAMMER CANCELLED: ABORT!!!!\n");
+	    g_hash_table_remove(gaym->hammers, args[0]);
+	    gaym_cmd_part(gaym, NULL, NULL, (const char**)args);
+	    return;
+	}
+#if 0
+        if (gaym->persist_room && !strcmp(gaym->persist_room, args[0])) {
+            g_free(gaym->persist_room);
+            gaym->persist_room = NULL;
+            gaim_request_close(GAIM_REQUEST_ACTION,
+                               gaym->hammer_cancel_dialog);
+
+        }
+#endif
+	g_hash_table_remove(gaym->hammers, args[0]);
+        serv_got_joined_chat(gc, id++, args[0]);
+
+        gint *entry = g_new(gint, 1);
+        *entry = MAX_CHANNEL_MEMBERS;
+        g_hash_table_insert(gaym->entry_order, g_strdup(args[0]), entry);
+
+        g_free(nick);
+        return;
+    }
+
+    convo = gaim_find_conversation_with_account(args[0], gaym->account);
+    if (convo == NULL) {
+        gaim_debug(GAIM_DEBUG_ERROR, "gaym", "JOIN for %s failed\n",
+                   args[0]);
+        g_free(nick);
+        return;
+    }
+
+    gint *entry = g_hash_table_lookup(gaym->entry_order, args[0]);
+    g_return_if_fail(entry != NULL);
+
+    gaym_buddy_status(gaym, nick, TRUE, args[1]);
+
+
+    gboolean gaym_botfilter_permit =
+        gaym_botfilter_check(gc, nick, bio, FALSE);
+
+    bio = gaym_bio_strdup(args[1]);
+    if (bio) {
+        bio_markedup = gaim_markup_linkify(bio);
+        g_free(bio);
+    }
+
+    if (*entry <= MAX_CHANNEL_MEMBERS) {
+        *entry = MAX_CHANNEL_MEMBERS + 1;
+    }
+
+    flags = chat_pecking_order(args[1]);
+    flags = include_chat_entry_order(flags, (*entry)++);
+
+    gboolean gaym_privacy_permit = gaym_privacy_check(gc, nick);
+    gboolean show_join =
+        gaim_prefs_get_bool("/plugins/prpl/gaym/show_join");
+
+    if (gaim_prefs_get_bool("/plugins/prpl/gaym/show_bio_with_join")) {
+        gaim_conv_chat_add_user(GAIM_CONV_CHAT(convo), nick, bio_markedup,
+                                flags, (gaym_privacy_permit
+                                        && gaym_botfilter_permit
+                                        && show_join));
+    } else {
+        gaim_conv_chat_add_user(GAIM_CONV_CHAT(convo), nick, NULL,
+                                flags, (gaym_privacy_permit
+                                        && gaym_botfilter_permit
+                                        && show_join));
+    }
+
+    /**
+     * Make the ignore.png icon appear next to the nick.
+     */
+    GaimConversationUiOps *ops = gaim_conversation_get_ui_ops(convo);
+    if (gaym_privacy_permit && gaym_botfilter_permit) {
+        gaim_conv_chat_unignore(GAIM_CONV_CHAT(convo), nick);
+    } else {
+        gaim_conv_chat_ignore(GAIM_CONV_CHAT(convo), nick);
+    }
+    ops->chat_update_user((convo), nick);
+
+    gaym_update_channel_member(gaym, nick, args[1]);
+    g_free(bio_markedup);
+    g_free(nick);
+}
+
+void gaym_msg_mode(struct gaym_conn *gaym, const char *name,
+                   const char *from, char **args)
+{
+    GaimConversation *convo;
+    char *nick = gaym_mask_nick(from), *buf;
+
+    if (*args[0] == '#' || *args[0] == '&') {   /* Channel */
+        convo =
+            gaim_find_conversation_with_account(args[0], gaym->account);
+        if (!convo) {
+            gaim_debug(GAIM_DEBUG_ERROR, "gaym",
+                       "MODE received for %s, which we are not in\n",
+                       args[0]);
+            g_free(nick);
+            return;
+        }
+        buf =
+            g_strdup_printf(_("mode (%s %s) by %s"), args[1],
+                            args[2] ? args[2] : "", nick);
+        gaim_conv_chat_write(GAIM_CONV_CHAT(convo), args[0], buf,
+                             GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
+                             time(NULL));
+        g_free(buf);
+        if (args[2]) {
+            GaimConvChatBuddyFlags newflag, flags;
+            char *mcur, *cur, *end, *user;
+            gboolean add = FALSE;
+            mcur = args[1];
+            cur = args[2];
+            while (*cur && *mcur) {
+                if ((*mcur == '+') || (*mcur == '-')) {
+                    add = (*mcur == '+') ? TRUE : FALSE;
+                    mcur++;
+                    continue;
+                }
+                end = strchr(cur, ' ');
+                if (!end)
+                    end = cur + strlen(cur);
+                user = g_strndup(cur, end - cur);
+                flags =
+                    gaim_conv_chat_user_get_flags(GAIM_CONV_CHAT(convo),
+                                                  user);
+                newflag = GAIM_CBFLAGS_NONE;
+                if (*mcur == 'o')
+                    newflag = GAIM_CBFLAGS_OP;
+                else if (*mcur == 'h')
+                    newflag = GAIM_CBFLAGS_HALFOP;
+                else if (*mcur == 'v')
+                    newflag = GAIM_CBFLAGS_VOICE;
+                if (newflag) {
+                    if (add)
+                        flags |= newflag;
+                    else
+                        flags &= ~newflag;
+                    gaim_conv_chat_user_set_flags(GAIM_CONV_CHAT(convo),
+                                                  user, flags);
+                }
+                g_free(user);
+                cur = end;
+                if (*cur)
+                    cur++;
+                if (*mcur)
+                    mcur++;
+            }
+        }
+    } else {                    /* User */
+    }
+    g_free(nick);
+}
+
+void gaym_msg_nick(struct gaym_conn *gaym, const char *name,
+                   const char *from, char **args)
+{
+    GSList *chats;
+
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+    char *nick = gaym_mask_nick(from);
+
+    if (!gc) {
+        g_free(nick);
+        return;
+    }
+
+    chats = gc->buddy_chats;
+
+    if (!gaim_utf8_strcasecmp(nick, gaim_connection_get_display_name(gc))) {
+        gaim_connection_set_display_name(gc, args[0]);
+    }
+
+    while (chats) {
+        GaimConvChat *chat = GAIM_CONV_CHAT(chats->data);
+        /* This is ugly ... */
+        if (gaim_conv_chat_find_user(chat, nick))
+            gaim_conv_chat_rename_user(chat, nick, args[0]);
+        chats = chats->next;
+    }
+    g_free(nick);
+}
+
+void gaym_msg_notice(struct gaym_conn *gaym, const char *name,
+                     const char *from, char **args)
+{
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+
+    if (!gc) {
+        return;
+    }
+
+    char *newargs[2];
+
+    newargs[0] = " notice ";    /* The spaces are magic, leave 'em in! */
+    newargs[1] = args[1];
+    gaym_msg_privmsg(gaym, name, from, newargs);
+}
+
+void gaym_msg_part(struct gaym_conn *gaym, const char *name,
+                   const char *from, char **args)
+{
+    GaimConversation *convo;
+    char *msg;
+
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+    char *nick = gaym_mask_nick(from);
+
+    if (!args || !args[0] || !gc || !nick) {
+        g_free(nick);
+        return;
+    }
+
+    convo = gaim_find_conversation_with_account(args[0], gaym->account);
+    gboolean show_part =
+        gaim_prefs_get_bool("/plugins/prpl/gaym/show_part");
+
+    gcom_nick_to_gaym(nick);
+    if (!gaim_utf8_strcasecmp(nick, gaim_connection_get_display_name(gc))) {
+
+        g_hash_table_remove(gaym->entry_order, args[0]);
+        msg = g_strdup_printf(_("You have parted the channel"));
+
+        gaim_conv_chat_write(GAIM_CONV_CHAT(convo), args[0], msg,
+                             GAIM_MESSAGE_SYSTEM, time(NULL));
+        g_free(msg);
+        serv_got_chat_left(gc,
+                           gaim_conv_chat_get_id(GAIM_CONV_CHAT(convo)));
+    } else {
+        if (!gaim_conv_chat_is_user_ignored(GAIM_CONV_CHAT(convo), nick)
+            && show_part) {
+            gaim_conv_chat_remove_user(GAIM_CONV_CHAT(convo), nick, NULL);
+        } else {
+            GaimConversationUiOps *ops =
+                gaim_conversation_get_ui_ops(convo);
+            if (ops != NULL && ops->chat_remove_user != NULL) {
+                ops->chat_remove_user(convo, nick);
+            }
+            GaimConvChatBuddy *cb =
+                gaim_conv_chat_cb_find(GAIM_CONV_CHAT(convo), nick);
+            if (cb) {
+                gaim_conv_chat_set_users(GAIM_CONV_CHAT(convo),
+                                         g_list_remove
+                                         (gaim_conv_chat_get_users
+                                          (GAIM_CONV_CHAT(convo)), cb));
+                gaim_conv_chat_cb_destroy(cb);
+                if (!gaym_unreference_channel_member(gaym, nick))
+                    gaim_debug_error("gaym",
+                                     "channel_members reference counting bug.\n");
+            }
+        }
+    }
+
+    g_free(nick);
+}
+
+void gaym_msg_ping(struct gaym_conn *gaym, const char *name,
+                   const char *from, char **args)
+{
+    char *buf;
+    if (!args || !args[0])
+        return;
+
+    buf = gaym_format(gaym, "v:", "PONG", args[0]);
+    gaym_send(gaym, buf);
+    g_free(buf);
+}
+
+void gaym_msg_pong(struct gaym_conn *gaym, const char *name,
+                   const char *from, char **args)
+{
+    GaimConversation *convo;
+    GaimConnection *gc;
+    char **parts, *msg;
+    time_t oldstamp;
+
+    if (!args || !args[1])
+        return;
+
+    parts = g_strsplit(args[1], " ", 2);
+
+    if (!parts[0] || !parts[1]) {
+        g_strfreev(parts);
+        return;
+    }
+
+    if (sscanf(parts[1], "%lu", &oldstamp) != 1) {
+        msg = g_strdup(_("Error: invalid PONG from server"));
+    } else {
+        msg =
+            g_strdup_printf(_("PING reply -- Lag: %lu seconds"),
+                            time(NULL) - oldstamp);
+    }
+
+    convo = gaim_find_conversation_with_account(parts[0], gaym->account);
+    g_strfreev(parts);
+    if (convo) {
+        if (gaim_conversation_get_type(convo) == GAIM_CONV_CHAT)
+            gaim_conv_chat_write(GAIM_CONV_CHAT(convo), "PONG", msg,
+                                 GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
+                                 time(NULL));
+        else
+            gaim_conv_im_write(GAIM_CONV_IM(convo), "PONG", msg,
+                               GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
+                               time(NULL));
+    } else {
+        gc = gaim_account_get_connection(gaym->account);
+        if (!gc) {
+            g_free(msg);
+            return;
+        }
+        gaim_notify_info(gc, NULL, "PONG", msg);
+    }
+    g_free(msg);
+}
+
+void gaym_msg_privmsg(struct gaym_conn *gaym, const char *name,
+                      const char *from, char **args)
+{
+    GaimConversation *convo;
+    char *tmp, *msg;
+    int notice = 0;
+
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+    char *nick = gaym_mask_nick(from);
+
+    if (!args || !args[0] || !args[1] || !gc) {
+        g_free(nick);
+        return;
+    }
+
+    /**
+     * Only nicks (sender/receiver) should use gcom_nick_to_gaym().
+     *
+     * Channels (which begin with either "#" or "&") should not be
+     * converted.
+     *
+     * Messages should also not be converted.
+     *
+     * CHAT ROOM:
+     * nick = the sender
+     * args[0] = the receiving channel
+     * args[1] = the message
+     *
+     * INSTANT MESSAGE:
+     * nick = the sender
+     * args[0] = the receiver (me)
+     * args[1] = the message
+     *
+     * NOTICE:
+     * nick = the sender
+     * args[0] = " notice "
+     * args[1] = the message
+     */
+    gcom_nick_to_gaym(nick);
+    if (args[0][0] != '#' && args[0][0] != '&') {
+        gcom_nick_to_gaym(args[0]);
+    }
+
+    convo = gaim_find_conversation_with_account(args[0], gaym->account);
+
+    notice = !strcmp(args[0], " notice ");
+    tmp = gaym_parse_ctcp(gaym, nick, args[0], args[1], notice);
+
+    if (!tmp) {
+        g_free(nick);
+        return;
+    }
+
+    if (!gaym_privacy_check(gc, nick)) {
+        g_free(nick);
+        return;
+    }
+
+    msg = gaim_escape_html(tmp);
+
+    g_free(tmp);
+
+    if (notice) {
+        tmp = g_strdup_printf("(notice) %s", msg);
+        g_free(msg);
+        msg = tmp;
+    }
+
+    if (!gaim_utf8_strcasecmp
+        (args[0], gaim_connection_get_display_name(gc))) {
+        serv_got_im(gc, nick, msg, 0, time(NULL));
+    } else if (notice) {
+        serv_got_im(gc, nick, msg, 0, time(NULL));
+    } else if (convo) {
+
+        serv_got_chat_in(gc, gaim_conv_chat_get_id(GAIM_CONV_CHAT(convo)),
+                         nick, 0, msg, time(NULL));
+    } else {
+        gaim_debug(GAIM_DEBUG_ERROR, "gaym",
+                   "Got a PRIVMSG on %s, which does not exist\n", args[0]);
+    }
+
+    g_free(msg);
+    g_free(nick);
+}
+
+void gaym_msg_regonly(struct gaym_conn *gaym, const char *name,
+                      const char *from, char **args)
+{
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+    char *msg;
+
+    if (!args || !args[1] || !args[2] || !gc)
+        return;
+
+    msg = g_strdup_printf(_("Cannot join %s:"), args[1]);
+    gaim_notify_error(gc, _("Cannot join channel"), msg, args[2]);
+    g_free(msg);
+}
+
+/* I don't think gay.com ever sends this message */
+void gaym_msg_quit(struct gaym_conn *gaym, const char *name,
+                   const char *from, char **args)
+{
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+    char *data[2];
+
+    if (!args || !args[0] || !gc)
+        return;
+
+    data[0] = gaym_mask_nick(from);
+    data[1] = args[0];
+    /* XXX this should have an API, I shouldn't grab this directly */
+    g_slist_foreach(gc->buddy_chats, (GFunc) gaym_chat_remove_buddy, data);
+
+    gaym_buddy_status(gaym, data[0], FALSE, NULL);
+
+    g_free(data[0]);
+
+    return;
+}
+
+void gaym_msg_who(struct gaym_conn *gaym, const char *name,
+                  const char *from, char **args)
+{
+    //Use the who msgs cross-referenced with the NAMES list to figure out who is who. Resolve conflicts.
+    
+}
+
+void hammer_stop_cb(gpointer data)
+{
+    struct hammer_cb_data* hdata = (struct hammer_cb_data *) data;
+
+    gaim_debug_misc("gaym","hammer stopped, dialog is %x\n",hdata->cancel_dialog);
+    //This destroys the hammer data!
+    gaim_debug_misc("gaym", "Cancelling hammer: %s\n",hdata->room);
+    //I'm not sure if the dialog data is freed. 
+    //For now, I assume not. 
+    //hdata->cancel_dialog=0;
+    //The old key gets freed, so strdup it again
+    g_hash_table_replace(hdata->gaym->hammers, g_strdup(hdata->room), NULL); 
+}
+
+void hammer_cb_data_destroy(struct hammer_cb_data *hdata) {
+    if(!hdata)
+	return;
+    if(hdata->cancel_dialog)
+	gaim_request_close(GAIM_REQUEST_ACTION, hdata->cancel_dialog);
+    if(hdata->room)
+	g_free(hdata->room);
+    g_free(hdata);
+}
+
+void hammer_cb_no(gpointer data) {
+    hammer_cb_data_destroy(data);
+}
+
+void hammer_cb_yes(gpointer data)
+{
+    struct hammer_cb_data *hdata = (struct hammer_cb_data *) data;
+    char* room=g_strdup(hdata->room);
+    const char *args[1]={room};
+    
+    char *msg;
+    msg = g_strdup_printf("Hammering into room %s", hdata->room);
+    hdata->cancel_dialog =
+        gaim_request_action(hdata->gaym->account->gc, _("Cancel Hammer"), msg,
+                            NULL, 0, hdata, 1, ("Cancel"), hammer_stop_cb);
+    g_hash_table_insert(hdata->gaym->hammers, g_strdup(hdata->room), hdata);
+    gaym_cmd_join(hdata->gaym, NULL, NULL, args);
+    if (msg)
+        g_free(msg);
+    if (room)
+	g_free(room);
+}
+void gaym_msg_chanfull(struct gaym_conn *gaym, const char *name,
+                       const char *from, char **args)
+{
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+    char *buf;
+    const char *joinargs[1];
+
+    if (!args || !args[1] || !gc)
+        return;
+
+    joinargs[0] = args[1];
+
+    gpointer unused=NULL;
+    gpointer data=NULL;
+    gboolean hammering=g_hash_table_lookup_extended
+	(gaym->hammers,args[1],&unused, &data);
+
+    if(hammering && data) {
+        //Add delay here?
+	gaym_cmd_join(gaym, NULL, NULL, joinargs);
+    }
+    else if(hammering && !data) { //hammer was cancelled.
+	    gaim_debug_misc("gaym","HAMMER CANCELLED ON FULL MESSAGE\n");
+	g_hash_table_remove(gaym->hammers, args[1]);
+    }
+    else {
+        buf =
+            g_strdup_printf("%s is full. Do you want to keep trying?",
+                            args[1]);
+	struct hammer_cb_data* hdata = g_new0(struct hammer_cb_data, 1);
+	hdata->gaym=gaym;
+	hdata->room=g_strdup(args[1]);
+	hdata->cancel_dialog=NULL;
+        gaim_request_yes_no(gc, _("Room Full"), _("Room Full"), buf, 0,
+                            hdata, hammer_cb_yes, hammer_cb_no);
+
+        g_free(buf);
+    }
+	
+}
+
+void gaym_msg_create_pay_only(struct gaym_conn *gaym, const char *name,
+                              const char *from, char **args)
+{
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+    char *buf;
+    if (!args || !args[1] || !gc) {
+        return;
+    }
+    buf = g_strdup_printf(_("%s"), args[2]);
+    gaim_notify_error(gc, _("Pay Only"), _("Pay Only"), buf);
+    /**
+     * FIXME
+     * by now the chatroom is already in the buddy list...need
+     * to remove it or something
+     */
+    g_free(buf);
+}
+
+void gaym_msg_pay_channel(struct gaym_conn *gaym, const char *name,
+                          const char *from, char **args)
+{
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+    char *buf;
+
+    if (!args || !args[1] || !gc)
+        return;
+
+    buf =
+        g_strdup_printf(_("The channel %s is for paying members only."),
+                        args[1]);
+    gaim_notify_error(gc, _("Pay Only"), _("Pay Only"), buf);
+    g_free(buf);
+}
+
+void gaym_msg_toomany_channels(struct gaym_conn *gaym, const char *name,
+                               const char *from, char **args)
+{
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+    char *buf;
+
+    if (!args || !args[1] || !gc)
+        return;
+
+    buf =
+        g_strdup_printf(_
+                        ("You have joined too many channels the maximum is (2). You cannot join channel %s. Part another channel first ."),
+                        args[1]);
+    gaim_notify_error(gc, _("Maximum ChannelsReached"),
+                      _("Maximum ChannelsReached"), buf);
+    g_free(buf);
+}
+
+void gaym_msg_list_busy(struct gaym_conn *gaym, const char *name,
+                        const char *from, char **args)
+{
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+    char *buf;
+    if (!args || !args[1] || !gc) {
+        return;
+    }
+    buf = g_strdup_printf(_("%s"), args[1]);
+    gaim_notify_error(gc, _("Server Busy"), _("Server Busy"), buf);
+    // if (gaym->roomlist) {
+    // gaim_roomlist_cancel_get_list(gaym->roomlist);
+    // }
+    g_free(buf);
+    /**
+     * Can't get member created rooms right now.
+     * This is our trigger to add the static rooms
+     */
+    build_roomlist_from_config(gaym->roomlist, gaym->confighash,
+                               gaym->roomlist_filter);
+    if (gaym->roomlist_filter) {
+        g_free(gaym->roomlist_filter);
+        gaym->roomlist_filter = NULL;
+    }
+    return;
+
+}
+
+void gaym_msg_richnames_list(struct gaym_conn *gaym, const char *name,
+                             const char *from, char **args)
+{
+    GaimConnection *gc = gaim_account_get_connection(gaym->account);
+    GaimConversation *convo;
+    GaimConvChatBuddyFlags flags = GAIM_CBFLAGS_NONE;
+    char *channel = args[1];
+    char *nick = args[2];
+    char *extra = args[4];
+
+    if (!gc) {
+        return;
+    }
+
+    gcom_nick_to_gaym(nick);
+    gaim_debug(GAIM_DEBUG_INFO, "gaym",
+               "gaym_msg_richnames_list() Channel: %s Nick: %s Extra: %s\n",
+               channel, nick, extra);
+
+    convo = gaim_find_conversation_with_account(channel, gaym->account);
+
+    char *bio = gaym_bio_strdup(extra);
+    gboolean gaym_botfilter_permit =
+        gaym_botfilter_check(gc, nick, bio, FALSE);
+    g_free(bio);
+
+    gaym_buddy_status(gaym, nick, TRUE, extra);
+
+    if (convo == NULL) {
+        gaim_debug(GAIM_DEBUG_ERROR, "gaym", "690 for %s failed\n",
+                   args[1]);
+        return;
+    }
+
+    gint *entry = g_hash_table_lookup(gaym->entry_order, channel);
+    g_return_if_fail(entry != NULL);
+
+    flags = chat_pecking_order(extra);
+    flags = include_chat_entry_order(flags, (*entry)--);
+
+    gaim_conv_chat_add_user(GAIM_CONV_CHAT(convo), nick, NULL, flags,
+                            FALSE);
+
+    /**
+     * Make the ignore.png icon appear next to the nick.
+     */
+    GaimConversationUiOps *ops = gaim_conversation_get_ui_ops(convo);
+    if (gaym_privacy_check(gc, nick) && gaym_botfilter_permit) {
+        gaim_conv_chat_unignore(GAIM_CONV_CHAT(convo), nick);
+    } else {
+        gaim_conv_chat_ignore(GAIM_CONV_CHAT(convo), nick);
+    }
+    ops->chat_update_user((convo), nick);
+    gaym_update_channel_member(gaym, nick, extra);
+}
+
+/**
+ * vim:tabstop=4:shiftwidth=4:expandtab:
+ */

Deleted: qrc/branches/buddy_icon_hack/gaym-extras/src/bio-popups.c
===================================================================
--- qrc/trunk/gaym-extras/src/bio-popups.c	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/branches/buddy_icon_hack/gaym-extras/src/bio-popups.c	2005-07-31 19:07:03 UTC (rev 263)
@@ -1,459 +0,0 @@
-#include "gaym-extras.h"
-// Consider combining into one popup hash...
-GHashTable *popup_rects;
-GHashTable *popup_timeouts;
-GHashTable *popups;
-void clean_popup_stuff(GaimConversation * c)
-{
-
-    if (!g_strrstr(gaim_account_get_protocol_id(c->account), "prpl-gaym"))
-        return;
-    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-    if (c->type == GAIM_CONV_IM) {
-        g_hash_table_remove(popup_timeouts, gtkconv->tab_label);
-        g_hash_table_remove(popups, gtkconv->tab_label);
-    } else if (c->type == GAIM_CONV_CHAT) {
-        GaimGtkChatPane *gtkchat = gtkconv->u.chat;
-        g_hash_table_remove(popup_timeouts, gtkchat->list);
-        g_hash_table_remove(popup_rects, gtkchat->list);
-        g_hash_table_remove(popups, gtkchat->list);
-    }
-
-}
-
-static void namelist_leave_cb(GtkWidget * tv, GdkEventCrossing * e,
-                              gpointer n)
-{
-    // This prevent clicks from demloishing popups.
-    if (e->mode != GDK_CROSSING_NORMAL)
-        return;
-
-    guint *timeout = g_hash_table_lookup(popup_timeouts, tv);
-    g_hash_table_remove(popups, tv);
-
-    if (*timeout) {
-        g_source_remove(*timeout);
-        *timeout = 0;
-    }
-}
-
-static void namelist_paint_tip(GtkWidget * tipwindow,
-                               GdkEventExpose * event, gpointer data)
-{
-    g_return_if_fail(data);
-
-    char *tooltiptext = ((struct paint_data *) data)->tooltiptext;
-    GdkPixbuf *pixbuf = ((struct paint_data *) data)->pixbuf;
-    GtkStyle *style = NULL;
-
-    PangoLayout *layout;
-
-    layout = gtk_widget_create_pango_layout(tipwindow, NULL);
-    pango_layout_set_markup(layout, tooltiptext, strlen(tooltiptext));
-    pango_layout_set_wrap(layout, PANGO_WRAP_WORD);
-    pango_layout_set_width(layout, 300000);
-    style = tipwindow->style;
-
-    gtk_paint_flat_box(style, tipwindow->window, GTK_STATE_NORMAL,
-                       GTK_SHADOW_OUT, NULL, tipwindow, "tooltip", 0, 0,
-                       -1, -1);
-
-#if GTK_CHECK_VERSION(2,2,0)
-    gdk_draw_pixbuf(GDK_DRAWABLE(tipwindow->window), NULL, pixbuf,
-                    0, 0, 4, 4, -1, -1, GDK_RGB_DITHER_NONE, 0, 0);
-#else
-    gdk_pixbuf_render_to_drawable(pixbuf,
-                                  GDK_DRAWABLE(tipwindow->window), NULL, 0,
-                                  0, 4, 4, -1, -1, GDK_RGB_DITHER_NONE, 0,
-                                  0);
-#endif
-
-    gtk_paint_layout(style, tipwindow->window, GTK_STATE_NORMAL, TRUE,
-                     NULL, tipwindow, "tooltip",
-                     gdk_pixbuf_get_width(pixbuf) + 9, 4, layout);
-
-    g_object_unref(pixbuf);
-    g_object_unref(layout);
-    g_free(tooltiptext);
-    g_free(data);
-
-    return;
-}
-
-GdkPixbuf *lookup_cached_thumbnail(GaimAccount * account,
-                                   const char *fullname)
-{
-    GDir *gdir = NULL;
-    GError *err = NULL;
-    GdkPixbuf *pixbuf = NULL;
-    const char *filename = NULL;
-    char *dirname = NULL;
-    char *path = NULL;
-    const char *name = gaim_normalize(account, fullname);
-    dirname =
-        g_build_filename(gaim_user_dir(), "icons", "gaym", name, NULL);
-    if (dirname) {
-        gdir = g_dir_open(dirname, 0, &err);
-        if (gdir) {
-            filename = g_dir_read_name(gdir);   // don't free filename:
-                                                // owned by glib.
-            if (filename) {
-                path = g_build_filename(dirname, filename, NULL);
-                if (path)
-                    pixbuf = gdk_pixbuf_new_from_file(path, &err);
-                g_free(path);
-            }
-            g_free(gdir);
-        }
-        g_free(dirname);
-    }
-    return pixbuf;
-}
-
-static gboolean tooltip_timeout(struct timeout_cb_data *data)
-{
-    const gchar *name;
-    int scr_w, scr_h, w, h, x, y;
-#if GTK_CHECK_VERSION(2,2,0)
-    int mon_num;
-    GdkScreen *screen = NULL;
-#endif
-    PangoLayout *layout;
-    gboolean tooltip_top = FALSE;
-    char *tooltiptext = NULL;
-    GdkRectangle mon_size;
-    guint *timeout;
-    GtkWidget *tipwindow;
-    GtkWidget *tv = data->tv;
-
-    GaymTooltipType type = data->type;
-    GaimAccount *account = data->account;
-    GaimPluginProtocolInfo *prpl_info =
-        GAIM_PLUGIN_PROTOCOL_INFO(gaim_find_prpl
-                                  (gaim_account_get_protocol_id(account)));
-
-
-    timeout = (guint *) g_hash_table_lookup(popup_timeouts, tv);
-    /* we check to see if we're still supposed to be moving, now that gtk
-       events have happened, and the mouse might not still be in the buddy 
-       list */
-    while (gtk_events_pending())
-        gtk_main_iteration();
-    if (!(*timeout)) {
-        return FALSE;
-    }
-
-    if (type == TOOLTIP_CHAT) {
-        GtkTreePath *path;
-        GtkTreeIter iter;
-        GtkTreeModel *model;
-        GdkRectangle *rect;
-
-        rect = g_hash_table_lookup(popup_rects, tv);
-        if (!gtk_tree_view_get_path_at_pos
-            (GTK_TREE_VIEW(tv), rect->x, rect->y, &path, NULL, NULL, NULL))
-            return FALSE;
-        model = gtk_tree_view_get_model(GTK_TREE_VIEW(tv));
-        gtk_tree_model_get_iter(model, &iter, path);
-        gtk_tree_model_get(model, &iter, CHAT_USERS_NAME_COLUMN, &name,
-                           -1);
-        gtk_tree_path_free(path);
-    } else if (type == TOOLTIP_IM) {
-        name = gtk_label_get_text(GTK_LABEL(tv));
-    } else
-        return FALSE;
-
-
-
-
-    GaimBuddy *gb = g_new0(GaimBuddy, 1);
-    gb->name = g_strdup(name);
-    gb->account = account;
-    tooltiptext = prpl_info->tooltip_text(gb);
-    g_free(gb->name);
-    g_free(gb);
-
-    if (!tooltiptext)
-        return FALSE;
-
-
-    g_return_val_if_fail(tooltiptext != NULL, FALSE);
-
-    tipwindow = g_hash_table_lookup(popups, tv);
-    if (tipwindow) {
-        g_hash_table_remove(popups, tv);
-    }
-    tipwindow = gtk_window_new(GTK_WINDOW_POPUP);
-    g_hash_table_insert(popups, tv, tipwindow);
-
-    gtk_widget_set_app_paintable(tipwindow, TRUE);
-    gtk_window_set_resizable(GTK_WINDOW(tipwindow), FALSE);
-    gtk_widget_set_name(tipwindow, "gtk-tooltips");
-
-    struct paint_data *pdata = g_new0(struct paint_data, 1);
-    pdata->tooltiptext = tooltiptext;
-    pdata->pixbuf = lookup_cached_thumbnail(account, name);
-    g_signal_connect(G_OBJECT(tipwindow), "expose_event",
-                     G_CALLBACK(namelist_paint_tip), pdata);
-    gtk_widget_ensure_style(tipwindow);
-    layout = gtk_widget_create_pango_layout(tipwindow, NULL);
-    pango_layout_set_wrap(layout, PANGO_WRAP_WORD);
-    pango_layout_set_width(layout, 300000);
-    pango_layout_set_markup(layout, tooltiptext, strlen(tooltiptext));
-    pango_layout_get_size(layout, &w, &h);
-
-#if GTK_CHECK_VERSION(2,2,0)
-    gdk_display_get_pointer(gdk_display_get_default(), &screen, &x, &y,
-                            NULL);
-    mon_num = gdk_screen_get_monitor_at_point(screen, x, y);
-    gdk_screen_get_monitor_geometry(screen, mon_num, &mon_size);
-
-    scr_w = mon_size.width + mon_size.x;
-    scr_h = mon_size.height + mon_size.y;
-#else
-    scr_w = gdk_screen_width();
-    scr_h = gdk_screen_height();
-    gdk_window_get_pointer(NULL, &x, &y, NULL);
-    mon_size.x = 0;
-    mon_size.y = 0;
-#endif
-
-
-    w = PANGO_PIXELS(w) + 8;
-    h = PANGO_PIXELS(h) + 8;
-
-    /* For the width, set it to the text width, plus 13 for 4 pixels on
-       each side and 5 between icon/text. For height, the greater of the
-       text height and the icon height, plus 8 (4 for each buffer on top
-       and bottom). */
-    w = w + gdk_pixbuf_get_width(pdata->pixbuf) + 4;
-    h = MAX(h, gdk_pixbuf_get_height(pdata->pixbuf) + 8);
-
-#if GTK_CHECK_VERSION(2,2,0)
-    if (w > mon_size.width)
-        w = mon_size.width - 10;
-
-    if (h > mon_size.height)
-        h = mon_size.height - 10;
-#endif
-
-    // Find the conversation window here....
-    // if (GTK_WIDGET_NO_WINDOW(window))
-    // y+=window->allocation.y;
-
-    x -= ((w >> 1) + 4);
-
-    if ((y + h + 4) > scr_h || tooltip_top)
-        y = y - h - 5;
-    else
-        y = y + 6;
-
-    if (y < mon_size.y)
-        y = mon_size.y;
-
-    if (y != mon_size.y) {
-        if ((x + w) > scr_w)
-            x -= (x + w + 5) - scr_w;
-        else if (x < mon_size.x)
-            x = mon_size.x;
-    } else {
-        x -= (w / 2 + 10);
-        if (x < mon_size.x)
-            x = mon_size.x;
-    }
-
-    g_object_unref(layout);
-    gtk_widget_set_size_request(tipwindow, w, h);
-    gtk_window_move(GTK_WINDOW(tipwindow), x, y);
-    gtk_widget_show(tipwindow);
-
-    return FALSE;
-}
-
-
-static gboolean namelist_motion_cb(GtkWidget * tv, GdkEventMotion * event,
-                                   gpointer account)
-{
-    GtkTreeModel *ls = NULL;
-    GtkTreePath *path = NULL;
-    GtkTreeIter iter;
-    char *name;
-    static int count = 0;
-    gboolean tf;
-    GdkRectangle *rect;
-    guint *timeout;
-    count++;
-    guint delay;
-    rect = g_hash_table_lookup(popup_rects, tv);
-    g_return_val_if_fail(rect != NULL, FALSE);
-
-    timeout = g_hash_table_lookup(popup_timeouts, tv);
-
-    delay = gaim_prefs_get_int("/gaim/gtk/blist/tooltip_delay");
-
-    if (delay == 0)
-        return FALSE;
-
-    if (*timeout) {
-        if ((event->y > rect->y) && ((event->y - rect->height) < rect->y))
-            return FALSE;
-        /* We've left the cell.  Remove the timeout and create a new one
-           below */
-
-        g_hash_table_remove(popups, tv);
-        g_source_remove(*timeout);
-    }
-
-    gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(tv), event->x, event->y,
-                                  &path, NULL, NULL, NULL);
-    if (G_UNLIKELY(path == NULL))
-        return FALSE;
-    struct timeout_cb_data *timeout_data =
-        g_new0(struct timeout_cb_data, 1);
-    timeout_data->tv = tv;
-    timeout_data->account = account;
-    timeout_data->type = TOOLTIP_CHAT;
-    *timeout =
-        g_timeout_add(delay, (GSourceFunc) tooltip_timeout, timeout_data);
-
-    gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, rect);
-
-    ls = gtk_tree_view_get_model(GTK_TREE_VIEW(tv));
-    tf = gtk_tree_model_get_iter(ls, &iter, path);
-    gtk_tree_model_get(ls, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
-    gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, rect);
-
-    return TRUE;
-}
-
-static void tab_leave_cb(GtkWidget * event, GdkEventCrossing * e,
-                         gpointer conv)
-{
-
-    GaimConversation *c = (GaimConversation *) conv;
-
-    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-    // Prevent clicks from demolishing popup.
-    if (e->mode != GDK_CROSSING_NORMAL)
-        return;
-    GtkWidget *tab = gtkconv->tab_label;
-
-    guint *timeout = g_hash_table_lookup(popup_timeouts, tab);
-    g_hash_table_remove(popups, tab);
-
-
-    if (timeout && *timeout) {
-        g_source_remove(*timeout);
-        *timeout = 0;
-    }
-}
-
-
-static gboolean tab_entry_cb(GtkWidget * event,
-                             GdkEventCrossing * crossing, gpointer conv)
-{
-
-    guint *timeout;
-    guint delay;
-    GaimConversation *c = (GaimConversation *) conv;
-    GaimAccount *account = gaim_conversation_get_account(c);
-    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-
-    GtkWidget *tab = gtkconv->tab_label;
-    timeout = g_hash_table_lookup(popup_timeouts, tab);
-
-    delay = gaim_prefs_get_int("/gaim/gtk/blist/tooltip_delay");
-
-    if (delay == 0)
-        return FALSE;
-
-    if (timeout && *timeout)
-        return FALSE;
-
-    // g_hash_table_remove(popups, tab);
-    // g_source_remove(*timeout);
-
-
-
-    struct timeout_cb_data *timeout_data =
-        g_new0(struct timeout_cb_data, 1);
-    timeout_data->tv = tab;
-    timeout_data->account = account;
-    timeout_data->type = TOOLTIP_IM;
-    *timeout =
-        g_timeout_add(delay, (GSourceFunc) tooltip_timeout, timeout_data);
-
-    return TRUE;
-}
-
-void add_chat_popup_stuff(GaimConversation * c)
-{
-
-    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-    GaimGtkChatPane *gtkchat = gtkconv->u.chat;
-    GaimAccount *account = gaim_conversation_get_account(c);
-
-    g_signal_connect(G_OBJECT(gtkchat->list), "motion-notify-event",
-                     G_CALLBACK(namelist_motion_cb), account);
-    g_signal_connect(G_OBJECT(gtkchat->list), "leave-notify-event",
-                     G_CALLBACK(namelist_leave_cb), NULL);
-
-
-    g_hash_table_insert(popup_rects, gtkchat->list,
-                        g_new0(GdkRectangle, 1));
-    g_hash_table_insert(popup_timeouts, gtkchat->list, g_new0(guint, 1));
-
-
-}
-
-void add_im_popup_stuff(GaimConversation * c)
-{
-    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-    GtkWidget *event = gtk_event_box_new();
-    GtkWidget *hbox = gtk_hbox_new(FALSE, 6);
-
-    gtk_widget_ref(gtkconv->icon);
-    gtk_container_remove(GTK_CONTAINER(gtkconv->tabby),
-                         GTK_WIDGET(gtkconv->icon));
-    gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(gtkconv->icon), FALSE,
-                       FALSE, 0);
-    gtk_widget_ref(gtkconv->icon);
-    gtk_widget_unref(gtkconv->icon);
-
-    gtk_widget_ref(gtkconv->tab_label);
-    gtk_container_remove(GTK_CONTAINER(gtkconv->tabby),
-                         GTK_WIDGET(gtkconv->tab_label));
-    gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(gtkconv->tab_label), TRUE,
-                       TRUE, 0);
-    gtk_widget_unref(gtkconv->tab_label);
-
-
-    gtk_widget_add_events(event,
-                          GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK);
-    g_signal_connect(G_OBJECT(event), "enter-notify-event",
-                     G_CALLBACK(tab_entry_cb), c);
-    g_signal_connect(G_OBJECT(event), "leave-notify-event",
-                     G_CALLBACK(tab_leave_cb), c);
-    gtk_box_pack_start(GTK_BOX(gtkconv->tabby), GTK_WIDGET(event), TRUE,
-                       TRUE, 0);
-    gtk_box_reorder_child(GTK_BOX(gtkconv->tabby), GTK_WIDGET(event), 0);
-    gtk_widget_show(GTK_WIDGET(event));
-    gtk_widget_show(GTK_WIDGET(hbox));
-    gtk_event_box_set_visible_window(GTK_EVENT_BOX(event), FALSE);
-    gtk_container_add(GTK_CONTAINER(event), GTK_WIDGET(hbox));
-    g_hash_table_insert(popup_timeouts, gtkconv->tab_label,
-                        g_new0(guint, 1));
-}
-
-void init_popups()
-{
-    popup_rects =
-        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
-
-    popup_timeouts =
-        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
-
-    popups =
-        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL,
-                              (GDestroyNotify) gtk_widget_destroy);
-}

Copied: qrc/branches/buddy_icon_hack/gaym-extras/src/bio-popups.c (from rev 260, qrc/trunk/gaym-extras/src/bio-popups.c)

Deleted: qrc/branches/buddy_icon_hack/gaym-extras/src/gaym-extras.c
===================================================================
--- qrc/trunk/gaym-extras/src/gaym-extras.c	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/branches/buddy_icon_hack/gaym-extras/src/gaym-extras.c	2005-07-31 19:07:03 UTC (rev 263)
@@ -1,140 +0,0 @@
-/* Show icons in chat room windows */
-
-
-#include "gaym-extras.h"
-// Adds motion handlers to IM tab labels.
-static void redo_im_window(GaimConversation * c)
-{
-    if (!g_strrstr(gaim_account_get_protocol_id(c->account), "prpl-gaym"))
-        return;
-    if (c && c->type == GAIM_CONV_IM)
-        add_im_popup_stuff(c);
-}
-
-
-static void update_info_cb(GaimAccount * account, char *name)
-{
-    if (!g_strrstr(gaim_account_get_protocol_id(account), "prpl-gaym"))
-        return;
-    gaim_debug_misc("gaym-extras", "info update\n");
-}
-
-static void redochatwindow(GaimConversation * c)
-{
-    if (!g_strrstr(gaim_account_get_protocol_id(c->account), "prpl-gaym"))
-        return;
-    add_chat_sort_functions(c);
-    add_chat_popup_stuff(c);
-    add_chat_icon_stuff(c);
-}
-static gchar *find_file(const char *dir, const char *base)
-{
-    char *filename;
-
-    if (base == NULL)
-        return NULL;
-
-    if (!strcmp(dir, "gaim"))
-        filename =
-            g_build_filename(GAIM_DATADIR, "pixmaps", "gaim", base, NULL);
-    else {
-        filename = g_build_filename(GAIM_DATADIR, "pixmaps", "gaim", dir,
-                                    base, NULL);
-    }
-
-    if (!g_file_test(filename, G_FILE_TEST_EXISTS)) {
-        g_critical("Unable to load stock pixmap %s\n", filename);
-
-        g_free(filename);
-
-        return NULL;
-    }
-
-    return filename;
-
-}
-
-void extras_register_stock()
-{
-
-    static gboolean stock_is_init = FALSE;
-    GtkIconFactory *icon_factory = NULL;
-    int i;
-    if (stock_is_init)
-        return;
-    stock_is_init = TRUE;
-    icon_factory = gtk_icon_factory_new();
-
-    gtk_icon_factory_add_default(icon_factory);
-
-    for (i = 0; i < G_N_ELEMENTS(stock_icons); i++) {
-        GdkPixbuf *pixbuf;
-        GtkIconSet *iconset;
-        gchar *filename;
-        filename = find_file(stock_icons[i].dir, stock_icons[i].filename);
-        if (filename == NULL)
-            continue;
-
-        pixbuf = gdk_pixbuf_new_from_file(filename, NULL);
-        g_free(filename);
-        iconset = gtk_icon_set_new_from_pixbuf(pixbuf);
-
-        g_object_unref(pixbuf);
-        gtk_icon_factory_add(icon_factory, stock_icons[i].name, iconset);
-        gtk_icon_set_unref(iconset);
-    }
-
-
-}
-static gboolean plugin_load(GaimPlugin * plugin)
-{
-    init_chat_icons();
-    init_popups();
-
-    gaim_signal_connect(gaim_conversations_get_handle(), "chat-joined",
-                        plugin, GAIM_CALLBACK(redochatwindow), NULL);
-
-    gaim_signal_connect(gaim_conversations_get_handle(),
-                        "conversation-created", plugin,
-                        GAIM_CALLBACK(redo_im_window), NULL);
-
-    gaim_signal_connect(gaim_accounts_get_handle(), "info-updated", plugin,
-                        GAIM_CALLBACK(update_info_cb), NULL);
-
-    gaim_signal_connect(gaim_conversations_get_handle(),
-                        "deleting-conversation", plugin,
-                        GAIM_CALLBACK(clean_popup_stuff), NULL);
-
-    extras_register_stock();
-    return TRUE;
-}
-
-static GaimPluginInfo info = {
-    GAIM_PLUGIN_MAGIC,
-    GAIM_MAJOR_VERSION,
-    GAIM_MINOR_VERSION,
-    GAIM_PLUGIN_STANDARD,
-    GAIM_GTK_PLUGIN_TYPE,
-    0,
-    NULL,
-    GAIM_PRIORITY_DEFAULT,
-    GAYM_EXTRAS_PLUGIN_ID,
-    N_("Gaym Extras"),
-    VERSION,
-    N_("GUI-related additions for the gaym protocol plugin."),
-    N_("Current functionality provided by this plugin:\n1. Allows namelist sort order in rooms to be changed.\n2. Shows thumbnails for currently selected user in rooms.\n3. Popup displays bio when you hover over a name in the namelist.\n4. Popup shows bio when you hover over an IM tab."),
-    "Jason LeBrun gaym at jasonlebrun.info",
-    GAIM_WEBSITE,
-    plugin_load,
-    NULL,
-    NULL,
-    NULL,
-    NULL,
-    NULL
-};
-
-static void init_plugin(GaimPlugin * plugin)
-{
-}
-
-GAIM_INIT_PLUGIN(history, init_plugin, info)

Copied: qrc/branches/buddy_icon_hack/gaym-extras/src/gaym-extras.c (from rev 260, qrc/trunk/gaym-extras/src/gaym-extras.c)

Deleted: qrc/branches/buddy_icon_hack/gaym-extras/src/roombrowse.c
===================================================================
--- qrc/trunk/gaym-extras/src/roombrowse.c	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/branches/buddy_icon_hack/gaym-extras/src/roombrowse.c	2005-07-31 19:07:03 UTC (rev 263)
@@ -1,435 +0,0 @@
-/* Puts last 4k of log in new conversations a la Everybuddy (and then
-   stolen by Trillian "Pro") */
-
-#include "internal.h"
-#include "gtkgaim.h"
-
-#include "conversation.h"
-#include "debug.h"
-#include "log.h"
-#include "prefs.h"
-#include "signals.h"
-#include "util.h"
-#include "version.h"
-#include "prpl.h"
-
-#include "gtkconv.h"
-#include "gtkimhtml.h"
-#include "gtkplugin.h"
-#include "gtkdialogs.h"
-#include "gtkutils.h"
-#include "gtkblist.h"
-#include "gtkimhtmltoolbar.h"
-#include <gdk/gdkkeysyms.h>
-
-#define CHATSORT_PLUGIN_ID "gtk-chatsort"
-#define CHATSORT_USERS_COLUMNS 4
-#define CHATSORT_USERS_ENTRY_COLUMN 3
-
-/**
- * Unused variables:
- *
- * static GList *browsers = NULL;
- */
-
-struct RoomBrowseInfo {
-
-    GaimAccount *account;
-    GaimConnection *gc;
-};
-
-static GtkWidget *setup_roombrowse_pane(GaimConversation * conv)
-{
-    GaimGtkConversation *gtkconv;
-    GaimGtkChatPane *gtkchat;
-    GaimConnection *gc;
-    GtkWidget *vpaned, *hpaned;
-    GtkWidget *vbox;
-
-        /**
-	 * Unused variables:
-	 *
-	 * GaimPluginProtocolInfo *prpl_info = NULL;
-	 * GtkWidget *hbox;
-	 * GtkWidget *lbox, *bbox;
-	 * GtkWidget *label;
-	 * GtkWidget *list;
-	 * GtkWidget *button;
-	 * GtkWidget *sw;
-	 * GtkListStore *ls;
-	 * GtkCellRenderer *rend;
-	 * GtkTreeViewColumn *col;
-	 * GList *focus_chain = NULL;
-	 */
-
-    gtkconv = GAIM_GTK_CONVERSATION(conv);
-    gtkchat = gtkconv->u.chat;
-    gc = gaim_conversation_get_gc(conv);
-
-    /* Setup the outer pane. */
-    vpaned = gtk_vpaned_new();
-    gtk_widget_show(vpaned);
-    /* Setup the top part of the pane. */
-    vbox = gtk_vbox_new(FALSE, 6);
-    gtk_paned_pack1(GTK_PANED(vpaned), vbox, TRUE, TRUE);
-    gtk_widget_show(vbox);
-
-    /* Setup the horizontal pane. */
-    hpaned = gtk_hpaned_new();
-    gtk_box_pack_start(GTK_BOX(vbox), hpaned, TRUE, TRUE, 0);
-    gtk_widget_show(hpaned);
-
-    /* Setup the scrolled window to put gtkimhtml in. */
-    gtkconv->sw = gtk_scrolled_window_new(NULL, NULL);
-    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(gtkconv->sw),
-                                   GTK_POLICY_AUTOMATIC,
-                                   GTK_POLICY_ALWAYS);
-    gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(gtkconv->sw),
-                                        GTK_SHADOW_IN);
-    gtk_paned_pack1(GTK_PANED(hpaned), gtkconv->sw, TRUE, TRUE);
-
-    gtk_widget_set_size_request(gtkconv->sw,
-                                gaim_prefs_get_int
-                                ("/gaim/gtk/conversations/chat/default_width"),
-                                gaim_prefs_get_int
-                                ("/gaim/gtk/conversations/chat/default_height"));
-
-    // g_signal_connect(G_OBJECT(gtkconv->sw), "size-allocate",
-    // G_CALLBACK(size_allocate_cb), conv);
-
-    gtk_widget_show(gtkconv->sw);
-
-    return vpaned;
-}
-
-static gint close_conv_cb(GtkWidget * w, gpointer d)
-{
-    GaimConversation *conv = (GaimConversation *) d;
-
-    gaim_conversation_destroy(conv);
-
-    return TRUE;
-}
-
-GdkPixbuf *get_tab_icon(GaimConversation * conv, gboolean small_icon)
-{
-    GaimAccount *account = NULL;
-    const char *name = NULL;
-    GdkPixbuf *status = NULL;
-
-    g_return_val_if_fail(conv != NULL, NULL);
-
-    account = gaim_conversation_get_account(conv);
-    name = gaim_conversation_get_name(conv);
-
-    g_return_val_if_fail(account != NULL, NULL);
-    g_return_val_if_fail(name != NULL, NULL);
-
-
-    if (gaim_conversation_get_type(conv) == GAIM_CONV_IM) {
-        GaimBuddy *b = gaim_find_buddy(account, name);
-        if (b != NULL) {
-            status = gaim_gtk_blist_get_status_icon((GaimBlistNode *) b,
-                                                    (small_icon ?
-                                                     GAIM_STATUS_ICON_SMALL
-                                                     :
-                                                     GAIM_STATUS_ICON_LARGE));
-        }
-    }
-
-    if (!status) {
-        GdkPixbuf *pixbuf;
-        pixbuf = create_prpl_icon(account);
-
-        if (small_icon && pixbuf != NULL) {
-            status = gdk_pixbuf_scale_simple(pixbuf, 15, 15,
-                                             GDK_INTERP_BILINEAR);
-            g_object_unref(pixbuf);
-        } else
-            status = pixbuf;
-    }
-    return status;
-}
-
-/**
- * Unused function
- */
-#if 0
-static void update_tab_icon(GaimConversation * conv)
-{
-    GaimGtkConversation *gtkconv;
-    GaimConvWindow *win = gaim_conversation_get_window(conv);
-    GaimAccount *account;
-    const char *name;
-    GdkPixbuf *status = NULL;
-
-    g_return_if_fail(conv != NULL);
-
-    gtkconv = GAIM_GTK_CONVERSATION(conv);
-    name = gaim_conversation_get_name(conv);
-    account = gaim_conversation_get_account(conv);
-
-    status = get_tab_icon(conv, TRUE);
-
-    g_return_if_fail(status != NULL);
-
-    gtk_image_set_from_pixbuf(GTK_IMAGE(gtkconv->icon), status);
-    gtk_image_set_from_pixbuf(GTK_IMAGE(gtkconv->menu_icon), status);
-
-    if (status != NULL)
-        g_object_unref(status);
-
-    if (gaim_conv_window_get_active_conversation(win) == conv &&
-        gtkconv->u.im->anim == NULL) {
-        status = get_tab_icon(conv, FALSE);
-
-        gtk_window_set_icon(GTK_WINDOW(GAIM_GTK_WINDOW(win)->window),
-                            status);
-
-        if (status != NULL)
-            g_object_unref(status);
-    }
-}
-#endif
-
-/* Courtesy of Galeon! */
-static void
-tab_close_button_state_changed_cb(GtkWidget * widget,
-                                  GtkStateType prev_state)
-{
-    if (GTK_WIDGET_STATE(widget) == GTK_STATE_ACTIVE)
-        gtk_widget_set_state(widget, GTK_STATE_NORMAL);
-}
-
-static void
-roombrowse_gtk_add_conversation(GaimConvWindow * win,
-                                GaimConversation * conv)
-{
-    GaimGtkWindow *gtkwin;
-    GaimGtkConversation *gtkconv, *focus_gtkconv;
-    GaimConversation *focus_conv;
-    GtkWidget *pane = NULL;
-    GtkWidget *tab_cont;
-    GtkWidget *tabby, *menu_tabby;
-    GtkWidget *close_image;
-    gboolean new_ui;
-    GaimConversationType conv_type;
-    const char *name;
-
-    name = gaim_conversation_get_name(conv);
-    conv_type = gaim_conversation_get_type(conv);
-    gtkwin = GAIM_GTK_WINDOW(win);
-
-    if (conv->ui_data != NULL) {
-        gtkconv = (GaimGtkConversation *) conv->ui_data;
-
-        tab_cont = gtkconv->tab_cont;
-
-        new_ui = FALSE;
-    } else {
-        gtkconv = g_malloc0(sizeof(GaimGtkConversation));
-        conv->ui_data = gtkconv;
-
-        /* Setup some initial variables. */
-        gtkconv->sg = gtk_size_group_new(GTK_SIZE_GROUP_BOTH);
-        gtkconv->tooltips = gtk_tooltips_new();
-
-        gaim_debug_misc("roombrowse", "setting up pane\n");
-        pane = setup_roombrowse_pane(conv);
-
-        gaim_debug_misc("roombrowse", "set up pane\n");
-
-        if (pane == NULL) {
-            g_free(gtkconv);
-            conv->ui_data = NULL;
-
-            return;
-        }
-
-
-
-        /* Setup the container for the tab. */
-        gtkconv->tab_cont = tab_cont = gtk_vbox_new(FALSE, 6);
-        gtk_container_set_border_width(GTK_CONTAINER(tab_cont), 6);
-        gtk_container_add(GTK_CONTAINER(tab_cont), pane);
-        gtk_widget_show(pane);
-
-        new_ui = TRUE;
-
-        gtkconv->make_sound = FALSE;
-        gtkconv->show_formatting_toolbar = FALSE;
-        gtkconv->show_timestamps = FALSE;
-
-        g_signal_connect_swapped(G_OBJECT(pane), "focus",
-                                 G_CALLBACK(gtk_widget_grab_focus),
-                                 gtkconv->entry);
-    }
-
-    gaim_debug_misc("roombrowse", "Setting up tabs\n");
-    gtkconv->tabby = tabby = gtk_hbox_new(FALSE, 6);
-    gtkconv->menu_tabby = menu_tabby = gtk_hbox_new(FALSE, 6);
-    gtkconv->entry = gtk_imhtml_new(NULL, NULL);
-    gtkconv->toolbar = gtk_imhtmltoolbar_new();
-
-    gaim_debug_misc("roombrowse", "Setting up close button\n");
-    /* Close button. */
-    gtkconv->close = gtk_button_new();
-    gtk_widget_set_size_request(GTK_WIDGET(gtkconv->close), 16, 16);
-    gtk_button_set_relief(GTK_BUTTON(gtkconv->close), GTK_RELIEF_NONE);
-    close_image =
-        gtk_image_new_from_stock(GTK_STOCK_CLOSE, GTK_ICON_SIZE_MENU);
-    gtk_widget_show(close_image);
-    gtk_container_add(GTK_CONTAINER(gtkconv->close), close_image);
-    gtk_tooltips_set_tip(gtkconv->tooltips, gtkconv->close,
-                         _("Close conversation"), NULL);
-
-    g_signal_connect(G_OBJECT(gtkconv->close), "clicked",
-                     G_CALLBACK(close_conv_cb), conv);
-
-    /* 
-     * I love Galeon. They have a fix for that stupid annoying visible
-     * border bug. I love you guys! -- ChipX86
-     */
-    g_signal_connect(G_OBJECT(gtkconv->close), "state_changed",
-                     G_CALLBACK(tab_close_button_state_changed_cb), NULL);
-
-    /* Status icon. */
-    gtkconv->icon = gtk_image_new();
-    gtkconv->menu_icon = gtk_image_new();
-    // update_tab_icon(conv);
-
-    /* Tab label. */
-    gtkconv->tab_label = gtk_label_new(gaim_conversation_get_title(conv));
-    gtkconv->menu_label = gtk_label_new(gaim_conversation_get_title(conv));
-#if 0
-    gtk_misc_set_alignment(GTK_MISC(gtkconv->tab_label), 0.00, 0.5);
-    gtk_misc_set_padding(GTK_MISC(gtkconv->tab_label), 4, 0);
-#endif
-
-    gaim_debug_misc("roombrowse", "Packing\n");
-    /* Pack it all together. */
-    gtk_box_pack_start(GTK_BOX(tabby), gtkconv->icon, FALSE, FALSE, 0);
-    gtk_box_pack_start(GTK_BOX(menu_tabby), gtkconv->menu_icon,
-                       FALSE, FALSE, 0);
-
-    gtk_widget_show_all(gtkconv->icon);
-    gtk_widget_show_all(gtkconv->menu_icon);
-
-    gtk_box_pack_start(GTK_BOX(tabby), gtkconv->tab_label, TRUE, TRUE, 0);
-    gtk_box_pack_start(GTK_BOX(menu_tabby), gtkconv->menu_label, TRUE,
-                       TRUE, 0);
-    gtk_widget_show(gtkconv->tab_label);
-    gtk_widget_show(gtkconv->menu_label);
-    gtk_misc_set_alignment(GTK_MISC(gtkconv->menu_label), 0, 0);
-
-    gtk_box_pack_start(GTK_BOX(tabby), gtkconv->close, FALSE, FALSE, 0);
-    if (gaim_prefs_get_bool("/gaim/gtk/conversations/close_on_tabs"))
-        gtk_widget_show(gtkconv->close);
-
-    gtk_widget_show(tabby);
-    gtk_widget_show(menu_tabby);
-
-    if (gaim_conversation_get_type(conv) == GAIM_CONV_IM)
-        gaim_gtkconv_update_buddy_icon(conv);
-
-    gaim_debug_misc("roombrowse", "Adding to notebook\n");
-    gaim_debug_misc("roombrowse", "gtkwin->notebook=%x\n",
-                    gtkwin->notebook);
-    gaim_debug_misc("roombrowse", "gtkwin=%x\n", gtkwin);
-    gaim_debug_misc("roombrowse", "tabby=%x\n", tabby);
-    gaim_debug_misc("roombrowse", "menu_tabby=%x\n", menu_tabby);
-    gaim_debug_misc("roombrowse", "tab_cont=%x\n", tab_cont);
-
-    /* Add this pane to the conversation's notebook. */
-    int n = gtk_notebook_get_n_pages(GTK_NOTEBOOK(gtkwin->notebook));
-    gaim_debug_misc("roombrowse:", "Notebook has %d pages\n", n);
-    gtk_notebook_append_page_menu(GTK_NOTEBOOK(gtkwin->notebook), tab_cont,
-                                  tabby, menu_tabby);
-    gaim_debug_misc("roombrowse", "Got through append_page_menu\n");
-    gtk_widget_show(tab_cont);
-
-    if (gaim_conv_window_get_conversation_count(win) == 1) {
-        /* Er, bug in notebooks? Switch to the page manually. */
-        gtk_notebook_set_current_page(GTK_NOTEBOOK(gtkwin->notebook), 0);
-
-        gtk_notebook_set_show_tabs(GTK_NOTEBOOK(gtkwin->notebook),
-                                   gaim_prefs_get_bool
-                                   ("/gaim/gtk/conversations/tabs"));
-    } else
-        gtk_notebook_set_show_tabs(GTK_NOTEBOOK(gtkwin->notebook), TRUE);
-    gaim_debug_misc("roombrowse", "FOcus stuff\n");
-    focus_conv = g_list_nth_data(gaim_conv_window_get_conversations(win),
-                                 gtk_notebook_get_current_page(GTK_NOTEBOOK
-                                                               (gtkwin->
-                                                                notebook)));
-    focus_gtkconv = GAIM_GTK_CONVERSATION(focus_conv);
-    gtk_widget_grab_focus(focus_gtkconv->entry);
-
-    if (!new_ui)
-        g_object_unref(gtkconv->tab_cont);
-}
-
-
-static void roombrowse_menu_cb(GaimBlistNode * node, gpointer data)
-{
-    GaimConvWindow *win = gaim_get_first_window_with_type(GAIM_CONV_MISC);
-    GaimConversation *conv = g_new0(GaimConversation, 1);
-
-    GaimAccount *account = ((GaimChat *) node)->account;
-    if (!win)
-        win = gaim_conv_window_new();
-    GaimChat *chat = ((GaimChat *) node);
-    char *room = g_strdup(g_hash_table_lookup(chat->components, "name"));
-
-
-    gaim_debug_misc("roombrowser", "In cb with node=%x, account=%x\n",
-                    node, account);
-    conv = gaim_conversation_new(GAIM_CONV_MISC, account, room);
-
-    gaim_conversation_set_logging(conv, FALSE);
-
-    roombrowse_gtk_add_conversation(conv->window, conv);
-    gaim_conv_window_show(conv->window);
-
-    g_free(room);
-
-}
-static void roombrowse_menu_create(GaimBlistNode * node, GList ** menu)
-{
-
-    char *label, *room;
-
-    struct gaym_conn *gaym;
-    GaimChat *chat = (GaimChat *) node;
-
-    gaim_debug_misc("roombrowse", "In callback\n");
-    if (node->type != GAIM_BLIST_CHAT_NODE)
-        return;
-
-    gaym = chat->account->gc->proto_data;
-
-    room = g_strdup(g_hash_table_lookup(chat->components, "name"));
-    gaim_debug_misc("roombrowse", "Room name: %s\n", room);
-    if (!room)
-        return;
-
-
-    label = g_strdup_printf("Lurk in %s", room);
-    GaimBlistNodeAction *act = gaim_blist_node_action_new(label,
-                                                          roombrowse_menu_cb,
-                                                          chat->account);
-
-    *menu = g_list_append(*menu, act);
-    // g_free(label);
-}
-static gboolean roombrowse_load(GaimPlugin * plugin)
-{
-    gaim_signal_connect(gaim_blist_get_handle(),
-                        "blist-node-extended-menu",
-                        plugin, GAIM_CALLBACK(roombrowse_menu_create),
-                        NULL);
-
-
-    gaim_debug_misc("roombrowse", "Callback registered!\n");
-    return TRUE;
-}

Copied: qrc/branches/buddy_icon_hack/gaym-extras/src/roombrowse.c (from rev 262, qrc/trunk/gaym-extras/src/roombrowse.c)

Deleted: qrc/branches/buddy_icon_hack/nsis/installer.nsi
===================================================================
--- qrc/trunk/nsis/installer.nsi	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/branches/buddy_icon_hack/nsis/installer.nsi	2005-07-31 19:07:03 UTC (rev 263)
@@ -1,346 +0,0 @@
-; NSIS Script for the Gaim-QRC Plugins
-; Uses NSIS v2.0
-
-Name "Gaim-QRC ${QRC_VERSION}"
-
-; Registry keys:
-!define QRC_REG_KEY        "SOFTWARE\gaim-qrc"
-!define QRC_UNINSTALL_KEY  "SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\gaim-qrc"
-!define QRC_UNINST_EXE     "gaim-qrc-uninst.exe"
-!define GAYM_DLL           "libgaym.dll"
-!define BOT_CHALLENGER_DLL "libbot-challenger.dll"
-!define GAYM_EXTRAS_DLL	   "libgaym-extras.dll"
-!define GAYM_PNG           "gaym.png"
-!define QRC_UNINSTALL_LNK  "Gaim-QRC Uninstall.lnk"
-!define	ALPHA_PNG	   "alpha.png"
-!define	ENTRY_PNG	   "entry.png"
-!define	PIC_PNG		    "pic.png"
-!include "MUI.nsh"
-
-;Do A CRC Check
-CRCCheck On
-
-;Output File Name
-OutFile "..\gaim-${GAIM_VERSION}-qrc-${QRC_VERSION}.exe"
-
-ShowInstDetails show
-ShowUnInstDetails show
-SetCompressor lzma
-
-; Translations
-!include "locale\english.nsh"
-
-; Gaim Plugin installer helper stuff
-
-!addincludedir "${GAIM_TOP}\src\win32\nsis"
-!include "${GAIM_TOP}\src\win32\nsis\gaim-plugin.nsh"
-
-; Modern UI Configuration
-!define MUI_HEADERIMAGE
-
-; Pages
-!define MUI_WELCOMEPAGE_TITLE $(WELCOME_TITLE)
-!define MUI_WELCOMEPAGE_TEXT $(WELCOME_TEXT)
-!insertmacro MUI_PAGE_WELCOME
-
-!insertmacro MUI_PAGE_LICENSE  "..\COPYING"
-
-!define MUI_DIRECTORYPAGE_TEXT_TOP $(DIR_SUBTITLE)
-!define MUI_DIRECTORYPAGE_TEXT_DESTINATION $(DIR_INNERTEXT)
-!insertmacro MUI_PAGE_DIRECTORY
-
-!define MUI_FINISHPAGE_NOAUTOCLOSE
-!insertmacro MUI_PAGE_INSTFILES
-
-!define MUI_FINISHPAGE_TITLE $(FINISH_TITLE)
-!define MUI_FINISHPAGE_TEXT $(FINISH_TEXT)
-!insertmacro MUI_PAGE_FINISH
-
-; MUI Config
-
-!define MUI_CUSTOMFUNCTION_GUIINIT qrc_checkGaimVersion
-!define MUI_ABORTWARNING
-!define MUI_UNINSTALLER
-!define MUI_PROGRESSBAR smooth
-!define MUI_INSTALLCOLORS /windows
-
-!insertmacro MUI_LANGUAGE "English"
-
-!define MUI_LICENSEPAGE_RADIOBUTTONS
-
-
-;The Default Installation Directory
-InstallDir "$PROGRAMFILES\gaim"
-InstallDirRegKey HKLM SOFTWARE\gaim ""
-
-Section -SecUninstallOldPlugin
-  ; Check install rights..
-  Call CheckUserInstallRights
-  Pop $R0
-
-  StrCmp $R0 "HKLM" rights_hklm
-  StrCmp $R0 "HKCU" rights_hkcu done
-
-  rights_hkcu:
-      ReadRegStr $R1 HKCU "${QRC_REG_KEY}" ""
-      ReadRegStr $R2 HKCU "${QRC_REG_KEY}" "Version"
-      ReadRegStr $R3 HKCU "${QRC_UNINSTALL_KEY}" "UninstallString"
-      Goto try_uninstall
-
-  rights_hklm:
-      ReadRegStr $R1 HKLM "${QRC_REG_KEY}" ""
-      ReadRegStr $R2 HKLM "${QRC_REG_KEY}" "Version"
-      ReadRegStr $R3 HKLM "${QRC_UNINSTALL_KEY}" "UninstallString"
-
-  ; If previous version exists .. remove
-  try_uninstall:
-    StrCmp $R1 "" done
-      StrCmp $R2 "" uninstall_problem
-        IfFileExists $R3 0 uninstall_problem
-          ; Have uninstall string.. go ahead and uninstall.
-          SetOverwrite on
-          ; Need to copy uninstaller outside of the install dir
-          ClearErrors
-          CopyFiles /SILENT $R3 "$TEMP\${QRC_UNINST_EXE}"
-          SetOverwrite off
-          IfErrors uninstall_problem
-            ; Ready to uninstall..
-            ClearErrors
-            ExecWait '"$TEMP\${QRC_UNINST_EXE}" /S _?=$R1'
-            IfErrors exec_error
-              Delete "$TEMP\${QRC_UNINST_EXE}"
-              Goto done
-
-            exec_error:
-              Delete "$TEMP\${QRC_UNINST_EXE}"
-              Goto uninstall_problem
-
-        uninstall_problem:
-            ; Just delete the plugin and uninstaller, and remove Registry key
-             MessageBox MB_YESNO $(QRC_PROMPT_WIPEOUT) IDYES do_wipeout IDNO cancel_install
-          cancel_install:
-            Quit
-
-          do_wipeout:
-            StrCmp $R0 "HKLM" del_lm_reg del_cu_reg
-            del_cu_reg:
-              DeleteRegKey HKCU ${QRC_REG_KEY}
-              Goto uninstall_prob_cont
-            del_lm_reg:
-              DeleteRegKey HKLM ${QRC_REG_KEY}
-
-            uninstall_prob_cont:
-              ; plugin DLL
-              Delete "$R1\plugins\${GAYM_DLL}"
-              Delete "$R1\plugins\${BOT_CHALLENGER_DLL}"
-              Delete "$R1\plugins\${GAYM_EXTRAS_DLL}"
-              ; pixmaps
-	      Delete "$R1\pixmaps\${ALPHA_PNG}"
-	      Delete "$R1\pixmaps\${ENTRY_PNG}"
-	      Delete "$R1\pixmaps\${PIC_PNG}"
-              Delete "$R1\pixmaps\gaim\status\default\${GAYM_PNG}"
-              Delete "$R3"
-
-  done:
-
-SectionEnd
-
-
-Section "Install"
-  Call CheckUserInstallRights
-  Pop $R0
-
-  StrCmp $R0 "NONE" instrights_none
-  StrCmp $R0 "HKLM" instrights_hklm instrights_hkcu
-
-  instrights_hklm:
-    ; Write the version registry keys:
-    WriteRegStr HKLM ${QRC_REG_KEY} "" "$INSTDIR"
-    WriteRegStr HKLM ${QRC_REG_KEY} "Version" "${QRC_VERSION}"
-
-    ; Write the uninstall keys for Windows
-    WriteRegStr HKLM ${QRC_UNINSTALL_KEY} "DisplayName" "$(QRC_UNINSTALL_DESC)"
-    WriteRegStr HKLM ${QRC_UNINSTALL_KEY} "UninstallString" "$INSTDIR\${QRC_UNINST_EXE}"
-    SetShellVarContext "all"
-    Goto install_files
-
-  instrights_hkcu:
-    ; Write the version registry keys:
-    WriteRegStr HKCU ${QRC_REG_KEY} "" "$INSTDIR"
-    WriteRegStr HKCU ${QRC_REG_KEY} "Version" "${QRC_VERSION}"
-
-    ; Write the uninstall keys for Windows
-    WriteRegStr HKCU ${QRC_UNINSTALL_KEY} "DisplayName" "$(QRC_UNINSTALL_DESC)"
-    WriteRegStr HKCU ${QRC_UNINSTALL_KEY} "UninstallString" "$INSTDIR\${QRC_UNINST_EXE}"
-    Goto install_files
-  
-  instrights_none:
-    ; No registry keys for us...
-    
-  install_files:
-    SetOutPath "$INSTDIR\plugins"
-    SetCompress Auto
-    SetOverwrite on
-    File "..\gaym\src\.libs\${GAYM_DLL}"
-    File "..\gaym-extras\src\.libs\${GAYM_EXTRAS_DLL}"
-    File "..\bot-challenger\.libs\${BOT_CHALLENGER_DLL}"
-    
-    SetOutPath "$INSTDIR\pixmaps\gaim\status\default"
-    File "..\gaym\pixmaps\${GAYM_PNG}"
-    	
-    SetOutPath "$INSTDIR\pixmaps"
-    File "..\gaym-extras\pixmaps\${ALPHA_PNG}"
-    File "..\gaym-extras\pixmaps\${ENTRY_PNG}"
-    File "..\gaym-extras\pixmaps\${PIC_PNG}"
-    StrCmp $R0 "NONE" done
-    CreateShortCut "$SMPROGRAMS\Gaim\${QRC_UNINSTALL_LNK}" "$INSTDIR\${QRC_UNINST_EXE}"
-    WriteUninstaller "$INSTDIR\${QRC_UNINST_EXE}"
-    SetOverWrite off
-
-  done:
-SectionEnd
-
-Section Uninstall
-  Call un.CheckUserInstallRights
-  Pop $R0
-  StrCmp $R0 "NONE" no_rights
-  StrCmp $R0 "HKCU" try_hkcu try_hklm
-
-  try_hkcu:
-    ReadRegStr $R0 HKCU "${QRC_REG_KEY}" ""
-    StrCmp $R0 $INSTDIR 0 cant_uninstall
-      ; HKCU install path matches our INSTDIR.. so uninstall
-      DeleteRegKey HKCU "${QRC_REG_KEY}"
-      DeleteRegKey HKCU "${QRC_UNINSTALL_KEY}"
-      Goto cont_uninstall
-
-  try_hklm:
-    ReadRegStr $R0 HKLM "${QRC_REG_KEY}" ""
-    StrCmp $R0 $INSTDIR 0 try_hkcu
-      ; HKLM install path matches our INSTDIR.. so uninstall
-      DeleteRegKey HKLM "${QRC_REG_KEY}"
-      DeleteRegKey HKLM "${QRC_UNINSTALL_KEY}"
-      ; Sets start menu and desktop scope to all users..
-      SetShellVarContext "all"
-
-  cont_uninstall:
-    ; plugin 
-    Delete "$INSTDIR\plugins\${GAYM_DLL}"
-    Delete "$INSTDIR\plugins\${BOT_CHALLENGER_DLL}"
-    ; pixmaps
-    Delete "$INSTDIR\pixmaps\gaim\status\default\${GAYM_PNG}"
-    Delete "$INSTDIR\pixmaps\${ALPHA_PNG}"
-    Delete "$INSTDIR\pixmaps\${ENTRY_PNG}"
-    Delete "$INSTDIR\pixmaps\${PIC_PNG}"
-    ; uninstaller
-    Delete "$INSTDIR\${QRC_UNINST_EXE}"
-    ; uninstaller shortcut
-    Delete "$SMPROGRAMS\Gaim\${QRC_UNINSTALL_LNK}"
-    
-    ; try to delete the Gaim directories, in case it has already uninstalled
-    RMDir "$INSTDIR\plugins"
-    RMDir "$INSTDIR"
-    RMDir "$SMPROGRAMS\Gaim"
-
-    Goto done
-
-  cant_uninstall:
-    MessageBox MB_OK $(un.QRC_UNINSTALL_ERROR_1) IDOK
-    Quit
-
-  no_rights:
-    MessageBox MB_OK $(un.QRC_UNINSTALL_ERROR_2) IDOK
-    Quit
-
-  done:
-SectionEnd
-
-Function .onVerifyInstDir
-  IfFileExists $INSTDIR\gaim.exe Good1
-    Abort
-  Good1:
-FunctionEnd
-
-Function qrc_checkGaimVersion
-  Push $R0
-
-  Push ${GAIM_VERSION}
-  Call CheckGaimVersion
-  Pop $R0
-
-  StrCmp $R0 ${GAIM_VERSION_OK} qrc_checkGaimVersion_OK
-  StrCmp $R0 ${GAIM_VERSION_INCOMPATIBLE} +1 +6
-    Call GetGaimVersion
-    IfErrors +3
-    Pop $R0
-    MessageBox MB_OK|MB_ICONSTOP "$(BAD_GAIM_VERSION_1) $R0 $(BAD_GAIM_VERSION_2)"
-    goto +2
-    MessageBox MB_OK|MB_ICONSTOP "$(NO_GAIM_VERSION)"
-    Quit
-
-  qrc_checkGaimVersion_OK:
-  Pop $R0
-FunctionEnd
-
-Function CheckUserInstallRights
-        ClearErrors
-        UserInfo::GetName
-        IfErrors Win9x
-        Pop $0
-        UserInfo::GetAccountType
-        Pop $1
-
-        StrCmp $1 "Admin" 0 +3
-                StrCpy $1 "HKLM"
-                Goto done
-        StrCmp $1 "Power" 0 +3
-                StrCpy $1 "HKLM"
-                Goto done
-        StrCmp $1 "User" 0 +3
-                StrCpy $1 "HKCU"
-                Goto done
-        StrCmp $1 "Guest" 0 +3
-                StrCpy $1 "NONE"
-                Goto done
-        ; Unknown error
-        StrCpy $1 "NONE"
-        Goto done
-
-        Win9x:
-                StrCpy $1 "HKLM"
-
-        done:
-        Push $1
-FunctionEnd
-
-Function un.CheckUserInstallRights
-        ClearErrors
-        UserInfo::GetName
-        IfErrors Win9x
-        Pop $0
-        UserInfo::GetAccountType
-        Pop $1
-        StrCmp $1 "Admin" 0 +3
-                StrCpy $1 "HKLM"
-                Goto done
-        StrCmp $1 "Power" 0 +3
-                StrCpy $1 "HKLM"
-                Goto done
-        StrCmp $1 "User" 0 +3
-                StrCpy $1 "HKCU"
-                Goto done
-        StrCmp $1 "Guest" 0 +3
-                StrCpy $1 "NONE"
-                Goto done
-        ; Unknown error
-        StrCpy $1 "NONE"
-        Goto done
-
-        Win9x:
-                StrCpy $1 "HKLM"
-
-        done:
-        Push $1
-FunctionEnd
-
-

Copied: qrc/branches/buddy_icon_hack/nsis/installer.nsi (from rev 260, qrc/trunk/nsis/installer.nsi)



From jblebrun at berlios.de  Sun Jul 31 21:13:30 2005
From: jblebrun at berlios.de (Jason LeBrun at BerliOS)
Date: Sun, 31 Jul 2005 21:13:30 +0200
Subject: [Qrc-svn] r264 - in qrc/tags: . release-0.9/gaym/src release-0.9/gaym-extras/src release-0.9/nsis
Message-ID: <200507311913.j6VJDUqB023067@sheep.berlios.de>

Author: jblebrun
Date: 2005-07-31 21:13:29 +0200 (Sun, 31 Jul 2005)
New Revision: 264

Added:
   qrc/tags/release-0.9/
   qrc/tags/release-0.9/gaym-extras/src/bio-popups.c
   qrc/tags/release-0.9/gaym-extras/src/gaym-extras.c
   qrc/tags/release-0.9/gaym-extras/src/roombrowse.c
   qrc/tags/release-0.9/gaym/src/gaym.c
   qrc/tags/release-0.9/gaym/src/gaym.h
   qrc/tags/release-0.9/gaym/src/gayminfo.c
   qrc/tags/release-0.9/gaym/src/gayminfo.h
   qrc/tags/release-0.9/gaym/src/helpers.c
   qrc/tags/release-0.9/gaym/src/msgs.c
   qrc/tags/release-0.9/nsis/installer.nsi
Removed:
   qrc/tags/release-0.9/gaym-extras/src/bio-popups.c
   qrc/tags/release-0.9/gaym-extras/src/gaym-extras.c
   qrc/tags/release-0.9/gaym-extras/src/roombrowse.c
   qrc/tags/release-0.9/gaym/src/gaym.c
   qrc/tags/release-0.9/gaym/src/gaym.h
   qrc/tags/release-0.9/gaym/src/gayminfo.c
   qrc/tags/release-0.9/gaym/src/gayminfo.h
   qrc/tags/release-0.9/gaym/src/helpers.c
   qrc/tags/release-0.9/gaym/src/msgs.c
   qrc/tags/release-0.9/nsis/installer.nsi
Log:
This revision seems stable. Please test the hell out of it.



Copied: qrc/tags/release-0.9 (from rev 259, qrc/trunk)

Deleted: qrc/tags/release-0.9/gaym/src/gaym.c
===================================================================
--- qrc/trunk/gaym/src/gaym.c	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/tags/release-0.9/gaym/src/gaym.c	2005-07-31 19:13:29 UTC (rev 264)
@@ -1,1632 +0,0 @@
-/**
- * @file gaym.c
- *
- * gaim
- *
- * Copyright (C) 2003, Robbert Haarman <gaim at inglorion.net>
- * Copyright (C) 2003, Ethan Blanton <eblanton at cs.purdue.edu>
- * Copyright (C) 2000-2003, Rob Flynn <rob at tgflinux.com>
- * Copyright (C) 1998-1999, Mark Spencer <markster at marko.net>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "internal.h"
-#include "accountopt.h"
-#include "blist.h"
-#include "conversation.h"
-#include "debug.h"
-#include "notify.h"
-#include "prpl.h"
-#include "plugin.h"
-#include "util.h"
-#include "version.h"
-#include "request.h"
-#include "privacy.h"
-#include "signals.h"
-
-#include "helpers.h"
-#include "gayminfo.h"
-#include "gaympriv.h"
-#include "botfilter.h"
-#include "gaym.h"
-
-static const char *gaym_blist_icon(GaimAccount * a, GaimBuddy * b);
-static void gaym_blist_emblems(GaimBuddy * b, char **se, char **sw,
-                               char **nw, char **ne);
-static GList *gaym_away_states(GaimConnection * gc);
-static GList *gaym_actions(GaimPlugin * plugin, gpointer context);
-/* static GList *gaym_chat_info(GaimConnection *gc); */
-static void gaym_login(GaimAccount * account);
-static void gaym_login_cb(gpointer data, gint source,
-                          GaimInputCondition cond);
-static void gaym_close(GaimConnection * gc);
-static int gaym_im_send(GaimConnection * gc, const char *who,
-                        const char *what, GaimConvImFlags flags);
-static int gaym_chat_send(GaimConnection * gc, int id, const char *what);
-static void gaym_chat_join(GaimConnection * gc, GHashTable * data);
-static void gaym_input_cb(gpointer data, gint source,
-                          GaimInputCondition cond);
-
-static guint gaym_nick_hash(const char *nick);
-static gboolean gaym_nick_equal(const char *nick1, const char *nick2);
-static void gaym_buddy_free(struct gaym_buddy *ib);
-static void gaym_channel_member_free(GaymBuddy * cm);
-
-static void gaym_buddy_append(char *name, struct gaym_buddy *ib,
-                              BListWhois * blist_whois);
-static void gaym_buddy_clear_done(char *name, struct gaym_buddy *ib,
-                                  gpointer nothing);
-
-static GaimPlugin *_gaym_plugin = NULL;
-
-static const char *status_chars = "@+%&";
-
-int gaym_send(struct gaym_conn *gaym, const char *buf)
-{
-    int ret;
-
-    if (gaym->fd < 0)
-        return -1;
-
-    /* gaim_debug(GAIM_DEBUG_MISC, "gaym", "sent: %s", buf); */
-    if ((ret = write(gaym->fd, buf, strlen(buf))) < 0)
-        gaim_connection_error(gaim_account_get_connection(gaym->account),
-                              _("Server has disconnected"));
-
-    return ret;
-}
-
-gboolean gaym_blist_timeout(struct gaym_conn * gaym)
-{
-    /**
-     * There are 510 characters available for an IRC command (512 if
-     * you count CR-LF).  "WHOIS " takes up 6 characters.  Assuming
-     * you need allow an extra character for the NULL when using
-     * g_string_sized_new(), we need to allocate (510-6)+1=505 here.
-     */
-    BListWhois *blist_whois = g_new0(BListWhois, 1);
-    blist_whois->count = 0;
-    blist_whois->string = g_string_sized_new(505);
-
-    char *list, *buf;
-
-    g_hash_table_foreach(gaym->buddies, (GHFunc) gaym_buddy_append,
-                         (gpointer) blist_whois);
-
-    list = g_string_free(blist_whois->string, FALSE);
-    if (!list || !strlen(list)) {
-        g_hash_table_foreach(gaym->buddies, (GHFunc) gaym_buddy_clear_done,
-                             NULL);
-        gaim_timeout_remove(gaym->timer);
-        gaym->timer =
-            gaim_timeout_add(BLIST_UPDATE_PERIOD,
-                             (GSourceFunc) gaym_blist_timeout,
-                             (gpointer) gaym);
-        g_free(list);
-        g_free(blist_whois);
-
-        return TRUE;
-    }
-    gaym->blist_updating = TRUE;
-    buf = gaym_format(gaym, "vn", "WHOIS", list);
-    gaym_send(gaym, buf);
-    gaim_timeout_remove(gaym->timer);
-    gaym->timer =
-        gaim_timeout_add(BLIST_CHUNK_INTERVAL,
-                         (GSourceFunc) gaym_blist_timeout,
-                         (gpointer) gaym);
-
-    g_free(buf);
-    g_free(list);
-    g_free(blist_whois);
-
-    return TRUE;
-}
-
-static void gaym_buddy_clear_done(char *name, struct gaym_buddy *ib,
-                                  gpointer nothing)
-{
-    ib->done = FALSE;
-}
-
-static void gaym_buddy_append(char *name, struct gaym_buddy *ib,
-                              BListWhois * blist_whois)
-{
-    char *converted_name = NULL;
-    converted_name = gaym_nick_to_gcom_strdup(name);
-
-    /**
-     * There are 510 characters available for an IRC command (512 if
-     * you count CR-LF).  "WHOIS " takes up 6 characters.  This means
-     * we have up to 504 characters available for comma separated
-     * converted_names
-     */
-    if (ib->done == FALSE && blist_whois->count < 10
-        && (strlen(converted_name) + blist_whois->string->len + 1) <=
-        504) {
-        blist_whois->count++;
-        ib->done = TRUE;
-        if (blist_whois->string->len == 0) {
-            g_string_append_printf(blist_whois->string, "%s",
-                                   converted_name);
-        } else {
-            g_string_append_printf(blist_whois->string, ",%s",
-                                   converted_name);
-        }
-    }
-
-    g_free(converted_name);
-    return;
-}
-
-static void gaym_whois_one(struct gaym_conn *gaym, struct gaym_buddy *ib)
-{
-    char *buf;
-    char *nick;
-    nick = gaym_nick_to_gcom_strdup(ib->name);
-    buf = gaym_format(gaym, "vn", "WHOIS", nick);
-    gaym_send(gaym, buf);
-    g_free(nick);
-    g_free(buf);
-}
-
-static const char *gaym_blist_icon(GaimAccount * a, GaimBuddy * b)
-{
-    return "gaym";
-}
-
-static void gaym_blist_emblems(GaimBuddy * b, char **se, char **sw,
-                               char **nw, char **ne)
-{
-    if (b->present == GAIM_BUDDY_OFFLINE)
-        *se = "offline";
-}
-
-static char *gaym_status_text(GaimBuddy * buddy)
-{
-    char *status;
-
-    struct gaym_conn *gaym =
-        (struct gaym_conn *) buddy->account->gc->proto_data;
-
-    if (!gaym) {
-        return g_strdup(_("Offline"));
-    }
-
-    struct gaym_buddy *ib =
-        g_hash_table_lookup(gaym->buddies, buddy->name);
-
-    if (!ib) {
-        return g_strdup(_("Offline"));
-    }
-
-    if (!ib->online) {
-        return g_strdup(_("Offline"));
-    }
-
-    if (!ib->bio) {
-        return NULL;
-    }
-
-    status = g_markup_escape_text(ib->bio, strlen(ib->bio));
-
-    return status;
-}
-
-static char *gaym_tooltip_text(GaimBuddy * buddy)
-{
-    struct gaym_conn *gaym =
-        (struct gaym_conn *) buddy->account->gc->proto_data;
-
-    if (!gaym) {
-        return NULL;
-    }
-
-    struct gaym_buddy *ib =
-        g_hash_table_lookup(gaym->channel_members, buddy->name);
-
-    if (!ib)
-        ib = g_hash_table_lookup(gaym->buddies, buddy->name);
-
-    if (!ib) {
-        return NULL;
-    }
-
-    return build_tooltip_text(ib);
-}
-
-static GList *gaym_away_states(GaimConnection * gc)
-{
-    return g_list_prepend(NULL, (gpointer) GAIM_AWAY_CUSTOM);
-}
-
-static void gaym_set_info(GaimConnection * gc, const char *info)
-{
-    struct gaym_conn *gaym = gc->proto_data;
-    GaimAccount *account = gaim_connection_get_account(gc);
-    char *hostname = "none";
-    char *buf, *bioline;
-    int i = 0;
-
-    char *tmpinfo = NULL;
-    if (info) {
-        tmpinfo = g_strdup(info);
-        for (i = 0; i < strlen(tmpinfo); i++) {
-            if (tmpinfo[i] == '\n') {
-                tmpinfo[i] = ' ';
-            }
-        }
-        tmpinfo = g_strstrip(tmpinfo);
-    }
-
-    if (gc->away && !tmpinfo) {
-        /**
-         * don't change any bio settings, since this is just
-         * setting an away message
-         */
-    } else {
-        if (gaym->bio) {
-            g_free(gaym->bio);
-        }
-        if (tmpinfo && strlen(tmpinfo) > 0) {
-            gaim_debug_misc("gaym", "option1, info=%x\n", tmpinfo);
-            /* java client allows MAX_BIO_LEN characters */
-            gaym->bio = g_strndup(tmpinfo, MAX_BIO_LEN);
-        } else if (gaym->server_bioline
-                   && strlen(gaym->server_bioline) > 0) {
-            gaim_debug_misc("gaym", "option2\n");
-            gaym->bio = gaym_bio_strdup(gaym->server_bioline);
-        } else {
-            gaim_debug_misc("gaym", "option3\n");
-            gaym->bio = g_strdup("Gaim User");
-        }
-        gaim_account_set_user_info(account, gaym->bio);
-        gaim_account_set_string(account, "bioline", gaym->bio);
-        gaim_debug_info("gaym", "INFO=%x BIO=%x\n", tmpinfo, gaym->bio);
-        gaim_debug_misc("gaym", "In login_cb, gc->account=%x\n",
-                        gc->account);
-    }
-
-    bioline =
-        g_strdup_printf("%s#%s\001%s",
-                        gaym->thumbnail ? gaym->thumbnail : "",
-                        gc->away ? gc->away : (gaym->bio ? gaym->bio : ""),
-                        gaym->server_stats ? gaym->server_stats : "");
-
-    buf = gaym_format(gaym, "vvvv:", "USER",
-                      gaim_account_get_username(account),
-                      hostname, gaym->server, bioline);
-
-    gaim_debug_misc("gaym", "BIO=%x\n", bioline);
-
-    if (gaym_send(gaym, buf) < 0) {
-        gaim_connection_error(gc, "Error registering with server");
-    }
-
-    if (tmpinfo) {
-        g_free(tmpinfo);
-    }
-    g_free(bioline);
-    g_free(buf);
-
-    return;
-}
-
-static void gaym_show_set_info(GaimPluginAction * action)
-{
-    GaimConnection *gc = (GaimConnection *) action->context;
-    gaim_account_request_change_user_info(gaim_connection_get_account(gc));
-}
-
-static GList *gaym_actions(GaimPlugin * plugin, gpointer context)
-{
-    GList *list = NULL;
-    GaimPluginAction *act = NULL;
-
-    act = gaim_plugin_action_new(_("Change Bio"), gaym_show_set_info);
-    list = g_list_prepend(list, act);
-
-    return list;
-}
-
-static void gaym_blist_join_chat_cb(GaimBlistNode * node, gpointer data)
-{
-    const char *args[1];
-
-    GaimChat *chat = (GaimChat *) node;
-    struct gaym_conn *gaym = chat->account->gc->proto_data;
-    args[0] = data;
-
-    g_return_if_fail(args[0] != NULL);
-    g_return_if_fail(gaym != NULL);
-
-    gaym_cmd_join(gaym, "join", NULL, args);
-}
-
-static GList *gaym_blist_node_menu(GaimBlistNode * node)
-{
-    GList *m = NULL;
-    GaimBlistNodeAction *act = NULL;
-    int i = 0;
-
-    if (node->type != GAIM_BLIST_CHAT_NODE) {
-        return m;
-    }
-
-    GaimChat *chat = (GaimChat *) node;
-    char *channel = g_hash_table_lookup(chat->components, "channel");
-
-    if (!channel) {
-        return m;
-    }
-
-    if (!g_str_has_suffix(channel, "=*")) {
-        return m;
-    }
-
-    char *label = NULL;
-    char *instance = NULL;
-
-    int max = gaim_prefs_get_int("/plugins/prpl/gaym/chat_room_instances");
-
-    for (i = max; i > 0; i--) {
-        label = g_strdup_printf(_("Join Room %d"), i);
-        instance =
-            g_strdup_printf("%.*s%d", strlen(channel) - 1, channel, i);
-        act =
-            gaim_blist_node_action_new(label, gaym_blist_join_chat_cb,
-                                       instance);
-        m = g_list_prepend(m, act);
-    }
-    return m;
-}
-
-static GList *gaym_chat_join_info(GaimConnection * gc)
-{
-    GList *m = NULL;
-    struct proto_chat_entry *pce;
-
-    pce = g_new0(struct proto_chat_entry, 1);
-    pce->label = _("_Room:");
-    pce->identifier = "channel";
-    m = g_list_prepend(m, pce);
-
-    return m;
-}
-
-GHashTable *gaym_chat_info_defaults(GaimConnection * gc,
-                                    const char *chat_name)
-{
-    GHashTable *defaults;
-
-    defaults =
-        g_hash_table_new_full(g_str_hash, g_str_equal, NULL, g_free);
-
-    if (chat_name != NULL)
-        g_hash_table_insert(defaults, "channel", g_strdup(chat_name));
-
-    return defaults;
-}
-
-static void gaym_login_with_chat_key(GaimAccount * account)
-{
-    GaimConnection *gc;
-    struct gaym_conn *gaym;
-    char *buf;
-    const char *username = gaim_account_get_username(account);
-    int err;
-
-    gc = gaim_account_get_connection(account);
-    gaym = gc->proto_data;
-
-    buf = g_strdup_printf(_("Signon: %s"), username);
-    gaim_connection_update_progress(gc, buf, 5, 6);
-    g_free(buf);
-    gaim_debug_misc("gaym", "Trying login to %s\n", gaym->server);
-    err = gaim_proxy_connect(account, gaym->server,
-                             gaim_account_get_int(account, "port",
-                                                  IRC_DEFAULT_PORT),
-                             gaym_login_cb, gc);
-    if (err || !account->gc) {
-        gaim_connection_error(gc, _("Couldn't create socket"));
-        gaim_debug_misc("gaym", "err: %d, account->gc: %x\n", err,
-                        account->gc);
-        return;
-    }
-
-}
-
-static void gaym_login(GaimAccount * account)
-{
-    GaimConnection *gc;
-    struct gaym_conn *gaym;
-    char *buf;
-    const char *username = gaim_account_get_username(account);
-
-    gc = gaim_account_get_connection(account);
-    gc->flags |= GAIM_CONNECTION_NO_NEWLINES | GAIM_CONNECTION_AUTO_RESP;
-
-    if (strpbrk(username, " \t\v\r\n") != NULL) {
-        gaim_connection_error(gc,
-                              _("IRC nicks may not contain whitespace"));
-        return;
-    }
-
-    gc->proto_data = gaym = g_new0(struct gaym_conn, 1);
-    gaym->account = account;
-
-
-    /**
-     * gaim_connection_set_display_name(gc, userparts[0]);
-     */
-    gaim_connection_set_display_name(gc, username);
-    gaym->server =
-        g_strdup(gaim_account_get_string
-                 (account, "server", "www.gay.com"));
-    /**
-     * gaym->server = "www.gay.com";
-     */
-    gaym->buddies =
-        g_hash_table_new_full((GHashFunc) gaym_nick_hash,
-                              (GEqualFunc) gaym_nick_equal, NULL,
-                              (GDestroyNotify) gaym_buddy_free);
-
-    gaym->channel_members =
-        g_hash_table_new_full((GHashFunc) gaym_nick_hash,
-                              (GEqualFunc) gaym_nick_equal, NULL,
-                              (GDestroyNotify) gaym_channel_member_free);
-
-    gaym->cmds = g_hash_table_new(g_str_hash, g_str_equal);
-    gaym_cmd_table_build(gaym);
-    gaym->msgs = g_hash_table_new(g_str_hash, g_str_equal);
-    gaym_msg_table_build(gaym);
-    gaym->roomlist_filter = NULL;
-    /**
-     * The last parameter needs to be NULL here, since the same
-     * field is added for both the key and the value (and if we
-     * free it twice, thats bad and causes crashing!).
-     */
-    gaym->info_window_needed =
-        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
-
-    gaym->entry_order =
-        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
-
-    /**
-     * This is similar to gaym->info_window_needed, except this is
-     * for thumbails inside the IM conversation window if the
-     * person is not already on the buddy list
-     */
-
-    buf = g_strdup_printf(_("Signon: %s"), username);
-    gaim_connection_update_progress(gc, buf, 1, 6);
-    g_free(buf);
-
-
-    /**
-     * Making a change to try cached password first.
-     * gaym_try_cached_password(account, gaym_login_with_chat_key);
-     */
-    gaym_get_chat_key_from_weblogin(account, gaym_login_with_chat_key);
-}
-
-
-static void gaym_get_configtxt_cb(gpointer proto_data,
-                                  const gchar * config_text, size_t len)
-{
-    struct gaym_conn *gaym = (struct gaym_conn *) proto_data;
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-
-    g_return_if_fail(config_text != NULL);
-
-    gaym->confighash = gaym_properties_new(config_text);
-    g_return_if_fail(gaym->confighash != NULL);
-
-    // synchronize_deny_list(gc, gaym->confighash);
-
-    return;
-}
-static void gaym_login_cb(gpointer data, gint source,
-                          GaimInputCondition cond)
-{
-    GaimConnection *gc = data;
-    struct gaym_conn *gaym = gc->proto_data;
-    char hostname[256];
-    char *buf;
-    const char *username;
-    const char *user_bioline = NULL;
-    char *bioline;
-    char *login_name;
-
-    if (GAIM_CONNECTION_IS_VALID(gc)) {
-
-
-        GList *connections = gaim_connections_get_all();
-
-        if (source < 0) {
-            gaim_connection_error(gc, _("Couldn't connect to host"));
-            return;
-        }
-
-        if (!g_list_find(connections, gc)) {
-            close(source);
-            return;
-        }
-
-        gaym->fd = source;
-        gaim_debug_misc("gaym", "In login_cb with chat_key=%s\n",
-                        gaym->chat_key);
-        if (gaym->chat_key) {
-
-            buf = gaym_format(gaym, "vv", "PASS", gaym->chat_key);
-            if (gaym_send(gaym, buf) < 0) {
-                gaim_connection_error(gc, "Error sending password");
-                return;
-            }
-            g_free(buf);
-        } else {
-            gaim_connection_error(gc,
-                                  _
-                                  ("Password wasn't recorded. Report bug."));
-            return;
-        }
-        gethostname(hostname, sizeof(hostname));
-        hostname[sizeof(hostname) - 1] = '\0';
-        username = gaim_account_get_string(gaym->account, "username", "");
-        user_bioline =
-            g_strdup(gaim_account_get_string
-                     (gaym->account, "bioline", ""));
-        gaim_debug_info("gaym", "USER BIOLINE=%x\n", user_bioline);
-        gaim_account_set_user_info(gc->account, user_bioline);
-        gaim_debug_misc("gaym",
-                        "In login_cb, user_bioline: %x, gc->account=%x\n",
-                        user_bioline, gc->account);
-
-        login_name =
-            gaym_nick_to_gcom_strdup(gaim_connection_get_display_name(gc));
-        bioline = g_strdup_printf("%s#%s\001%s",
-                                  gaym->thumbnail,
-                                  user_bioline ? user_bioline : "",
-                                  gaym->server_stats ? gaym->
-                                  server_stats : "");
-
-        buf = gaym_format(gaym, "vn", "NICK", login_name);
-        gaim_debug_misc("gaym", "Command: %s\n", buf);
-
-        if (gaym_send(gaym, buf) < 0) {
-            gaim_connection_error(gc, "Error sending nickname");
-            return;
-        }
-        g_free(buf);
-        buf =
-            gaym_format(gaym, "vvvv:", "USER", login_name, hostname,
-                        gaym->server, bioline);
-
-        gaim_debug_misc("gaym", "Command: %s\n", buf);
-        if (gaym_send(gaym, buf) < 0) {
-            gaim_connection_error(gc, "Error registering with server");
-            return;
-        }
-        g_free(login_name);
-        g_free(buf);
-
-        const char *server = gaim_account_get_string(gc->account, "server",
-                                                     IRC_DEFAULT_SERVER);
-        char *url =
-            g_strdup_printf
-            ("http://%s/messenger/config.txt?%s", server, gaym->chat_key);
-
-        char *user_agent = "Mozilla/4.0";
-
-        get_spamlist_from_web();
-        gaim_url_fetch(url, FALSE, user_agent, FALSE,
-                       gaym_get_configtxt_cb, gaym);
-
-        g_free(url);
-        gc->inpa =
-            gaim_input_add(gaym->fd, GAIM_INPUT_READ, gaym_input_cb, gc);
-
-
-    }
-}
-static void gaym_close(GaimConnection * gc)
-{
-    struct gaym_conn *gaym = gc->proto_data;
-
-    gaim_debug_misc("gaym", "gaym close function has been called\n");
-    if (gaym == NULL)
-        return;
-
-    gaym_cmd_quit(gaym, "quit", NULL, NULL);
-
-    if (gc->inpa)
-        gaim_input_remove(gc->inpa);
-
-    g_free(gaym->inbuf);
-    gaim_debug_misc("gaym", "closing fd %i\n", gaym->fd);
-    close(gaym->fd);
-
-    if (gaym->timer)
-        gaim_timeout_remove(gaym->timer);
-
-    if (gaym->thumbnail)
-        g_free(gaym->thumbnail);
-
-    if (gaym->chat_key)
-        g_free(gaym->chat_key);
-
-    if (gaym->server_bioline)
-        g_free(gaym->server_bioline);
-
-    if (gaym->server_stats)
-        g_free(gaym->server_stats);
-
-    if (gaym->roomlist_filter)
-        g_free(gaym->roomlist_filter);
-
-    if (gaym->bio)
-        g_free(gaym->bio);
-
-    g_hash_table_destroy(gaym->cmds);
-    g_hash_table_destroy(gaym->msgs);
-    g_hash_table_destroy(gaym->info_window_needed);
-    g_hash_table_destroy(gaym->entry_order);
-    if (gaym->motd)
-        g_string_free(gaym->motd, TRUE);
-
-    if (gaym->names)
-        g_string_free(gaym->names, TRUE);
-
-    if (gaym->nameconv)
-        g_free(gaym->nameconv);
-    if (gaym->subroom)
-        g_free(gaym->subroom);
-
-    g_hash_table_destroy(gaym->confighash);
-
-    if (gaym->hammer_cancel_dialog)
-        gaim_request_close(GAIM_REQUEST_ACTION,
-                           gaym->hammer_cancel_dialog);
-
-    g_free(gaym->server);
-    g_free(gaym);
-}
-
-static int gaym_im_send(GaimConnection * gc, const char *who,
-                        const char *what, GaimConvImFlags flags)
-{
-    struct gaym_conn *gaym = gc->proto_data;
-    const char *args[2];
-    char *automsg = NULL;
-    char *stripped_msg = NULL;
-    if (strchr(status_chars, *who) != NULL) {
-        args[0] = who + 1;
-    } else {
-        args[0] = who;
-    }
-    if (flags & GAIM_CONV_IM_AUTO_RESP) {
-        stripped_msg = gaim_markup_strip_html(what);
-        automsg = g_strdup_printf("<AUTO-REPLY> %s", stripped_msg);
-        g_free(stripped_msg);
-        args[1] = automsg;
-
-    } else {
-        args[1] = what;
-    }
-    gaym_cmd_privmsg(gaym, "msg", NULL, args);
-    if (automsg) {
-        g_free(automsg);
-    }
-    return 1;
-}
-
-static void gaym_get_info(GaimConnection * gc, const char *who)
-{
-    struct gaym_conn *gaym = gc->proto_data;
-    const char *args[1];
-    args[0] = who;
-
-    char *normalized = g_strdup(gaim_normalize(gc->account, who));
-    /**
-     * We are adding the same char* to both the key and the value.
-     * If this changes, we need to change the corresponding
-     * g_hash_table_new_full() so that things are properly cleaned
-     * up during the remove/destroy phase.
-     */
-    g_hash_table_insert(gaym->info_window_needed, normalized, normalized);
-    gaym_cmd_whois(gaym, "whois", NULL, args);
-}
-
-static void gaym_set_away(GaimConnection * gc, const char *state,
-                          const char *msg)
-{
-    char *bio = NULL;
-    char *tmpmsg = NULL;
-    int i = 0;
-    struct gaym_conn *gaym = gc->proto_data;
-
-    if (gc->away) {
-        g_free(gc->away);
-        gc->away = NULL;
-    }
-
-    /**
-     * In addition to setting the away message, set the Bio to the
-     * away message; if the away message is NULL, then set the Bio
-     * to the original bio.
-     */
-
-    if (msg) {
-        tmpmsg = g_strdup(msg);
-        for (i = 0; i < strlen(tmpmsg); i++) {
-            if (tmpmsg[i] == '\n') {
-                tmpmsg[i] = ' ';
-            }
-        }
-        tmpmsg = g_strstrip(tmpmsg);
-
-        gc->away = g_strndup(tmpmsg, MAX_BIO_LEN);
-        gaym_set_info(gc, NULL);
-        g_free(tmpmsg);
-    } else {
-        if (gaym && gaym->bio) {
-            bio = g_strdup(gaym->bio);
-            gaym_set_info(gc, bio);
-            g_free(bio);
-        } else {
-            gaym_set_info(gc, NULL);
-        }
-    }
-
-    /**
-     *  The following would be great, and gay.com's server supports
-     *  it, but gay.com's clients don't see the result.  So even though
-     *  we can see the result, we won't bother.
-     *
-     * args[0] = msg;
-     * gaym_cmd_away(gaym, "away", NULL, args);
-     */
-}
-
-GaymBuddy *gaym_get_channel_member_reference(struct gaym_conn
-                                             *gaym, const gchar * name)
-{
-
-    GaymBuddy *channel_member =
-        (GaymBuddy *) g_hash_table_lookup(gaym->channel_members,
-                                          name);
-
-    if (!channel_member) {
-        GaymBuddy *channel_member = g_new0(GaymBuddy, 1);
-        channel_member->ref_count = 1;
-        g_hash_table_insert(gaym->channel_members, g_strdup(name),
-                            channel_member);
-        gaim_debug_misc("gaym", "Creating channel_members entry for %s\n",
-                        name);
-        return g_hash_table_lookup(gaym->channel_members, name);
-    } else {
-        gaim_debug_misc("gaym",
-                        "Adding reference to channel_members entry for %s\n",
-                        name);
-        (channel_member->ref_count)++;
-        return channel_member;
-    }
-
-}
-
-gboolean gaym_unreference_channel_member(struct gaym_conn * gaym,
-                                         gchar * name)
-{
-
-    GaymBuddy *channel_member;
-    channel_member =
-        (GaymBuddy *) g_hash_table_lookup(gaym->channel_members, name);
-    if (!channel_member)
-        return FALSE;
-    else {
-
-        if (channel_member->ref_count <= 0)
-            gaim_debug_error("gaym",
-                             "****Reference counting error with channel members struct.\n");
-
-        channel_member->ref_count--;
-
-        if (channel_member->ref_count == 0) {
-            gaim_debug_misc("gaym", "Removing %s from channel_members\n",
-                            name);
-            return g_hash_table_remove(gaym->channel_members, name);
-        }
-        return FALSE;
-    }
-}
-
-static void gaym_add_buddy(GaimConnection * gc, GaimBuddy * buddy,
-                           GaimGroup * group)
-{
-    if (buddy->name) {
-        buddy->name = g_strstrip(buddy->name);
-    }
-    if (buddy->alias) {
-        buddy->alias = g_strstrip(buddy->alias);
-    }
-    if (buddy->server_alias) {
-        buddy->server_alias = g_strstrip(buddy->server_alias);
-    }
-    struct gaym_conn *gaym = (struct gaym_conn *) gc->proto_data;
-    struct gaym_buddy *ib = g_new0(struct gaym_buddy, 1);
-    ib->name = g_strdup(buddy->name);
-    ib->done = FALSE;
-    ib->online = FALSE;
-    ib->bio = NULL;
-    ib->thumbnail = NULL;
-    ib->sex = NULL;
-    ib->age = NULL;
-    ib->location = NULL;
-    g_hash_table_replace(gaym->buddies, ib->name, ib);
-    gaim_debug_misc("gaym", "Add buddy: %s\n", buddy->name);
-    /**
-     * if the timer isn't set, this is during signon, so we don't want to
-     * flood ourself off with WHOIS's, so we don't, but after that we want
-     * to know when someone's online asap
-     */
-    if (gaym->timer)
-        gaym_whois_one(gaym, ib);
-}
-
-static void gaym_remove_buddy(GaimConnection * gc, GaimBuddy * buddy,
-                              GaimGroup * group)
-{
-    struct gaym_conn *gaym = (struct gaym_conn *) gc->proto_data;
-
-    /**
-     * Only remove buddy->name from gaym->buddies if it doesn't
-     * exist in any other group on the buddy list.  This allows us
-     * to manage the buddy once, even though it might exist in
-     * several groups within the buddy list.
-     *
-     * To add to confusion, the buddy being deleted is not yet deleted,
-     * so we look for less than two identical buddies, and if so, then
-     * remove the buddy from gaym->buddies.
-     */
-
-    GSList *buddies = gaim_find_buddies(gaym->account, buddy->name);
-    guint length = g_slist_length(buddies);
-
-    if (length < 2) {
-        g_hash_table_remove(gaym->buddies, buddy->name);
-    }
-
-    g_slist_free(buddies);
-}
-
-static void gaym_input_cb(gpointer data, gint source,
-                          GaimInputCondition cond)
-{
-    GaimConnection *gc = data;
-    struct gaym_conn *gaym = gc->proto_data;
-    char *cur, *end;
-    int len;
-
-    if (gaym->inbuflen < gaym->inbufused + IRC_INITIAL_BUFSIZE) {
-        gaym->inbuflen += IRC_INITIAL_BUFSIZE;
-        gaym->inbuf = g_realloc(gaym->inbuf, gaym->inbuflen);
-    }
-
-    if ((len =
-         read(gaym->fd, gaym->inbuf + gaym->inbufused,
-              IRC_INITIAL_BUFSIZE - 1)) < 0) {
-        gaim_connection_error(gc, _("Read error"));
-        return;
-    } else if (len == 0) {
-        gaim_connection_error(gc, _("Server has disconnected"));
-        return;
-    }
-
-    gaym->inbufused += len;
-    gaym->inbuf[gaym->inbufused] = '\0';
-
-    cur = gaym->inbuf;
-    while (cur < gaym->inbuf + gaym->inbufused &&
-           ((end = strstr(cur, "\r\n")) || (end = strstr(cur, "\n")))) {
-        int step = (*end == '\r' ? 2 : 1);
-        *end = '\0';
-        gaym_parse_msg(gaym, cur);
-        cur = end + step;
-    }
-    if (cur != gaym->inbuf + gaym->inbufused) { /* leftover */
-        gaym->inbufused -= (cur - gaym->inbuf);
-        memmove(gaym->inbuf, cur, gaym->inbufused);
-    } else {
-        gaym->inbufused = 0;
-    }
-}
-
-static void gaym_add_permit(GaimConnection * gc, const char *name)
-{
-    if (!gaym_nick_check(name)) {
-        gaim_privacy_permit_remove(gc->account, name, TRUE);
-        gaim_notify_error(gc, _("Invalid User Name"), name,
-                          _("Invalid user name not added."));
-    } else {
-        gaym_privacy_change(gc, name);
-    }
-}
-
-static void gaym_add_deny(GaimConnection * gc, const char *name)
-{
-    if (!gaym_nick_check(name)) {
-        gaim_privacy_deny_remove(gc->account, name, TRUE);
-        gaim_notify_error(gc, _("Invalid User Name"), name,
-                          _("Invalid user name not added."));
-        return;
-    }
-    gaym_server_store_deny(gc, name, TRUE);
-    gaym_privacy_change(gc, name);
-}
-
-static void gaym_rem_permit(GaimConnection * gc, const char *name)
-{
-    gaym_privacy_change(gc, name);
-}
-
-static void gaym_rem_deny(GaimConnection * gc, const char *name)
-{
-    gaym_server_store_deny(gc, name, FALSE);
-    gaym_privacy_change(gc, name);
-}
-
-static void gaym_set_permit_deny(GaimConnection * gc)
-{
-    gaym_privacy_change(gc, NULL);
-}
-
-static void gaym_warn(GaimConnection * gc, const char *who,
-                      gboolean anonymous)
-{
-    void *handle = NULL;
-    struct gaym_conn *gaym = gc->proto_data;
-    char *buf =
-        g_strdup_printf
-        ("http://%s/members/report/form.html?area=chat&room=&report=%s",
-         gaym->server, who);
-    gaim_notify_uri(handle, buf);
-    g_free(buf);
-}
-
-static void gaym_chat_join(GaimConnection * gc, GHashTable * data)
-{
-    struct gaym_conn *gaym = gc->proto_data;
-    const char *args[1];
-    char *alias = NULL;
-
-    GaimChat *c = NULL;
-
-    /**
-     * need a copy, because data gets
-     * destroyed in roomlist.c
-     */
-    GHashTable *chatinfo = NULL;
-
-    args[0] = g_hash_table_lookup(data, "channel");
-
-    if (args[0]) {
-        alias = g_hash_table_lookup(data, "description");
-        c = gaim_blist_find_chat(gaim_connection_get_account(gc), args[0]);
-        if (!c) {
-            chatinfo = g_hash_table_new(g_str_hash, g_str_equal);
-
-            g_hash_table_replace(chatinfo, "channel", g_strdup(args[0]));
-
-            c = gaim_chat_new(gaim_connection_get_account(gc),
-                              alias, chatinfo);
-
-            gaim_blist_add_chat(c, NULL, NULL);
-        }
-    }
-
-    if (!args[0] || *args[0] != '#') {
-        /**
-         * Trigger a room search in config.txt....
-         */
-        return;
-    }
-
-    gaym_cmd_join(gaym, "join", NULL, args);
-}
-
-static char *gaym_get_chat_name(GHashTable * data)
-{
-    return g_strdup(g_hash_table_lookup(data, "channel"));
-}
-
-static void gaym_chat_invite(GaimConnection * gc, int id,
-                             const char *message, const char *name)
-{
-    struct gaym_conn *gaym = gc->proto_data;
-    GaimConversation *convo = gaim_find_chat(gc, id);
-    const char *args[2];
-
-    if (!convo) {
-        gaim_debug(GAIM_DEBUG_ERROR, "gaym",
-                   "Got chat invite request for bogus chat\n");
-        return;
-    }
-    args[0] = name;
-    args[1] = gaim_conversation_get_name(convo);
-    gaym_cmd_invite(gaym, "invite", gaim_conversation_get_name(convo),
-                    args);
-}
-
-static void gaym_chat_leave(GaimConnection * gc, int id)
-{
-    struct gaym_conn *gaym = gc->proto_data;
-    GaimConversation *convo = gaim_find_chat(gc, id);
-    const char *args[2];
-
-    if (!convo)
-        return;
-
-    args[0] = gaim_conversation_get_name(convo);
-    args[1] = NULL;
-    gaym_cmd_part(gaym, "part", gaim_conversation_get_name(convo), args);
-    serv_got_chat_left(gc, id);
-}
-
-static int gaym_chat_send(GaimConnection * gc, int id, const char *what)
-{
-    struct gaym_conn *gaym = gc->proto_data;
-    GaimConversation *convo = gaim_find_chat(gc, id);
-    const char *args[2];
-    char *tmp;
-
-    if (!convo) {
-        gaim_debug(GAIM_DEBUG_ERROR, "gaym",
-                   "chat send on nonexistent chat\n");
-        return -EINVAL;
-    }
-#if 0
-    if (*what == '/') {
-        return gaym_parse_cmd(gaym, convo->name, what + 1);
-    }
-#endif
-    args[0] = convo->name;
-    args[1] = what;
-
-    gaym_cmd_privmsg(gaym, "msg", NULL, args);
-
-    tmp = gaim_escape_html(what);
-    serv_got_chat_in(gc, id, gaim_connection_get_display_name(gc), 0, tmp,
-                     time(NULL));
-    g_free(tmp);
-    return 0;
-}
-
-static guint gaym_nick_hash(const char *nick)
-{
-    char *lc = NULL;
-    guint bucket;
-
-    if (!nick)
-        return 0;
-    lc = g_utf8_strdown(nick, -1);
-    bucket = g_str_hash(lc);
-    g_free(lc);
-
-    return bucket;
-}
-
-static gboolean gaym_nick_equal(const char *nick1, const char *nick2)
-{
-    return (gaim_utf8_strcasecmp(nick1, nick2) == 0);
-}
-
-static void gaym_channel_member_free(GaymBuddy * cm)
-{
-    g_free(cm->name);
-    g_free(cm->bio);
-    g_free(cm->thumbnail);
-    g_free(cm->sex);
-    g_free(cm->age);
-    g_free(cm->location);
-    g_free(cm);
-}
-
-static void gaym_buddy_free(struct gaym_buddy *ib)
-{
-    g_free(ib->name);
-    g_free(ib->bio);
-    g_free(ib->thumbnail);
-    g_free(ib->sex);
-    g_free(ib->age);
-    g_free(ib->location);
-    g_free(ib);
-}
-
-static GaimChat *gaym_find_blist_chat(GaimAccount * account,
-                                      const char *name)
-{
-    char *chat_name;
-    GaimChat *chat;
-    GaimPlugin *prpl;
-    GaimPluginProtocolInfo *prpl_info = NULL;
-    struct proto_chat_entry *pce;
-    GaimBlistNode *node, *group;
-    GList *parts;
-
-    GaimBuddyList *gaimbuddylist = gaim_get_blist();
-
-    g_return_val_if_fail(gaimbuddylist != NULL, NULL);
-    g_return_val_if_fail((name != NULL) && (*name != '\0'), NULL);
-
-    if (!gaim_account_is_connected(account))
-        return NULL;
-
-    prpl = gaim_find_prpl(gaim_account_get_protocol_id(account));
-    prpl_info = GAIM_PLUGIN_PROTOCOL_INFO(prpl);
-
-    for (group = gaimbuddylist->root; group != NULL; group = group->next) {
-        for (node = group->child; node != NULL; node = node->next) {
-            if (GAIM_BLIST_NODE_IS_CHAT(node)) {
-
-                chat = (GaimChat *) node;
-
-                if (account != chat->account)
-                    continue;
-
-                parts =
-                    prpl_info->
-                    chat_info(gaim_account_get_connection(chat->account));
-
-                pce = parts->data;
-                chat_name = g_hash_table_lookup(chat->components,
-                                                pce->identifier);
-
-                if (chat->account == account && chat_name != NULL &&
-                    name != NULL
-                    && g_pattern_match_simple(chat_name, name)) {
-
-                    return chat;
-                }
-            }
-        }
-    }
-
-    return NULL;
-}
-
-static GaimRoomlist *gaym_roomlist_get_list(GaimConnection * gc)
-{
-    struct gaym_conn *gaym;
-    GList *fields = NULL;
-    GaimRoomlistField *f;
-    char *buf;
-
-    gaym = gc->proto_data;
-
-    if (gaym->roomlist) {
-        gaim_roomlist_unref(gaym->roomlist);
-    }
-
-    gaym->roomlist = gaim_roomlist_new(gaim_connection_get_account(gc));
-
-    f = gaim_roomlist_field_new(GAIM_ROOMLIST_FIELD_STRING, _("Channel"),
-                                "channel", FALSE);
-    fields = g_list_prepend(fields, f);
-
-    f = gaim_roomlist_field_new(GAIM_ROOMLIST_FIELD_STRING, "",
-                                "description", TRUE);
-    fields = g_list_prepend(fields, f);
-
-    gaim_roomlist_set_fields(gaym->roomlist, fields);
-
-    /**
-     * Member created rooms are retrieved through the IRC protocol
-     * and after the last response is recieved from that request
-     * the static rooms are added
-     */
-
-    buf = gaym_format(gaym, "v", "LIST #_*");
-    gaym_send(gaym, buf);
-    g_free(buf);
-
-    return gaym->roomlist;
-}
-
-static void gaym_roomlist_cancel(struct _GaimRoomlist *list)
-{
-    GaimConnection *gc = gaim_account_get_connection(list->account);
-    struct gaym_conn *gaym;
-
-    if (gc == NULL)
-        return;
-
-    gaym = gc->proto_data;
-
-    gaim_roomlist_set_in_progress(list, FALSE);
-
-    if (gaym->roomlist == list) {
-        g_list_free(g_list_nth_data(list->rooms, 0));
-        gaym->roomlist = NULL;
-        gaim_roomlist_unref(list);
-    }
-
-    if (gaym->roomlist_filter) {
-        g_free(gaym->roomlist_filter);
-        gaym->roomlist_filter = NULL;
-    }
-}
-
-void gaym_roomlist_expand_category(struct _GaimRoomlist *list,
-                                   struct _GaimRoomlistRoom *category)
-{
-    GaimRoomlistRoom *room = NULL;
-    gchar *altname = NULL;
-    gchar *altchan = NULL;
-    int i = 0;
-
-    if (category->type & GAIM_ROOMLIST_ROOMTYPE_ROOM
-        && !category->expanded_once) {
-
-        category->expanded_once = TRUE;
-
-        int max =
-            gaim_prefs_get_int("/plugins/prpl/gaym/chat_room_instances");
-
-        gchar *name = category->fields->data;
-        gchar *chan = category->fields->next->data;
-
-        for (i = 1; i <= max; i++) {
-            altname = g_strdup_printf("%.*s%d", strlen(name) - 1, name, i);
-            altchan = g_strdup_printf("%.*s%d", strlen(chan) - 1, chan, i);
-
-            room =
-                gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_ROOM,
-                                       altname, category);
-
-            gaim_roomlist_room_add_field(list, room, altname);
-            gaim_roomlist_room_add_field(list, room, altchan);
-            gaim_roomlist_room_add(list, room);
-            g_free(altname);
-            g_free(altchan);
-        }
-    }
-    gaim_roomlist_set_in_progress(list, FALSE);
-}
-
-static GaimPluginProtocolInfo prpl_info = {
-    0,                          /* options */
-    NULL,                       /* user_splits */
-    NULL,                       /* protocol_options */
-    {"jpg", 57, 77, 57, 77},    /* icon_spec */
-    gaym_blist_icon,            /* list_icon */
-    gaym_blist_emblems,         /* list_emblems */
-    gaym_status_text,           /* status_text */
-    gaym_tooltip_text,          /* tooltip_text */
-    gaym_away_states,           /* away_states */
-    gaym_blist_node_menu,       /* blist_node_menu */
-    gaym_chat_join_info,        /* chat_info */
-    gaym_chat_info_defaults,    /* chat_info_defaults */
-    gaym_login,                 /* login */
-    gaym_close,                 /* close */
-    gaym_im_send,               /* send_im */
-    gaym_set_info,              /* set_info */
-    NULL,                       /* send_typing */
-    gaym_get_info,              /* get_info */
-    gaym_set_away,              /* set_away */
-    NULL,                       /* set_idle */
-    NULL,                       /* change_passwd */
-    gaym_add_buddy,             /* add_buddy */
-    NULL,                       /* add_buddies */
-    gaym_remove_buddy,          /* remove_buddy */
-    NULL,                       /* remove_buddies */
-    gaym_add_permit,            /* add_permit */
-    gaym_add_deny,              /* add_deny */
-    gaym_rem_permit,            /* rem_permit */
-    gaym_rem_deny,              /* rem_deny */
-    gaym_set_permit_deny,       /* set_permit_deny */
-    gaym_warn,                  /* warn */
-    gaym_chat_join,             /* join_chat */
-    NULL,                       /* reject_chat */
-    gaym_get_chat_name,         /* get_chat_name */
-    gaym_chat_invite,           /* chat_invite */
-    gaym_chat_leave,            /* chat_leave */
-    NULL,                       /* chat_whisper */
-    gaym_chat_send,             /* chat_send */
-    NULL,                       /* keepalive */
-    NULL,                       /* register_user */
-    NULL,                       /* get_cb_info */
-    NULL,                       /* get_cb_away */
-    NULL,                       /* alias_buddy */
-    NULL,                       /* group_buddy */
-    NULL,                       /* rename_group */
-    NULL,                       /* buddy_free */
-    NULL,                       /* convo_closed */
-    NULL,                       /* normalize */
-    NULL,                       /* set_buddy_icon */
-    NULL,                       /* remove_group */
-    NULL,                       /* get_cb_real_name */
-    NULL,                       /* set_chat_topic */
-    gaym_find_blist_chat,       /* find_blist_chat */
-    gaym_roomlist_get_list,     /* roomlist_get_list */
-    gaym_roomlist_cancel,       /* roomlist_cancel */
-    gaym_roomlist_expand_category,      /* roomlist_expand_category */
-    NULL,                       /* can_receive_file */
-    gaym_dccsend_send_file      /* send_file */
-};
-
-void deref_one_user(gpointer * user, gpointer * data)
-{
-
-    struct gaym_conn *gaym = (struct gaym_conn *) data;
-    GaimConvChatBuddy *cb = (GaimConvChatBuddy *) user;
-    gaim_debug_misc("gaym", "Removing %s in %x from list\n",
-                    (char *) cb->name, cb);
-
-    gaim_debug_misc("    ", "Succes was: %i\n",
-                    gaym_unreference_channel_member(gaym, cb->name));
-
-}
-static void gaym_clean_channel_members(GaimConversation * conv)
-{
-
-    g_return_if_fail(conv != NULL);
-
-    if (conv->type == GAIM_CONV_CHAT) {
-        GaimConvChat *chat = gaim_conversation_get_chat_data(conv);
-        GaimConnection *gc = gaim_conversation_get_gc(conv);
-        g_return_if_fail(gc != NULL);
-        struct gaym_conn *gaym = gc->proto_data;
-        GList *users = gaim_conv_chat_get_users(chat);
-        gaim_debug_misc("gaym", "got userlist %x length %i\n", users,
-                        g_list_length(users));
-        g_list_foreach(users, (GFunc) deref_one_user, gaym);
-    } else if (conv->type == GAIM_CONV_IM) {
-        gaim_debug_misc("gaym", "removing reference to %s\n", conv->name);
-        GaimConnection *gc = gaim_conversation_get_gc(conv);
-        g_return_if_fail(gc != NULL);
-        struct gaym_conn *gaym = gc->proto_data;
-        gaym_unreference_channel_member(gaym, conv->name);
-    }
-}
-static void gaym_get_photo_info(GaimConversation * conv)
-{
-    char *buf;
-    char *name;
-    gaim_debug_misc("gaym", "Got conversation-created signal\n");
-    if (strncmp(conv->account->protocol_id, "prpl-gaym", 9) == 0
-        && gaim_conversation_get_type(conv) == GAIM_CONV_IM) {
-
-        /**
-         * First check to see if we already have the photo via
-         * the buddy list process.
-         */
-
-        struct gaym_conn *gaym;
-
-        GaimConnection *gc = gaim_conversation_get_gc(conv);
-        gaym = (struct gaym_conn *) gc->proto_data;
-
-        if (!gaym) {
-            return;
-        }
-
-        struct gaym_buddy *ib =
-            g_hash_table_lookup(gaym->buddies, conv->name);
-
-        if (ib) {
-            return;
-        }
-
-        /**
-         * Since this person isn't in our buddy list, go ahead
-         * with the WHOIS to get the photo for the IM thumbnail
-         */
-
-
-        name = gaym_nick_to_gcom_strdup(conv->name);
-        buf = gaym_format(gaym, "vn", "WHOIS", name);
-        gaim_debug_misc("gaym", "Conversation triggered command: %s\n",
-                        buf);
-        gaym_send(gaym, buf);
-        gaym_get_channel_member_reference(gaym, name);
-        g_free(name);
-        g_free(buf);
-        // Opens a reference in channel_members.
-
-    }
-}
-
-static GaimPluginPrefFrame *get_plugin_pref_frame(GaimPlugin * plugin)
-{
-    GaimPluginPrefFrame *frame;
-    GaimPluginPref *ppref;
-
-    frame = gaim_plugin_pref_frame_new();
-
-    ppref = gaim_plugin_pref_new_with_label(_("Chat Rooms"));
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_name_and_label
-        ("/plugins/prpl/gaym/show_join", _("Show entrance announcement"));
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_name_and_label
-        ("/plugins/prpl/gaym/show_bio_with_join",
-         _("Show member bio with entrance announcement"));
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_name_and_label
-        ("/plugins/prpl/gaym/show_part", _("Show exit announcement"));
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_name_and_label
-        ("/plugins/prpl/gaym/chat_room_instances",
-         _("Number of chat room instances to display"));
-    gaim_plugin_pref_set_bounds(ppref, 0, 9);
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_label(_
-                                        ("Bio-Based Chat Room Activity Filtering"));
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_name_and_label
-        ("/plugins/prpl/gaym/botfilter_enable", _("Enable"));
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_name_and_label
-        ("/plugins/prpl/gaym/botfilter_ignore_null",
-         _("Ignore if bio is blank"));
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_name_and_label
-        ("/plugins/prpl/gaym/botfilter_patterns",
-         _
-         ("Ignore if bio contains these patterns\n\t? = match any single character\n\t* = match zero, one, or more"));
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_name_and_label
-        ("/plugins/prpl/gaym/botfilter_sep",
-         _("Above patterns are separated by"));
-    gaim_plugin_pref_set_max_length(ppref, 1);
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    ppref =
-        gaim_plugin_pref_new_with_name_and_label
-        ("/plugins/prpl/gaym/botfilter_url",
-         _
-         ("URL for GayBoi's spam database\n\tblank to disable\n\tchanges affect next login\n\tdefault is "
-          GAYBOI_SPAM_URL));
-    gaim_plugin_pref_frame_add(frame, ppref);
-
-    return frame;
-}
-
-static GaimPluginUiInfo prefs_info = {
-    get_plugin_pref_frame
-};
-
-static GaimPluginInfo info = {
-    GAIM_PLUGIN_MAGIC,
-    GAIM_MAJOR_VERSION,
-    GAIM_MINOR_VERSION,
-    GAIM_PLUGIN_PROTOCOL,                                 /**< type           */
-    NULL,                                                 /**< ui_requirement */
-    0,                                                    /**< flags          */
-    NULL,                                                 /**< dependencies   */
-    GAIM_PRIORITY_DEFAULT,                                /**< priority       */
-
-    "prpl-gaym",                                          /**< id             */
-    "GayM",                                               /**< name           */
-    VERSION,                                              /**< version        */
-    N_("GayM Protocol Plugin"),                           /**  summary        */
-    N_("Gay.com Messaging based on IRC"),                 /**  description    */
-    NULL,                                                 /**< author         */
-    "http://qrc.berlios.de/",                             /**< homepage       */
-
-    NULL,                                                 /**< load           */
-    NULL,                                                 /**< unload         */
-    NULL,                                                 /**< destroy        */
-
-    NULL,                                                  /**< ui_info        */
-    &prpl_info,                                           /**< extra_info     */
-    &prefs_info,
-    gaym_actions
-};
-
-static void _init_plugin(GaimPlugin * plugin)
-{
-
-    GaimAccountOption *option;
-
-    option = gaim_account_option_string_new(_("Bio Line"), "bioline", "");
-    prpl_info.protocol_options =
-        g_list_prepend(prpl_info.protocol_options, option);
-
-    option =
-        gaim_account_option_int_new(_("Port"), "port", IRC_DEFAULT_PORT);
-    prpl_info.protocol_options =
-        g_list_prepend(prpl_info.protocol_options, option);
-
-    option =
-        gaim_account_option_string_new(_("Server"), "server",
-                                       IRC_DEFAULT_SERVER);
-    prpl_info.protocol_options =
-        g_list_prepend(prpl_info.protocol_options, option);
-
-    /**
-     * We have to pull thumbnails, since they aren't pushed like with
-     * other protocols.
-     */
-    gaim_signal_connect(gaim_conversations_get_handle(),
-                        "conversation-created", plugin,
-                        GAIM_CALLBACK(gaym_get_photo_info), NULL);
-
-
-    gaim_signal_connect(gaim_conversations_get_handle(),
-                        "deleting-conversation", plugin,
-                        GAIM_CALLBACK(gaym_clean_channel_members), NULL);
-
-    gaim_signal_register(gaim_accounts_get_handle(),
-                         "info-updated",
-                         gaim_marshal_VOID__POINTER_POINTER, NULL, 2,
-                         gaim_value_new(GAIM_TYPE_SUBTYPE,
-                                        GAIM_SUBTYPE_ACCOUNT),
-                         gaim_value_new(GAIM_TYPE_POINTER,
-                                        GAIM_TYPE_CHAR));
-
-
-
-    gaim_prefs_add_none("/plugins/prpl/gaym");
-    gaim_prefs_add_int("/plugins/prpl/gaym/chat_room_instances", 4);
-    gaim_prefs_add_bool("/plugins/prpl/gaym/show_join", TRUE);
-    gaim_prefs_add_bool("/plugins/prpl/gaym/show_part", TRUE);
-    gaim_prefs_add_bool("/plugins/prpl/gaym/show_bio_with_join", TRUE);
-
-    gaim_prefs_add_bool("/plugins/prpl/gaym/botfilter_enable", FALSE);
-    gaim_prefs_add_bool("/plugins/prpl/gaym/botfilter_ignore_null", FALSE);
-    gaim_prefs_add_string("/plugins/prpl/gaym/botfilter_sep", "|");
-    gaim_prefs_add_string("/plugins/prpl/gaym/botfilter_patterns",
-                          "NULL|MODE * -i|*dantcamboy*|*Free preview*|*epowerchat*|*Live gay sex cam show*|*camboiz*");
-    gaim_prefs_add_string("/plugins/prpl/gaym/botfilter_url",
-                          GAYBOI_SPAM_URL);
-
-    gaim_prefs_connect_callback("/plugins/prpl/gaym/botfilter_url",
-                                botfilter_url_changed_cb, NULL);
-
-    gaim_prefs_add_string("/plugins/prpl/gaym/botfilter_url_result", "");
-    gaim_prefs_add_int("/plugins/prpl/gaym/botfilter_url_last_check", 0);
-
-    _gaym_plugin = plugin;
-
-    gaym_register_commands();
-}
-
-GAIM_INIT_PLUGIN(gaym, _init_plugin, info);
-
-
-
-/**
- * vim:tabstop=4:shiftwidth=4:expandtab:
- */

Copied: qrc/tags/release-0.9/gaym/src/gaym.c (from rev 262, qrc/trunk/gaym/src/gaym.c)

Deleted: qrc/tags/release-0.9/gaym/src/gaym.h
===================================================================
--- qrc/trunk/gaym/src/gaym.h	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/tags/release-0.9/gaym/src/gaym.h	2005-07-31 19:13:29 UTC (rev 264)
@@ -1,247 +0,0 @@
-/**
- * @file gaym.h
- * 
- * gaim
- *
- * Copyright (C) 2003, Ethan Blanton <eblanton at cs.purdue.edu>
- * 
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#ifndef _GAIM_GAYM_H
-#define _GAIM_GAYM_H
-
-#include "internal.h"
-
-#include <glib.h>
-
-#include "roomlist.h"
-
-#define IRC_DEFAULT_SERVER "www.gay.com"
-#define IRC_DEFAULT_PORT 7514
-
-#define IRC_DEFAULT_CHARSET "UTF-8"
-#define IRC_DEFAULT_ALIAS "gaim"
-
-#define IRC_INITIAL_BUFSIZE 1024
-
-#define BLIST_UPDATE_PERIOD 60000       /* buddy list updated every 45s */
-#define BLIST_CHUNK_INTERVAL 5000       /* 5s between ISON chunks */
-
-#define MAX_BIO_LEN 150         /* max number of characters in bio */
-
-#define MAX_CHANNEL_MEMBERS 200
-
-#define GAYBOI_SPAM_URL "http://gayboi.org/spam/spamlst.php"
-
-typedef struct _BListWhois BListWhois;
-struct _BListWhois {
-    int count;
-    GString *string;
-};
-
-enum { IRC_USEROPT_SERVER, IRC_USEROPT_PORT, IRC_USEROPT_CHARSET };
-enum gaym_state { IRC_STATE_NEW, IRC_STATE_ESTABLISHED };
-enum info_string { INFO_AGE, INFO_LOCATION, INFO_BIO, INFO_URL };
-
-struct gaym_conn {
-    GaimAccount *account;
-    GHashTable *msgs;
-    GHashTable *cmds;
-    char *server;
-    int fd;
-    guint timer;
-    GHashTable *buddies;        /* hash table of struct gaym_buddy */
-    GHashTable *channel_members;        /* hash table of struct gaym_buddy 
-                                         */
-
-    char *inbuf;
-    int inbuflen;
-    int inbufused;
-
-    char *thumbnail;
-    char *chat_key;
-    char *server_bioline;
-    char *server_stats;
-    char *roomlist_filter;
-    char *bio;
-
-    gboolean blist_updating;
-    GHashTable *info_window_needed;
-
-    GString *motd;
-    GString *names;
-    char *nameconv;
-    char *traceconv;
-
-    GaimRoomlist *roomlist;
-
-    GList **node_menu;
-    gboolean quitting;
-    char *subroom;
-    GHashTable *confighash;
-    GHashTable *entry_order;
-
-    char *persist_room;
-    gboolean cancelling_persist;
-    void *hammer_cancel_dialog;
-
-};
-
-typedef struct {
-
-    gchar *cookies;
-    GHashTable *cookie_table;
-    void (*session_cb) (GaimAccount *);
-    GaimAccount *account;
-    char *username;
-    char *password;
-    struct gaym_conn *gaym;
-    gboolean hasFormData;
-
-} GaimUrlSession;
-
-typedef struct gaym_buddy GaymBuddy;
-struct gaym_buddy {
-    char *name;                 /* gaym formatted nick */
-    gboolean done;              /* has been checked */
-    gboolean online;            /* is online */
-    gint ref_count;             /* reference count for mem mngmnt */
-    char *bio;                  /* bio string */
-    char *thumbnail;            /* thumbnail string */
-    char *sex;                  /* sex string */
-    char *age;                  /* age string */
-    char *location;             /* location string */
-};
-
-gboolean gaym_unreference_channel_member(struct gaym_conn *gaym,
-                                         gchar * name);
-GaymBuddy *gaym_get_channel_member_info(struct gaym_conn *gaym,
-                                        const gchar * name);
-
-GaymBuddy *gaym_get_channel_member_reference(struct gaym_conn
-                                             *gaym, const char *name);
-typedef int (*IRCCmdCallback) (struct gaym_conn * gaym, const char *cmd,
-                               const char *target, const char **args);
-
-int gaym_send(struct gaym_conn *gaym, const char *buf);
-gboolean gaym_blist_timeout(struct gaym_conn *gaym);
-
-char *gaym_mgaym2html(const char *string);
-char *gaym_mgaym2txt(const char *string);
-
-void gaym_register_commands(void);
-void gaym_msg_table_build(struct gaym_conn *gaym);
-void gaym_parse_msg(struct gaym_conn *gaym, char *input);
-char *gaym_parse_ctcp(struct gaym_conn *gaym, const char *from,
-                      const char *to, const char *msg, int notice);
-char *gaym_format(struct gaym_conn *gaym, const char *format, ...);
-
-typedef void (msg_handler) (struct gaym_conn * gaym, const char *name,
-                            const char *from, char **args);
-msg_handler gaym_msg_away;
-msg_handler gaym_msg_default;
-msg_handler gaym_msg_away;
-msg_handler gaym_msg_badmode;
-msg_handler gaym_msg_banned;
-msg_handler gaym_msg_chanmode;
-msg_handler gaym_msg_endwhois;
-msg_handler gaym_msg_endmotd;
-msg_handler gaym_msg_invite;
-msg_handler gaym_msg_inviteonly;
-msg_handler gaym_msg_who;
-msg_handler gaym_msg_chanfull;
-msg_handler gaym_msg_join;
-msg_handler gaym_msg_kick;
-msg_handler gaym_msg_list;
-msg_handler gaym_msg_login_failed;
-msg_handler gaym_msg_mode;
-msg_handler gaym_msg_motd;
-msg_handler gaym_msg_names;
-msg_handler gaym_msg_nick;
-msg_handler gaym_msg_nickused;
-msg_handler gaym_msg_nochan;
-msg_handler gaym_msg_nonick_chan;
-msg_handler gaym_msg_nonick;
-msg_handler gaym_msg_no_such_nick;
-msg_handler gaym_msg_nochangenick;
-msg_handler gaym_msg_nosend;
-msg_handler gaym_msg_notice;
-msg_handler gaym_msg_notinchan;
-msg_handler gaym_msg_notop;
-msg_handler gaym_msg_part;
-msg_handler gaym_msg_ping;
-msg_handler gaym_msg_pong;
-msg_handler gaym_msg_privmsg;
-msg_handler gaym_msg_regonly;
-msg_handler gaym_msg_quit;
-msg_handler gaym_msg_topic;
-msg_handler gaym_msg_trace;
-msg_handler gaym_msg_unknown;
-msg_handler gaym_msg_wallops;
-msg_handler gaym_msg_whois;
-msg_handler gaym_msg_richnames_list;
-msg_handler gaym_msg_create_pay_only;
-msg_handler gaym_msg_pay_channel;
-msg_handler gaym_msg_toomany_channels;
-msg_handler gaym_msg_list_busy;
-
-
-void gaym_cmd_table_build(struct gaym_conn *gaym);
-
-typedef int (cmd_handler) (struct gaym_conn * gaym, const char *cmd,
-                           const char *target, const char **args);
-
-cmd_handler gaym_cmd_default;
-cmd_handler gaym_cmd_away;
-cmd_handler gaym_cmd_ctcp_action;
-cmd_handler gaym_cmd_invite;
-cmd_handler gaym_cmd_join;
-cmd_handler gaym_cmd_kick;
-cmd_handler gaym_cmd_list;
-cmd_handler gaym_cmd_mode;
-cmd_handler gaym_cmd_names;
-cmd_handler gaym_cmd_nick;
-cmd_handler gaym_cmd_op;
-cmd_handler gaym_cmd_privmsg;
-cmd_handler gaym_cmd_part;
-cmd_handler gaym_cmd_ping;
-cmd_handler gaym_cmd_quit;
-cmd_handler gaym_cmd_quote;
-cmd_handler gaym_cmd_query;
-cmd_handler gaym_cmd_remove;
-cmd_handler gaym_cmd_topic;
-cmd_handler gaym_cmd_trace;
-cmd_handler gaym_cmd_wallops;
-cmd_handler gaym_cmd_whois;
-
-
-void gaym_dccsend_send_file(GaimConnection * gc, const char *who,
-                            const char *file);
-void gaym_dccsend_recv(struct gaym_conn *gaym, const char *from,
-                       const char *msg);
-void gaym_get_chat_key_from_weblogin(GaimAccount * account,
-                                     void (*callback) (GaimAccount *));
-
-void gaim_session_fetch(const char *url, gboolean full,
-                        const char *user_agent, gboolean http11,
-                        void (*cb) (gpointer, const char *, size_t),
-                        void *user_data, GaimUrlSession * session);
-
-#endif                          /* _GAIM_GAYM_H */
-
-/**
- * vim:tabstop=4:shiftwidth=4:expandtab:
- */

Copied: qrc/tags/release-0.9/gaym/src/gaym.h (from rev 262, qrc/trunk/gaym/src/gaym.h)

Deleted: qrc/tags/release-0.9/gaym/src/gayminfo.c
===================================================================
--- qrc/trunk/gaym/src/gayminfo.c	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/tags/release-0.9/gaym/src/gayminfo.c	2005-07-31 19:13:29 UTC (rev 264)
@@ -1,310 +0,0 @@
-/**
- * @file gayminfo.c
- *
- * GayM
- *
- * GayM is the legal property of its developers, whose names are too numerous
- * to list here.  Please refer to the COPYRIGHT file distributed with this
- * source distribution.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "gayminfo.h"
-#include "util.h"
-#include "debug.h"
-
-char *gaym_thumbnail_strdup(const char *info)
-{
-    char *start = strchr(info, ':');
-    char *end = 0;
-    if (start) {
-        start++;
-        end = strchr(info, '#');
-    }
-    if (start != end && end) {
-        return g_strdup_printf("%.*s", end - start, start);
-    } else {
-        return 0;
-    }
-}
-
-char *gaym_bio_strdup(const char *info)
-{
-    char *start = strchr(info, '#');
-    char *end = 0;
-    if (start) {
-        start++;
-        end = strchr(start, 0x01);
-        if (!end)
-            end = strchr(start, 0);
-    }
-
-    if ((end) && (start < end)) {
-        return g_strdup_printf("%.*s", end - start, start);
-    } else {
-        return 0;
-    }
-}
-
-char *gaym_stats_strdup(const char *info)
-{
-
-    char *start = strchr(info, '#');
-
-    if (start)
-        start = strchr(start, 0x01);
-
-    char *end = 0;
-    if (start) {
-        start++;
-        end = strchr(info, '\0');
-    }
-
-    if (start != end && end) {
-        return g_strdup_printf("%.*s", end - start, start);
-    } else {
-        return 0;
-    }
-}
-
-
-void gaym_update_channel_member(struct gaym_conn *gaym, const char *nick,
-                                const char *info)
-{
-    GaymBuddy *cm = gaym_get_channel_member_reference(gaym, nick);
-    if (!cm) {
-        gaim_debug_error("gaym",
-                         "ERROR: A member has joined a channel, or a conversation was opened, but we were unable to add the member to the internal management structure. Report a bug.");
-        return;
-    } else {
-        gchar *stats = gaym_stats_strdup(info);
-        if (stats) {
-            gchar **s = g_strsplit(stats, "|", 3);
-            if (s[0] && strlen(g_strstrip(s[0])) > 0) {
-                cm->sex = g_ascii_strup(s[0], -1);
-            }
-            if (s[1] && strlen(g_strstrip(s[1])) > 0) {
-                cm->age = g_strdup(s[1]);
-            }
-            if (s[2] && strlen(g_strstrip(s[2])) > 0) {
-                cm->location = g_strdup(s[2]);
-            }
-            g_strfreev(s);
-            g_free(stats);
-        }
-        cm->name = g_strdup(nick);
-        cm->bio = gaym_bio_strdup(info);
-        cm->thumbnail = gaym_thumbnail_strdup(info);
-
-    }
-}
-void gaym_fetch_thumbnail_cb(void *user_data, const char *pic_data,
-                             size_t len)
-{
-    if (!user_data)
-        return;
-    struct gaym_fetch_thumbnail_data *d = user_data;
-    if (!pic_data) {
-        return;
-    }
-
-    if (len && !g_strrstr_len(pic_data, len, "Server Error")) {
-        char *dir =
-            g_build_filename(gaim_user_dir(), "icons", "gaym", d->who,
-                             NULL);
-        char *filename = g_strdup(d->filename);
-        char *path = g_build_filename(dir, filename, NULL);
-        gaim_debug_misc("gayminfo", "dir: %s\n", dir);
-        gaim_debug_misc("gayminfo", "filename: %s\n", filename);
-        gaim_debug_misc("gayminfo", "path: %s\n", path);
-        if (!g_file_test(dir, G_FILE_TEST_EXISTS))
-            gaim_build_dir(dir, S_IRUSR | S_IWUSR | S_IXUSR);
-
-        if (path && !g_file_test(path, G_FILE_TEST_EXISTS)) {
-            FILE *file;
-            if ((file = g_fopen(path, "wb"))) {
-                fwrite(pic_data, 1, len, file);
-                fclose(file);
-            } else {
-                gaim_debug_misc("fetch_thumbnail_cb",
-                                "Couldn't write file\n");
-            }
-            g_free(filename);
-            g_free(path);
-            g_free(dir);
-        }
-    }
-    if (GAIM_CONNECTION_IS_VALID(d->gc) && len) {
-        gaim_signal_emit(gaim_accounts_get_handle(), "info-updated",
-                         d->gc, NULL, d->who);
-        if (gaim_find_conversation_with_account(d->who, d->gc->account)) {
-            gaim_buddy_icons_set_for_user(gaim_connection_get_account
-                                          (d->gc), d->who,
-                                          (void *) pic_data, len);
-        }
-
-    } else {
-        gaim_debug_error("gaym", "Fetching buddy icon failed.\n");
-    }
-
-    g_free(d->who);
-    g_free(d);
-}
-
-void gaym_buddy_status(struct gaym_conn *gaym, char *name,
-                       gboolean online, char *info)
-{
-    char *bio = NULL;
-    char *thumbnail = NULL;
-    char *stats = NULL;
-    char *url = NULL;
-    struct gaym_fetch_thumbnail_data *data;
-
-    if (!gaym || !gaym->account || !gaym->buddies || !name) {
-        return;
-    }
-
-    if (info) {
-        bio = gaym_bio_strdup(info);
-        if (bio) {
-            bio = g_strstrip(bio);
-        }
-
-        thumbnail = gaym_thumbnail_strdup(info);
-        if (thumbnail) {
-            thumbnail = g_strstrip(thumbnail);
-        }
-
-        stats = gaym_stats_strdup(info);
-        if (stats) {
-            stats = g_strstrip(stats);
-        }
-    }
-
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-
-    if (!gc) {
-        return;
-    }
-
-    struct gaym_buddy *ib = g_hash_table_lookup(gaym->buddies, name);
-
-    char *normalized = g_strdup(gaim_normalize(gaym->account, name));
-
-    if (thumbnail) {
-        gboolean do_fetch = 1;
-        GError *err = NULL;
-        if (!ib || gaim_utf8_strcasecmp(thumbnail, ib->thumbnail)) {
-            char *dirname =
-                g_build_filename(gaim_user_dir(), "icons", "gaym",
-                                 gaim_normalize(gaym->account, name),
-                                 NULL);
-            GDir *gdir = g_dir_open(dirname, 0, &err);
-            if (gdir) {
-                const char *filename;
-
-                while ((filename = g_dir_read_name(gdir)))      // don't
-                    // free
-                    // filename: 
-                    // owned
-                    // by
-                    // glib.
-                {
-                    char *thumbnail_base = g_path_get_basename(thumbnail);
-                    gaim_debug_misc("gaym", "compared %s and %s\n",
-                                    thumbnail_base, filename);
-                    if (!gaim_utf8_strcasecmp(thumbnail_base, filename)) {
-                        do_fetch = 0;
-                        break;
-                    }
-                    g_free(thumbnail_base);
-                }
-            }
-            if (do_fetch) {
-
-                gaim_debug_misc("gaym",
-                                "********************************************\n");
-                gaim_debug_misc("gaym",
-                                "*****************FETCH**********************\n");
-                gaim_debug_misc("gaym",
-                                "********************************************\n");
-                char *hashurl = NULL;
-                hashurl =
-                    g_hash_table_lookup(gaym->confighash,
-                                        "mini-profile-panel.thumbnail-prefix");
-                g_return_if_fail(hashurl != NULL);
-                data = g_new0(struct gaym_fetch_thumbnail_data, 1);
-                data->gc = gaim_account_get_connection(gaym->account);
-                data->who = g_strdup(gaim_normalize(gaym->account, name));
-                data->filename = g_strdup(g_strrstr(thumbnail, "/"));
-                gaim_debug_misc("gayminfo", "Found filename: %s\n",
-                                data->filename);
-                url = g_strdup_printf("%s%s", hashurl, thumbnail);
-                gaim_url_fetch(url, FALSE, "Mozilla/4.0", FALSE,
-                               gaym_fetch_thumbnail_cb, data);
-                g_free(url);
-            }
-
-        }
-    }
-
-    g_free(normalized);
-
-    if (ib) {
-        g_free(ib->bio);
-        ib->bio = NULL;
-        g_free(ib->thumbnail);
-        ib->thumbnail = NULL;
-        g_free(ib->sex);
-        ib->sex = NULL;
-        g_free(ib->age);
-        ib->age = NULL;
-        g_free(ib->location);
-        ib->location = NULL;
-
-        ib->online = online;
-
-        if (bio && strlen(g_strstrip(bio)) > 0) {
-            ib->bio = bio;
-        }
-        if (thumbnail && strlen(g_strstrip(thumbnail)) > 0) {
-            ib->thumbnail = thumbnail;
-        }
-        if (stats && strlen(g_strstrip(stats)) > 0) {
-            gchar **s = g_strsplit(stats, "|", 3);
-            if (s[0] && strlen(g_strstrip(s[0])) > 0) {
-                ib->sex = g_ascii_strup(s[0], -1);
-            }
-            if (s[1] && strlen(g_strstrip(s[1])) > 0) {
-                ib->age = g_strdup(s[1]);
-            }
-            if (s[2] && strlen(g_strstrip(s[2])) > 0) {
-                ib->location = g_strdup(s[2]);
-            }
-            g_strfreev(s);
-            g_free(stats);
-        }
-        GaimBuddy *buddy = gaim_find_buddy(gaym->account, name);
-        if (buddy) {
-            serv_got_update(gc, buddy->name, online, 0, 0, 0, 0);
-        }
-    }
-    return;
-}
-
-/**
- * vim:tabstop=4:shiftwidth=4:expandtab:
- */

Copied: qrc/tags/release-0.9/gaym/src/gayminfo.c (from rev 261, qrc/trunk/gaym/src/gayminfo.c)

Deleted: qrc/tags/release-0.9/gaym/src/gayminfo.h
===================================================================
--- qrc/trunk/gaym/src/gayminfo.h	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/tags/release-0.9/gaym/src/gayminfo.h	2005-07-31 19:13:29 UTC (rev 264)
@@ -1,98 +0,0 @@
-/**
- * @file gayminfo.h GayM User Info (IRC-based) API
- *
- * GayM
- *
- * GayM is the legal property of its developers, whose names are too numerous
- * to list here.  Please refer to the COPYRIGHT file distributed with this
- * source distribution.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-#ifndef _GAIM_GAYM_GAYMINFO_H_
-#define _GAIM_GAYM_GAYMINFO_H_
-
-#include <glib.h>
-
-#include "gaym.h"
-
-/**
- * Begin temporary, pending further refactoring
- */
-#include "connection.h"
-struct gaym_fetch_thumbnail_data {
-    GaimConnection *gc;
-    char *who;
-    char *filename;
-    char *bio;
-    char *stats;
-    // const char *pic_data;
-    // gint pic_data_len;
-};
-void gaym_fetch_thumbnail_cb(void *user_data, const char *pic_data,
-                             size_t len);
-/**
- * End temporary, pending further refactoring
- */
-
-/**
- * Extract the thumbnail string from the extra IRC info about the user.
- * The returned string should be freed when no longer needed.
- *
- * @param info The extra IRC info string.
- *
- * @return The thumbnail string.
- */
-char *gaym_thumbnail_strdup(const char *info);
-
-/**
- * Extract the bio string from the extra IRC info about the user.
- * The returned string should be freed when no longer needed.
- *
- * @param info The extra IRC info string.
- *
- * @return The bio string.
- */
-char *gaym_bio_strdup(const char *info);
-
-/**
- * Extract the stats string from the extra IRC info about the user.
- * The returned string should be freed when no longer needed.
- *
- * @param info The extra IRC info string.
- *
- * @return The stats string.
- */
-char *gaym_stats_strdup(const char *info);
-
-/**
- * Process extra IRC information about a buddy
- *
- * @param gaym The protocol-specific data related to the connection.
- * @param name The buddy name
- * @param online Is the buddy on line.
- * @param info The extra IRC info string about the buddy, if any.
- */
-void gaym_buddy_status(struct gaym_conn *gaym, char *name,
-                       gboolean online, char *info);
-
-
-void gaym_update_channel_member(struct gaym_conn *gaym, const char *nick,
-                                const char *info);
-#endif                          /* _GAIM_GAYM_GAYMINFO_H_ */
-
-/**
- * vim:tabstop=4:shiftwidth=4:expandtab:
- */

Copied: qrc/tags/release-0.9/gaym/src/gayminfo.h (from rev 261, qrc/trunk/gaym/src/gayminfo.h)

Deleted: qrc/tags/release-0.9/gaym/src/helpers.c
===================================================================
--- qrc/trunk/gaym/src/helpers.c	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/tags/release-0.9/gaym/src/helpers.c	2005-07-31 19:13:29 UTC (rev 264)
@@ -1,509 +0,0 @@
-/**
- * GayM
- *
- * GayM is the legal property of its developers, whose names are too numerous
- * to list here.  Please refer to the COPYRIGHT file distributed with this
- * source distribution.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-#include "internal.h"
-#include "debug.h"
-#include "helpers.h"
-
-void gcom_nick_to_gaym(char *nick)
-{
-    int i = 0;
-
-    if (!nick) {
-        return;
-    }
-
-    /**
-     * If there is a "|" in the first position, it must be removed.
-     */
-    if (nick[0] == '|') {
-        nick[0] = ' ';
-        nick = g_strchug(nick);
-    }
-
-    /**
-     * Any remaining "|" must be replaced with "."
-     */
-    for (i = 0; i < strlen(nick); i++) {
-        if (nick[i] == '|') {
-            nick[i] = '.';
-        }
-    }
-    return;
-}
-
-char *gaym_nick_to_gcom_strdup(const char *nick)
-{
-    int i = 0;
-    char *converted = NULL;
-
-    /**
-     * If the first character is not an upper or lower case letter
-     * then gay.com's IRC server requires "|" to be prepended
-     */
-    if (g_ascii_isalpha(nick[0])) {
-        converted = g_strdup_printf("%s", nick);
-    } else {
-        converted = g_strdup_printf("|%s", nick);
-    }
-
-    /**
-     * gay.com's IRC server requires all "." in nicks to be represented
-     * by "|"
-     */
-    for (i = 0; i < strlen(converted); i++) {
-        if (converted[i] == '.') {
-            converted[i] = '|';
-        }
-    }
-    return converted;
-}
-
-char *return_string_between(const char *startbit, const char *endbit,
-                            const char *source)
-{
-    char *start = 0;
-    char *end = 0;
-
-    if (!source || !startbit || !endbit)
-        return 0;
-
-    start = strstr(source, startbit);
-
-    if (start) {
-        start += strlen(startbit);
-        end = strstr(start, endbit);
-    }
-    /**
-     * gaim_debug_misc("gaym", "source: %d; start: %d; end: %d\n", source,
-     * start, end);
-     */
-    if (start && end) {
-        return g_strdup_printf("%.*s", end - start, start);
-    } else {
-        return 0;
-    }
-}
-
-gchar *ascii2native(const gchar * str)
-{
-    gint i;                     /* Temp variable */
-    gint len = strlen(str);
-
-    /**
-     * This allocates enough space, and probably a little too much.
-     */
-    gchar *outstr = g_malloc(len * sizeof(guchar));
-
-    gint pos = 0;               /* Current position in the output string. */
-    for (i = 0; i < len; i++) {
-        /**
-         * If we see a '\u' then parse it.
-         */
-        if (((char) *(str + i) == '\\')
-            && (((char) *(str + i + 1)) == 'u')
-            && (g_ascii_isxdigit((char) *(str + i + 2)))
-            && (g_ascii_isxdigit((char) *(str + i + 3)))
-            && (g_ascii_isxdigit((char) *(str + i + 4)))
-            && (g_ascii_isxdigit((char) *(str + i + 5)))) {
-
-            gint bytes;
-            gchar unibuf[6];
-            gunichar value = 0;
-
-            /**
-             * Assumption that the /u will be followed by 4 hex digits.
-             * <<12 to multiply by 16^3, <<8 for 16^2, <<4 for 16
-             * I.e., each hex digit
-             */
-            value = (g_ascii_xdigit_value((gchar) * (str + i + 2)) << 12) +
-                (g_ascii_xdigit_value((gchar) * (str + i + 3)) << 8) +
-                (g_ascii_xdigit_value((gchar) * (str + i + 4)) << 4) +
-                (g_ascii_xdigit_value((gchar) * (str + i + 5)));
-
-            bytes = g_unichar_to_utf8(value, unibuf);
-            int j;
-            for (j = 0; j < bytes; j++) {
-                outstr[pos++] = unibuf[j];
-            }
-            /**
-             * Move past the entire escape sequence.
-             */
-            i += 5;
-        }
-        /**
-         * Otherwise, just copy the byte.
-         */
-        else {
-            outstr[pos++] = str[i];
-        }
-    }
-    return outstr;
-}
-
-gboolean gaym_nick_check(const char *nick)
-{
-    gboolean retval = FALSE;
-
-    if (!nick) {
-        return retval;
-    }
-
-    char *allowed =
-        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-\0";
-    int i = 0;
-    int j = 0;
-
-    /**
-     * validate characters
-     */
-    for (i = 0; nick[i]; i++) {
-        retval = FALSE;
-        for (j = 0; allowed[j]; j++) {
-            if (nick[i] == allowed[j]) {
-                retval = TRUE;
-                break;
-            }
-        }
-        if (!retval) {
-            break;
-        }
-    }
-    if (!retval) {
-        return retval;
-    }
-    /**
-     * validate length
-     */
-    if (i > 30) {
-        retval = FALSE;
-        return retval;
-    }
-    /**
-     * its valid!
-     */
-    return retval;
-}
-
-void replace_dollar_n(gpointer key, gpointer value, gpointer user_data)
-{
-
-    /**
-     * replace $[0-9] with %s, so we can use printf style
-     * processing with the provided property values
-     */
-    gchar *pos = (gchar *) value;
-    while ((pos = (strchr(pos, '$')))) {
-        pos++;
-        if (g_ascii_isdigit(*pos)) {
-            *pos = 's';
-            *(pos - 1) = '%';
-
-        }
-    }
-}
-
-GHashTable *gaym_properties_new(const gchar * str)
-{
-
-    gchar *tmpstr = NULL;
-    gchar **tmparr = NULL;
-    gchar **proparr = NULL;
-    int i = 0;
-
-    GHashTable *props =
-        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
-
-    /**
-     * convert ascii-escaped to native
-     */
-    tmpstr = ascii2native(str);
-
-    /**
-     * strip out continuation character followed by newline 
-     */
-    // tmparr = g_strsplit(tmpstr, "\\\n", -1);
-    // g_free(tmpstr);
-    // tmpstr = g_strjoinv(NULL, tmparr);
-    // g_strfreev(tmparr);
-    /**
-     * Since the properties get stripped of spaces later,
-     * just replace \\\n with <space>\n in-place, for speed.
-     * */
-    char *pos = tmpstr;
-    while ((pos = g_strrstr(pos, "\\\n"))) {
-        *pos = ' ';
-        *(pos + 1) = ' ';
-    }
-    /**
-     * We're getting close.  Now we need an array as follows:
-     *
-     * property=value
-     * property=value
-     * ...
-     */
-    tmparr = g_strsplit(tmpstr, "\n", -1);
-
-    for (i = 0; tmparr[i] != NULL; i++) {
-        /**
-         * do nothing if this is a blank line
-         */
-        if (strlen(g_strstrip(tmparr[i])) == 0) {
-            continue;
-        }
-        /**
-         * do nothing if this is a comment line
-         */
-        if (tmparr[i][0] == '#') {
-            continue;
-        }
-        /**
-         * this must be a property=value string, so we make
-         * it into a 2-element array:
-         *
-         * property
-         * value
-         *
-         * but we won't store it in our hash table unless both
-         * have real values after stripping whitespace
-         */
-        proparr = g_strsplit(tmparr[i], "=", 2);
-        if (proparr[0] && strlen(g_strstrip(proparr[0])) > 0
-            && proparr[1] && strlen(g_strstrip(proparr[1])) > 0) {
-
-            g_hash_table_insert(props, g_strdup(proparr[0]),
-                                g_strdup(proparr[1]));
-
-        }
-        g_strfreev(proparr);
-    }
-
-    g_strfreev(tmparr);
-
-    g_hash_table_foreach(props, replace_dollar_n, NULL);
-
-    return props;
-}
-
-int roomlist_level_strip(char *description)
-{
-    int val = 0;
-    int i = 0;
-
-    if (!description) {
-        return val;
-    }
-
-    for (i = 0; i < strlen(description); i++) {
-        if (description[i] == '+') {
-            description[i] = ' ';
-        } else {
-            break;
-        }
-        val++;
-    }
-
-    description = g_strchug(description);
-
-    return val;
-}
-
-GaimRoomlistRoom *find_parent(int level, int old_level,
-                              GaimRoomlistRoom * last_room)
-{
-    GaimRoomlistRoom *parent = NULL;
-    int i = 0;
-
-    if (level == 0) {
-        /* do nothing */
-    } else if (level == old_level) {
-        parent = last_room->parent;
-    } else if (level > old_level) {
-        parent = last_room;
-    } else if (level < old_level) {
-        parent = last_room;
-        for (i = old_level - level; i >= 0; i--) {
-            parent = parent->parent;
-        }
-    }
-    return parent;
-}
-
-void build_roomlist_from_config(GaimRoomlist * roomlist,
-                                GHashTable * confighash, gchar * pattern)
-{
-    gchar **roominst = NULL;
-    gchar *altname = NULL;
-    gchar *normalized = NULL;
-    gchar *lowercase = NULL;
-    gchar *found = NULL;
-    int level = 0;
-    int old_level = 0;
-    int i = 0;
-    GaimRoomlistRoom *room = NULL;
-    GaimRoomlistRoom *parent = NULL;
-
-    g_return_if_fail(roomlist != NULL);
-    g_return_if_fail(confighash != NULL);
-
-    int max = gaim_prefs_get_int("/plugins/prpl/gaym/chat_room_instances");
-
-    gchar *roomstr = g_hash_table_lookup(confighash, "roomlist");
-    g_return_if_fail(roomstr != NULL);
-
-    gchar **roomarr = g_strsplit(roomstr, "|", -1);
-
-    /**
-     * We need to skip the first instance, because they start
-     * with a "|", which we've just split by, leaving a blank
-     * at the beginning of the list
-     */
-    for (i = 1; roomarr[i] != NULL; i++) {
-        if (roomarr[i][0] == '#') {
-            /**
-             * This is an actual room string, break it into its
-             * component parts, determine the level and the parent,
-             * and add this as both a room and a category
-             */
-            if (pattern != NULL) {
-                lowercase = g_utf8_strdown(roomarr[i], -1);
-                normalized =
-                    g_utf8_normalize(lowercase, -1, G_NORMALIZE_ALL);
-                found = g_strstr_len(normalized, -1, pattern);
-                g_free(normalized);
-                g_free(lowercase);
-            }
-            if (found != NULL || pattern == NULL) {
-                found = NULL;
-                roominst = g_strsplit(roomarr[i], " ", 2);
-                level = roomlist_level_strip(roominst[1]);
-                parent = find_parent(level, old_level, room);
-                altname = g_strdup_printf("%s:*", roominst[1]);
-                if (max == 0) {
-                    room =
-                        gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_ROOM,
-                                               altname, parent);
-                } else {
-                    room =
-                        gaim_roomlist_room_new
-                        (GAIM_ROOMLIST_ROOMTYPE_CATEGORY |
-                         GAIM_ROOMLIST_ROOMTYPE_ROOM, altname, parent);
-                }
-                gaim_roomlist_room_add_field(roomlist, room, altname);
-                gaim_roomlist_room_add_field(roomlist, room, roominst[0]);
-                gaim_roomlist_room_add(roomlist, room);
-                g_free(altname);
-                g_strfreev(roominst);
-                old_level = level;
-            }
-        } else if (pattern == NULL) {
-            /**
-             * This is a plain category, determine the level and
-             * the parent and add it.
-             */
-            level = roomlist_level_strip(roomarr[i]);
-            parent = find_parent(level, old_level, room);
-            room =
-                gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_CATEGORY,
-                                       roomarr[i], parent);
-            gaim_roomlist_room_add(roomlist, room);
-        }
-        old_level = level;
-    }
-    g_strfreev(roomarr);
-    gaim_roomlist_set_in_progress(roomlist, FALSE);
-}
-
-GaimConvChatBuddyFlags chat_pecking_order(const char *extra)
-{
-    GaimConvChatBuddyFlags flags = GAIM_CBFLAGS_NONE;
-    if (extra[0] == '1' && extra[1] == '8') {
-        /* profile and g-rated photo */
-        flags = GAIM_CBFLAGS_FOUNDER;
-    } else if (extra[0] == '1' && extra[1] == '9') {
-        /* profile and x-rated photo */
-        flags = GAIM_CBFLAGS_OP;
-    } else if (extra[0] == '8') {
-        /* profile but no photo */
-        flags = GAIM_CBFLAGS_HALFOP;
-    } else if (extra[0] == '0') {
-        /* no profile and no photo */
-        flags = GAIM_CBFLAGS_NONE;
-    } else {
-        /* unknown */
-        flags = GAIM_CBFLAGS_VOICE;
-    }
-    return flags;
-}
-
-char *build_tooltip_text(struct gaym_buddy *ib)
-{
-    char *escaped;
-    GString *tooltip = g_string_new("");
-    g_string_printf(tooltip, "<b><i>%s</i></b>", ib->name);
-
-    g_return_val_if_fail(ib != NULL, NULL);
-
-    if (ib->sex) {
-        escaped = g_markup_escape_text(ib->sex, strlen(ib->sex));
-        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"), _("Sex"),
-                               escaped);
-        g_free(escaped);
-    }
-
-    if (ib->age) {
-        escaped = g_markup_escape_text(ib->age, strlen(ib->age));
-        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"), _("Age"),
-                               escaped);
-        g_free(escaped);
-    }
-    if (ib->location) {
-        escaped = g_markup_escape_text(ib->location, strlen(ib->location));
-        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"),
-                               _("Location"), escaped);
-        g_free(escaped);
-    }
-
-    if (ib->bio) {
-        escaped = g_markup_escape_text(ib->bio, strlen(ib->bio));
-        g_string_append_printf(tooltip, _("\n<b>%s:</b> %s"), _("Bio"),
-                               escaped);
-        g_free(escaped);
-    }
-
-    if (tooltip->len == 0) {
-        g_string_append_printf(tooltip, _(" No info."));
-    }
-    // g_string_erase(tooltip, 0, 1);
-
-    return g_string_free(tooltip, FALSE);
-}
-
-GaimConvChatBuddyFlags include_chat_entry_order(GaimConvChatBuddyFlags
-                                                flags, gint entry)
-{
-
-    return (flags | (entry << 4));
-}
-
-/**
- * vim:tabstop=4:shiftwidth=4:expandtab:
- */

Copied: qrc/tags/release-0.9/gaym/src/helpers.c (from rev 261, qrc/trunk/gaym/src/helpers.c)

Deleted: qrc/tags/release-0.9/gaym/src/msgs.c
===================================================================
--- qrc/trunk/gaym/src/msgs.c	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/tags/release-0.9/gaym/src/msgs.c	2005-07-31 19:13:29 UTC (rev 264)
@@ -1,1331 +0,0 @@
-/**
- * @file msgs.c
- *
- * GayM
- *
- * GayM is the legal property of its developers, whose names are too numerous
- * to list here.  Please refer to the COPYRIGHT file distributed with this
- * source distribution.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include "internal.h"
-#include "conversation.h"
-#include "blist.h"
-#include "notify.h"
-#include "util.h"
-#include "debug.h"
-#include "imgstore.h"
-#include "request.h"
-#include "privacy.h"
-#include "prefs.h"
-
-#include "botfilter.h"
-#include "gaym.h"
-#include "gayminfo.h"
-#include "gaympriv.h"
-#include "helpers.h"
-
-static char *gaym_mask_nick(const char *mask)
-{
-    char *end, *buf;
-
-    end = strchr(mask, '!');
-    if (!end)
-        buf = g_strdup(mask);
-    else
-        buf = g_strndup(mask, end - mask);
-
-    return buf;
-}
-
-static void gaym_chat_remove_buddy(GaimConversation * convo, char *data[2])
-{
-    /**
-     * FIXME: is *message ever used ???
-     */
-    char *message = g_strdup_printf("quit: %s", data[1]);
-
-    if (gaim_conv_chat_find_user(GAIM_CONV_CHAT(convo), data[0]))
-        gaim_conv_chat_remove_user(GAIM_CONV_CHAT(convo), data[0], NULL);
-
-    g_free(message);
-}
-
-void gaym_msg_default(struct gaym_conn *gaym, const char *name,
-                      const char *from, char **args)
-{
-    gaim_debug(GAIM_DEBUG_INFO, "gaym", "Unrecognized message: %s\n",
-               args[0]);
-}
-
-void gaym_msg_away(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-
-    if (!args || !args[1] || !gc) {
-        return;
-    }
-
-    gcom_nick_to_gaym(args[1]);
-    serv_got_im(gc, args[1], args[2], GAIM_CONV_IM_AUTO_RESP, time(NULL));
-}
-
-static void gaym_fetch_photo_cb(void *user_data, const char *info_data,
-                                size_t len)
-{
-    if (!info_data || !user_data) {
-        return;
-    }
-
-    struct gaym_fetch_thumbnail_data *d = user_data;
-
-    char *info, *t;
-
-    struct gaym_conn *gaym = d->gc->proto_data;
-
-    char *hashurl =
-        g_hash_table_lookup(gaym->confighash, "view-profile-url");
-    g_return_if_fail(hashurl != NULL);
-
-    int id = gaim_imgstore_add(info_data, len, NULL);
-    if (d->stats && d->bio)
-        info =
-            g_strdup_printf
-            ("<b>Stats:</b> %s<br><b>Bio:</b> %s<br><img id=%d><br><a href='%s%s'>Full Profile</a>",
-             d->stats, d->bio, id, hashurl, d->who);
-    else if (d->stats)
-        info =
-            g_strdup_printf
-            ("<b>Stats:</b> %s<br><img id=%d><br><a href='%s%s'>Full Profile</a>",
-             d->stats, id, hashurl, d->who);
-    else if (d->bio)
-        info =
-            g_strdup_printf
-            ("<b>Bio:</b> %s<br><img id=%d><br><a href='%s%s'>Full Profile</a>",
-             d->bio, id, hashurl, d->who);
-    else
-        info =
-            g_strdup_printf
-            ("No Info Found<br><img id=%d><br><a href='%s%s'>Full Profile</a>",
-             id, hashurl, d->who);
-
-    gaim_notify_userinfo(d->gc, d->who,
-                         t = g_strdup_printf("Gay.com - %s", d->who),
-                         d->who, NULL, info, NULL, NULL);
-    g_free(t);
-
-    if (d) {
-        if (d->who)
-            g_free(d->who);
-        if (d->bio)
-            g_free(d->bio);
-        if (d->stats)
-            g_free(d->stats);
-        g_free(d);
-    }
-    gaim_imgstore_unref(id);
-}
-
-static void gaym_fetch_info_cb(void *user_data, const char *info_data,
-                               size_t len)
-{
-    struct gaym_fetch_thumbnail_data *d = user_data;
-    char *picpath;
-    char *picurl;
-    char *info, *t;
-    char *match = "pictures.0.url=";
-
-    struct gaym_conn *gaym = d->gc->proto_data;
-
-    char *hashurl =
-        g_hash_table_lookup(gaym->confighash, "view-profile-url");
-    g_return_if_fail(hashurl != NULL);
-
-    if (d->stats && d->bio)
-        info =
-            g_strdup_printf
-            ("<b>Stats:</b> %s<br><b>Bio:</b> %s<br><a href='%s%s'>Full Profile</a>",
-             d->stats, d->bio, hashurl, d->who);
-    else if (d->stats)
-        info =
-            g_strdup_printf
-            ("<b>Stats:</b> %s<br><a href='%s%s'>Full Profile</a>",
-             d->stats, hashurl, d->who);
-    else if (d->bio)
-        info =
-            g_strdup_printf
-            ("<b>Bio:</b> %s<br><a href='%s%s'>Full Profile</a>",
-             d->bio, hashurl, d->who);
-    else
-        info =
-            g_strdup_printf
-            ("No Info Found<br><a href='%s%s'>Full Profile</a>",
-             hashurl, d->who);
-
-    picpath = return_string_between(match, "\n", info_data);
-    if (!picpath || strlen(picpath) == 0) {
-        gaim_notify_userinfo(d->gc, d->who,
-                             t = g_strdup_printf("Gay.com - %s", d->who),
-                             d->who, NULL, info, NULL, NULL);
-        g_free(t);
-        return;
-    }
-
-    picurl = g_strdup_printf("http://www.gay.com%s", picpath);
-    if (picurl) {
-        gaim_url_fetch(picurl, FALSE, "Mozilla/4.0 (compatible; MSIE 5.0)",
-                       FALSE, gaym_fetch_photo_cb, user_data);
-        return;
-    }
-}
-
-void gaym_msg_no_such_nick(struct gaym_conn *gaym, const char *name,
-                           const char *from, char **args)
-{
-    /**
-     * name = 701
-     * from = irc.server.name
-     * args[1] = the nick that wasn't found
-     */
-
-    if (!gaym || !args || !args[1]) {
-        return;
-    }
-
-    gcom_nick_to_gaym(args[1]);
-
-    gaym_buddy_status(gaym, args[1], FALSE, NULL);
-
-    char *normalized = g_strdup(gaim_normalize(gaym->account, args[1]));
-
-    if (g_hash_table_lookup(gaym->info_window_needed, normalized)) {
-        g_hash_table_remove(gaym->info_window_needed, normalized);
-
-        char *hashurl =
-            g_hash_table_lookup(gaym->confighash, "view-profile-url");
-        g_return_if_fail(hashurl != NULL);
-
-        char *buf;
-        buf =
-            g_strdup_printf
-            ("That user is not logged on. Check <a href='%s%s'>here</a> to see if that user has a profile.",
-             hashurl, args[1]);
-        gaim_notify_userinfo(gaim_account_get_connection(gaym->account),
-                             NULL, NULL, "No such user", NULL, buf, NULL,
-                             NULL);
-    }
-    g_free(normalized);
-}
-
-void gaym_msg_whois(struct gaym_conn *gaym, const char *name,
-                    const char *from, char **args)
-{
-    /**
-     * name = 311
-     * from = irc.server.name
-     * args[1] = the nick that we have information about
-     */
-
-    if (!gaym || !args || !args[1]) {
-        return;
-    }
-
-    gcom_nick_to_gaym(args[1]);
-
-    gaym_buddy_status(gaym, args[1], TRUE, args[5]);
-
-    char *normalized = g_strdup(gaim_normalize(gaym->account, args[1]));
-
-    struct gaym_fetch_thumbnail_data *data;
-
-    // Update, but then release the reference. It was already opened
-    // during conversation-created.
-    gaym_update_channel_member(gaym, args[1], args[5]);
-    gaym_unreference_channel_member(gaym, args[1]);
-    gaim_signal_emit(gaim_accounts_get_handle(), "info-updated",
-                     gaym->account, args[1]);
-
-    if (g_hash_table_lookup(gaym->info_window_needed, normalized)) {
-
-        data = g_new0(struct gaym_fetch_thumbnail_data, 1);
-        data->gc = gaim_account_get_connection(gaym->account);
-        data->who = g_strdup(args[1]);
-        data->bio = gaym_bio_strdup(args[5]);
-        data->stats = gaym_stats_strdup(args[5]);
-        g_hash_table_remove(gaym->info_window_needed, normalized);
-        char *hashurl = g_hash_table_lookup(gaym->confighash,
-                                            "ohm.profile-url");
-        g_return_if_fail(hashurl != NULL);
-
-        char *infourl = g_strdup_printf("%s?pw=%s&name=%s", hashurl,
-                                        gaym->chat_key, args[1]);
-        if (infourl) {
-            gaim_url_fetch(infourl, FALSE,
-                           "Mozilla/4.0 (compatible; MSIE 5.0)", FALSE,
-                           gaym_fetch_info_cb, data);
-            g_free(infourl);
-        }
-    }
-    g_free(normalized);
-}
-
-void gaym_msg_login_failed(struct gaym_conn *gaym, const char *name,
-                           const char *from, char **args)
-{
-
-
-
-    gaym_cmd_quit(gaym, "quit", NULL, NULL);
-
-    // if (gc->inpa)
-    // gaim_input_remove(gc->inpa);
-
-    // g_free(gaym->inbuf);
-    // gaim_debug_misc("gaym", "Login failed. closing fd %i\n", gaym->fd);
-    // close(gaym->fd);
-    // gaim_debug_misc("gaym", "Get chatkey from weblogin\n");
-    // gaym_get_hash_from_weblogin(gaym->account,
-    // gaym_login_with_chat_key);
-
-}
-
-void gaym_msg_list(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args)
-{
-    /**
-     * If you free anything here related to the roomlist
-     * be sure you test what happens when the roomlist reference
-     * count goes to zero! Because it may crash gaim.
-     */
-    if (!gaym->roomlist) {
-        return;
-    }
-    /**
-     * Begin result of member created room list
-     */
-    if (!strcmp(name, "321") && gaym->roomlist_filter == NULL) {
-        GaimRoomlistRoom *room;
-        room = gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_CATEGORY,
-                                      _("Member Created"), NULL);
-        gaim_roomlist_room_add(gaym->roomlist, room);
-        gaim_roomlist_set_in_progress(gaym->roomlist, TRUE);
-        return;
-    }
-
-    /**
-     * The list of member created rooms
-     */
-    if (!strcmp(name, "322")) {
-        GaimRoomlistRoom *room;
-        char *field_start = NULL;
-        char *field_end = NULL;
-        size_t field_len = 0;
-        int i = 0;
-
-        if (!args[1]) {
-            return;
-        }
-
-        /**
-         * strip leading "#_" and trailing "=1"
-         */
-        field_start = strchr(args[1], '_');
-        field_end = strrchr(args[1], '=');
-
-        if (!field_start || !field_end) {
-            gaim_debug_error("gaym",
-                             "Member created room list parsing error");
-            return;
-        }
-        field_start++;
-        field_end = field_end + 2;
-
-        field_len = field_end - field_start;
-
-        char *field_name = g_strndup(field_start, field_len);
-
-        /**
-         * replace all remaining "_" with " "
-         */
-        for (i = 0; field_name[i] != '\0'; i++) {
-            if (field_name[i] == '_') {
-                field_name[i] = ' ';
-            }
-        }
-        /**
-         * replace '=' with ':'
-         */
-        field_name[i - 2] = ':';
-
-        gchar *lowercase = g_utf8_strdown(field_name, -1);
-        gchar *normalized =
-            g_utf8_normalize(lowercase, -1, G_NORMALIZE_ALL);
-        g_free(lowercase);
-        if (gaym->roomlist_filter == NULL ||
-            g_strstr_len(normalized, -1, gaym->roomlist_filter) != NULL) {
-
-            room = gaim_roomlist_room_new(GAIM_ROOMLIST_ROOMTYPE_ROOM,
-                                          field_name,
-                                          g_list_nth_data(gaym->roomlist->
-                                                          rooms, 0));
-            gaim_roomlist_room_add_field(gaym->roomlist, room, field_name);
-            gaim_roomlist_room_add_field(gaym->roomlist, room, args[1]);
-            gaim_roomlist_room_add(gaym->roomlist, room);
-        }
-        g_free(normalized);
-        g_free(field_name);
-    }
-
-    /**
-     * End result of member created room list
-     * This is our trigger to add the static rooms
-     */
-    if (!strcmp(name, "323")) {
-        build_roomlist_from_config(gaym->roomlist, gaym->confighash,
-                                   gaym->roomlist_filter);
-        if (gaym->roomlist_filter) {
-            g_free(gaym->roomlist_filter);
-            gaym->roomlist_filter = NULL;
-        }
-        return;
-    }
-}
-
-void gaym_msg_unknown(struct gaym_conn *gaym, const char *name,
-                      const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *buf;
-
-    if (!args || !args[1] || !gc)
-        return;
-
-    buf = g_strdup_printf(_("Unknown message '%s'"), args[1]);
-    gaim_notify_error(gc, _("Unknown message"), buf,
-                      _
-                      ("Gaim has sent a message the IRC server did not understand."));
-    g_free(buf);
-}
-
-void gaym_msg_names(struct gaym_conn *gaym, const char *name,
-                    const char *from, char **args)
-{
-    char *names, *cur, *end, *tmp, *msg;
-    GaimConversation *convo;
-
-    if (!strcmp(name, "366")) {
-        convo =
-            gaim_find_conversation_with_account(gaym->nameconv ? gaym->
-                                                nameconv : args[1],
-                                                gaym->account);
-        if (!convo) {
-            gaim_debug(GAIM_DEBUG_ERROR, "gaym",
-                       "Got a NAMES list for %s, which doesn't exist\n",
-                       args[2]);
-            g_string_free(gaym->names, TRUE);
-            gaym->names = NULL;
-            g_free(gaym->nameconv);
-            gaym->nameconv = NULL;
-            return;
-        }
-
-        names = cur = g_string_free(gaym->names, FALSE);
-        gaym->names = NULL;
-        if (gaym->nameconv) {
-            msg =
-                g_strdup_printf(_("Users on %s: %s"),
-                                args[1] ? args[1] : "",
-                                names ? names : "");
-            if (gaim_conversation_get_type(convo) == GAIM_CONV_CHAT)
-                gaim_conv_chat_write(GAIM_CONV_CHAT(convo), "", msg,
-                                     GAIM_MESSAGE_SYSTEM |
-                                     GAIM_MESSAGE_NO_LOG, time(NULL));
-            else
-                gaim_conv_im_write(GAIM_CONV_IM(convo), "", msg,
-                                   GAIM_MESSAGE_SYSTEM |
-                                   GAIM_MESSAGE_NO_LOG, time(NULL));
-            g_free(msg);
-            g_free(gaym->nameconv);
-            gaym->nameconv = NULL;
-        } else {
-            GList *users = NULL;
-
-            while (*cur) {
-                end = strchr(cur, ' ');
-                tmp = g_strndup(cur, end - cur);
-                gcom_nick_to_gaym(tmp);
-                users = g_list_prepend(users, tmp);
-                cur = end;
-                if (*cur)
-                    cur++;
-            }
-            users = g_list_reverse(users);
-
-            if (users != NULL) {
-                GList *l;
-
-                gaim_conv_chat_add_users(GAIM_CONV_CHAT(convo), users,
-                                         NULL);
-
-                for (l = users; l != NULL; l = l->next)
-                    g_free(l->data);
-
-                g_list_free(users);
-            }
-        }
-        g_free(names);
-    } else {
-        if (!gaym->names)
-            gaym->names = g_string_new("");
-
-        gaym->names = g_string_append(gaym->names, args[3]);
-    }
-}
-
-/**
- * Change this to WELCOME
- */
-
-void gaym_msg_endmotd(struct gaym_conn *gaym, const char *name,
-                      const char *from, char **args)
-{
-    GaimConnection *gc;
-
-    gaim_debug_misc("gaym", "Got motd\n");
-
-    gc = gaim_account_get_connection(gaym->account);
-    if (!gc) {
-        gaim_debug_misc("gaym", "!gc ???\n");
-        return;
-    }
-    gaim_connection_set_state(gc, GAIM_CONNECTED);
-    serv_finish_login(gc);
-
-    gaym_blist_timeout(gaym);
-    if (!gaym->timer)
-        gaym->timer =
-            gaim_timeout_add(BLIST_UPDATE_PERIOD,
-                             (GSourceFunc) gaym_blist_timeout,
-                             (gpointer) gaym);
-}
-
-void gaym_msg_nochan(struct gaym_conn *gaym, const char *name,
-                     const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-
-    if (gc == NULL || args == NULL || args[1] == NULL)
-        return;
-
-    gaim_notify_error(gc, NULL, _("No such channel"), args[1]);
-}
-
-void gaym_msg_nonick_chan(struct gaym_conn *gaym, const char *name,
-                          const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-
-    if (gc == NULL || args == NULL || args[1] == NULL)
-        return;
-
-    gaim_notify_error(gc, NULL, _("Not logged in:"), args[1]);
-}
-
-void gaym_msg_nonick(struct gaym_conn *gaym, const char *name,
-                     const char *from, char **args)
-{
-    GaimConnection *gc;
-    GaimConversation *convo;
-
-    convo = gaim_find_conversation_with_account(args[1], gaym->account);
-    if (convo) {
-        if (gaim_conversation_get_type(convo) == GAIM_CONV_CHAT) {
-            /* does this happen? */
-            gaim_conv_chat_write(GAIM_CONV_CHAT(convo), args[1],
-                                 _("no such channel"),
-                                 GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
-                                 time(NULL));
-        } else {
-            gaim_conv_im_write(GAIM_CONV_IM(convo), args[1],
-                               _("User is not logged in"),
-                               GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
-                               time(NULL));
-        }
-    } else {
-        if ((gc = gaim_account_get_connection(gaym->account)) == NULL)
-            return;
-        gaim_notify_error(gc, NULL, _("No such nick or channel"), args[1]);
-    }
-}
-
-void gaym_msg_nosend(struct gaym_conn *gaym, const char *name,
-                     const char *from, char **args)
-{
-    GaimConnection *gc;
-    GaimConversation *convo;
-
-    convo = gaim_find_conversation_with_account(args[1], gaym->account);
-    if (convo) {
-        gaim_conv_chat_write(GAIM_CONV_CHAT(convo), args[1], args[2],
-                             GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
-                             time(NULL));
-    } else {
-        if ((gc = gaim_account_get_connection(gaym->account)) == NULL)
-            return;
-        gaim_notify_error(gc, NULL, _("Could not send"), args[2]);
-    }
-}
-
-/**
- * Is this used?
- */
-void gaym_msg_notinchan(struct gaym_conn *gaym, const char *name,
-                        const char *from, char **args)
-{
-    GaimConversation *convo =
-        gaim_find_conversation_with_account(args[1], gaym->account);
-
-    gaim_debug(GAIM_DEBUG_INFO, "gaym",
-               "We're apparently not in %s, but tried to use it\n",
-               args[1]);
-    if (convo) {
-        /* g_slist_remove(gaym->gc->buddy_chats, convo);
-           gaim_conversation_set_account(convo, NULL); */
-        gaim_conv_chat_write(GAIM_CONV_CHAT(convo), args[1], args[2],
-                             GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
-                             time(NULL));
-    }
-}
-
-/**
- * Invite WORKS in gay.com!
- */
-void gaym_msg_invite(struct gaym_conn *gaym, const char *name,
-                     const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *nick = gaym_mask_nick(from);
-    GHashTable *components =
-        g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
-
-    if (!args || !args[1] || !gc) {
-        g_free(nick);
-        g_hash_table_destroy(components);
-        return;
-    }
-
-    if (!gaym_privacy_check(gc, nick)) {
-        g_free(nick);
-        g_hash_table_destroy(components);
-        return;
-    }
-
-    g_hash_table_insert(components, strdup("channel"), strdup(args[1]));
-    gcom_nick_to_gaym(nick);
-    serv_got_chat_invite(gc, args[1], nick, NULL, components);
-
-    g_free(nick);
-}
-
-void gaym_msg_inviteonly(struct gaym_conn *gaym, const char *name,
-                         const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *buf;
-
-    if (!args || !args[1] || !gc)
-        return;
-
-    buf =
-        g_strdup_printf(_("Joining %s requires an invitation."), args[1]);
-    gaim_notify_error(gc, _("Invitation only"), _("Invitation only"), buf);
-    g_free(buf);
-}
-
-void gaym_msg_trace(struct gaym_conn *gaym, const char *name,
-                    const char *from, char **args)
-{
-    GaimConversation *conv =
-        gaim_find_conversation_with_account(gaym->traceconv ? gaym->
-                                            traceconv : args[1],
-                                            gaym->account);
-    gaim_conversation_write(conv, "TRACE", args[3],
-                            GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
-                            time(NULL));
-
-}
-
-void gaym_msg_join(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    g_return_if_fail(gc != NULL);
-
-    char *nick = gaym_mask_nick(from);
-
-    GaimConversation *convo;
-    GaimConvChatBuddyFlags flags = GAIM_CBFLAGS_NONE;
-    char *bio = NULL;
-    char *bio_markedup = NULL;
-    static int id = 1;
-
-    gcom_nick_to_gaym(nick);
-    if (!gaim_utf8_strcasecmp(nick, gaim_connection_get_display_name(gc))) {
-        /* We are joining a channel for the first time */
-        if (gaym->persist_room && !strcmp(gaym->persist_room, args[0])) {
-            g_free(gaym->persist_room);
-            gaym->persist_room = NULL;
-            gaim_request_close(GAIM_REQUEST_ACTION,
-                               gaym->hammer_cancel_dialog);
-
-        }
-
-        serv_got_joined_chat(gc, id++, args[0]);
-
-        gint *entry = g_new(gint, 1);
-        *entry = MAX_CHANNEL_MEMBERS;
-        g_hash_table_insert(gaym->entry_order, g_strdup(args[0]), entry);
-
-        g_free(nick);
-        return;
-    }
-
-    convo = gaim_find_conversation_with_account(args[0], gaym->account);
-    if (convo == NULL) {
-        gaim_debug(GAIM_DEBUG_ERROR, "gaym", "JOIN for %s failed\n",
-                   args[0]);
-        g_free(nick);
-        return;
-    }
-
-    gint *entry = g_hash_table_lookup(gaym->entry_order, args[0]);
-    g_return_if_fail(entry != NULL);
-
-    gaym_buddy_status(gaym, nick, TRUE, args[1]);
-
-
-    gboolean gaym_botfilter_permit =
-        gaym_botfilter_check(gc, nick, bio, FALSE);
-
-    bio = gaym_bio_strdup(args[1]);
-    if (bio) {
-        bio_markedup = gaim_markup_linkify(bio);
-        g_free(bio);
-    }
-
-    if (*entry <= MAX_CHANNEL_MEMBERS) {
-        *entry = MAX_CHANNEL_MEMBERS + 1;
-    }
-
-    flags = chat_pecking_order(args[1]);
-    flags = include_chat_entry_order(flags, (*entry)++);
-
-    gboolean gaym_privacy_permit = gaym_privacy_check(gc, nick);
-    gboolean show_join =
-        gaim_prefs_get_bool("/plugins/prpl/gaym/show_join");
-
-    if (gaim_prefs_get_bool("/plugins/prpl/gaym/show_bio_with_join")) {
-        gaim_conv_chat_add_user(GAIM_CONV_CHAT(convo), nick, bio_markedup,
-                                flags, (gaym_privacy_permit
-                                        && gaym_botfilter_permit
-                                        && show_join));
-    } else {
-        gaim_conv_chat_add_user(GAIM_CONV_CHAT(convo), nick, NULL,
-                                flags, (gaym_privacy_permit
-                                        && gaym_botfilter_permit
-                                        && show_join));
-    }
-
-    /**
-     * Make the ignore.png icon appear next to the nick.
-     */
-    GaimConversationUiOps *ops = gaim_conversation_get_ui_ops(convo);
-    if (gaym_privacy_permit && gaym_botfilter_permit) {
-        gaim_conv_chat_unignore(GAIM_CONV_CHAT(convo), nick);
-    } else {
-        gaim_conv_chat_ignore(GAIM_CONV_CHAT(convo), nick);
-    }
-    ops->chat_update_user((convo), nick);
-
-    gaym_update_channel_member(gaym, nick, args[1]);
-    g_free(bio_markedup);
-    g_free(nick);
-}
-
-void gaym_msg_mode(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args)
-{
-    GaimConversation *convo;
-    char *nick = gaym_mask_nick(from), *buf;
-
-    if (*args[0] == '#' || *args[0] == '&') {   /* Channel */
-        convo =
-            gaim_find_conversation_with_account(args[0], gaym->account);
-        if (!convo) {
-            gaim_debug(GAIM_DEBUG_ERROR, "gaym",
-                       "MODE received for %s, which we are not in\n",
-                       args[0]);
-            g_free(nick);
-            return;
-        }
-        buf =
-            g_strdup_printf(_("mode (%s %s) by %s"), args[1],
-                            args[2] ? args[2] : "", nick);
-        gaim_conv_chat_write(GAIM_CONV_CHAT(convo), args[0], buf,
-                             GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
-                             time(NULL));
-        g_free(buf);
-        if (args[2]) {
-            GaimConvChatBuddyFlags newflag, flags;
-            char *mcur, *cur, *end, *user;
-            gboolean add = FALSE;
-            mcur = args[1];
-            cur = args[2];
-            while (*cur && *mcur) {
-                if ((*mcur == '+') || (*mcur == '-')) {
-                    add = (*mcur == '+') ? TRUE : FALSE;
-                    mcur++;
-                    continue;
-                }
-                end = strchr(cur, ' ');
-                if (!end)
-                    end = cur + strlen(cur);
-                user = g_strndup(cur, end - cur);
-                flags =
-                    gaim_conv_chat_user_get_flags(GAIM_CONV_CHAT(convo),
-                                                  user);
-                newflag = GAIM_CBFLAGS_NONE;
-                if (*mcur == 'o')
-                    newflag = GAIM_CBFLAGS_OP;
-                else if (*mcur == 'h')
-                    newflag = GAIM_CBFLAGS_HALFOP;
-                else if (*mcur == 'v')
-                    newflag = GAIM_CBFLAGS_VOICE;
-                if (newflag) {
-                    if (add)
-                        flags |= newflag;
-                    else
-                        flags &= ~newflag;
-                    gaim_conv_chat_user_set_flags(GAIM_CONV_CHAT(convo),
-                                                  user, flags);
-                }
-                g_free(user);
-                cur = end;
-                if (*cur)
-                    cur++;
-                if (*mcur)
-                    mcur++;
-            }
-        }
-    } else {                    /* User */
-    }
-    g_free(nick);
-}
-
-void gaym_msg_nick(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args)
-{
-    GSList *chats;
-
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *nick = gaym_mask_nick(from);
-
-    if (!gc) {
-        g_free(nick);
-        return;
-    }
-
-    chats = gc->buddy_chats;
-
-    if (!gaim_utf8_strcasecmp(nick, gaim_connection_get_display_name(gc))) {
-        gaim_connection_set_display_name(gc, args[0]);
-    }
-
-    while (chats) {
-        GaimConvChat *chat = GAIM_CONV_CHAT(chats->data);
-        /* This is ugly ... */
-        if (gaim_conv_chat_find_user(chat, nick))
-            gaim_conv_chat_rename_user(chat, nick, args[0]);
-        chats = chats->next;
-    }
-    g_free(nick);
-}
-
-void gaym_msg_notice(struct gaym_conn *gaym, const char *name,
-                     const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-
-    if (!gc) {
-        return;
-    }
-
-    char *newargs[2];
-
-    newargs[0] = " notice ";    /* The spaces are magic, leave 'em in! */
-    newargs[1] = args[1];
-    gaym_msg_privmsg(gaym, name, from, newargs);
-}
-
-void gaym_msg_part(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args)
-{
-    GaimConversation *convo;
-    char *msg;
-
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *nick = gaym_mask_nick(from);
-
-    if (!args || !args[0] || !gc || !nick) {
-        g_free(nick);
-        return;
-    }
-
-    convo = gaim_find_conversation_with_account(args[0], gaym->account);
-    gboolean show_part =
-        gaim_prefs_get_bool("/plugins/prpl/gaym/show_part");
-
-    gcom_nick_to_gaym(nick);
-    if (!gaim_utf8_strcasecmp(nick, gaim_connection_get_display_name(gc))) {
-
-        g_hash_table_remove(gaym->entry_order, args[0]);
-        msg = g_strdup_printf(_("You have parted the channel"));
-
-        gaim_conv_chat_write(GAIM_CONV_CHAT(convo), args[0], msg,
-                             GAIM_MESSAGE_SYSTEM, time(NULL));
-        g_free(msg);
-        serv_got_chat_left(gc,
-                           gaim_conv_chat_get_id(GAIM_CONV_CHAT(convo)));
-    } else {
-        if (!gaim_conv_chat_is_user_ignored(GAIM_CONV_CHAT(convo), nick)
-            && show_part) {
-            gaim_conv_chat_remove_user(GAIM_CONV_CHAT(convo), nick, NULL);
-        } else {
-            GaimConversationUiOps *ops =
-                gaim_conversation_get_ui_ops(convo);
-            if (ops != NULL && ops->chat_remove_user != NULL) {
-                ops->chat_remove_user(convo, nick);
-            }
-            GaimConvChatBuddy *cb =
-                gaim_conv_chat_cb_find(GAIM_CONV_CHAT(convo), nick);
-            if (cb) {
-                gaim_conv_chat_set_users(GAIM_CONV_CHAT(convo),
-                                         g_list_remove
-                                         (gaim_conv_chat_get_users
-                                          (GAIM_CONV_CHAT(convo)), cb));
-                gaim_conv_chat_cb_destroy(cb);
-                if (!gaym_unreference_channel_member(gaym, nick))
-                    gaim_debug_error("gaym",
-                                     "channel_members reference counting bug.\n");
-            }
-        }
-    }
-
-    g_free(nick);
-}
-
-void gaym_msg_ping(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args)
-{
-    char *buf;
-    if (!args || !args[0])
-        return;
-
-    buf = gaym_format(gaym, "v:", "PONG", args[0]);
-    gaym_send(gaym, buf);
-    g_free(buf);
-}
-
-void gaym_msg_pong(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args)
-{
-    GaimConversation *convo;
-    GaimConnection *gc;
-    char **parts, *msg;
-    time_t oldstamp;
-
-    if (!args || !args[1])
-        return;
-
-    parts = g_strsplit(args[1], " ", 2);
-
-    if (!parts[0] || !parts[1]) {
-        g_strfreev(parts);
-        return;
-    }
-
-    if (sscanf(parts[1], "%lu", &oldstamp) != 1) {
-        msg = g_strdup(_("Error: invalid PONG from server"));
-    } else {
-        msg =
-            g_strdup_printf(_("PING reply -- Lag: %lu seconds"),
-                            time(NULL) - oldstamp);
-    }
-
-    convo = gaim_find_conversation_with_account(parts[0], gaym->account);
-    g_strfreev(parts);
-    if (convo) {
-        if (gaim_conversation_get_type(convo) == GAIM_CONV_CHAT)
-            gaim_conv_chat_write(GAIM_CONV_CHAT(convo), "PONG", msg,
-                                 GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
-                                 time(NULL));
-        else
-            gaim_conv_im_write(GAIM_CONV_IM(convo), "PONG", msg,
-                               GAIM_MESSAGE_SYSTEM | GAIM_MESSAGE_NO_LOG,
-                               time(NULL));
-    } else {
-        gc = gaim_account_get_connection(gaym->account);
-        if (!gc) {
-            g_free(msg);
-            return;
-        }
-        gaim_notify_info(gc, NULL, "PONG", msg);
-    }
-    g_free(msg);
-}
-
-void gaym_msg_privmsg(struct gaym_conn *gaym, const char *name,
-                      const char *from, char **args)
-{
-    GaimConversation *convo;
-    char *tmp, *msg;
-    int notice = 0;
-
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *nick = gaym_mask_nick(from);
-
-    if (!args || !args[0] || !args[1] || !gc) {
-        g_free(nick);
-        return;
-    }
-
-    /**
-     * Only nicks (sender/receiver) should use gcom_nick_to_gaym().
-     *
-     * Channels (which begin with either "#" or "&") should not be
-     * converted.
-     *
-     * Messages should also not be converted.
-     *
-     * CHAT ROOM:
-     * nick = the sender
-     * args[0] = the receiving channel
-     * args[1] = the message
-     *
-     * INSTANT MESSAGE:
-     * nick = the sender
-     * args[0] = the receiver (me)
-     * args[1] = the message
-     *
-     * NOTICE:
-     * nick = the sender
-     * args[0] = " notice "
-     * args[1] = the message
-     */
-    gcom_nick_to_gaym(nick);
-    if (args[0][0] != '#' && args[0][0] != '&') {
-        gcom_nick_to_gaym(args[0]);
-    }
-
-    convo = gaim_find_conversation_with_account(args[0], gaym->account);
-
-    notice = !strcmp(args[0], " notice ");
-    tmp = gaym_parse_ctcp(gaym, nick, args[0], args[1], notice);
-
-    if (!tmp) {
-        g_free(nick);
-        return;
-    }
-
-    if (!gaym_privacy_check(gc, nick)) {
-        g_free(nick);
-        return;
-    }
-
-    msg = gaim_escape_html(tmp);
-
-    g_free(tmp);
-
-    if (notice) {
-        tmp = g_strdup_printf("(notice) %s", msg);
-        g_free(msg);
-        msg = tmp;
-    }
-
-    if (!gaim_utf8_strcasecmp
-        (args[0], gaim_connection_get_display_name(gc))) {
-        serv_got_im(gc, nick, msg, 0, time(NULL));
-    } else if (notice) {
-        serv_got_im(gc, nick, msg, 0, time(NULL));
-    } else if (convo) {
-
-        serv_got_chat_in(gc, gaim_conv_chat_get_id(GAIM_CONV_CHAT(convo)),
-                         nick, 0, msg, time(NULL));
-    } else {
-        gaim_debug(GAIM_DEBUG_ERROR, "gaym",
-                   "Got a PRIVMSG on %s, which does not exist\n", args[0]);
-    }
-
-    g_free(msg);
-    g_free(nick);
-}
-
-void gaym_msg_regonly(struct gaym_conn *gaym, const char *name,
-                      const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *msg;
-
-    if (!args || !args[1] || !args[2] || !gc)
-        return;
-
-    msg = g_strdup_printf(_("Cannot join %s:"), args[1]);
-    gaim_notify_error(gc, _("Cannot join channel"), msg, args[2]);
-    g_free(msg);
-}
-
-/* I don't think gay.com ever sends this message */
-void gaym_msg_quit(struct gaym_conn *gaym, const char *name,
-                   const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *data[2];
-
-    if (!args || !args[0] || !gc)
-        return;
-
-    data[0] = gaym_mask_nick(from);
-    data[1] = args[0];
-    /* XXX this should have an API, I shouldn't grab this directly */
-    g_slist_foreach(gc->buddy_chats, (GFunc) gaym_chat_remove_buddy, data);
-
-    gaym_buddy_status(gaym, data[0], FALSE, NULL);
-
-    g_free(data[0]);
-
-    return;
-}
-
-void gaym_msg_who(struct gaym_conn *gaym, const char *name,
-                  const char *from, char **args)
-{
-}
-
-void hammer_stop_cb(gpointer data)
-{
-
-    struct gaym_conn *gaym = (struct gaym_conn *) data;
-
-    gaym->cancelling_persist = TRUE;
-    gaim_debug_misc("gaym", "Cancelling persist: %s\n",
-                    gaym->persist_room);
-}
-
-void hammer_cb(gpointer data)
-{
-
-    struct gaym_conn *gaym = (struct gaym_conn *) data;
-    const char *args[1];
-    char *msg;
-    gaim_debug_misc("gaym", "Persisting room %s\n", gaym->persist_room);
-    args[0] = gaym->persist_room;
-    gaym->cancelling_persist = FALSE;
-    msg = g_strdup_printf("Hammering into room %s", gaym->persist_room);
-    gaym->hammer_cancel_dialog =
-        gaim_request_action(gaym->account->gc, _("Cancel Hammer"), msg,
-                            NULL, 0, gaym, 1, ("Cancel"), hammer_stop_cb);
-
-    gaym_cmd_join(gaym, NULL, NULL, args);
-    if (msg)
-        g_free(msg);
-}
-
-void gaym_msg_chanfull(struct gaym_conn *gaym, const char *name,
-                       const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *buf;
-    const char *joinargs[1];
-
-    if (!args || !args[1] || !gc)
-        return;
-
-    joinargs[0] = args[1];
-
-    if (gaym->persist_room && !strcmp(gaym->persist_room, args[1]))
-        if (gaym->cancelling_persist) {
-            if (gaym->persist_room) {
-                g_free(gaym->persist_room);
-                gaym->persist_room = NULL;
-            }
-            gaym->cancelling_persist = FALSE;
-        } else {
-            gaim_debug_misc("gaym", "trying again\n");
-            gaym_cmd_join(gaym, NULL, NULL, joinargs);
-    } else {
-
-        gaym->persist_room = g_strdup(args[1]);
-        buf =
-            g_strdup_printf("%s is full. Do you want to keep trying?",
-                            args[1]);
-        gaim_request_yes_no(gc, _("Room Full"), _("Room Full"), buf, 0,
-                            gaym, hammer_cb, NULL);
-
-        g_free(buf);
-    }
-}
-
-void gaym_msg_create_pay_only(struct gaym_conn *gaym, const char *name,
-                              const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *buf;
-    if (!args || !args[1] || !gc) {
-        return;
-    }
-    buf = g_strdup_printf(_("%s"), args[2]);
-    gaim_notify_error(gc, _("Pay Only"), _("Pay Only"), buf);
-    /**
-     * FIXME
-     * by now the chatroom is already in the buddy list...need
-     * to remove it or something
-     */
-    g_free(buf);
-}
-
-void gaym_msg_pay_channel(struct gaym_conn *gaym, const char *name,
-                          const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *buf;
-
-    if (!args || !args[1] || !gc)
-        return;
-
-    buf =
-        g_strdup_printf(_("The channel %s is for paying members only."),
-                        args[1]);
-    gaim_notify_error(gc, _("Pay Only"), _("Pay Only"), buf);
-    g_free(buf);
-}
-
-void gaym_msg_toomany_channels(struct gaym_conn *gaym, const char *name,
-                               const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *buf;
-
-    if (!args || !args[1] || !gc)
-        return;
-
-    buf =
-        g_strdup_printf(_
-                        ("You have joined too many channels the maximum is (2). You cannot join channel %s. Part another channel first ."),
-                        args[1]);
-    gaim_notify_error(gc, _("Maximum ChannelsReached"),
-                      _("Maximum ChannelsReached"), buf);
-    g_free(buf);
-}
-
-void gaym_msg_list_busy(struct gaym_conn *gaym, const char *name,
-                        const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    char *buf;
-    if (!args || !args[1] || !gc) {
-        return;
-    }
-    buf = g_strdup_printf(_("%s"), args[1]);
-    gaim_notify_error(gc, _("Server Busy"), _("Server Busy"), buf);
-    // if (gaym->roomlist) {
-    // gaim_roomlist_cancel_get_list(gaym->roomlist);
-    // }
-    g_free(buf);
-    /**
-     * Can't get member created rooms right now.
-     * This is our trigger to add the static rooms
-     */
-    build_roomlist_from_config(gaym->roomlist, gaym->confighash,
-                               gaym->roomlist_filter);
-    if (gaym->roomlist_filter) {
-        g_free(gaym->roomlist_filter);
-        gaym->roomlist_filter = NULL;
-    }
-    return;
-
-}
-
-void gaym_msg_richnames_list(struct gaym_conn *gaym, const char *name,
-                             const char *from, char **args)
-{
-    GaimConnection *gc = gaim_account_get_connection(gaym->account);
-    GaimConversation *convo;
-    GaimConvChatBuddyFlags flags = GAIM_CBFLAGS_NONE;
-    char *channel = args[1];
-    char *nick = args[2];
-    char *extra = args[4];
-
-    if (!gc) {
-        return;
-    }
-
-    gcom_nick_to_gaym(nick);
-    gaim_debug(GAIM_DEBUG_INFO, "gaym",
-               "gaym_msg_richnames_list() Channel: %s Nick: %s Extra: %s\n",
-               channel, nick, extra);
-
-    convo = gaim_find_conversation_with_account(channel, gaym->account);
-
-    char *bio = gaym_bio_strdup(extra);
-    gboolean gaym_botfilter_permit =
-        gaym_botfilter_check(gc, nick, bio, FALSE);
-    g_free(bio);
-
-    gaym_buddy_status(gaym, nick, TRUE, extra);
-
-    if (convo == NULL) {
-        gaim_debug(GAIM_DEBUG_ERROR, "gaym", "690 for %s failed\n",
-                   args[1]);
-        return;
-    }
-
-    gint *entry = g_hash_table_lookup(gaym->entry_order, channel);
-    g_return_if_fail(entry != NULL);
-
-    flags = chat_pecking_order(extra);
-    flags = include_chat_entry_order(flags, (*entry)--);
-
-    gaim_conv_chat_add_user(GAIM_CONV_CHAT(convo), nick, NULL, flags,
-                            FALSE);
-
-    /**
-     * Make the ignore.png icon appear next to the nick.
-     */
-    GaimConversationUiOps *ops = gaim_conversation_get_ui_ops(convo);
-    if (gaym_privacy_check(gc, nick) && gaym_botfilter_permit) {
-        gaim_conv_chat_unignore(GAIM_CONV_CHAT(convo), nick);
-    } else {
-        gaim_conv_chat_ignore(GAIM_CONV_CHAT(convo), nick);
-    }
-    ops->chat_update_user((convo), nick);
-    gaym_update_channel_member(gaym, nick, extra);
-}
-
-/**
- * vim:tabstop=4:shiftwidth=4:expandtab:
- */

Copied: qrc/tags/release-0.9/gaym/src/msgs.c (from rev 262, qrc/trunk/gaym/src/msgs.c)

Deleted: qrc/tags/release-0.9/gaym-extras/src/bio-popups.c
===================================================================
--- qrc/trunk/gaym-extras/src/bio-popups.c	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/tags/release-0.9/gaym-extras/src/bio-popups.c	2005-07-31 19:13:29 UTC (rev 264)
@@ -1,459 +0,0 @@
-#include "gaym-extras.h"
-// Consider combining into one popup hash...
-GHashTable *popup_rects;
-GHashTable *popup_timeouts;
-GHashTable *popups;
-void clean_popup_stuff(GaimConversation * c)
-{
-
-    if (!g_strrstr(gaim_account_get_protocol_id(c->account), "prpl-gaym"))
-        return;
-    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-    if (c->type == GAIM_CONV_IM) {
-        g_hash_table_remove(popup_timeouts, gtkconv->tab_label);
-        g_hash_table_remove(popups, gtkconv->tab_label);
-    } else if (c->type == GAIM_CONV_CHAT) {
-        GaimGtkChatPane *gtkchat = gtkconv->u.chat;
-        g_hash_table_remove(popup_timeouts, gtkchat->list);
-        g_hash_table_remove(popup_rects, gtkchat->list);
-        g_hash_table_remove(popups, gtkchat->list);
-    }
-
-}
-
-static void namelist_leave_cb(GtkWidget * tv, GdkEventCrossing * e,
-                              gpointer n)
-{
-    // This prevent clicks from demloishing popups.
-    if (e->mode != GDK_CROSSING_NORMAL)
-        return;
-
-    guint *timeout = g_hash_table_lookup(popup_timeouts, tv);
-    g_hash_table_remove(popups, tv);
-
-    if (*timeout) {
-        g_source_remove(*timeout);
-        *timeout = 0;
-    }
-}
-
-static void namelist_paint_tip(GtkWidget * tipwindow,
-                               GdkEventExpose * event, gpointer data)
-{
-    g_return_if_fail(data);
-
-    char *tooltiptext = ((struct paint_data *) data)->tooltiptext;
-    GdkPixbuf *pixbuf = ((struct paint_data *) data)->pixbuf;
-    GtkStyle *style = NULL;
-
-    PangoLayout *layout;
-
-    layout = gtk_widget_create_pango_layout(tipwindow, NULL);
-    pango_layout_set_markup(layout, tooltiptext, strlen(tooltiptext));
-    pango_layout_set_wrap(layout, PANGO_WRAP_WORD);
-    pango_layout_set_width(layout, 300000);
-    style = tipwindow->style;
-
-    gtk_paint_flat_box(style, tipwindow->window, GTK_STATE_NORMAL,
-                       GTK_SHADOW_OUT, NULL, tipwindow, "tooltip", 0, 0,
-                       -1, -1);
-
-#if GTK_CHECK_VERSION(2,2,0)
-    gdk_draw_pixbuf(GDK_DRAWABLE(tipwindow->window), NULL, pixbuf,
-                    0, 0, 4, 4, -1, -1, GDK_RGB_DITHER_NONE, 0, 0);
-#else
-    gdk_pixbuf_render_to_drawable(pixbuf,
-                                  GDK_DRAWABLE(tipwindow->window), NULL, 0,
-                                  0, 4, 4, -1, -1, GDK_RGB_DITHER_NONE, 0,
-                                  0);
-#endif
-
-    gtk_paint_layout(style, tipwindow->window, GTK_STATE_NORMAL, TRUE,
-                     NULL, tipwindow, "tooltip",
-                     gdk_pixbuf_get_width(pixbuf) + 9, 4, layout);
-
-    g_object_unref(pixbuf);
-    g_object_unref(layout);
-    g_free(tooltiptext);
-    g_free(data);
-
-    return;
-}
-
-GdkPixbuf *lookup_cached_thumbnail(GaimAccount * account,
-                                   const char *fullname)
-{
-    GDir *gdir = NULL;
-    GError *err = NULL;
-    GdkPixbuf *pixbuf = NULL;
-    const char *filename = NULL;
-    char *dirname = NULL;
-    char *path = NULL;
-    const char *name = gaim_normalize(account, fullname);
-    dirname =
-        g_build_filename(gaim_user_dir(), "icons", "gaym", name, NULL);
-    if (dirname) {
-        gdir = g_dir_open(dirname, 0, &err);
-        if (gdir) {
-            filename = g_dir_read_name(gdir);   // don't free filename:
-                                                // owned by glib.
-            if (filename) {
-                path = g_build_filename(dirname, filename, NULL);
-                if (path)
-                    pixbuf = gdk_pixbuf_new_from_file(path, &err);
-                g_free(path);
-            }
-            g_free(gdir);
-        }
-        g_free(dirname);
-    }
-    return pixbuf;
-}
-
-static gboolean tooltip_timeout(struct timeout_cb_data *data)
-{
-    const gchar *name;
-    int scr_w, scr_h, w, h, x, y;
-#if GTK_CHECK_VERSION(2,2,0)
-    int mon_num;
-    GdkScreen *screen = NULL;
-#endif
-    PangoLayout *layout;
-    gboolean tooltip_top = FALSE;
-    char *tooltiptext = NULL;
-    GdkRectangle mon_size;
-    guint *timeout;
-    GtkWidget *tipwindow;
-    GtkWidget *tv = data->tv;
-
-    GaymTooltipType type = data->type;
-    GaimAccount *account = data->account;
-    GaimPluginProtocolInfo *prpl_info =
-        GAIM_PLUGIN_PROTOCOL_INFO(gaim_find_prpl
-                                  (gaim_account_get_protocol_id(account)));
-
-
-    timeout = (guint *) g_hash_table_lookup(popup_timeouts, tv);
-    /* we check to see if we're still supposed to be moving, now that gtk
-       events have happened, and the mouse might not still be in the buddy 
-       list */
-    while (gtk_events_pending())
-        gtk_main_iteration();
-    if (!(*timeout)) {
-        return FALSE;
-    }
-
-    if (type == TOOLTIP_CHAT) {
-        GtkTreePath *path;
-        GtkTreeIter iter;
-        GtkTreeModel *model;
-        GdkRectangle *rect;
-
-        rect = g_hash_table_lookup(popup_rects, tv);
-        if (!gtk_tree_view_get_path_at_pos
-            (GTK_TREE_VIEW(tv), rect->x, rect->y, &path, NULL, NULL, NULL))
-            return FALSE;
-        model = gtk_tree_view_get_model(GTK_TREE_VIEW(tv));
-        gtk_tree_model_get_iter(model, &iter, path);
-        gtk_tree_model_get(model, &iter, CHAT_USERS_NAME_COLUMN, &name,
-                           -1);
-        gtk_tree_path_free(path);
-    } else if (type == TOOLTIP_IM) {
-        name = gtk_label_get_text(GTK_LABEL(tv));
-    } else
-        return FALSE;
-
-
-
-
-    GaimBuddy *gb = g_new0(GaimBuddy, 1);
-    gb->name = g_strdup(name);
-    gb->account = account;
-    tooltiptext = prpl_info->tooltip_text(gb);
-    g_free(gb->name);
-    g_free(gb);
-
-    if (!tooltiptext)
-        return FALSE;
-
-
-    g_return_val_if_fail(tooltiptext != NULL, FALSE);
-
-    tipwindow = g_hash_table_lookup(popups, tv);
-    if (tipwindow) {
-        g_hash_table_remove(popups, tv);
-    }
-    tipwindow = gtk_window_new(GTK_WINDOW_POPUP);
-    g_hash_table_insert(popups, tv, tipwindow);
-
-    gtk_widget_set_app_paintable(tipwindow, TRUE);
-    gtk_window_set_resizable(GTK_WINDOW(tipwindow), FALSE);
-    gtk_widget_set_name(tipwindow, "gtk-tooltips");
-
-    struct paint_data *pdata = g_new0(struct paint_data, 1);
-    pdata->tooltiptext = tooltiptext;
-    pdata->pixbuf = lookup_cached_thumbnail(account, name);
-    g_signal_connect(G_OBJECT(tipwindow), "expose_event",
-                     G_CALLBACK(namelist_paint_tip), pdata);
-    gtk_widget_ensure_style(tipwindow);
-    layout = gtk_widget_create_pango_layout(tipwindow, NULL);
-    pango_layout_set_wrap(layout, PANGO_WRAP_WORD);
-    pango_layout_set_width(layout, 300000);
-    pango_layout_set_markup(layout, tooltiptext, strlen(tooltiptext));
-    pango_layout_get_size(layout, &w, &h);
-
-#if GTK_CHECK_VERSION(2,2,0)
-    gdk_display_get_pointer(gdk_display_get_default(), &screen, &x, &y,
-                            NULL);
-    mon_num = gdk_screen_get_monitor_at_point(screen, x, y);
-    gdk_screen_get_monitor_geometry(screen, mon_num, &mon_size);
-
-    scr_w = mon_size.width + mon_size.x;
-    scr_h = mon_size.height + mon_size.y;
-#else
-    scr_w = gdk_screen_width();
-    scr_h = gdk_screen_height();
-    gdk_window_get_pointer(NULL, &x, &y, NULL);
-    mon_size.x = 0;
-    mon_size.y = 0;
-#endif
-
-
-    w = PANGO_PIXELS(w) + 8;
-    h = PANGO_PIXELS(h) + 8;
-
-    /* For the width, set it to the text width, plus 13 for 4 pixels on
-       each side and 5 between icon/text. For height, the greater of the
-       text height and the icon height, plus 8 (4 for each buffer on top
-       and bottom). */
-    w = w + gdk_pixbuf_get_width(pdata->pixbuf) + 4;
-    h = MAX(h, gdk_pixbuf_get_height(pdata->pixbuf) + 8);
-
-#if GTK_CHECK_VERSION(2,2,0)
-    if (w > mon_size.width)
-        w = mon_size.width - 10;
-
-    if (h > mon_size.height)
-        h = mon_size.height - 10;
-#endif
-
-    // Find the conversation window here....
-    // if (GTK_WIDGET_NO_WINDOW(window))
-    // y+=window->allocation.y;
-
-    x -= ((w >> 1) + 4);
-
-    if ((y + h + 4) > scr_h || tooltip_top)
-        y = y - h - 5;
-    else
-        y = y + 6;
-
-    if (y < mon_size.y)
-        y = mon_size.y;
-
-    if (y != mon_size.y) {
-        if ((x + w) > scr_w)
-            x -= (x + w + 5) - scr_w;
-        else if (x < mon_size.x)
-            x = mon_size.x;
-    } else {
-        x -= (w / 2 + 10);
-        if (x < mon_size.x)
-            x = mon_size.x;
-    }
-
-    g_object_unref(layout);
-    gtk_widget_set_size_request(tipwindow, w, h);
-    gtk_window_move(GTK_WINDOW(tipwindow), x, y);
-    gtk_widget_show(tipwindow);
-
-    return FALSE;
-}
-
-
-static gboolean namelist_motion_cb(GtkWidget * tv, GdkEventMotion * event,
-                                   gpointer account)
-{
-    GtkTreeModel *ls = NULL;
-    GtkTreePath *path = NULL;
-    GtkTreeIter iter;
-    char *name;
-    static int count = 0;
-    gboolean tf;
-    GdkRectangle *rect;
-    guint *timeout;
-    count++;
-    guint delay;
-    rect = g_hash_table_lookup(popup_rects, tv);
-    g_return_val_if_fail(rect != NULL, FALSE);
-
-    timeout = g_hash_table_lookup(popup_timeouts, tv);
-
-    delay = gaim_prefs_get_int("/gaim/gtk/blist/tooltip_delay");
-
-    if (delay == 0)
-        return FALSE;
-
-    if (*timeout) {
-        if ((event->y > rect->y) && ((event->y - rect->height) < rect->y))
-            return FALSE;
-        /* We've left the cell.  Remove the timeout and create a new one
-           below */
-
-        g_hash_table_remove(popups, tv);
-        g_source_remove(*timeout);
-    }
-
-    gtk_tree_view_get_path_at_pos(GTK_TREE_VIEW(tv), event->x, event->y,
-                                  &path, NULL, NULL, NULL);
-    if (G_UNLIKELY(path == NULL))
-        return FALSE;
-    struct timeout_cb_data *timeout_data =
-        g_new0(struct timeout_cb_data, 1);
-    timeout_data->tv = tv;
-    timeout_data->account = account;
-    timeout_data->type = TOOLTIP_CHAT;
-    *timeout =
-        g_timeout_add(delay, (GSourceFunc) tooltip_timeout, timeout_data);
-
-    gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, rect);
-
-    ls = gtk_tree_view_get_model(GTK_TREE_VIEW(tv));
-    tf = gtk_tree_model_get_iter(ls, &iter, path);
-    gtk_tree_model_get(ls, &iter, CHAT_USERS_NAME_COLUMN, &name, -1);
-    gtk_tree_view_get_cell_area(GTK_TREE_VIEW(tv), path, NULL, rect);
-
-    return TRUE;
-}
-
-static void tab_leave_cb(GtkWidget * event, GdkEventCrossing * e,
-                         gpointer conv)
-{
-
-    GaimConversation *c = (GaimConversation *) conv;
-
-    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-    // Prevent clicks from demolishing popup.
-    if (e->mode != GDK_CROSSING_NORMAL)
-        return;
-    GtkWidget *tab = gtkconv->tab_label;
-
-    guint *timeout = g_hash_table_lookup(popup_timeouts, tab);
-    g_hash_table_remove(popups, tab);
-
-
-    if (timeout && *timeout) {
-        g_source_remove(*timeout);
-        *timeout = 0;
-    }
-}
-
-
-static gboolean tab_entry_cb(GtkWidget * event,
-                             GdkEventCrossing * crossing, gpointer conv)
-{
-
-    guint *timeout;
-    guint delay;
-    GaimConversation *c = (GaimConversation *) conv;
-    GaimAccount *account = gaim_conversation_get_account(c);
-    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-
-    GtkWidget *tab = gtkconv->tab_label;
-    timeout = g_hash_table_lookup(popup_timeouts, tab);
-
-    delay = gaim_prefs_get_int("/gaim/gtk/blist/tooltip_delay");
-
-    if (delay == 0)
-        return FALSE;
-
-    if (timeout && *timeout)
-        return FALSE;
-
-    // g_hash_table_remove(popups, tab);
-    // g_source_remove(*timeout);
-
-
-
-    struct timeout_cb_data *timeout_data =
-        g_new0(struct timeout_cb_data, 1);
-    timeout_data->tv = tab;
-    timeout_data->account = account;
-    timeout_data->type = TOOLTIP_IM;
-    *timeout =
-        g_timeout_add(delay, (GSourceFunc) tooltip_timeout, timeout_data);
-
-    return TRUE;
-}
-
-void add_chat_popup_stuff(GaimConversation * c)
-{
-
-    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-    GaimGtkChatPane *gtkchat = gtkconv->u.chat;
-    GaimAccount *account = gaim_conversation_get_account(c);
-
-    g_signal_connect(G_OBJECT(gtkchat->list), "motion-notify-event",
-                     G_CALLBACK(namelist_motion_cb), account);
-    g_signal_connect(G_OBJECT(gtkchat->list), "leave-notify-event",
-                     G_CALLBACK(namelist_leave_cb), NULL);
-
-
-    g_hash_table_insert(popup_rects, gtkchat->list,
-                        g_new0(GdkRectangle, 1));
-    g_hash_table_insert(popup_timeouts, gtkchat->list, g_new0(guint, 1));
-
-
-}
-
-void add_im_popup_stuff(GaimConversation * c)
-{
-    GaimGtkConversation *gtkconv = GAIM_GTK_CONVERSATION(c);
-    GtkWidget *event = gtk_event_box_new();
-    GtkWidget *hbox = gtk_hbox_new(FALSE, 6);
-
-    gtk_widget_ref(gtkconv->icon);
-    gtk_container_remove(GTK_CONTAINER(gtkconv->tabby),
-                         GTK_WIDGET(gtkconv->icon));
-    gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(gtkconv->icon), FALSE,
-                       FALSE, 0);
-    gtk_widget_ref(gtkconv->icon);
-    gtk_widget_unref(gtkconv->icon);
-
-    gtk_widget_ref(gtkconv->tab_label);
-    gtk_container_remove(GTK_CONTAINER(gtkconv->tabby),
-                         GTK_WIDGET(gtkconv->tab_label));
-    gtk_box_pack_start(GTK_BOX(hbox), GTK_WIDGET(gtkconv->tab_label), TRUE,
-                       TRUE, 0);
-    gtk_widget_unref(gtkconv->tab_label);
-
-
-    gtk_widget_add_events(event,
-                          GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK);
-    g_signal_connect(G_OBJECT(event), "enter-notify-event",
-                     G_CALLBACK(tab_entry_cb), c);
-    g_signal_connect(G_OBJECT(event), "leave-notify-event",
-                     G_CALLBACK(tab_leave_cb), c);
-    gtk_box_pack_start(GTK_BOX(gtkconv->tabby), GTK_WIDGET(event), TRUE,
-                       TRUE, 0);
-    gtk_box_reorder_child(GTK_BOX(gtkconv->tabby), GTK_WIDGET(event), 0);
-    gtk_widget_show(GTK_WIDGET(event));
-    gtk_widget_show(GTK_WIDGET(hbox));
-    gtk_event_box_set_visible_window(GTK_EVENT_BOX(event), FALSE);
-    gtk_container_add(GTK_CONTAINER(event), GTK_WIDGET(hbox));
-    g_hash_table_insert(popup_timeouts, gtkconv->tab_label,
-                        g_new0(guint, 1));
-}
-
-void init_popups()
-{
-    popup_rects =
-        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
-
-    popup_timeouts =
-        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, g_free);
-
-    popups =
-        g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL,
-                              (GDestroyNotify) gtk_widget_destroy);
-}

Copied: qrc/tags/release-0.9/gaym-extras/src/bio-popups.c (from rev 260, qrc/trunk/gaym-extras/src/bio-popups.c)

Deleted: qrc/tags/release-0.9/gaym-extras/src/gaym-extras.c
===================================================================
--- qrc/trunk/gaym-extras/src/gaym-extras.c	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/tags/release-0.9/gaym-extras/src/gaym-extras.c	2005-07-31 19:13:29 UTC (rev 264)
@@ -1,140 +0,0 @@
-/* Show icons in chat room windows */
-
-
-#include "gaym-extras.h"
-// Adds motion handlers to IM tab labels.
-static void redo_im_window(GaimConversation * c)
-{
-    if (!g_strrstr(gaim_account_get_protocol_id(c->account), "prpl-gaym"))
-        return;
-    if (c && c->type == GAIM_CONV_IM)
-        add_im_popup_stuff(c);
-}
-
-
-static void update_info_cb(GaimAccount * account, char *name)
-{
-    if (!g_strrstr(gaim_account_get_protocol_id(account), "prpl-gaym"))
-        return;
-    gaim_debug_misc("gaym-extras", "info update\n");
-}
-
-static void redochatwindow(GaimConversation * c)
-{
-    if (!g_strrstr(gaim_account_get_protocol_id(c->account), "prpl-gaym"))
-        return;
-    add_chat_sort_functions(c);
-    add_chat_popup_stuff(c);
-    add_chat_icon_stuff(c);
-}
-static gchar *find_file(const char *dir, const char *base)
-{
-    char *filename;
-
-    if (base == NULL)
-        return NULL;
-
-    if (!strcmp(dir, "gaim"))
-        filename =
-            g_build_filename(GAIM_DATADIR, "pixmaps", "gaim", base, NULL);
-    else {
-        filename = g_build_filename(GAIM_DATADIR, "pixmaps", "gaim", dir,
-                                    base, NULL);
-    }
-
-    if (!g_file_test(filename, G_FILE_TEST_EXISTS)) {
-        g_critical("Unable to load stock pixmap %s\n", filename);
-
-        g_free(filename);
-
-        return NULL;
-    }
-
-    return filename;
-
-}
-
-void extras_register_stock()
-{
-
-    static gboolean stock_is_init = FALSE;
-    GtkIconFactory *icon_factory = NULL;
-    int i;
-    if (stock_is_init)
-        return;
-    stock_is_init = TRUE;
-    icon_factory = gtk_icon_factory_new();
-
-    gtk_icon_factory_add_default(icon_factory);
-
-    for (i = 0; i < G_N_ELEMENTS(stock_icons); i++) {
-        GdkPixbuf *pixbuf;
-        GtkIconSet *iconset;
-        gchar *filename;
-        filename = find_file(stock_icons[i].dir, stock_icons[i].filename);
-        if (filename == NULL)
-            continue;
-
-        pixbuf = gdk_pixbuf_new_from_file(filename, NULL);
-        g_free(filename);
-        iconset = gtk_icon_set_new_from_pixbuf(pixbuf);
-
-        g_object_unref(pixbuf);
-        gtk_icon_factory_add(icon_factory, stock_icons[i].name, iconset);
-        gtk_icon_set_unref(iconset);
-    }
-
-
-}
-static gboolean plugin_load(GaimPlugin * plugin)
-{
-    init_chat_icons();
-    init_popups();
-
-    gaim_signal_connect(gaim_conversations_get_handle(), "chat-joined",
-                        plugin, GAIM_CALLBACK(redochatwindow), NULL);
-
-    gaim_signal_connect(gaim_conversations_get_handle(),
-                        "conversation-created", plugin,
-                        GAIM_CALLBACK(redo_im_window), NULL);
-
-    gaim_signal_connect(gaim_accounts_get_handle(), "info-updated", plugin,
-                        GAIM_CALLBACK(update_info_cb), NULL);
-
-    gaim_signal_connect(gaim_conversations_get_handle(),
-                        "deleting-conversation", plugin,
-                        GAIM_CALLBACK(clean_popup_stuff), NULL);
-
-    extras_register_stock();
-    return TRUE;
-}
-
-static GaimPluginInfo info = {
-    GAIM_PLUGIN_MAGIC,
-    GAIM_MAJOR_VERSION,
-    GAIM_MINOR_VERSION,
-    GAIM_PLUGIN_STANDARD,
-    GAIM_GTK_PLUGIN_TYPE,
-    0,
-    NULL,
-    GAIM_PRIORITY_DEFAULT,
-    GAYM_EXTRAS_PLUGIN_ID,
-    N_("Gaym Extras"),
-    VERSION,
-    N_("GUI-related additions for the gaym protocol plugin."),
-    N_("Current functionality provided by this plugin:\n1. Allows namelist sort order in rooms to be changed.\n2. Shows thumbnails for currently selected user in rooms.\n3. Popup displays bio when you hover over a name in the namelist.\n4. Popup shows bio when you hover over an IM tab."),
-    "Jason LeBrun gaym at jasonlebrun.info",
-    GAIM_WEBSITE,
-    plugin_load,
-    NULL,
-    NULL,
-    NULL,
-    NULL,
-    NULL
-};
-
-static void init_plugin(GaimPlugin * plugin)
-{
-}
-
-GAIM_INIT_PLUGIN(history, init_plugin, info)

Copied: qrc/tags/release-0.9/gaym-extras/src/gaym-extras.c (from rev 260, qrc/trunk/gaym-extras/src/gaym-extras.c)

Deleted: qrc/tags/release-0.9/gaym-extras/src/roombrowse.c
===================================================================
--- qrc/trunk/gaym-extras/src/roombrowse.c	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/tags/release-0.9/gaym-extras/src/roombrowse.c	2005-07-31 19:13:29 UTC (rev 264)
@@ -1,435 +0,0 @@
-/* Puts last 4k of log in new conversations a la Everybuddy (and then
-   stolen by Trillian "Pro") */
-
-#include "internal.h"
-#include "gtkgaim.h"
-
-#include "conversation.h"
-#include "debug.h"
-#include "log.h"
-#include "prefs.h"
-#include "signals.h"
-#include "util.h"
-#include "version.h"
-#include "prpl.h"
-
-#include "gtkconv.h"
-#include "gtkimhtml.h"
-#include "gtkplugin.h"
-#include "gtkdialogs.h"
-#include "gtkutils.h"
-#include "gtkblist.h"
-#include "gtkimhtmltoolbar.h"
-#include <gdk/gdkkeysyms.h>
-
-#define CHATSORT_PLUGIN_ID "gtk-chatsort"
-#define CHATSORT_USERS_COLUMNS 4
-#define CHATSORT_USERS_ENTRY_COLUMN 3
-
-/**
- * Unused variables:
- *
- * static GList *browsers = NULL;
- */
-
-struct RoomBrowseInfo {
-
-    GaimAccount *account;
-    GaimConnection *gc;
-};
-
-static GtkWidget *setup_roombrowse_pane(GaimConversation * conv)
-{
-    GaimGtkConversation *gtkconv;
-    GaimGtkChatPane *gtkchat;
-    GaimConnection *gc;
-    GtkWidget *vpaned, *hpaned;
-    GtkWidget *vbox;
-
-        /**
-	 * Unused variables:
-	 *
-	 * GaimPluginProtocolInfo *prpl_info = NULL;
-	 * GtkWidget *hbox;
-	 * GtkWidget *lbox, *bbox;
-	 * GtkWidget *label;
-	 * GtkWidget *list;
-	 * GtkWidget *button;
-	 * GtkWidget *sw;
-	 * GtkListStore *ls;
-	 * GtkCellRenderer *rend;
-	 * GtkTreeViewColumn *col;
-	 * GList *focus_chain = NULL;
-	 */
-
-    gtkconv = GAIM_GTK_CONVERSATION(conv);
-    gtkchat = gtkconv->u.chat;
-    gc = gaim_conversation_get_gc(conv);
-
-    /* Setup the outer pane. */
-    vpaned = gtk_vpaned_new();
-    gtk_widget_show(vpaned);
-    /* Setup the top part of the pane. */
-    vbox = gtk_vbox_new(FALSE, 6);
-    gtk_paned_pack1(GTK_PANED(vpaned), vbox, TRUE, TRUE);
-    gtk_widget_show(vbox);
-
-    /* Setup the horizontal pane. */
-    hpaned = gtk_hpaned_new();
-    gtk_box_pack_start(GTK_BOX(vbox), hpaned, TRUE, TRUE, 0);
-    gtk_widget_show(hpaned);
-
-    /* Setup the scrolled window to put gtkimhtml in. */
-    gtkconv->sw = gtk_scrolled_window_new(NULL, NULL);
-    gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(gtkconv->sw),
-                                   GTK_POLICY_AUTOMATIC,
-                                   GTK_POLICY_ALWAYS);
-    gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(gtkconv->sw),
-                                        GTK_SHADOW_IN);
-    gtk_paned_pack1(GTK_PANED(hpaned), gtkconv->sw, TRUE, TRUE);
-
-    gtk_widget_set_size_request(gtkconv->sw,
-                                gaim_prefs_get_int
-                                ("/gaim/gtk/conversations/chat/default_width"),
-                                gaim_prefs_get_int
-                                ("/gaim/gtk/conversations/chat/default_height"));
-
-    // g_signal_connect(G_OBJECT(gtkconv->sw), "size-allocate",
-    // G_CALLBACK(size_allocate_cb), conv);
-
-    gtk_widget_show(gtkconv->sw);
-
-    return vpaned;
-}
-
-static gint close_conv_cb(GtkWidget * w, gpointer d)
-{
-    GaimConversation *conv = (GaimConversation *) d;
-
-    gaim_conversation_destroy(conv);
-
-    return TRUE;
-}
-
-GdkPixbuf *get_tab_icon(GaimConversation * conv, gboolean small_icon)
-{
-    GaimAccount *account = NULL;
-    const char *name = NULL;
-    GdkPixbuf *status = NULL;
-
-    g_return_val_if_fail(conv != NULL, NULL);
-
-    account = gaim_conversation_get_account(conv);
-    name = gaim_conversation_get_name(conv);
-
-    g_return_val_if_fail(account != NULL, NULL);
-    g_return_val_if_fail(name != NULL, NULL);
-
-
-    if (gaim_conversation_get_type(conv) == GAIM_CONV_IM) {
-        GaimBuddy *b = gaim_find_buddy(account, name);
-        if (b != NULL) {
-            status = gaim_gtk_blist_get_status_icon((GaimBlistNode *) b,
-                                                    (small_icon ?
-                                                     GAIM_STATUS_ICON_SMALL
-                                                     :
-                                                     GAIM_STATUS_ICON_LARGE));
-        }
-    }
-
-    if (!status) {
-        GdkPixbuf *pixbuf;
-        pixbuf = create_prpl_icon(account);
-
-        if (small_icon && pixbuf != NULL) {
-            status = gdk_pixbuf_scale_simple(pixbuf, 15, 15,
-                                             GDK_INTERP_BILINEAR);
-            g_object_unref(pixbuf);
-        } else
-            status = pixbuf;
-    }
-    return status;
-}
-
-/**
- * Unused function
- */
-#if 0
-static void update_tab_icon(GaimConversation * conv)
-{
-    GaimGtkConversation *gtkconv;
-    GaimConvWindow *win = gaim_conversation_get_window(conv);
-    GaimAccount *account;
-    const char *name;
-    GdkPixbuf *status = NULL;
-
-    g_return_if_fail(conv != NULL);
-
-    gtkconv = GAIM_GTK_CONVERSATION(conv);
-    name = gaim_conversation_get_name(conv);
-    account = gaim_conversation_get_account(conv);
-
-    status = get_tab_icon(conv, TRUE);
-
-    g_return_if_fail(status != NULL);
-
-    gtk_image_set_from_pixbuf(GTK_IMAGE(gtkconv->icon), status);
-    gtk_image_set_from_pixbuf(GTK_IMAGE(gtkconv->menu_icon), status);
-
-    if (status != NULL)
-        g_object_unref(status);
-
-    if (gaim_conv_window_get_active_conversation(win) == conv &&
-        gtkconv->u.im->anim == NULL) {
-        status = get_tab_icon(conv, FALSE);
-
-        gtk_window_set_icon(GTK_WINDOW(GAIM_GTK_WINDOW(win)->window),
-                            status);
-
-        if (status != NULL)
-            g_object_unref(status);
-    }
-}
-#endif
-
-/* Courtesy of Galeon! */
-static void
-tab_close_button_state_changed_cb(GtkWidget * widget,
-                                  GtkStateType prev_state)
-{
-    if (GTK_WIDGET_STATE(widget) == GTK_STATE_ACTIVE)
-        gtk_widget_set_state(widget, GTK_STATE_NORMAL);
-}
-
-static void
-roombrowse_gtk_add_conversation(GaimConvWindow * win,
-                                GaimConversation * conv)
-{
-    GaimGtkWindow *gtkwin;
-    GaimGtkConversation *gtkconv, *focus_gtkconv;
-    GaimConversation *focus_conv;
-    GtkWidget *pane = NULL;
-    GtkWidget *tab_cont;
-    GtkWidget *tabby, *menu_tabby;
-    GtkWidget *close_image;
-    gboolean new_ui;
-    GaimConversationType conv_type;
-    const char *name;
-
-    name = gaim_conversation_get_name(conv);
-    conv_type = gaim_conversation_get_type(conv);
-    gtkwin = GAIM_GTK_WINDOW(win);
-
-    if (conv->ui_data != NULL) {
-        gtkconv = (GaimGtkConversation *) conv->ui_data;
-
-        tab_cont = gtkconv->tab_cont;
-
-        new_ui = FALSE;
-    } else {
-        gtkconv = g_malloc0(sizeof(GaimGtkConversation));
-        conv->ui_data = gtkconv;
-
-        /* Setup some initial variables. */
-        gtkconv->sg = gtk_size_group_new(GTK_SIZE_GROUP_BOTH);
-        gtkconv->tooltips = gtk_tooltips_new();
-
-        gaim_debug_misc("roombrowse", "setting up pane\n");
-        pane = setup_roombrowse_pane(conv);
-
-        gaim_debug_misc("roombrowse", "set up pane\n");
-
-        if (pane == NULL) {
-            g_free(gtkconv);
-            conv->ui_data = NULL;
-
-            return;
-        }
-
-
-
-        /* Setup the container for the tab. */
-        gtkconv->tab_cont = tab_cont = gtk_vbox_new(FALSE, 6);
-        gtk_container_set_border_width(GTK_CONTAINER(tab_cont), 6);
-        gtk_container_add(GTK_CONTAINER(tab_cont), pane);
-        gtk_widget_show(pane);
-
-        new_ui = TRUE;
-
-        gtkconv->make_sound = FALSE;
-        gtkconv->show_formatting_toolbar = FALSE;
-        gtkconv->show_timestamps = FALSE;
-
-        g_signal_connect_swapped(G_OBJECT(pane), "focus",
-                                 G_CALLBACK(gtk_widget_grab_focus),
-                                 gtkconv->entry);
-    }
-
-    gaim_debug_misc("roombrowse", "Setting up tabs\n");
-    gtkconv->tabby = tabby = gtk_hbox_new(FALSE, 6);
-    gtkconv->menu_tabby = menu_tabby = gtk_hbox_new(FALSE, 6);
-    gtkconv->entry = gtk_imhtml_new(NULL, NULL);
-    gtkconv->toolbar = gtk_imhtmltoolbar_new();
-
-    gaim_debug_misc("roombrowse", "Setting up close button\n");
-    /* Close button. */
-    gtkconv->close = gtk_button_new();
-    gtk_widget_set_size_request(GTK_WIDGET(gtkconv->close), 16, 16);
-    gtk_button_set_relief(GTK_BUTTON(gtkconv->close), GTK_RELIEF_NONE);
-    close_image =
-        gtk_image_new_from_stock(GTK_STOCK_CLOSE, GTK_ICON_SIZE_MENU);
-    gtk_widget_show(close_image);
-    gtk_container_add(GTK_CONTAINER(gtkconv->close), close_image);
-    gtk_tooltips_set_tip(gtkconv->tooltips, gtkconv->close,
-                         _("Close conversation"), NULL);
-
-    g_signal_connect(G_OBJECT(gtkconv->close), "clicked",
-                     G_CALLBACK(close_conv_cb), conv);
-
-    /* 
-     * I love Galeon. They have a fix for that stupid annoying visible
-     * border bug. I love you guys! -- ChipX86
-     */
-    g_signal_connect(G_OBJECT(gtkconv->close), "state_changed",
-                     G_CALLBACK(tab_close_button_state_changed_cb), NULL);
-
-    /* Status icon. */
-    gtkconv->icon = gtk_image_new();
-    gtkconv->menu_icon = gtk_image_new();
-    // update_tab_icon(conv);
-
-    /* Tab label. */
-    gtkconv->tab_label = gtk_label_new(gaim_conversation_get_title(conv));
-    gtkconv->menu_label = gtk_label_new(gaim_conversation_get_title(conv));
-#if 0
-    gtk_misc_set_alignment(GTK_MISC(gtkconv->tab_label), 0.00, 0.5);
-    gtk_misc_set_padding(GTK_MISC(gtkconv->tab_label), 4, 0);
-#endif
-
-    gaim_debug_misc("roombrowse", "Packing\n");
-    /* Pack it all together. */
-    gtk_box_pack_start(GTK_BOX(tabby), gtkconv->icon, FALSE, FALSE, 0);
-    gtk_box_pack_start(GTK_BOX(menu_tabby), gtkconv->menu_icon,
-                       FALSE, FALSE, 0);
-
-    gtk_widget_show_all(gtkconv->icon);
-    gtk_widget_show_all(gtkconv->menu_icon);
-
-    gtk_box_pack_start(GTK_BOX(tabby), gtkconv->tab_label, TRUE, TRUE, 0);
-    gtk_box_pack_start(GTK_BOX(menu_tabby), gtkconv->menu_label, TRUE,
-                       TRUE, 0);
-    gtk_widget_show(gtkconv->tab_label);
-    gtk_widget_show(gtkconv->menu_label);
-    gtk_misc_set_alignment(GTK_MISC(gtkconv->menu_label), 0, 0);
-
-    gtk_box_pack_start(GTK_BOX(tabby), gtkconv->close, FALSE, FALSE, 0);
-    if (gaim_prefs_get_bool("/gaim/gtk/conversations/close_on_tabs"))
-        gtk_widget_show(gtkconv->close);
-
-    gtk_widget_show(tabby);
-    gtk_widget_show(menu_tabby);
-
-    if (gaim_conversation_get_type(conv) == GAIM_CONV_IM)
-        gaim_gtkconv_update_buddy_icon(conv);
-
-    gaim_debug_misc("roombrowse", "Adding to notebook\n");
-    gaim_debug_misc("roombrowse", "gtkwin->notebook=%x\n",
-                    gtkwin->notebook);
-    gaim_debug_misc("roombrowse", "gtkwin=%x\n", gtkwin);
-    gaim_debug_misc("roombrowse", "tabby=%x\n", tabby);
-    gaim_debug_misc("roombrowse", "menu_tabby=%x\n", menu_tabby);
-    gaim_debug_misc("roombrowse", "tab_cont=%x\n", tab_cont);
-
-    /* Add this pane to the conversation's notebook. */
-    int n = gtk_notebook_get_n_pages(GTK_NOTEBOOK(gtkwin->notebook));
-    gaim_debug_misc("roombrowse:", "Notebook has %d pages\n", n);
-    gtk_notebook_append_page_menu(GTK_NOTEBOOK(gtkwin->notebook), tab_cont,
-                                  tabby, menu_tabby);
-    gaim_debug_misc("roombrowse", "Got through append_page_menu\n");
-    gtk_widget_show(tab_cont);
-
-    if (gaim_conv_window_get_conversation_count(win) == 1) {
-        /* Er, bug in notebooks? Switch to the page manually. */
-        gtk_notebook_set_current_page(GTK_NOTEBOOK(gtkwin->notebook), 0);
-
-        gtk_notebook_set_show_tabs(GTK_NOTEBOOK(gtkwin->notebook),
-                                   gaim_prefs_get_bool
-                                   ("/gaim/gtk/conversations/tabs"));
-    } else
-        gtk_notebook_set_show_tabs(GTK_NOTEBOOK(gtkwin->notebook), TRUE);
-    gaim_debug_misc("roombrowse", "FOcus stuff\n");
-    focus_conv = g_list_nth_data(gaim_conv_window_get_conversations(win),
-                                 gtk_notebook_get_current_page(GTK_NOTEBOOK
-                                                               (gtkwin->
-                                                                notebook)));
-    focus_gtkconv = GAIM_GTK_CONVERSATION(focus_conv);
-    gtk_widget_grab_focus(focus_gtkconv->entry);
-
-    if (!new_ui)
-        g_object_unref(gtkconv->tab_cont);
-}
-
-
-static void roombrowse_menu_cb(GaimBlistNode * node, gpointer data)
-{
-    GaimConvWindow *win = gaim_get_first_window_with_type(GAIM_CONV_MISC);
-    GaimConversation *conv = g_new0(GaimConversation, 1);
-
-    GaimAccount *account = ((GaimChat *) node)->account;
-    if (!win)
-        win = gaim_conv_window_new();
-    GaimChat *chat = ((GaimChat *) node);
-    char *room = g_strdup(g_hash_table_lookup(chat->components, "name"));
-
-
-    gaim_debug_misc("roombrowser", "In cb with node=%x, account=%x\n",
-                    node, account);
-    conv = gaim_conversation_new(GAIM_CONV_MISC, account, room);
-
-    gaim_conversation_set_logging(conv, FALSE);
-
-    roombrowse_gtk_add_conversation(conv->window, conv);
-    gaim_conv_window_show(conv->window);
-
-    g_free(room);
-
-}
-static void roombrowse_menu_create(GaimBlistNode * node, GList ** menu)
-{
-
-    char *label, *room;
-
-    struct gaym_conn *gaym;
-    GaimChat *chat = (GaimChat *) node;
-
-    gaim_debug_misc("roombrowse", "In callback\n");
-    if (node->type != GAIM_BLIST_CHAT_NODE)
-        return;
-
-    gaym = chat->account->gc->proto_data;
-
-    room = g_strdup(g_hash_table_lookup(chat->components, "name"));
-    gaim_debug_misc("roombrowse", "Room name: %s\n", room);
-    if (!room)
-        return;
-
-
-    label = g_strdup_printf("Lurk in %s", room);
-    GaimBlistNodeAction *act = gaim_blist_node_action_new(label,
-                                                          roombrowse_menu_cb,
-                                                          chat->account);
-
-    *menu = g_list_append(*menu, act);
-    // g_free(label);
-}
-static gboolean roombrowse_load(GaimPlugin * plugin)
-{
-    gaim_signal_connect(gaim_blist_get_handle(),
-                        "blist-node-extended-menu",
-                        plugin, GAIM_CALLBACK(roombrowse_menu_create),
-                        NULL);
-
-
-    gaim_debug_misc("roombrowse", "Callback registered!\n");
-    return TRUE;
-}

Copied: qrc/tags/release-0.9/gaym-extras/src/roombrowse.c (from rev 262, qrc/trunk/gaym-extras/src/roombrowse.c)

Deleted: qrc/tags/release-0.9/nsis/installer.nsi
===================================================================
--- qrc/trunk/nsis/installer.nsi	2005-07-30 22:19:23 UTC (rev 259)
+++ qrc/tags/release-0.9/nsis/installer.nsi	2005-07-31 19:13:29 UTC (rev 264)
@@ -1,346 +0,0 @@
-; NSIS Script for the Gaim-QRC Plugins
-; Uses NSIS v2.0
-
-Name "Gaim-QRC ${QRC_VERSION}"
-
-; Registry keys:
-!define QRC_REG_KEY        "SOFTWARE\gaim-qrc"
-!define QRC_UNINSTALL_KEY  "SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\gaim-qrc"
-!define QRC_UNINST_EXE     "gaim-qrc-uninst.exe"
-!define GAYM_DLL           "libgaym.dll"
-!define BOT_CHALLENGER_DLL "libbot-challenger.dll"
-!define GAYM_EXTRAS_DLL	   "libgaym-extras.dll"
-!define GAYM_PNG           "gaym.png"
-!define QRC_UNINSTALL_LNK  "Gaim-QRC Uninstall.lnk"
-!define	ALPHA_PNG	   "alpha.png"
-!define	ENTRY_PNG	   "entry.png"
-!define	PIC_PNG		    "pic.png"
-!include "MUI.nsh"
-
-;Do A CRC Check
-CRCCheck On
-
-;Output File Name
-OutFile "..\gaim-${GAIM_VERSION}-qrc-${QRC_VERSION}.exe"
-
-ShowInstDetails show
-ShowUnInstDetails show
-SetCompressor lzma
-
-; Translations
-!include "locale\english.nsh"
-
-; Gaim Plugin installer helper stuff
-
-!addincludedir "${GAIM_TOP}\src\win32\nsis"
-!include "${GAIM_TOP}\src\win32\nsis\gaim-plugin.nsh"
-
-; Modern UI Configuration
-!define MUI_HEADERIMAGE
-
-; Pages
-!define MUI_WELCOMEPAGE_TITLE $(WELCOME_TITLE)
-!define MUI_WELCOMEPAGE_TEXT $(WELCOME_TEXT)
-!insertmacro MUI_PAGE_WELCOME
-
-!insertmacro MUI_PAGE_LICENSE  "..\COPYING"
-
-!define MUI_DIRECTORYPAGE_TEXT_TOP $(DIR_SUBTITLE)
-!define MUI_DIRECTORYPAGE_TEXT_DESTINATION $(DIR_INNERTEXT)
-!insertmacro MUI_PAGE_DIRECTORY
-
-!define MUI_FINISHPAGE_NOAUTOCLOSE
-!insertmacro MUI_PAGE_INSTFILES
-
-!define MUI_FINISHPAGE_TITLE $(FINISH_TITLE)
-!define MUI_FINISHPAGE_TEXT $(FINISH_TEXT)
-!insertmacro MUI_PAGE_FINISH
-
-; MUI Config
-
-!define MUI_CUSTOMFUNCTION_GUIINIT qrc_checkGaimVersion
-!define MUI_ABORTWARNING
-!define MUI_UNINSTALLER
-!define MUI_PROGRESSBAR smooth
-!define MUI_INSTALLCOLORS /windows
-
-!insertmacro MUI_LANGUAGE "English"
-
-!define MUI_LICENSEPAGE_RADIOBUTTONS
-
-
-;The Default Installation Directory
-InstallDir "$PROGRAMFILES\gaim"
-InstallDirRegKey HKLM SOFTWARE\gaim ""
-
-Section -SecUninstallOldPlugin
-  ; Check install rights..
-  Call CheckUserInstallRights
-  Pop $R0
-
-  StrCmp $R0 "HKLM" rights_hklm
-  StrCmp $R0 "HKCU" rights_hkcu done
-
-  rights_hkcu:
-      ReadRegStr $R1 HKCU "${QRC_REG_KEY}" ""
-      ReadRegStr $R2 HKCU "${QRC_REG_KEY}" "Version"
-      ReadRegStr $R3 HKCU "${QRC_UNINSTALL_KEY}" "UninstallString"
-      Goto try_uninstall
-
-  rights_hklm:
-      ReadRegStr $R1 HKLM "${QRC_REG_KEY}" ""
-      ReadRegStr $R2 HKLM "${QRC_REG_KEY}" "Version"
-      ReadRegStr $R3 HKLM "${QRC_UNINSTALL_KEY}" "UninstallString"
-
-  ; If previous version exists .. remove
-  try_uninstall:
-    StrCmp $R1 "" done
-      StrCmp $R2 "" uninstall_problem
-        IfFileExists $R3 0 uninstall_problem
-          ; Have uninstall string.. go ahead and uninstall.
-          SetOverwrite on
-          ; Need to copy uninstaller outside of the install dir
-          ClearErrors
-          CopyFiles /SILENT $R3 "$TEMP\${QRC_UNINST_EXE}"
-          SetOverwrite off
-          IfErrors uninstall_problem
-            ; Ready to uninstall..
-            ClearErrors
-            ExecWait '"$TEMP\${QRC_UNINST_EXE}" /S _?=$R1'
-            IfErrors exec_error
-              Delete "$TEMP\${QRC_UNINST_EXE}"
-              Goto done
-
-            exec_error:
-              Delete "$TEMP\${QRC_UNINST_EXE}"
-              Goto uninstall_problem
-
-        uninstall_problem:
-            ; Just delete the plugin and uninstaller, and remove Registry key
-             MessageBox MB_YESNO $(QRC_PROMPT_WIPEOUT) IDYES do_wipeout IDNO cancel_install
-          cancel_install:
-            Quit
-
-          do_wipeout:
-            StrCmp $R0 "HKLM" del_lm_reg del_cu_reg
-            del_cu_reg:
-              DeleteRegKey HKCU ${QRC_REG_KEY}
-              Goto uninstall_prob_cont
-            del_lm_reg:
-              DeleteRegKey HKLM ${QRC_REG_KEY}
-
-            uninstall_prob_cont:
-              ; plugin DLL
-              Delete "$R1\plugins\${GAYM_DLL}"
-              Delete "$R1\plugins\${BOT_CHALLENGER_DLL}"
-              Delete "$R1\plugins\${GAYM_EXTRAS_DLL}"
-              ; pixmaps
-	      Delete "$R1\pixmaps\${ALPHA_PNG}"
-	      Delete "$R1\pixmaps\${ENTRY_PNG}"
-	      Delete "$R1\pixmaps\${PIC_PNG}"
-              Delete "$R1\pixmaps\gaim\status\default\${GAYM_PNG}"
-              Delete "$R3"
-
-  done:
-
-SectionEnd
-
-
-Section "Install"
-  Call CheckUserInstallRights
-  Pop $R0
-
-  StrCmp $R0 "NONE" instrights_none
-  StrCmp $R0 "HKLM" instrights_hklm instrights_hkcu
-
-  instrights_hklm:
-    ; Write the version registry keys:
-    WriteRegStr HKLM ${QRC_REG_KEY} "" "$INSTDIR"
-    WriteRegStr HKLM ${QRC_REG_KEY} "Version" "${QRC_VERSION}"
-
-    ; Write the uninstall keys for Windows
-    WriteRegStr HKLM ${QRC_UNINSTALL_KEY} "DisplayName" "$(QRC_UNINSTALL_DESC)"
-    WriteRegStr HKLM ${QRC_UNINSTALL_KEY} "UninstallString" "$INSTDIR\${QRC_UNINST_EXE}"
-    SetShellVarContext "all"
-    Goto install_files
-
-  instrights_hkcu:
-    ; Write the version registry keys:
-    WriteRegStr HKCU ${QRC_REG_KEY} "" "$INSTDIR"
-    WriteRegStr HKCU ${QRC_REG_KEY} "Version" "${QRC_VERSION}"
-
-    ; Write the uninstall keys for Windows
-    WriteRegStr HKCU ${QRC_UNINSTALL_KEY} "DisplayName" "$(QRC_UNINSTALL_DESC)"
-    WriteRegStr HKCU ${QRC_UNINSTALL_KEY} "UninstallString" "$INSTDIR\${QRC_UNINST_EXE}"
-    Goto install_files
-  
-  instrights_none:
-    ; No registry keys for us...
-    
-  install_files:
-    SetOutPath "$INSTDIR\plugins"
-    SetCompress Auto
-    SetOverwrite on
-    File "..\gaym\src\.libs\${GAYM_DLL}"
-    File "..\gaym-extras\src\.libs\${GAYM_EXTRAS_DLL}"
-    File "..\bot-challenger\.libs\${BOT_CHALLENGER_DLL}"
-    
-    SetOutPath "$INSTDIR\pixmaps\gaim\status\default"
-    File "..\gaym\pixmaps\${GAYM_PNG}"
-    	
-    SetOutPath "$INSTDIR\pixmaps"
-    File "..\gaym-extras\pixmaps\${ALPHA_PNG}"
-    File "..\gaym-extras\pixmaps\${ENTRY_PNG}"
-    File "..\gaym-extras\pixmaps\${PIC_PNG}"
-    StrCmp $R0 "NONE" done
-    CreateShortCut "$SMPROGRAMS\Gaim\${QRC_UNINSTALL_LNK}" "$INSTDIR\${QRC_UNINST_EXE}"
-    WriteUninstaller "$INSTDIR\${QRC_UNINST_EXE}"
-    SetOverWrite off
-
-  done:
-SectionEnd
-
-Section Uninstall
-  Call un.CheckUserInstallRights
-  Pop $R0
-  StrCmp $R0 "NONE" no_rights
-  StrCmp $R0 "HKCU" try_hkcu try_hklm
-
-  try_hkcu:
-    ReadRegStr $R0 HKCU "${QRC_REG_KEY}" ""
-    StrCmp $R0 $INSTDIR 0 cant_uninstall
-      ; HKCU install path matches our INSTDIR.. so uninstall
-      DeleteRegKey HKCU "${QRC_REG_KEY}"
-      DeleteRegKey HKCU "${QRC_UNINSTALL_KEY}"
-      Goto cont_uninstall
-
-  try_hklm:
-    ReadRegStr $R0 HKLM "${QRC_REG_KEY}" ""
-    StrCmp $R0 $INSTDIR 0 try_hkcu
-      ; HKLM install path matches our INSTDIR.. so uninstall
-      DeleteRegKey HKLM "${QRC_REG_KEY}"
-      DeleteRegKey HKLM "${QRC_UNINSTALL_KEY}"
-      ; Sets start menu and desktop scope to all users..
-      SetShellVarContext "all"
-
-  cont_uninstall:
-    ; plugin 
-    Delete "$INSTDIR\plugins\${GAYM_DLL}"
-    Delete "$INSTDIR\plugins\${BOT_CHALLENGER_DLL}"
-    ; pixmaps
-    Delete "$INSTDIR\pixmaps\gaim\status\default\${GAYM_PNG}"
-    Delete "$INSTDIR\pixmaps\${ALPHA_PNG}"
-    Delete "$INSTDIR\pixmaps\${ENTRY_PNG}"
-    Delete "$INSTDIR\pixmaps\${PIC_PNG}"
-    ; uninstaller
-    Delete "$INSTDIR\${QRC_UNINST_EXE}"
-    ; uninstaller shortcut
-    Delete "$SMPROGRAMS\Gaim\${QRC_UNINSTALL_LNK}"
-    
-    ; try to delete the Gaim directories, in case it has already uninstalled
-    RMDir "$INSTDIR\plugins"
-    RMDir "$INSTDIR"
-    RMDir "$SMPROGRAMS\Gaim"
-
-    Goto done
-
-  cant_uninstall:
-    MessageBox MB_OK $(un.QRC_UNINSTALL_ERROR_1) IDOK
-    Quit
-
-  no_rights:
-    MessageBox MB_OK $(un.QRC_UNINSTALL_ERROR_2) IDOK
-    Quit
-
-  done:
-SectionEnd
-
-Function .onVerifyInstDir
-  IfFileExists $INSTDIR\gaim.exe Good1
-    Abort
-  Good1:
-FunctionEnd
-
-Function qrc_checkGaimVersion
-  Push $R0
-
-  Push ${GAIM_VERSION}
-  Call CheckGaimVersion
-  Pop $R0
-
-  StrCmp $R0 ${GAIM_VERSION_OK} qrc_checkGaimVersion_OK
-  StrCmp $R0 ${GAIM_VERSION_INCOMPATIBLE} +1 +6
-    Call GetGaimVersion
-    IfErrors +3
-    Pop $R0
-    MessageBox MB_OK|MB_ICONSTOP "$(BAD_GAIM_VERSION_1) $R0 $(BAD_GAIM_VERSION_2)"
-    goto +2
-    MessageBox MB_OK|MB_ICONSTOP "$(NO_GAIM_VERSION)"
-    Quit
-
-  qrc_checkGaimVersion_OK:
-  Pop $R0
-FunctionEnd
-
-Function CheckUserInstallRights
-        ClearErrors
-        UserInfo::GetName
-        IfErrors Win9x
-        Pop $0
-        UserInfo::GetAccountType
-        Pop $1
-
-        StrCmp $1 "Admin" 0 +3
-                StrCpy $1 "HKLM"
-                Goto done
-        StrCmp $1 "Power" 0 +3
-                StrCpy $1 "HKLM"
-                Goto done
-        StrCmp $1 "User" 0 +3
-                StrCpy $1 "HKCU"
-                Goto done
-        StrCmp $1 "Guest" 0 +3
-                StrCpy $1 "NONE"
-                Goto done
-        ; Unknown error
-        StrCpy $1 "NONE"
-        Goto done
-
-        Win9x:
-                StrCpy $1 "HKLM"
-
-        done:
-        Push $1
-FunctionEnd
-
-Function un.CheckUserInstallRights
-        ClearErrors
-        UserInfo::GetName
-        IfErrors Win9x
-        Pop $0
-        UserInfo::GetAccountType
-        Pop $1
-        StrCmp $1 "Admin" 0 +3
-                StrCpy $1 "HKLM"
-                Goto done
-        StrCmp $1 "Power" 0 +3
-                StrCpy $1 "HKLM"
-                Goto done
-        StrCmp $1 "User" 0 +3
-                StrCpy $1 "HKCU"
-                Goto done
-        StrCmp $1 "Guest" 0 +3
-                StrCpy $1 "NONE"
-                Goto done
-        ; Unknown error
-        StrCpy $1 "NONE"
-        Goto done
-
-        Win9x:
-                StrCpy $1 "HKLM"
-
-        done:
-        Push $1
-FunctionEnd
-
-

Copied: qrc/tags/release-0.9/nsis/installer.nsi (from rev 260, qrc/trunk/nsis/installer.nsi)



